/*********************************************************************/
/* from regdef.v by regdef2h auto-generated C-header file            */
/* please see the regdef.html file for detailed register description */
/*********************************************************************/

#ifndef __regdef_netx51_h__
#define __regdef_netx51_h__


/* ===================================================================== */

/* Area of ARMiTCM_memarea */

/* ===================================================================== */

#define Addr_NX51_ARMiTCM_memarea 0x00000000U

/* ===================================================================== */

/* AREA intram0_start4 */
/* Area of intram0_mirror_itcm */

/* ===================================================================== */

#define Addr_NX51_intram0_mirror_itcm 0x00000000U

/* --------------------------------------------------------------------- */
/* Register intram0_base_start4 */
/* => internal SRAM AHBL slave 0 start address */
/*    Area size: 128kB - 4bytes */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    Offset 0x0 is ROM Boot-vector */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram0_base_start4                 0x00000004U
#define Adr_NX51_intram0_mirror_itcm_intram0_base_start4 0x00000004U
#define Adr_NX51_intram0_base_start4                     0x00000004U

/* --------------------------------------------------------------------- */
/* Register intram0_end_start4 */
/* => internal SRAM AHBL slave 0 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram0_end_start4                 0x0001FFFCU
#define Adr_NX51_intram0_mirror_itcm_intram0_end_start4 0x0001FFFCU
#define Adr_NX51_intram0_end_start4                     0x0001FFFCU


/* ===================================================================== */

/* Area of arm_boot_vector */

/* ===================================================================== */

#define Addr_NX51_arm_boot_vector 0x00000000U

/* --------------------------------------------------------------------- */
/* Register arm_boot_vector */
/* => ARM boot vector. */
/*    This address is mirrored to ROM base address Adr_rom_base. */
/*    ARM special: When ARM instruction TCM is enabled, access to this address targets instruction TCM. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_boot_vector             0x00000000U
#define Adr_NX51_arm_boot_vector_arm_boot_vector 0x00000000U
#define Adr_NX51_arm_boot_vector                 0x00000000U


/* ===================================================================== */

/* AREA intram1 */
/* Area of intram1_mirror_itcm, intram1_mirror_dtcm, intram1, intram1_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram1_mirror_itcm 0x00020000U
#define Addr_NX51_intram1_mirror_dtcm 0x04020000U
#define Addr_NX51_intram1             0x08020000U
#define Addr_NX51_intram1_mirror_hi   0xFFE20000U

/* --------------------------------------------------------------------- */
/* Register intram1_base */
/* => internal SRAM AHBL slave 1 start address */
/*    Area size: 128kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram1_base                 0x00000000U
#define Adr_NX51_intram1_mirror_itcm_intram1_base 0x00020000U
#define Adr_NX51_intram1_mirror_dtcm_intram1_base 0x04020000U
#define Adr_NX51_intram1_intram1_base             0x08020000U
#define Adr_NX51_intram1_mirror_hi_intram1_base   0xFFE20000U

/* --------------------------------------------------------------------- */
/* Register intram1_end */
/* => internal SRAM AHBL slave 1 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram1_end                 0x0001FFFCU
#define Adr_NX51_intram1_mirror_itcm_intram1_end 0x0003FFFCU
#define Adr_NX51_intram1_mirror_dtcm_intram1_end 0x0403FFFCU
#define Adr_NX51_intram1_intram1_end             0x0803FFFCU
#define Adr_NX51_intram1_mirror_hi_intram1_end   0xFFE3FFFCU


/* ===================================================================== */

/* AREA intram2 */
/* Area of intram2_mirror_itcm, intram2_mirror_dtcm, intram2, intram2_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram2_mirror_itcm 0x00040000U
#define Addr_NX51_intram2_mirror_dtcm 0x04040000U
#define Addr_NX51_intram2             0x08040000U
#define Addr_NX51_intram2_mirror_hi   0xFFE40000U

/* --------------------------------------------------------------------- */
/* Register intram2_base */
/* => internal SRAM AHBL slave 2 start address */
/*    Area size: 64kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram2_base                 0x00000000U
#define Adr_NX51_intram2_mirror_itcm_intram2_base 0x00040000U
#define Adr_NX51_intram2_mirror_dtcm_intram2_base 0x04040000U
#define Adr_NX51_intram2_intram2_base             0x08040000U
#define Adr_NX51_intram2_mirror_hi_intram2_base   0xFFE40000U

/* --------------------------------------------------------------------- */
/* Register intram2_end */
/* => internal SRAM AHBL slave 2 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram2_end                 0x0000FFFCU
#define Adr_NX51_intram2_mirror_itcm_intram2_end 0x0004FFFCU
#define Adr_NX51_intram2_mirror_dtcm_intram2_end 0x0404FFFCU
#define Adr_NX51_intram2_intram2_end             0x0804FFFCU
#define Adr_NX51_intram2_mirror_hi_intram2_end   0xFFE4FFFCU


/* ===================================================================== */

/* AREA intram3 */
/* Area of intram3_mirror_itcm, intram3_mirror_dtcm, intram3, intram3_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram3_mirror_itcm 0x00050000U
#define Addr_NX51_intram3_mirror_dtcm 0x04050000U
#define Addr_NX51_intram3             0x08050000U
#define Addr_NX51_intram3_mirror_hi   0xFFE50000U

/* --------------------------------------------------------------------- */
/* Register intram3_base */
/* => internal SRAM AHBL slave 3 start address */
/*    Area size: 64kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram3_base                 0x00000000U
#define Adr_NX51_intram3_mirror_itcm_intram3_base 0x00050000U
#define Adr_NX51_intram3_mirror_dtcm_intram3_base 0x04050000U
#define Adr_NX51_intram3_intram3_base             0x08050000U
#define Adr_NX51_intram3_mirror_hi_intram3_base   0xFFE50000U

/* --------------------------------------------------------------------- */
/* Register intram3_end */
/* => internal SRAM AHBL slave 3 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram3_end                 0x0000FFFCU
#define Adr_NX51_intram3_mirror_itcm_intram3_end 0x0005FFFCU
#define Adr_NX51_intram3_mirror_dtcm_intram3_end 0x0405FFFCU
#define Adr_NX51_intram3_intram3_end             0x0805FFFCU
#define Adr_NX51_intram3_mirror_hi_intram3_end   0xFFE5FFFCU


/* ===================================================================== */

/* AREA intram4 */
/* Area of intram4_mirror_itcm, intram4_mirror_dtcm, intram4, intram4_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram4_mirror_itcm 0x00060000U
#define Addr_NX51_intram4_mirror_dtcm 0x04060000U
#define Addr_NX51_intram4             0x08060000U
#define Addr_NX51_intram4_mirror_hi   0xFFE60000U

/* --------------------------------------------------------------------- */
/* Register intram4_base */
/* => internal SRAM AHBL slave 4 start address */
/*    Area size: 64kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram4_base                 0x00000000U
#define Adr_NX51_intram4_mirror_itcm_intram4_base 0x00060000U
#define Adr_NX51_intram4_mirror_dtcm_intram4_base 0x04060000U
#define Adr_NX51_intram4_intram4_base             0x08060000U
#define Adr_NX51_intram4_mirror_hi_intram4_base   0xFFE60000U

/* --------------------------------------------------------------------- */
/* Register intram4_end */
/* => internal SRAM AHBL slave 4 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram4_end                 0x0000FFFCU
#define Adr_NX51_intram4_mirror_itcm_intram4_end 0x0006FFFCU
#define Adr_NX51_intram4_mirror_dtcm_intram4_end 0x0406FFFCU
#define Adr_NX51_intram4_intram4_end             0x0806FFFCU
#define Adr_NX51_intram4_mirror_hi_intram4_end   0xFFE6FFFCU


/* ===================================================================== */

/* AREA intram5 */
/* Area of intram5_mirror_itcm, intram5_mirror_dtcm, intram5, intram5_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram5_mirror_itcm  0x00070000U
#define Addr_NX51_intram5_mirror_dtcm  0x04070000U
#define Addr_NX51_intram5              0x08070000U
#define NX51_NETX_MEM_INTRN_XPICI_AREA 0x08070000U
#define Addr_NX51_intram5_mirror_hi    0xFFE70000U

/* --------------------------------------------------------------------- */
/* Register intram5_base */
/* => internal SRAM AHBL slave 5 start address */
/*    Area size: 32kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram5_base                 0x00000000U
#define Adr_NX51_intram5_mirror_itcm_intram5_base 0x00070000U
#define Adr_NX51_intram5_mirror_dtcm_intram5_base 0x04070000U
#define Adr_NX51_intram5_intram5_base             0x08070000U
#define Adr_NX51_intram5_mirror_hi_intram5_base   0xFFE70000U

/* --------------------------------------------------------------------- */
/* Register intram5_end */
/* => internal SRAM AHBL slave 5 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram5_end                 0x00007FFCU
#define Adr_NX51_intram5_mirror_itcm_intram5_end 0x00077FFCU
#define Adr_NX51_intram5_mirror_dtcm_intram5_end 0x04077FFCU
#define Adr_NX51_intram5_intram5_end             0x08077FFCU
#define Adr_NX51_intram5_mirror_hi_intram5_end   0xFFE77FFCU


/* ===================================================================== */

/* AREA intram6 */
/* Area of intram6_mirror_itcm, intram6_mirror_dtcm, intram6, intram6_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram6_mirror_itcm  0x00078000U
#define Addr_NX51_intram6_mirror_dtcm  0x04078000U
#define Addr_NX51_intram6              0x08078000U
#define NX51_NETX_MEM_INTRN_XPICD_AREA 0x08078000U
#define Addr_NX51_intram6_mirror_hi    0xFFE78000U

/* --------------------------------------------------------------------- */
/* Register intram6_base */
/* => internal SRAM AHBL slave 6 start address */
/*    Area size: 32kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram6_base                 0x00000000U
#define Adr_NX51_intram6_mirror_itcm_intram6_base 0x00078000U
#define Adr_NX51_intram6_mirror_dtcm_intram6_base 0x04078000U
#define Adr_NX51_intram6_intram6_base             0x08078000U
#define Adr_NX51_intram6_mirror_hi_intram6_base   0xFFE78000U

/* --------------------------------------------------------------------- */
/* Register intram6_end */
/* => internal SRAM AHBL slave 6 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram6_end                 0x00007FFCU
#define Adr_NX51_intram6_mirror_itcm_intram6_end 0x0007FFFCU
#define Adr_NX51_intram6_mirror_dtcm_intram6_end 0x0407FFFCU
#define Adr_NX51_intram6_intram6_end             0x0807FFFCU
#define Adr_NX51_intram6_mirror_hi_intram6_end   0xFFE7FFFCU


/* ===================================================================== */

/* AREA intram7 */
/* Area of intram7_mirror_itcm, intram7_mirror_dtcm, intram7, intram7_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram7_mirror_itcm 0x00080000U
#define Addr_NX51_intram7_mirror_dtcm 0x04080000U
#define Addr_NX51_intram7             0x08080000U
#define NX51_NETX_MEM_INTRN_XC0_AREA  0x08080000U
#define Addr_NX51_intram7_mirror_hi   0xFFE80000U

/* --------------------------------------------------------------------- */
/* Register intram7_base */
/* => internal SRAM AHBL slave 7 start address */
/*    Area size: 64kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram7_base                 0x00000000U
#define Adr_NX51_intram7_mirror_itcm_intram7_base 0x00080000U
#define Adr_NX51_intram7_mirror_dtcm_intram7_base 0x04080000U
#define Adr_NX51_intram7_intram7_base             0x08080000U
#define Adr_NX51_intram7_mirror_hi_intram7_base   0xFFE80000U

/* --------------------------------------------------------------------- */
/* Register intram7_end */
/* => internal SRAM AHBL slave 7 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram7_end                 0x0000FFFCU
#define Adr_NX51_intram7_mirror_itcm_intram7_end 0x0008FFFCU
#define Adr_NX51_intram7_mirror_dtcm_intram7_end 0x0408FFFCU
#define Adr_NX51_intram7_intram7_end             0x0808FFFCU
#define Adr_NX51_intram7_mirror_hi_intram7_end   0xFFE8FFFCU


/* ===================================================================== */

/* AREA intram8 */
/* Area of intram8_mirror_itcm, intram8_mirror_dtcm, intram8, intram8_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram8_mirror_itcm 0x00090000U
#define Addr_NX51_intram8_mirror_dtcm 0x04090000U
#define Addr_NX51_intram8             0x08090000U
#define NX51_NETX_MEM_INTRN_XC1_AREA  0x08090000U
#define Addr_NX51_intram8_mirror_hi   0xFFE90000U

/* --------------------------------------------------------------------- */
/* Register intram8_base */
/* => internal SRAM AHBL slave 8 start address */
/*    Area size: 64kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram8_base                 0x00000000U
#define Adr_NX51_intram8_mirror_itcm_intram8_base 0x00090000U
#define Adr_NX51_intram8_mirror_dtcm_intram8_base 0x04090000U
#define Adr_NX51_intram8_intram8_base             0x08090000U
#define Adr_NX51_intram8_mirror_hi_intram8_base   0xFFE90000U

/* --------------------------------------------------------------------- */
/* Register intram8_end */
/* => internal SRAM AHBL slave 8 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram8_end                 0x0000FFFCU
#define Adr_NX51_intram8_mirror_itcm_intram8_end 0x0009FFFCU
#define Adr_NX51_intram8_mirror_dtcm_intram8_end 0x0409FFFCU
#define Adr_NX51_intram8_intram8_end             0x0809FFFCU
#define Adr_NX51_intram8_mirror_hi_intram8_end   0xFFE9FFFCU


/* ===================================================================== */

/* AREA rom */
/* Area of rom_mirror_itcm, rom_mirror_dtcm, rom, rom_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_rom_mirror_itcm   0x000F0000U
#define Addr_NX51_rom_mirror_dtcm   0x040F0000U
#define Addr_NX51_rom               0x080F0000U
#define NX51_NETX_MEM_BOOT_ROM_AREA 0x080F0000U
#define Addr_NX51_rom_mirror_hi     0xFFEF0000U

/* --------------------------------------------------------------------- */
/* Register rom_base */
/* => internal ROM start address */
/*    Area size: 64kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Highest 4kB of ROM will be hidden after ROM Watchdog timed out (secure data). */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_rom_base             0x00000000U
#define Adr_NX51_rom_mirror_itcm_rom_base 0x000F0000U
#define Adr_NX51_rom_mirror_dtcm_rom_base 0x040F0000U
#define Adr_NX51_rom_rom_base             0x080F0000U
#define Adr_NX51_rom_mirror_hi_rom_base   0xFFEF0000U

/* --------------------------------------------------------------------- */
/* Register rom_end */
/* => internal ROM end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_rom_end             0x0000FFFCU
#define Adr_NX51_rom_mirror_itcm_rom_end 0x000FFFFCU
#define Adr_NX51_rom_mirror_dtcm_rom_end 0x040FFFFCU
#define Adr_NX51_rom_rom_end             0x080FFFFCU
#define Adr_NX51_rom_mirror_hi_rom_end   0xFFEFFFFCU


/* ===================================================================== */

/* Area of ARMdTCM_memarea */

/* ===================================================================== */

#define Addr_NX51_ARMdTCM_memarea 0x04000000U

/* ===================================================================== */

/* AREA intram0 */
/* Area of intram0_mirror_dtcm, intram0, intram0_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intram0_mirror_dtcm  0x04000000U
#define Addr_NX51_intram0              0x08000000U
#define NX51_NETX_MEM_INTRN_ARMDI_AREA 0x08000000U
#define Addr_NX51_intram0_mirror_hi    0xFFE00000U

/* --------------------------------------------------------------------- */
/* Register intram0_base */
/* => internal SRAM AHBL slave 0 start address */
/*    Area size: 128kB */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    Offset 0x0 is ROM Boot-vector */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram0_base                 0x00000000U
#define Adr_NX51_intram0_mirror_dtcm_intram0_base 0x04000000U
#define Adr_NX51_intram0_intram0_base             0x08000000U
#define Adr_NX51_intram0_mirror_hi_intram0_base   0xFFE00000U

/* --------------------------------------------------------------------- */
/* Register intram0_end */
/* => internal SRAM AHBL slave 0 end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intram0_end                 0x0001FFFCU
#define Adr_NX51_intram0_mirror_dtcm_intram0_end 0x0401FFFCU
#define Adr_NX51_intram0_intram0_end             0x0801FFFCU
#define Adr_NX51_intram0_mirror_hi_intram0_end   0xFFE1FFFCU


/* ===================================================================== */

/* Area of ARM_buf_area */

/* ===================================================================== */

#define Addr_NX51_ARM_buf_area 0x08000000U

/* ===================================================================== */

/* AREA osac */
/* Area of osac_buf, osac */

/* ===================================================================== */

#define Addr_NX51_osac_buf 0x08200000U
#define Addr_NX51_osac     0x10200000U

/* ===================================================================== */

/* AREA sqirom */
/* Area of sqirom, sqirom_unbuf */

/* ===================================================================== */

#define Addr_NX51_sqirom       0x0C000000U
#define Addr_NX51_sqirom_unbuf 0x1C000000U

/* ===================================================================== */

/* Area of ARM_nbuf_area */

/* ===================================================================== */

#define Addr_NX51_ARM_nbuf_area 0x10000000U

/* ===================================================================== */

/* AREA intlogic_motion */
/* Area of intlogic_motion, intlogic_motion_mirror_buf, intlogic_motion_mirror_hi */

/* ===================================================================== */

#define Addr_NX51_intlogic_motion            0x10100000U
#define Addr_NX51_intlogic_motion_mirror_buf 0x08100000U
#define Addr_NX51_intlogic_motion_mirror_hi  0xFFF00000U

/* ===================================================================== */

/* AREA xc */
/* Area of xc_motion */

/* ===================================================================== */

#define Addr_NX51_xc_motion 0x10100000U

/* ===================================================================== */

/* AREA sr */
/* Area of sr_motion */

/* ===================================================================== */

#define Addr_NX51_sr_motion 0x10100680U

/* --------------------------------------------------------------------- */
/* Register sr_sr0 */
/* => Shared Work Register 0 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr0       0x00000000U
#define Adr_NX51_sr_motion_sr_sr0 0x10100680U
#define Adr_NX51_sr_sr0           0x10100680U
#define DFLT_VAL_NX51_sr_sr0      0x00000000U

#define MSK_NX51_sr_sr0_val         0x0000ffffU
#define SRT_NX51_sr_sr0_val         0
#define DFLT_VAL_NX51_sr_sr0_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr0_val 0x00000000U

/* all used bits of 'NX51_sr_sr0': */
#define MSK_USED_BITS_NX51_sr_sr0 0x0000ffffU

enum {
	BFW_NX51_sr_sr0_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr0_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR0_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr0_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr0_reserved1; /* reserved                                                            */
} NX51_SR_SR0_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR0_BIT_T bf;
} NX51_SR_SR0_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr1 */
/* => Shared Work Register 1 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr1       0x00000004U
#define Adr_NX51_sr_motion_sr_sr1 0x10100684U
#define Adr_NX51_sr_sr1           0x10100684U
#define DFLT_VAL_NX51_sr_sr1      0x00000000U

#define MSK_NX51_sr_sr1_val         0x0000ffffU
#define SRT_NX51_sr_sr1_val         0
#define DFLT_VAL_NX51_sr_sr1_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr1_val 0x00000000U

/* all used bits of 'NX51_sr_sr1': */
#define MSK_USED_BITS_NX51_sr_sr1 0x0000ffffU

enum {
	BFW_NX51_sr_sr1_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr1_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR1_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr1_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr1_reserved1; /* reserved                                                            */
} NX51_SR_SR1_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR1_BIT_T bf;
} NX51_SR_SR1_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr2 */
/* => Shared Work Register 2 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr2       0x00000008U
#define Adr_NX51_sr_motion_sr_sr2 0x10100688U
#define Adr_NX51_sr_sr2           0x10100688U
#define DFLT_VAL_NX51_sr_sr2      0x00000000U

#define MSK_NX51_sr_sr2_val         0x0000ffffU
#define SRT_NX51_sr_sr2_val         0
#define DFLT_VAL_NX51_sr_sr2_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr2_val 0x00000000U

/* all used bits of 'NX51_sr_sr2': */
#define MSK_USED_BITS_NX51_sr_sr2 0x0000ffffU

enum {
	BFW_NX51_sr_sr2_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr2_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR2_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr2_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr2_reserved1; /* reserved                                                            */
} NX51_SR_SR2_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR2_BIT_T bf;
} NX51_SR_SR2_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr3 */
/* => Shared Work Register 3 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr3       0x0000000CU
#define Adr_NX51_sr_motion_sr_sr3 0x1010068CU
#define Adr_NX51_sr_sr3           0x1010068CU
#define DFLT_VAL_NX51_sr_sr3      0x00000000U

#define MSK_NX51_sr_sr3_val         0x0000ffffU
#define SRT_NX51_sr_sr3_val         0
#define DFLT_VAL_NX51_sr_sr3_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr3_val 0x00000000U

/* all used bits of 'NX51_sr_sr3': */
#define MSK_USED_BITS_NX51_sr_sr3 0x0000ffffU

enum {
	BFW_NX51_sr_sr3_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr3_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR3_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr3_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr3_reserved1; /* reserved                                                            */
} NX51_SR_SR3_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR3_BIT_T bf;
} NX51_SR_SR3_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr4 */
/* => Shared Work Register 4 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr4       0x00000010U
#define Adr_NX51_sr_motion_sr_sr4 0x10100690U
#define Adr_NX51_sr_sr4           0x10100690U
#define DFLT_VAL_NX51_sr_sr4      0x00000000U

#define MSK_NX51_sr_sr4_val         0x0000ffffU
#define SRT_NX51_sr_sr4_val         0
#define DFLT_VAL_NX51_sr_sr4_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr4_val 0x00000000U

/* all used bits of 'NX51_sr_sr4': */
#define MSK_USED_BITS_NX51_sr_sr4 0x0000ffffU

enum {
	BFW_NX51_sr_sr4_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr4_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR4_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr4_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr4_reserved1; /* reserved                                                            */
} NX51_SR_SR4_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR4_BIT_T bf;
} NX51_SR_SR4_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr5 */
/* => Shared Work Register 5 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr5       0x00000014U
#define Adr_NX51_sr_motion_sr_sr5 0x10100694U
#define Adr_NX51_sr_sr5           0x10100694U
#define DFLT_VAL_NX51_sr_sr5      0x00000000U

#define MSK_NX51_sr_sr5_val         0x0000ffffU
#define SRT_NX51_sr_sr5_val         0
#define DFLT_VAL_NX51_sr_sr5_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr5_val 0x00000000U

/* all used bits of 'NX51_sr_sr5': */
#define MSK_USED_BITS_NX51_sr_sr5 0x0000ffffU

enum {
	BFW_NX51_sr_sr5_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr5_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR5_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr5_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr5_reserved1; /* reserved                                                            */
} NX51_SR_SR5_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR5_BIT_T bf;
} NX51_SR_SR5_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr6 */
/* => Shared Work Register 6 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr6       0x00000018U
#define Adr_NX51_sr_motion_sr_sr6 0x10100698U
#define Adr_NX51_sr_sr6           0x10100698U
#define DFLT_VAL_NX51_sr_sr6      0x00000000U

#define MSK_NX51_sr_sr6_val         0x0000ffffU
#define SRT_NX51_sr_sr6_val         0
#define DFLT_VAL_NX51_sr_sr6_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr6_val 0x00000000U

/* all used bits of 'NX51_sr_sr6': */
#define MSK_USED_BITS_NX51_sr_sr6 0x0000ffffU

enum {
	BFW_NX51_sr_sr6_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr6_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR6_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr6_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr6_reserved1; /* reserved                                                            */
} NX51_SR_SR6_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR6_BIT_T bf;
} NX51_SR_SR6_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr7 */
/* => Shared Work Register 7 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr7       0x0000001CU
#define Adr_NX51_sr_motion_sr_sr7 0x1010069CU
#define Adr_NX51_sr_sr7           0x1010069CU
#define DFLT_VAL_NX51_sr_sr7      0x00000000U

#define MSK_NX51_sr_sr7_val         0x0000ffffU
#define SRT_NX51_sr_sr7_val         0
#define DFLT_VAL_NX51_sr_sr7_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr7_val 0x00000000U

/* all used bits of 'NX51_sr_sr7': */
#define MSK_USED_BITS_NX51_sr_sr7 0x0000ffffU

enum {
	BFW_NX51_sr_sr7_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr7_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR7_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr7_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr7_reserved1; /* reserved                                                            */
} NX51_SR_SR7_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR7_BIT_T bf;
} NX51_SR_SR7_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr8 */
/* => Shared Work Register 8 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr8       0x00000020U
#define Adr_NX51_sr_motion_sr_sr8 0x101006A0U
#define Adr_NX51_sr_sr8           0x101006A0U
#define DFLT_VAL_NX51_sr_sr8      0x00000000U

#define MSK_NX51_sr_sr8_val         0x0000ffffU
#define SRT_NX51_sr_sr8_val         0
#define DFLT_VAL_NX51_sr_sr8_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr8_val 0x00000000U

/* all used bits of 'NX51_sr_sr8': */
#define MSK_USED_BITS_NX51_sr_sr8 0x0000ffffU

enum {
	BFW_NX51_sr_sr8_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr8_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR8_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr8_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr8_reserved1; /* reserved                                                            */
} NX51_SR_SR8_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR8_BIT_T bf;
} NX51_SR_SR8_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr9 */
/* => Shared Work Register 9 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr9       0x00000024U
#define Adr_NX51_sr_motion_sr_sr9 0x101006A4U
#define Adr_NX51_sr_sr9           0x101006A4U
#define DFLT_VAL_NX51_sr_sr9      0x00000000U

#define MSK_NX51_sr_sr9_val         0x0000ffffU
#define SRT_NX51_sr_sr9_val         0
#define DFLT_VAL_NX51_sr_sr9_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr9_val 0x00000000U

/* all used bits of 'NX51_sr_sr9': */
#define MSK_USED_BITS_NX51_sr_sr9 0x0000ffffU

enum {
	BFW_NX51_sr_sr9_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr9_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR9_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr9_val;       /* Shared Register                                                     */
	                                                    /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr9_reserved1; /* reserved                                                            */
} NX51_SR_SR9_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SR_SR9_BIT_T bf;
} NX51_SR_SR9_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr10 */
/* => Shared Work Register 10 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr10       0x00000028U
#define Adr_NX51_sr_motion_sr_sr10 0x101006A8U
#define Adr_NX51_sr_sr10           0x101006A8U
#define DFLT_VAL_NX51_sr_sr10      0x00000000U

#define MSK_NX51_sr_sr10_val         0x0000ffffU
#define SRT_NX51_sr_sr10_val         0
#define DFLT_VAL_NX51_sr_sr10_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr10_val 0x00000000U

/* all used bits of 'NX51_sr_sr10': */
#define MSK_USED_BITS_NX51_sr_sr10 0x0000ffffU

enum {
	BFW_NX51_sr_sr10_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr10_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR10_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr10_val;       /* Shared Register                                                     */
	                                                     /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr10_reserved1; /* reserved                                                            */
} NX51_SR_SR10_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SR_SR10_BIT_T bf;
} NX51_SR_SR10_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr11 */
/* => Shared Work Register 11 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr11       0x0000002CU
#define Adr_NX51_sr_motion_sr_sr11 0x101006ACU
#define Adr_NX51_sr_sr11           0x101006ACU
#define DFLT_VAL_NX51_sr_sr11      0x00000000U

#define MSK_NX51_sr_sr11_val         0x0000ffffU
#define SRT_NX51_sr_sr11_val         0
#define DFLT_VAL_NX51_sr_sr11_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr11_val 0x00000000U

/* all used bits of 'NX51_sr_sr11': */
#define MSK_USED_BITS_NX51_sr_sr11 0x0000ffffU

enum {
	BFW_NX51_sr_sr11_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr11_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR11_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr11_val;       /* Shared Register                                                     */
	                                                     /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr11_reserved1; /* reserved                                                            */
} NX51_SR_SR11_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SR_SR11_BIT_T bf;
} NX51_SR_SR11_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr12 */
/* => Shared Work Register 12 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr12       0x00000030U
#define Adr_NX51_sr_motion_sr_sr12 0x101006B0U
#define Adr_NX51_sr_sr12           0x101006B0U
#define DFLT_VAL_NX51_sr_sr12      0x00000000U

#define MSK_NX51_sr_sr12_val         0x0000ffffU
#define SRT_NX51_sr_sr12_val         0
#define DFLT_VAL_NX51_sr_sr12_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr12_val 0x00000000U

/* all used bits of 'NX51_sr_sr12': */
#define MSK_USED_BITS_NX51_sr_sr12 0x0000ffffU

enum {
	BFW_NX51_sr_sr12_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr12_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR12_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr12_val;       /* Shared Register                                                     */
	                                                     /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr12_reserved1; /* reserved                                                            */
} NX51_SR_SR12_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SR_SR12_BIT_T bf;
} NX51_SR_SR12_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr13 */
/* => Shared Work Register 13 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr13       0x00000034U
#define Adr_NX51_sr_motion_sr_sr13 0x101006B4U
#define Adr_NX51_sr_sr13           0x101006B4U
#define DFLT_VAL_NX51_sr_sr13      0x00000000U

#define MSK_NX51_sr_sr13_val         0x0000ffffU
#define SRT_NX51_sr_sr13_val         0
#define DFLT_VAL_NX51_sr_sr13_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr13_val 0x00000000U

/* all used bits of 'NX51_sr_sr13': */
#define MSK_USED_BITS_NX51_sr_sr13 0x0000ffffU

enum {
	BFW_NX51_sr_sr13_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr13_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR13_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr13_val;       /* Shared Register                                                     */
	                                                     /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr13_reserved1; /* reserved                                                            */
} NX51_SR_SR13_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SR_SR13_BIT_T bf;
} NX51_SR_SR13_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr14 */
/* => Shared Work Register 14 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr14       0x00000038U
#define Adr_NX51_sr_motion_sr_sr14 0x101006B8U
#define Adr_NX51_sr_sr14           0x101006B8U
#define DFLT_VAL_NX51_sr_sr14      0x00000000U

#define MSK_NX51_sr_sr14_val         0x0000ffffU
#define SRT_NX51_sr_sr14_val         0
#define DFLT_VAL_NX51_sr_sr14_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr14_val 0x00000000U

/* all used bits of 'NX51_sr_sr14': */
#define MSK_USED_BITS_NX51_sr_sr14 0x0000ffffU

enum {
	BFW_NX51_sr_sr14_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr14_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR14_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr14_val;       /* Shared Register                                                     */
	                                                     /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr14_reserved1; /* reserved                                                            */
} NX51_SR_SR14_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SR_SR14_BIT_T bf;
} NX51_SR_SR14_T;

/* --------------------------------------------------------------------- */
/* Register sr_sr15 */
/* => Shared Work Register 15 accessed over motion intlogic. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_sr15       0x0000003CU
#define Adr_NX51_sr_motion_sr_sr15 0x101006BCU
#define Adr_NX51_sr_sr15           0x101006BCU
#define DFLT_VAL_NX51_sr_sr15      0x00000000U

#define MSK_NX51_sr_sr15_val         0x0000ffffU
#define SRT_NX51_sr_sr15_val         0
#define DFLT_VAL_NX51_sr_sr15_val    0x00000000U
#define DFLT_BF_VAL_NX51_sr_sr15_val 0x00000000U

/* all used bits of 'NX51_sr_sr15': */
#define MSK_USED_BITS_NX51_sr_sr15 0x0000ffffU

enum {
	BFW_NX51_sr_sr15_val       = 16, /* [15:0] */
	BFW_NX51_sr_sr15_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_SR_SR15_BIT_Ttag {
	unsigned int val       : BFW_NX51_sr_sr15_val;       /* Shared Register                                                     */
	                                                     /* This register is writable but can also be changed by hardware. (XC) */
	unsigned int reserved1 : BFW_NX51_sr_sr15_reserved1; /* reserved                                                            */
} NX51_SR_SR15_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SR_SR15_BIT_T bf;
} NX51_SR_SR15_T;

/* --------------------------------------------------------------------- */
/* Register sr_statcfg0 */
/* => XPEC Shared Config/Status Register 0 */
/*    This register is writable but can also be changed by hardware. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_statcfg0       0x00000040U
#define Adr_NX51_sr_motion_sr_statcfg0 0x101006C0U
#define Adr_NX51_sr_statcfg0           0x101006C0U
#define DFLT_VAL_NX51_sr_statcfg0      0x00000000U

#define MSK_NX51_sr_statcfg0_xmac0_config_shared0         0x000000ffU
#define SRT_NX51_sr_statcfg0_xmac0_config_shared0         0
#define DFLT_VAL_NX51_sr_statcfg0_xmac0_config_shared0    0x00000000U
#define DFLT_BF_VAL_NX51_sr_statcfg0_xmac0_config_shared0 0x00000000U
#define MSK_NX51_sr_statcfg0_xmac0_io_oe_shared0          0x0000ff00U
#define SRT_NX51_sr_statcfg0_xmac0_io_oe_shared0          8
#define DFLT_VAL_NX51_sr_statcfg0_xmac0_io_oe_shared0     0x00000000U
#define DFLT_BF_VAL_NX51_sr_statcfg0_xmac0_io_oe_shared0  0x00000000U
#define MSK_NX51_sr_statcfg0_xmac0_status_shared0         0xffff0000U
#define SRT_NX51_sr_statcfg0_xmac0_status_shared0         16
#define DFLT_VAL_NX51_sr_statcfg0_xmac0_status_shared0    0x00000000U
#define DFLT_BF_VAL_NX51_sr_statcfg0_xmac0_status_shared0 0x00000000U

/* all used bits of 'NX51_sr_statcfg0': */
#define MSK_USED_BITS_NX51_sr_statcfg0 0xffffffffU

enum {
	BFW_NX51_sr_statcfg0_xmac0_config_shared0 = 8,  /* [7:0] */
	BFW_NX51_sr_statcfg0_xmac0_io_oe_shared0  = 8,  /* [15:8] */
	BFW_NX51_sr_statcfg0_xmac0_status_shared0 = 16  /* [31:16] */
};

typedef struct NX51_SR_STATCFG0_BIT_Ttag {
	unsigned int xmac0_config_shared0 : BFW_NX51_sr_statcfg0_xmac0_config_shared0; /* same as xmac0_config_shared0[7:0]           */
	unsigned int xmac0_io_oe_shared0  : BFW_NX51_sr_statcfg0_xmac0_io_oe_shared0;  /* same as xmac0_io_oe_shared0[7:0]            */
	unsigned int xmac0_status_shared0 : BFW_NX51_sr_statcfg0_xmac0_status_shared0; /* read access: same as xmac0_status_shared0   */
	                                                                               /* write access: write bit mask for bits 15..0 */
} NX51_SR_STATCFG0_BIT_T;

typedef union {
	unsigned int           val;
	NX51_SR_STATCFG0_BIT_T bf;
} NX51_SR_STATCFG0_T;

/* --------------------------------------------------------------------- */
/* Register sr_statcfg1 */
/* => XPEC Shared Config/Status Register 1 */
/*    This register is writable but can also be changed by hardware. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_statcfg1       0x00000044U
#define Adr_NX51_sr_motion_sr_statcfg1 0x101006C4U
#define Adr_NX51_sr_statcfg1           0x101006C4U
#define DFLT_VAL_NX51_sr_statcfg1      0x00000000U

#define MSK_NX51_sr_statcfg1_xmac1_config_shared1         0x000000ffU
#define SRT_NX51_sr_statcfg1_xmac1_config_shared1         0
#define DFLT_VAL_NX51_sr_statcfg1_xmac1_config_shared1    0x00000000U
#define DFLT_BF_VAL_NX51_sr_statcfg1_xmac1_config_shared1 0x00000000U
#define MSK_NX51_sr_statcfg1_xmac1_io_oe_shared1          0x0000ff00U
#define SRT_NX51_sr_statcfg1_xmac1_io_oe_shared1          8
#define DFLT_VAL_NX51_sr_statcfg1_xmac1_io_oe_shared1     0x00000000U
#define DFLT_BF_VAL_NX51_sr_statcfg1_xmac1_io_oe_shared1  0x00000000U
#define MSK_NX51_sr_statcfg1_xmac1_status_shared1         0xffff0000U
#define SRT_NX51_sr_statcfg1_xmac1_status_shared1         16
#define DFLT_VAL_NX51_sr_statcfg1_xmac1_status_shared1    0x00000000U
#define DFLT_BF_VAL_NX51_sr_statcfg1_xmac1_status_shared1 0x00000000U

/* all used bits of 'NX51_sr_statcfg1': */
#define MSK_USED_BITS_NX51_sr_statcfg1 0xffffffffU

enum {
	BFW_NX51_sr_statcfg1_xmac1_config_shared1 = 8,  /* [7:0] */
	BFW_NX51_sr_statcfg1_xmac1_io_oe_shared1  = 8,  /* [15:8] */
	BFW_NX51_sr_statcfg1_xmac1_status_shared1 = 16  /* [31:16] */
};

typedef struct NX51_SR_STATCFG1_BIT_Ttag {
	unsigned int xmac1_config_shared1 : BFW_NX51_sr_statcfg1_xmac1_config_shared1; /* same as xmac1_config_shared1[7:0]           */
	unsigned int xmac1_io_oe_shared1  : BFW_NX51_sr_statcfg1_xmac1_io_oe_shared1;  /* same as xmac1_io_oe_shared1[7:0]            */
	unsigned int xmac1_status_shared1 : BFW_NX51_sr_statcfg1_xmac1_status_shared1; /* read access: same as xmac1_status_shared1   */
	                                                                               /* write access: write bit mask for bits 15..0 */
} NX51_SR_STATCFG1_BIT_T;

typedef union {
	unsigned int           val;
	NX51_SR_STATCFG1_BIT_T bf;
} NX51_SR_STATCFG1_T;

/* --------------------------------------------------------------------- */
/* Register sr_stat_bits_shared */
/* => Shared stat register accessed by all xPECs and all xMACs (with 16 events). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sr_stat_bits_shared       0x00000048U
#define Adr_NX51_sr_motion_sr_stat_bits_shared 0x101006C8U
#define Adr_NX51_sr_stat_bits_shared           0x101006C8U
#define DFLT_VAL_NX51_sr_stat_bits_shared      0x00000000U

#define MSK_NX51_sr_stat_bits_shared_flags            0x0000ffffU
#define SRT_NX51_sr_stat_bits_shared_flags            0
#define DFLT_VAL_NX51_sr_stat_bits_shared_flags       0x00000000U
#define DFLT_BF_VAL_NX51_sr_stat_bits_shared_flags    0x00000000U
#define MSK_NX51_sr_stat_bits_shared_set_mask         0xffff0000U
#define SRT_NX51_sr_stat_bits_shared_set_mask         16
#define DFLT_VAL_NX51_sr_stat_bits_shared_set_mask    0x00000000U
#define DFLT_BF_VAL_NX51_sr_stat_bits_shared_set_mask 0x00000000U

/* all used bits of 'NX51_sr_stat_bits_shared': */
#define MSK_USED_BITS_NX51_sr_stat_bits_shared 0xffffffffU

enum {
	BFW_NX51_sr_stat_bits_shared_flags    = 16, /* [15:0] */
	BFW_NX51_sr_stat_bits_shared_set_mask = 16  /* [31:16] */
};

typedef struct NX51_SR_STAT_BITS_SHARED_BIT_Ttag {
	unsigned int flags    : BFW_NX51_sr_stat_bits_shared_flags;    /* flags                                                               */
	unsigned int set_mask : BFW_NX51_sr_stat_bits_shared_set_mask; /* set mask                                                            */
	                                                               /* This register is writable but can also be changed by hardware. (XC) */
} NX51_SR_STAT_BITS_SHARED_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_SR_STAT_BITS_SHARED_BIT_T bf;
} NX51_SR_STAT_BITS_SHARED_T;


/* ===================================================================== */

/* Area of cordic */

/* ===================================================================== */

#define Addr_NX51_cordic 0x10140000U

/* --------------------------------------------------------------------- */
/* Register cordic_ctrl */
/* => CORDIC control register. */
/*    This register controls the precision and the mode of operation.  It is also used to start the CORDIC. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cordic_ctrl    0x00000000U
#define Adr_NX51_cordic_cordic_ctrl 0x10140000U
#define Adr_NX51_cordic_ctrl        0x10140000U
#define DFLT_VAL_NX51_cordic_ctrl   0x00000040U

#define MSK_NX51_cordic_ctrl_start               0x00000001U
#define SRT_NX51_cordic_ctrl_start               0
#define DFLT_VAL_NX51_cordic_ctrl_start          0x00000000U
#define DFLT_BF_VAL_NX51_cordic_ctrl_start       0x00000000U
#define MSK_NX51_cordic_ctrl_target_axis         0x00000060U
#define SRT_NX51_cordic_ctrl_target_axis         5
#define DFLT_VAL_NX51_cordic_ctrl_target_axis    0x00000040U
#define DFLT_BF_VAL_NX51_cordic_ctrl_target_axis 0x00000002U

/* all used bits of 'NX51_cordic_ctrl': */
#define MSK_USED_BITS_NX51_cordic_ctrl 0x00000061U

enum {
	BFW_NX51_cordic_ctrl_start       = 1,  /* [0] */
	BFW_NX51_cordic_ctrl_reserved1   = 4,  /* [4:1] */
	BFW_NX51_cordic_ctrl_target_axis = 2,  /* [6:5] */
	BFW_NX51_cordic_ctrl_reserved2   = 25  /* [31:7] */
};

typedef struct NX51_CORDIC_CTRL_BIT_Ttag {
	unsigned int start       : BFW_NX51_cordic_ctrl_start;       /* 1: start calculation.  this bit is reset to zero by the CORDIC once it finished calculation. */
	                                                             /* This bit is writable but can also be changed by hardware.                                    */
	                                                             /* Reading the resolution registers while the CORDIC is running yields undefined values         */
	unsigned int reserved1   : BFW_NX51_cordic_ctrl_reserved1;   /* reserved                                                                                     */
	unsigned int target_axis : BFW_NX51_cordic_ctrl_target_axis; /* specifies which register (component of the vector) is driven towards the target value of 0.  */
	                                                             /* 01: vectoring mode. Rotate until Y=0.                                                        */
	                                                             /* 10: rotation mode. Rotate until Z=0.                                                         */
	unsigned int reserved2   : BFW_NX51_cordic_ctrl_reserved2;   /* reserved                                                                                     */
} NX51_CORDIC_CTRL_BIT_T;

typedef union {
	unsigned int           val;
	NX51_CORDIC_CTRL_BIT_T bf;
} NX51_CORDIC_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register cordic_x_reg */
/* => CORDIC argument and result register X */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cordic_x_reg    0x00000004U
#define Adr_NX51_cordic_cordic_x_reg 0x10140004U
#define Adr_NX51_cordic_x_reg        0x10140004U
#define DFLT_VAL_NX51_cordic_x_reg   0x00000000U

#define MSK_NX51_cordic_x_reg_argument         0xffffffffU
#define SRT_NX51_cordic_x_reg_argument         0
#define DFLT_VAL_NX51_cordic_x_reg_argument    0x00000000U
#define DFLT_BF_VAL_NX51_cordic_x_reg_argument 0x00000000U

/* all used bits of 'NX51_cordic_x_reg': */
#define MSK_USED_BITS_NX51_cordic_x_reg 0xffffffffU

enum {
	BFW_NX51_cordic_x_reg_argument = 32  /* [31:0] */
};

typedef struct NX51_CORDIC_X_REG_BIT_Ttag {
	unsigned int argument : BFW_NX51_cordic_x_reg_argument; /* x-component of input vector */
} NX51_CORDIC_X_REG_BIT_T;

typedef union {
	unsigned int            val;
	NX51_CORDIC_X_REG_BIT_T bf;
} NX51_CORDIC_X_REG_T;

/* --------------------------------------------------------------------- */
/* Register cordic_y_reg */
/* => CORDIC argument and result register Y */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cordic_y_reg    0x00000008U
#define Adr_NX51_cordic_cordic_y_reg 0x10140008U
#define Adr_NX51_cordic_y_reg        0x10140008U
#define DFLT_VAL_NX51_cordic_y_reg   0x00000000U

#define MSK_NX51_cordic_y_reg_argument         0xffffffffU
#define SRT_NX51_cordic_y_reg_argument         0
#define DFLT_VAL_NX51_cordic_y_reg_argument    0x00000000U
#define DFLT_BF_VAL_NX51_cordic_y_reg_argument 0x00000000U

/* all used bits of 'NX51_cordic_y_reg': */
#define MSK_USED_BITS_NX51_cordic_y_reg 0xffffffffU

enum {
	BFW_NX51_cordic_y_reg_argument = 32  /* [31:0] */
};

typedef struct NX51_CORDIC_Y_REG_BIT_Ttag {
	unsigned int argument : BFW_NX51_cordic_y_reg_argument; /* y-component of input vector */
} NX51_CORDIC_Y_REG_BIT_T;

typedef union {
	unsigned int            val;
	NX51_CORDIC_Y_REG_BIT_T bf;
} NX51_CORDIC_Y_REG_T;

/* --------------------------------------------------------------------- */
/* Register cordic_z_reg */
/* => CORDIC argument and result register Z */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cordic_z_reg    0x0000000CU
#define Adr_NX51_cordic_cordic_z_reg 0x1014000CU
#define Adr_NX51_cordic_z_reg        0x1014000CU
#define DFLT_VAL_NX51_cordic_z_reg   0x00000000U

#define MSK_NX51_cordic_z_reg_argument         0xffffffffU
#define SRT_NX51_cordic_z_reg_argument         0
#define DFLT_VAL_NX51_cordic_z_reg_argument    0x00000000U
#define DFLT_BF_VAL_NX51_cordic_z_reg_argument 0x00000000U

/* all used bits of 'NX51_cordic_z_reg': */
#define MSK_USED_BITS_NX51_cordic_z_reg 0xffffffffU

enum {
	BFW_NX51_cordic_z_reg_argument = 32  /* [31:0] */
};

typedef struct NX51_CORDIC_Z_REG_BIT_Ttag {
	unsigned int argument : BFW_NX51_cordic_z_reg_argument; /* input angle */
} NX51_CORDIC_Z_REG_BIT_T;

typedef union {
	unsigned int            val;
	NX51_CORDIC_Z_REG_BIT_T bf;
} NX51_CORDIC_Z_REG_T;


/* ===================================================================== */

/* AREA gpio */
/* Area of gpio_motion, gpio */

/* ===================================================================== */

#define Addr_NX51_gpio_motion 0x10140400U
#define Addr_NX51_gpio        0x1018CA00U
#define NX51_NETX_GPIO_AREA   0x1018CA00U

/* --------------------------------------------------------------------- */
/* Register gpio_cfg0 */
/* => GPIO pin 0 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg0         0x00000000U
#define Adr_NX51_gpio_motion_gpio_cfg0 0x10140400U
#define Adr_NX51_gpio_gpio_cfg0        0x1018CA00U
#define DFLT_VAL_NX51_gpio_cfg0        0x00000000U

#define MSK_NX51_gpio_cfg0_mode              0x0000000fU
#define SRT_NX51_gpio_cfg0_mode              0
#define DFLT_VAL_NX51_gpio_cfg0_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg0_mode      0x00000000U
#define MSK_NX51_gpio_cfg0_inv               0x00000010U
#define SRT_NX51_gpio_cfg0_inv               4
#define DFLT_VAL_NX51_gpio_cfg0_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg0_inv       0x00000000U
#define MSK_NX51_gpio_cfg0_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg0_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg0_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg0_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg0': */
#define MSK_USED_BITS_NX51_gpio_cfg0 0x000000ffU

enum {
	BFW_NX51_gpio_cfg0_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg0_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg0_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg0_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG0_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg0_mode;      /* defines the gp input or output mode - depends on iocfg                                                */
	                                                       /* Input modi :                                                                                          */
	                                                       /*  0000: read mode                                                                                      */
	                                                       /*  0001: capture continued at rising edge (allows gpio_irq on each capture)                             */
	                                                       /*  0010: capture once at rising edge (reset gpio_irq (in intlogic or intlogic_motion) to capture again) */
	                                                       /*  0011: capture once at high level  (reset gpio_irq (in intlogic or intlogic_motion) to capture again) */
	                                                       /* Output modi:                                                                                          */
	                                                       /*  0100: set to 0                                                                                       */
	                                                       /*  0101: set to 1                                                                                       */
	                                                       /*  0110: set to gpio_line[0]                                                                            */
	                                                       /*  0111: pwm mode, direct treshold update (might cause hazards on output)                               */
	                                                       /* Multi pin modi:                                                                                       */
	                                                       /*  1111: pwm2-mode with treshold update at counter=0 from gpio_tc[n+1] register (hazard-free)           */
	unsigned int inv       : BFW_NX51_gpio_cfg0_inv;       /* 1: invert input/output value                                                                          */
	                                                       /* 0: don't invert input/output                                                                          */
	unsigned int count_ref : BFW_NX51_gpio_cfg0_count_ref; /* counter reference                                                                                     */
	                                                       /*  000: counter 0                                                                                       */
	                                                       /*  001: counter 1                                                                                       */
	                                                       /*  010: counter 2                                                                                       */
	                                                       /*  011: counter 3                                                                                       */
	                                                       /*  100: counter 4                                                                                       */
	                                                       /*  111: sys_time (global system time)                                                                   */
	unsigned int reserved1 : BFW_NX51_gpio_cfg0_reserved1; /* reserved                                                                                              */
} NX51_GPIO_CFG0_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG0_BIT_T bf;
} NX51_GPIO_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg1 */
/* => GPIO pin 1 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg1         0x00000004U
#define Adr_NX51_gpio_motion_gpio_cfg1 0x10140404U
#define Adr_NX51_gpio_gpio_cfg1        0x1018CA04U
#define DFLT_VAL_NX51_gpio_cfg1        0x00000000U

#define MSK_NX51_gpio_cfg1_mode              0x0000000fU
#define SRT_NX51_gpio_cfg1_mode              0
#define DFLT_VAL_NX51_gpio_cfg1_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg1_mode      0x00000000U
#define MSK_NX51_gpio_cfg1_inv               0x00000010U
#define SRT_NX51_gpio_cfg1_inv               4
#define DFLT_VAL_NX51_gpio_cfg1_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg1_inv       0x00000000U
#define MSK_NX51_gpio_cfg1_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg1_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg1_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg1_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg1': */
#define MSK_USED_BITS_NX51_gpio_cfg1 0x000000ffU

enum {
	BFW_NX51_gpio_cfg1_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg1_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg1_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg1_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG1_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg1_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg1_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg1_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg1_reserved1; /* reserved            */
} NX51_GPIO_CFG1_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG1_BIT_T bf;
} NX51_GPIO_CFG1_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg2 */
/* => GPIO pin 2 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg2         0x00000008U
#define Adr_NX51_gpio_motion_gpio_cfg2 0x10140408U
#define Adr_NX51_gpio_gpio_cfg2        0x1018CA08U
#define DFLT_VAL_NX51_gpio_cfg2        0x00000000U

#define MSK_NX51_gpio_cfg2_mode              0x0000000fU
#define SRT_NX51_gpio_cfg2_mode              0
#define DFLT_VAL_NX51_gpio_cfg2_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg2_mode      0x00000000U
#define MSK_NX51_gpio_cfg2_inv               0x00000010U
#define SRT_NX51_gpio_cfg2_inv               4
#define DFLT_VAL_NX51_gpio_cfg2_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg2_inv       0x00000000U
#define MSK_NX51_gpio_cfg2_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg2_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg2_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg2_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg2': */
#define MSK_USED_BITS_NX51_gpio_cfg2 0x000000ffU

enum {
	BFW_NX51_gpio_cfg2_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg2_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg2_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg2_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG2_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg2_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg2_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg2_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg2_reserved1; /* reserved            */
} NX51_GPIO_CFG2_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG2_BIT_T bf;
} NX51_GPIO_CFG2_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg3 */
/* => GPIO pin 3 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg3         0x0000000CU
#define Adr_NX51_gpio_motion_gpio_cfg3 0x1014040CU
#define Adr_NX51_gpio_gpio_cfg3        0x1018CA0CU
#define DFLT_VAL_NX51_gpio_cfg3        0x00000000U

#define MSK_NX51_gpio_cfg3_mode              0x0000000fU
#define SRT_NX51_gpio_cfg3_mode              0
#define DFLT_VAL_NX51_gpio_cfg3_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg3_mode      0x00000000U
#define MSK_NX51_gpio_cfg3_inv               0x00000010U
#define SRT_NX51_gpio_cfg3_inv               4
#define DFLT_VAL_NX51_gpio_cfg3_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg3_inv       0x00000000U
#define MSK_NX51_gpio_cfg3_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg3_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg3_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg3_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg3': */
#define MSK_USED_BITS_NX51_gpio_cfg3 0x000000ffU

enum {
	BFW_NX51_gpio_cfg3_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg3_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg3_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg3_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG3_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg3_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg3_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg3_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg3_reserved1; /* reserved            */
} NX51_GPIO_CFG3_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG3_BIT_T bf;
} NX51_GPIO_CFG3_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg4 */
/* => GPIO pin 4 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg4         0x00000010U
#define Adr_NX51_gpio_motion_gpio_cfg4 0x10140410U
#define Adr_NX51_gpio_gpio_cfg4        0x1018CA10U
#define DFLT_VAL_NX51_gpio_cfg4        0x00000000U

#define MSK_NX51_gpio_cfg4_mode              0x0000000fU
#define SRT_NX51_gpio_cfg4_mode              0
#define DFLT_VAL_NX51_gpio_cfg4_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg4_mode      0x00000000U
#define MSK_NX51_gpio_cfg4_inv               0x00000010U
#define SRT_NX51_gpio_cfg4_inv               4
#define DFLT_VAL_NX51_gpio_cfg4_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg4_inv       0x00000000U
#define MSK_NX51_gpio_cfg4_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg4_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg4_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg4_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg4': */
#define MSK_USED_BITS_NX51_gpio_cfg4 0x000000ffU

enum {
	BFW_NX51_gpio_cfg4_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg4_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg4_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg4_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG4_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg4_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg4_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg4_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg4_reserved1; /* reserved            */
} NX51_GPIO_CFG4_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG4_BIT_T bf;
} NX51_GPIO_CFG4_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg5 */
/* => GPIO pin 5 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg5         0x00000014U
#define Adr_NX51_gpio_motion_gpio_cfg5 0x10140414U
#define Adr_NX51_gpio_gpio_cfg5        0x1018CA14U
#define DFLT_VAL_NX51_gpio_cfg5        0x00000000U

#define MSK_NX51_gpio_cfg5_mode              0x0000000fU
#define SRT_NX51_gpio_cfg5_mode              0
#define DFLT_VAL_NX51_gpio_cfg5_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg5_mode      0x00000000U
#define MSK_NX51_gpio_cfg5_inv               0x00000010U
#define SRT_NX51_gpio_cfg5_inv               4
#define DFLT_VAL_NX51_gpio_cfg5_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg5_inv       0x00000000U
#define MSK_NX51_gpio_cfg5_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg5_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg5_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg5_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg5': */
#define MSK_USED_BITS_NX51_gpio_cfg5 0x000000ffU

enum {
	BFW_NX51_gpio_cfg5_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg5_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg5_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg5_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG5_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg5_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg5_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg5_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg5_reserved1; /* reserved            */
} NX51_GPIO_CFG5_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG5_BIT_T bf;
} NX51_GPIO_CFG5_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg6 */
/* => GPIO pin 6 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg6         0x00000018U
#define Adr_NX51_gpio_motion_gpio_cfg6 0x10140418U
#define Adr_NX51_gpio_gpio_cfg6        0x1018CA18U
#define DFLT_VAL_NX51_gpio_cfg6        0x00000000U

#define MSK_NX51_gpio_cfg6_mode              0x0000000fU
#define SRT_NX51_gpio_cfg6_mode              0
#define DFLT_VAL_NX51_gpio_cfg6_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg6_mode      0x00000000U
#define MSK_NX51_gpio_cfg6_inv               0x00000010U
#define SRT_NX51_gpio_cfg6_inv               4
#define DFLT_VAL_NX51_gpio_cfg6_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg6_inv       0x00000000U
#define MSK_NX51_gpio_cfg6_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg6_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg6_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg6_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg6': */
#define MSK_USED_BITS_NX51_gpio_cfg6 0x000000ffU

enum {
	BFW_NX51_gpio_cfg6_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg6_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg6_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg6_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG6_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg6_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg6_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg6_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg6_reserved1; /* reserved            */
} NX51_GPIO_CFG6_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG6_BIT_T bf;
} NX51_GPIO_CFG6_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg7 */
/* => GPIO pin 7 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg7         0x0000001CU
#define Adr_NX51_gpio_motion_gpio_cfg7 0x1014041CU
#define Adr_NX51_gpio_gpio_cfg7        0x1018CA1CU
#define DFLT_VAL_NX51_gpio_cfg7        0x00000000U

#define MSK_NX51_gpio_cfg7_mode              0x0000000fU
#define SRT_NX51_gpio_cfg7_mode              0
#define DFLT_VAL_NX51_gpio_cfg7_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg7_mode      0x00000000U
#define MSK_NX51_gpio_cfg7_inv               0x00000010U
#define SRT_NX51_gpio_cfg7_inv               4
#define DFLT_VAL_NX51_gpio_cfg7_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg7_inv       0x00000000U
#define MSK_NX51_gpio_cfg7_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg7_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg7_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg7_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg7': */
#define MSK_USED_BITS_NX51_gpio_cfg7 0x000000ffU

enum {
	BFW_NX51_gpio_cfg7_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg7_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg7_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg7_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG7_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg7_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg7_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg7_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg7_reserved1; /* reserved            */
} NX51_GPIO_CFG7_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG7_BIT_T bf;
} NX51_GPIO_CFG7_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg8 */
/* => GPIO pin 8 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg8         0x00000020U
#define Adr_NX51_gpio_motion_gpio_cfg8 0x10140420U
#define Adr_NX51_gpio_gpio_cfg8        0x1018CA20U
#define DFLT_VAL_NX51_gpio_cfg8        0x00000000U

#define MSK_NX51_gpio_cfg8_mode              0x0000000fU
#define SRT_NX51_gpio_cfg8_mode              0
#define DFLT_VAL_NX51_gpio_cfg8_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg8_mode      0x00000000U
#define MSK_NX51_gpio_cfg8_inv               0x00000010U
#define SRT_NX51_gpio_cfg8_inv               4
#define DFLT_VAL_NX51_gpio_cfg8_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg8_inv       0x00000000U
#define MSK_NX51_gpio_cfg8_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg8_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg8_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg8_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg8': */
#define MSK_USED_BITS_NX51_gpio_cfg8 0x000000ffU

enum {
	BFW_NX51_gpio_cfg8_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg8_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg8_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg8_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG8_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg8_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg8_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg8_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg8_reserved1; /* reserved            */
} NX51_GPIO_CFG8_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG8_BIT_T bf;
} NX51_GPIO_CFG8_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg9 */
/* => GPIO pin 9 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg9         0x00000024U
#define Adr_NX51_gpio_motion_gpio_cfg9 0x10140424U
#define Adr_NX51_gpio_gpio_cfg9        0x1018CA24U
#define DFLT_VAL_NX51_gpio_cfg9        0x00000000U

#define MSK_NX51_gpio_cfg9_mode              0x0000000fU
#define SRT_NX51_gpio_cfg9_mode              0
#define DFLT_VAL_NX51_gpio_cfg9_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg9_mode      0x00000000U
#define MSK_NX51_gpio_cfg9_inv               0x00000010U
#define SRT_NX51_gpio_cfg9_inv               4
#define DFLT_VAL_NX51_gpio_cfg9_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg9_inv       0x00000000U
#define MSK_NX51_gpio_cfg9_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg9_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg9_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg9_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg9': */
#define MSK_USED_BITS_NX51_gpio_cfg9 0x000000ffU

enum {
	BFW_NX51_gpio_cfg9_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg9_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg9_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg9_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG9_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg9_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg9_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg9_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg9_reserved1; /* reserved            */
} NX51_GPIO_CFG9_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_CFG9_BIT_T bf;
} NX51_GPIO_CFG9_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg10 */
/* => GPIO pin 10 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg10         0x00000028U
#define Adr_NX51_gpio_motion_gpio_cfg10 0x10140428U
#define Adr_NX51_gpio_gpio_cfg10        0x1018CA28U
#define DFLT_VAL_NX51_gpio_cfg10        0x00000000U

#define MSK_NX51_gpio_cfg10_mode              0x0000000fU
#define SRT_NX51_gpio_cfg10_mode              0
#define DFLT_VAL_NX51_gpio_cfg10_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg10_mode      0x00000000U
#define MSK_NX51_gpio_cfg10_inv               0x00000010U
#define SRT_NX51_gpio_cfg10_inv               4
#define DFLT_VAL_NX51_gpio_cfg10_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg10_inv       0x00000000U
#define MSK_NX51_gpio_cfg10_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg10_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg10_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg10_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg10': */
#define MSK_USED_BITS_NX51_gpio_cfg10 0x000000ffU

enum {
	BFW_NX51_gpio_cfg10_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg10_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg10_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg10_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG10_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg10_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg10_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg10_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg10_reserved1; /* reserved            */
} NX51_GPIO_CFG10_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG10_BIT_T bf;
} NX51_GPIO_CFG10_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg11 */
/* => GPIO pin 11 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg11         0x0000002CU
#define Adr_NX51_gpio_motion_gpio_cfg11 0x1014042CU
#define Adr_NX51_gpio_gpio_cfg11        0x1018CA2CU
#define DFLT_VAL_NX51_gpio_cfg11        0x00000000U

#define MSK_NX51_gpio_cfg11_mode              0x0000000fU
#define SRT_NX51_gpio_cfg11_mode              0
#define DFLT_VAL_NX51_gpio_cfg11_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg11_mode      0x00000000U
#define MSK_NX51_gpio_cfg11_inv               0x00000010U
#define SRT_NX51_gpio_cfg11_inv               4
#define DFLT_VAL_NX51_gpio_cfg11_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg11_inv       0x00000000U
#define MSK_NX51_gpio_cfg11_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg11_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg11_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg11_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg11': */
#define MSK_USED_BITS_NX51_gpio_cfg11 0x000000ffU

enum {
	BFW_NX51_gpio_cfg11_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg11_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg11_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg11_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG11_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg11_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg11_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg11_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg11_reserved1; /* reserved            */
} NX51_GPIO_CFG11_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG11_BIT_T bf;
} NX51_GPIO_CFG11_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg12 */
/* => GPIO pin 12 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg12         0x00000030U
#define Adr_NX51_gpio_motion_gpio_cfg12 0x10140430U
#define Adr_NX51_gpio_gpio_cfg12        0x1018CA30U
#define DFLT_VAL_NX51_gpio_cfg12        0x00000000U

#define MSK_NX51_gpio_cfg12_mode              0x0000000fU
#define SRT_NX51_gpio_cfg12_mode              0
#define DFLT_VAL_NX51_gpio_cfg12_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg12_mode      0x00000000U
#define MSK_NX51_gpio_cfg12_inv               0x00000010U
#define SRT_NX51_gpio_cfg12_inv               4
#define DFLT_VAL_NX51_gpio_cfg12_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg12_inv       0x00000000U
#define MSK_NX51_gpio_cfg12_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg12_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg12_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg12_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg12': */
#define MSK_USED_BITS_NX51_gpio_cfg12 0x000000ffU

enum {
	BFW_NX51_gpio_cfg12_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg12_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg12_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg12_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG12_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg12_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg12_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg12_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg12_reserved1; /* reserved            */
} NX51_GPIO_CFG12_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG12_BIT_T bf;
} NX51_GPIO_CFG12_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg13 */
/* => GPIO pin 13 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg13         0x00000034U
#define Adr_NX51_gpio_motion_gpio_cfg13 0x10140434U
#define Adr_NX51_gpio_gpio_cfg13        0x1018CA34U
#define DFLT_VAL_NX51_gpio_cfg13        0x00000000U

#define MSK_NX51_gpio_cfg13_mode              0x0000000fU
#define SRT_NX51_gpio_cfg13_mode              0
#define DFLT_VAL_NX51_gpio_cfg13_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg13_mode      0x00000000U
#define MSK_NX51_gpio_cfg13_inv               0x00000010U
#define SRT_NX51_gpio_cfg13_inv               4
#define DFLT_VAL_NX51_gpio_cfg13_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg13_inv       0x00000000U
#define MSK_NX51_gpio_cfg13_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg13_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg13_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg13_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg13': */
#define MSK_USED_BITS_NX51_gpio_cfg13 0x000000ffU

enum {
	BFW_NX51_gpio_cfg13_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg13_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg13_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg13_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG13_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg13_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg13_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg13_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg13_reserved1; /* reserved            */
} NX51_GPIO_CFG13_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG13_BIT_T bf;
} NX51_GPIO_CFG13_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg14 */
/* => GPIO pin 14 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg14         0x00000038U
#define Adr_NX51_gpio_motion_gpio_cfg14 0x10140438U
#define Adr_NX51_gpio_gpio_cfg14        0x1018CA38U
#define DFLT_VAL_NX51_gpio_cfg14        0x00000000U

#define MSK_NX51_gpio_cfg14_mode              0x0000000fU
#define SRT_NX51_gpio_cfg14_mode              0
#define DFLT_VAL_NX51_gpio_cfg14_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg14_mode      0x00000000U
#define MSK_NX51_gpio_cfg14_inv               0x00000010U
#define SRT_NX51_gpio_cfg14_inv               4
#define DFLT_VAL_NX51_gpio_cfg14_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg14_inv       0x00000000U
#define MSK_NX51_gpio_cfg14_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg14_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg14_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg14_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg14': */
#define MSK_USED_BITS_NX51_gpio_cfg14 0x000000ffU

enum {
	BFW_NX51_gpio_cfg14_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg14_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg14_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg14_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG14_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg14_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg14_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg14_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg14_reserved1; /* reserved            */
} NX51_GPIO_CFG14_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG14_BIT_T bf;
} NX51_GPIO_CFG14_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg15 */
/* => GPIO pin 15 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg15         0x0000003CU
#define Adr_NX51_gpio_motion_gpio_cfg15 0x1014043CU
#define Adr_NX51_gpio_gpio_cfg15        0x1018CA3CU
#define DFLT_VAL_NX51_gpio_cfg15        0x00000000U

#define MSK_NX51_gpio_cfg15_mode              0x0000000fU
#define SRT_NX51_gpio_cfg15_mode              0
#define DFLT_VAL_NX51_gpio_cfg15_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg15_mode      0x00000000U
#define MSK_NX51_gpio_cfg15_inv               0x00000010U
#define SRT_NX51_gpio_cfg15_inv               4
#define DFLT_VAL_NX51_gpio_cfg15_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg15_inv       0x00000000U
#define MSK_NX51_gpio_cfg15_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg15_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg15_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg15_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg15': */
#define MSK_USED_BITS_NX51_gpio_cfg15 0x000000ffU

enum {
	BFW_NX51_gpio_cfg15_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg15_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg15_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg15_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG15_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg15_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg15_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg15_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg15_reserved1; /* reserved            */
} NX51_GPIO_CFG15_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG15_BIT_T bf;
} NX51_GPIO_CFG15_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg16 */
/* => GPIO pin 16 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg16         0x00000040U
#define Adr_NX51_gpio_motion_gpio_cfg16 0x10140440U
#define Adr_NX51_gpio_gpio_cfg16        0x1018CA40U
#define DFLT_VAL_NX51_gpio_cfg16        0x00000000U

#define MSK_NX51_gpio_cfg16_mode              0x0000000fU
#define SRT_NX51_gpio_cfg16_mode              0
#define DFLT_VAL_NX51_gpio_cfg16_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg16_mode      0x00000000U
#define MSK_NX51_gpio_cfg16_inv               0x00000010U
#define SRT_NX51_gpio_cfg16_inv               4
#define DFLT_VAL_NX51_gpio_cfg16_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg16_inv       0x00000000U
#define MSK_NX51_gpio_cfg16_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg16_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg16_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg16_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg16': */
#define MSK_USED_BITS_NX51_gpio_cfg16 0x000000ffU

enum {
	BFW_NX51_gpio_cfg16_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg16_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg16_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg16_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG16_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg16_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg16_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg16_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg16_reserved1; /* reserved            */
} NX51_GPIO_CFG16_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG16_BIT_T bf;
} NX51_GPIO_CFG16_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg17 */
/* => GPIO pin 17 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg17         0x00000044U
#define Adr_NX51_gpio_motion_gpio_cfg17 0x10140444U
#define Adr_NX51_gpio_gpio_cfg17        0x1018CA44U
#define DFLT_VAL_NX51_gpio_cfg17        0x00000000U

#define MSK_NX51_gpio_cfg17_mode              0x0000000fU
#define SRT_NX51_gpio_cfg17_mode              0
#define DFLT_VAL_NX51_gpio_cfg17_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg17_mode      0x00000000U
#define MSK_NX51_gpio_cfg17_inv               0x00000010U
#define SRT_NX51_gpio_cfg17_inv               4
#define DFLT_VAL_NX51_gpio_cfg17_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg17_inv       0x00000000U
#define MSK_NX51_gpio_cfg17_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg17_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg17_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg17_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg17': */
#define MSK_USED_BITS_NX51_gpio_cfg17 0x000000ffU

enum {
	BFW_NX51_gpio_cfg17_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg17_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg17_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg17_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG17_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg17_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg17_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg17_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg17_reserved1; /* reserved            */
} NX51_GPIO_CFG17_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG17_BIT_T bf;
} NX51_GPIO_CFG17_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg18 */
/* => GPIO pin 18 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg18         0x00000048U
#define Adr_NX51_gpio_motion_gpio_cfg18 0x10140448U
#define Adr_NX51_gpio_gpio_cfg18        0x1018CA48U
#define DFLT_VAL_NX51_gpio_cfg18        0x00000000U

#define MSK_NX51_gpio_cfg18_mode              0x0000000fU
#define SRT_NX51_gpio_cfg18_mode              0
#define DFLT_VAL_NX51_gpio_cfg18_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg18_mode      0x00000000U
#define MSK_NX51_gpio_cfg18_inv               0x00000010U
#define SRT_NX51_gpio_cfg18_inv               4
#define DFLT_VAL_NX51_gpio_cfg18_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg18_inv       0x00000000U
#define MSK_NX51_gpio_cfg18_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg18_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg18_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg18_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg18': */
#define MSK_USED_BITS_NX51_gpio_cfg18 0x000000ffU

enum {
	BFW_NX51_gpio_cfg18_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg18_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg18_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg18_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG18_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg18_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg18_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg18_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg18_reserved1; /* reserved            */
} NX51_GPIO_CFG18_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG18_BIT_T bf;
} NX51_GPIO_CFG18_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg19 */
/* => GPIO pin 19 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg19         0x0000004CU
#define Adr_NX51_gpio_motion_gpio_cfg19 0x1014044CU
#define Adr_NX51_gpio_gpio_cfg19        0x1018CA4CU
#define DFLT_VAL_NX51_gpio_cfg19        0x00000000U

#define MSK_NX51_gpio_cfg19_mode              0x0000000fU
#define SRT_NX51_gpio_cfg19_mode              0
#define DFLT_VAL_NX51_gpio_cfg19_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg19_mode      0x00000000U
#define MSK_NX51_gpio_cfg19_inv               0x00000010U
#define SRT_NX51_gpio_cfg19_inv               4
#define DFLT_VAL_NX51_gpio_cfg19_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg19_inv       0x00000000U
#define MSK_NX51_gpio_cfg19_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg19_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg19_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg19_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg19': */
#define MSK_USED_BITS_NX51_gpio_cfg19 0x000000ffU

enum {
	BFW_NX51_gpio_cfg19_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg19_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg19_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg19_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG19_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg19_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg19_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg19_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg19_reserved1; /* reserved            */
} NX51_GPIO_CFG19_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG19_BIT_T bf;
} NX51_GPIO_CFG19_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg20 */
/* => GPIO pin 20 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg20         0x00000050U
#define Adr_NX51_gpio_motion_gpio_cfg20 0x10140450U
#define Adr_NX51_gpio_gpio_cfg20        0x1018CA50U
#define DFLT_VAL_NX51_gpio_cfg20        0x00000000U

#define MSK_NX51_gpio_cfg20_mode              0x0000000fU
#define SRT_NX51_gpio_cfg20_mode              0
#define DFLT_VAL_NX51_gpio_cfg20_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg20_mode      0x00000000U
#define MSK_NX51_gpio_cfg20_inv               0x00000010U
#define SRT_NX51_gpio_cfg20_inv               4
#define DFLT_VAL_NX51_gpio_cfg20_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg20_inv       0x00000000U
#define MSK_NX51_gpio_cfg20_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg20_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg20_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg20_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg20': */
#define MSK_USED_BITS_NX51_gpio_cfg20 0x000000ffU

enum {
	BFW_NX51_gpio_cfg20_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg20_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg20_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg20_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG20_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg20_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg20_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg20_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg20_reserved1; /* reserved            */
} NX51_GPIO_CFG20_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG20_BIT_T bf;
} NX51_GPIO_CFG20_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg21 */
/* => GPIO pin 21 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg21         0x00000054U
#define Adr_NX51_gpio_motion_gpio_cfg21 0x10140454U
#define Adr_NX51_gpio_gpio_cfg21        0x1018CA54U
#define DFLT_VAL_NX51_gpio_cfg21        0x00000000U

#define MSK_NX51_gpio_cfg21_mode              0x0000000fU
#define SRT_NX51_gpio_cfg21_mode              0
#define DFLT_VAL_NX51_gpio_cfg21_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg21_mode      0x00000000U
#define MSK_NX51_gpio_cfg21_inv               0x00000010U
#define SRT_NX51_gpio_cfg21_inv               4
#define DFLT_VAL_NX51_gpio_cfg21_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg21_inv       0x00000000U
#define MSK_NX51_gpio_cfg21_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg21_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg21_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg21_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg21': */
#define MSK_USED_BITS_NX51_gpio_cfg21 0x000000ffU

enum {
	BFW_NX51_gpio_cfg21_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg21_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg21_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg21_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG21_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg21_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg21_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg21_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg21_reserved1; /* reserved            */
} NX51_GPIO_CFG21_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG21_BIT_T bf;
} NX51_GPIO_CFG21_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg22 */
/* => GPIO pin 22 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg22         0x00000058U
#define Adr_NX51_gpio_motion_gpio_cfg22 0x10140458U
#define Adr_NX51_gpio_gpio_cfg22        0x1018CA58U
#define DFLT_VAL_NX51_gpio_cfg22        0x00000000U

#define MSK_NX51_gpio_cfg22_mode              0x0000000fU
#define SRT_NX51_gpio_cfg22_mode              0
#define DFLT_VAL_NX51_gpio_cfg22_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg22_mode      0x00000000U
#define MSK_NX51_gpio_cfg22_inv               0x00000010U
#define SRT_NX51_gpio_cfg22_inv               4
#define DFLT_VAL_NX51_gpio_cfg22_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg22_inv       0x00000000U
#define MSK_NX51_gpio_cfg22_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg22_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg22_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg22_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg22': */
#define MSK_USED_BITS_NX51_gpio_cfg22 0x000000ffU

enum {
	BFW_NX51_gpio_cfg22_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg22_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg22_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg22_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG22_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg22_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg22_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg22_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg22_reserved1; /* reserved            */
} NX51_GPIO_CFG22_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG22_BIT_T bf;
} NX51_GPIO_CFG22_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg23 */
/* => GPIO pin 23 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg23         0x0000005CU
#define Adr_NX51_gpio_motion_gpio_cfg23 0x1014045CU
#define Adr_NX51_gpio_gpio_cfg23        0x1018CA5CU
#define DFLT_VAL_NX51_gpio_cfg23        0x00000000U

#define MSK_NX51_gpio_cfg23_mode              0x0000000fU
#define SRT_NX51_gpio_cfg23_mode              0
#define DFLT_VAL_NX51_gpio_cfg23_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg23_mode      0x00000000U
#define MSK_NX51_gpio_cfg23_inv               0x00000010U
#define SRT_NX51_gpio_cfg23_inv               4
#define DFLT_VAL_NX51_gpio_cfg23_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg23_inv       0x00000000U
#define MSK_NX51_gpio_cfg23_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg23_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg23_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg23_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg23': */
#define MSK_USED_BITS_NX51_gpio_cfg23 0x000000ffU

enum {
	BFW_NX51_gpio_cfg23_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg23_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg23_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg23_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG23_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg23_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg23_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg23_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg23_reserved1; /* reserved            */
} NX51_GPIO_CFG23_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG23_BIT_T bf;
} NX51_GPIO_CFG23_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg24 */
/* => GPIO pin 24 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg24         0x00000060U
#define Adr_NX51_gpio_motion_gpio_cfg24 0x10140460U
#define Adr_NX51_gpio_gpio_cfg24        0x1018CA60U
#define DFLT_VAL_NX51_gpio_cfg24        0x00000000U

#define MSK_NX51_gpio_cfg24_mode              0x0000000fU
#define SRT_NX51_gpio_cfg24_mode              0
#define DFLT_VAL_NX51_gpio_cfg24_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg24_mode      0x00000000U
#define MSK_NX51_gpio_cfg24_inv               0x00000010U
#define SRT_NX51_gpio_cfg24_inv               4
#define DFLT_VAL_NX51_gpio_cfg24_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg24_inv       0x00000000U
#define MSK_NX51_gpio_cfg24_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg24_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg24_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg24_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg24': */
#define MSK_USED_BITS_NX51_gpio_cfg24 0x000000ffU

enum {
	BFW_NX51_gpio_cfg24_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg24_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg24_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg24_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG24_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg24_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg24_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg24_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg24_reserved1; /* reserved            */
} NX51_GPIO_CFG24_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG24_BIT_T bf;
} NX51_GPIO_CFG24_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg25 */
/* => GPIO pin 25 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg25         0x00000064U
#define Adr_NX51_gpio_motion_gpio_cfg25 0x10140464U
#define Adr_NX51_gpio_gpio_cfg25        0x1018CA64U
#define DFLT_VAL_NX51_gpio_cfg25        0x00000000U

#define MSK_NX51_gpio_cfg25_mode              0x0000000fU
#define SRT_NX51_gpio_cfg25_mode              0
#define DFLT_VAL_NX51_gpio_cfg25_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg25_mode      0x00000000U
#define MSK_NX51_gpio_cfg25_inv               0x00000010U
#define SRT_NX51_gpio_cfg25_inv               4
#define DFLT_VAL_NX51_gpio_cfg25_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg25_inv       0x00000000U
#define MSK_NX51_gpio_cfg25_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg25_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg25_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg25_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg25': */
#define MSK_USED_BITS_NX51_gpio_cfg25 0x000000ffU

enum {
	BFW_NX51_gpio_cfg25_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg25_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg25_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg25_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG25_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg25_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg25_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg25_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg25_reserved1; /* reserved            */
} NX51_GPIO_CFG25_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG25_BIT_T bf;
} NX51_GPIO_CFG25_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg26 */
/* => GPIO pin 26 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg26         0x00000068U
#define Adr_NX51_gpio_motion_gpio_cfg26 0x10140468U
#define Adr_NX51_gpio_gpio_cfg26        0x1018CA68U
#define DFLT_VAL_NX51_gpio_cfg26        0x00000000U

#define MSK_NX51_gpio_cfg26_mode              0x0000000fU
#define SRT_NX51_gpio_cfg26_mode              0
#define DFLT_VAL_NX51_gpio_cfg26_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg26_mode      0x00000000U
#define MSK_NX51_gpio_cfg26_inv               0x00000010U
#define SRT_NX51_gpio_cfg26_inv               4
#define DFLT_VAL_NX51_gpio_cfg26_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg26_inv       0x00000000U
#define MSK_NX51_gpio_cfg26_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg26_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg26_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg26_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg26': */
#define MSK_USED_BITS_NX51_gpio_cfg26 0x000000ffU

enum {
	BFW_NX51_gpio_cfg26_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg26_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg26_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg26_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG26_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg26_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg26_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg26_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg26_reserved1; /* reserved            */
} NX51_GPIO_CFG26_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG26_BIT_T bf;
} NX51_GPIO_CFG26_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg27 */
/* => GPIO pin 27 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg27         0x0000006CU
#define Adr_NX51_gpio_motion_gpio_cfg27 0x1014046CU
#define Adr_NX51_gpio_gpio_cfg27        0x1018CA6CU
#define DFLT_VAL_NX51_gpio_cfg27        0x00000000U

#define MSK_NX51_gpio_cfg27_mode              0x0000000fU
#define SRT_NX51_gpio_cfg27_mode              0
#define DFLT_VAL_NX51_gpio_cfg27_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg27_mode      0x00000000U
#define MSK_NX51_gpio_cfg27_inv               0x00000010U
#define SRT_NX51_gpio_cfg27_inv               4
#define DFLT_VAL_NX51_gpio_cfg27_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg27_inv       0x00000000U
#define MSK_NX51_gpio_cfg27_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg27_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg27_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg27_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg27': */
#define MSK_USED_BITS_NX51_gpio_cfg27 0x000000ffU

enum {
	BFW_NX51_gpio_cfg27_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg27_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg27_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg27_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG27_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg27_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg27_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg27_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg27_reserved1; /* reserved            */
} NX51_GPIO_CFG27_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG27_BIT_T bf;
} NX51_GPIO_CFG27_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg28 */
/* => GPIO pin 28 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg28         0x00000070U
#define Adr_NX51_gpio_motion_gpio_cfg28 0x10140470U
#define Adr_NX51_gpio_gpio_cfg28        0x1018CA70U
#define DFLT_VAL_NX51_gpio_cfg28        0x00000000U

#define MSK_NX51_gpio_cfg28_mode              0x0000000fU
#define SRT_NX51_gpio_cfg28_mode              0
#define DFLT_VAL_NX51_gpio_cfg28_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg28_mode      0x00000000U
#define MSK_NX51_gpio_cfg28_inv               0x00000010U
#define SRT_NX51_gpio_cfg28_inv               4
#define DFLT_VAL_NX51_gpio_cfg28_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg28_inv       0x00000000U
#define MSK_NX51_gpio_cfg28_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg28_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg28_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg28_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg28': */
#define MSK_USED_BITS_NX51_gpio_cfg28 0x000000ffU

enum {
	BFW_NX51_gpio_cfg28_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg28_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg28_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg28_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG28_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg28_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg28_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg28_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg28_reserved1; /* reserved            */
} NX51_GPIO_CFG28_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG28_BIT_T bf;
} NX51_GPIO_CFG28_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg29 */
/* => GPIO pin 29 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg29         0x00000074U
#define Adr_NX51_gpio_motion_gpio_cfg29 0x10140474U
#define Adr_NX51_gpio_gpio_cfg29        0x1018CA74U
#define DFLT_VAL_NX51_gpio_cfg29        0x00000000U

#define MSK_NX51_gpio_cfg29_mode              0x0000000fU
#define SRT_NX51_gpio_cfg29_mode              0
#define DFLT_VAL_NX51_gpio_cfg29_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg29_mode      0x00000000U
#define MSK_NX51_gpio_cfg29_inv               0x00000010U
#define SRT_NX51_gpio_cfg29_inv               4
#define DFLT_VAL_NX51_gpio_cfg29_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg29_inv       0x00000000U
#define MSK_NX51_gpio_cfg29_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg29_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg29_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg29_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg29': */
#define MSK_USED_BITS_NX51_gpio_cfg29 0x000000ffU

enum {
	BFW_NX51_gpio_cfg29_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg29_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg29_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg29_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG29_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg29_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg29_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg29_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg29_reserved1; /* reserved            */
} NX51_GPIO_CFG29_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG29_BIT_T bf;
} NX51_GPIO_CFG29_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg30 */
/* => GPIO pin 30 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg30         0x00000078U
#define Adr_NX51_gpio_motion_gpio_cfg30 0x10140478U
#define Adr_NX51_gpio_gpio_cfg30        0x1018CA78U
#define DFLT_VAL_NX51_gpio_cfg30        0x00000000U

#define MSK_NX51_gpio_cfg30_mode              0x0000000fU
#define SRT_NX51_gpio_cfg30_mode              0
#define DFLT_VAL_NX51_gpio_cfg30_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg30_mode      0x00000000U
#define MSK_NX51_gpio_cfg30_inv               0x00000010U
#define SRT_NX51_gpio_cfg30_inv               4
#define DFLT_VAL_NX51_gpio_cfg30_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg30_inv       0x00000000U
#define MSK_NX51_gpio_cfg30_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg30_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg30_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg30_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg30': */
#define MSK_USED_BITS_NX51_gpio_cfg30 0x000000ffU

enum {
	BFW_NX51_gpio_cfg30_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg30_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg30_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg30_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG30_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg30_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg30_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg30_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg30_reserved1; /* reserved            */
} NX51_GPIO_CFG30_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG30_BIT_T bf;
} NX51_GPIO_CFG30_T;

/* --------------------------------------------------------------------- */
/* Register gpio_cfg31 */
/* => GPIO pin 31 config register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_cfg31         0x0000007CU
#define Adr_NX51_gpio_motion_gpio_cfg31 0x1014047CU
#define Adr_NX51_gpio_gpio_cfg31        0x1018CA7CU
#define DFLT_VAL_NX51_gpio_cfg31        0x00000000U

#define MSK_NX51_gpio_cfg31_mode              0x0000000fU
#define SRT_NX51_gpio_cfg31_mode              0
#define DFLT_VAL_NX51_gpio_cfg31_mode         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg31_mode      0x00000000U
#define MSK_NX51_gpio_cfg31_inv               0x00000010U
#define SRT_NX51_gpio_cfg31_inv               4
#define DFLT_VAL_NX51_gpio_cfg31_inv          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg31_inv       0x00000000U
#define MSK_NX51_gpio_cfg31_count_ref         0x000000e0U
#define SRT_NX51_gpio_cfg31_count_ref         5
#define DFLT_VAL_NX51_gpio_cfg31_count_ref    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_cfg31_count_ref 0x00000000U

/* all used bits of 'NX51_gpio_cfg31': */
#define MSK_USED_BITS_NX51_gpio_cfg31 0x000000ffU

enum {
	BFW_NX51_gpio_cfg31_mode      = 4,  /* [3:0] */
	BFW_NX51_gpio_cfg31_inv       = 1,  /* [4] */
	BFW_NX51_gpio_cfg31_count_ref = 3,  /* [7:5] */
	BFW_NX51_gpio_cfg31_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_GPIO_CFG31_BIT_Ttag {
	unsigned int mode      : BFW_NX51_gpio_cfg31_mode;      /* analog to gpio_cfg0 */
	unsigned int inv       : BFW_NX51_gpio_cfg31_inv;       /* analog to gpio_cfg0 */
	unsigned int count_ref : BFW_NX51_gpio_cfg31_count_ref; /* analog to gpio_cfg0 */
	unsigned int reserved1 : BFW_NX51_gpio_cfg31_reserved1; /* reserved            */
} NX51_GPIO_CFG31_BIT_T;

typedef union {
	unsigned int          val;
	NX51_GPIO_CFG31_BIT_T bf;
} NX51_GPIO_CFG31_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc0 */
/* => GPIO pin 0 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc0         0x00000080U
#define Adr_NX51_gpio_motion_gpio_tc0 0x10140480U
#define Adr_NX51_gpio_gpio_tc0        0x1018CA80U
#define DFLT_VAL_NX51_gpio_tc0        0x00000000U

#define MSK_NX51_gpio_tc0_val         0xffffffffU
#define SRT_NX51_gpio_tc0_val         0
#define DFLT_VAL_NX51_gpio_tc0_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc0_val 0x00000000U

/* all used bits of 'NX51_gpio_tc0': */
#define MSK_USED_BITS_NX51_gpio_tc0 0xffffffffU

enum {
	BFW_NX51_gpio_tc0_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC0_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc0_val; /* Treshold/Capture register:                                                                                      */
	                                          /* PWM mode (treshold):                                                                                            */
	                                          /*   The counter threshold value equals the number of inactive clockcylces per period (cycles with pwm=0).         */
	                                          /*   Therefore it is interpreted different in symmetrical and asymmetrical counter mode:                           */
	                                          /*   Asymmetrical mode (sawtooth): pwm = (counter >= gpio_tc)                                                      */
	                                          /*   Symmetrical mode (triangle) : counter is compared with gpio_tc[31:1], gpio_tc[0] prolonges the inactive phase */
	                                          /*     by 1 cc only while upcounting. This allows running 10ns resolution even in symmetrical mode.                */
	                                          /* Capture mode (capture register)                                                                                 */
	                                          /*   In capture mode this register holds the captured counter value.                                               */
} NX51_GPIO_TC0_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC0_BIT_T bf;
} NX51_GPIO_TC0_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc1 */
/* => GPIO pin 1 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc1         0x00000084U
#define Adr_NX51_gpio_motion_gpio_tc1 0x10140484U
#define Adr_NX51_gpio_gpio_tc1        0x1018CA84U
#define DFLT_VAL_NX51_gpio_tc1        0x00000000U

#define MSK_NX51_gpio_tc1_val         0xffffffffU
#define SRT_NX51_gpio_tc1_val         0
#define DFLT_VAL_NX51_gpio_tc1_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc1_val 0x00000000U

/* all used bits of 'NX51_gpio_tc1': */
#define MSK_USED_BITS_NX51_gpio_tc1 0xffffffffU

enum {
	BFW_NX51_gpio_tc1_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC1_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc1_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC1_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC1_BIT_T bf;
} NX51_GPIO_TC1_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc2 */
/* => GPIO pin 2 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc2         0x00000088U
#define Adr_NX51_gpio_motion_gpio_tc2 0x10140488U
#define Adr_NX51_gpio_gpio_tc2        0x1018CA88U
#define DFLT_VAL_NX51_gpio_tc2        0x00000000U

#define MSK_NX51_gpio_tc2_val         0xffffffffU
#define SRT_NX51_gpio_tc2_val         0
#define DFLT_VAL_NX51_gpio_tc2_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc2_val 0x00000000U

/* all used bits of 'NX51_gpio_tc2': */
#define MSK_USED_BITS_NX51_gpio_tc2 0xffffffffU

enum {
	BFW_NX51_gpio_tc2_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC2_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc2_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC2_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC2_BIT_T bf;
} NX51_GPIO_TC2_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc3 */
/* => GPIO pin 3 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc3         0x0000008CU
#define Adr_NX51_gpio_motion_gpio_tc3 0x1014048CU
#define Adr_NX51_gpio_gpio_tc3        0x1018CA8CU
#define DFLT_VAL_NX51_gpio_tc3        0x00000000U

#define MSK_NX51_gpio_tc3_val         0xffffffffU
#define SRT_NX51_gpio_tc3_val         0
#define DFLT_VAL_NX51_gpio_tc3_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc3_val 0x00000000U

/* all used bits of 'NX51_gpio_tc3': */
#define MSK_USED_BITS_NX51_gpio_tc3 0xffffffffU

enum {
	BFW_NX51_gpio_tc3_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC3_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc3_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC3_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC3_BIT_T bf;
} NX51_GPIO_TC3_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc4 */
/* => GPIO pin 4 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc4         0x00000090U
#define Adr_NX51_gpio_motion_gpio_tc4 0x10140490U
#define Adr_NX51_gpio_gpio_tc4        0x1018CA90U
#define DFLT_VAL_NX51_gpio_tc4        0x00000000U

#define MSK_NX51_gpio_tc4_val         0xffffffffU
#define SRT_NX51_gpio_tc4_val         0
#define DFLT_VAL_NX51_gpio_tc4_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc4_val 0x00000000U

/* all used bits of 'NX51_gpio_tc4': */
#define MSK_USED_BITS_NX51_gpio_tc4 0xffffffffU

enum {
	BFW_NX51_gpio_tc4_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC4_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc4_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC4_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC4_BIT_T bf;
} NX51_GPIO_TC4_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc5 */
/* => GPIO pin 5 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc5         0x00000094U
#define Adr_NX51_gpio_motion_gpio_tc5 0x10140494U
#define Adr_NX51_gpio_gpio_tc5        0x1018CA94U
#define DFLT_VAL_NX51_gpio_tc5        0x00000000U

#define MSK_NX51_gpio_tc5_val         0xffffffffU
#define SRT_NX51_gpio_tc5_val         0
#define DFLT_VAL_NX51_gpio_tc5_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc5_val 0x00000000U

/* all used bits of 'NX51_gpio_tc5': */
#define MSK_USED_BITS_NX51_gpio_tc5 0xffffffffU

enum {
	BFW_NX51_gpio_tc5_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC5_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc5_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC5_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC5_BIT_T bf;
} NX51_GPIO_TC5_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc6 */
/* => GPIO pin 6 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc6         0x00000098U
#define Adr_NX51_gpio_motion_gpio_tc6 0x10140498U
#define Adr_NX51_gpio_gpio_tc6        0x1018CA98U
#define DFLT_VAL_NX51_gpio_tc6        0x00000000U

#define MSK_NX51_gpio_tc6_val         0xffffffffU
#define SRT_NX51_gpio_tc6_val         0
#define DFLT_VAL_NX51_gpio_tc6_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc6_val 0x00000000U

/* all used bits of 'NX51_gpio_tc6': */
#define MSK_USED_BITS_NX51_gpio_tc6 0xffffffffU

enum {
	BFW_NX51_gpio_tc6_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC6_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc6_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC6_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC6_BIT_T bf;
} NX51_GPIO_TC6_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc7 */
/* => GPIO pin 7 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc7         0x0000009CU
#define Adr_NX51_gpio_motion_gpio_tc7 0x1014049CU
#define Adr_NX51_gpio_gpio_tc7        0x1018CA9CU
#define DFLT_VAL_NX51_gpio_tc7        0x00000000U

#define MSK_NX51_gpio_tc7_val         0xffffffffU
#define SRT_NX51_gpio_tc7_val         0
#define DFLT_VAL_NX51_gpio_tc7_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc7_val 0x00000000U

/* all used bits of 'NX51_gpio_tc7': */
#define MSK_USED_BITS_NX51_gpio_tc7 0xffffffffU

enum {
	BFW_NX51_gpio_tc7_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC7_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc7_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC7_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC7_BIT_T bf;
} NX51_GPIO_TC7_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc8 */
/* => GPIO pin 8 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc8         0x000000A0U
#define Adr_NX51_gpio_motion_gpio_tc8 0x101404A0U
#define Adr_NX51_gpio_gpio_tc8        0x1018CAA0U
#define DFLT_VAL_NX51_gpio_tc8        0x00000000U

#define MSK_NX51_gpio_tc8_val         0xffffffffU
#define SRT_NX51_gpio_tc8_val         0
#define DFLT_VAL_NX51_gpio_tc8_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc8_val 0x00000000U

/* all used bits of 'NX51_gpio_tc8': */
#define MSK_USED_BITS_NX51_gpio_tc8 0xffffffffU

enum {
	BFW_NX51_gpio_tc8_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC8_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc8_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC8_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC8_BIT_T bf;
} NX51_GPIO_TC8_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc9 */
/* => GPIO pin 9 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc9         0x000000A4U
#define Adr_NX51_gpio_motion_gpio_tc9 0x101404A4U
#define Adr_NX51_gpio_gpio_tc9        0x1018CAA4U
#define DFLT_VAL_NX51_gpio_tc9        0x00000000U

#define MSK_NX51_gpio_tc9_val         0xffffffffU
#define SRT_NX51_gpio_tc9_val         0
#define DFLT_VAL_NX51_gpio_tc9_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc9_val 0x00000000U

/* all used bits of 'NX51_gpio_tc9': */
#define MSK_USED_BITS_NX51_gpio_tc9 0xffffffffU

enum {
	BFW_NX51_gpio_tc9_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC9_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc9_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC9_BIT_T;

typedef union {
	unsigned int        val;
	NX51_GPIO_TC9_BIT_T bf;
} NX51_GPIO_TC9_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc10 */
/* => GPIO pin 10 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc10         0x000000A8U
#define Adr_NX51_gpio_motion_gpio_tc10 0x101404A8U
#define Adr_NX51_gpio_gpio_tc10        0x1018CAA8U
#define DFLT_VAL_NX51_gpio_tc10        0x00000000U

#define MSK_NX51_gpio_tc10_val         0xffffffffU
#define SRT_NX51_gpio_tc10_val         0
#define DFLT_VAL_NX51_gpio_tc10_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc10_val 0x00000000U

/* all used bits of 'NX51_gpio_tc10': */
#define MSK_USED_BITS_NX51_gpio_tc10 0xffffffffU

enum {
	BFW_NX51_gpio_tc10_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC10_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc10_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC10_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC10_BIT_T bf;
} NX51_GPIO_TC10_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc11 */
/* => GPIO pin 11 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc11         0x000000ACU
#define Adr_NX51_gpio_motion_gpio_tc11 0x101404ACU
#define Adr_NX51_gpio_gpio_tc11        0x1018CAACU
#define DFLT_VAL_NX51_gpio_tc11        0x00000000U

#define MSK_NX51_gpio_tc11_val         0xffffffffU
#define SRT_NX51_gpio_tc11_val         0
#define DFLT_VAL_NX51_gpio_tc11_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc11_val 0x00000000U

/* all used bits of 'NX51_gpio_tc11': */
#define MSK_USED_BITS_NX51_gpio_tc11 0xffffffffU

enum {
	BFW_NX51_gpio_tc11_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC11_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc11_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC11_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC11_BIT_T bf;
} NX51_GPIO_TC11_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc12 */
/* => GPIO pin 12 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc12         0x000000B0U
#define Adr_NX51_gpio_motion_gpio_tc12 0x101404B0U
#define Adr_NX51_gpio_gpio_tc12        0x1018CAB0U
#define DFLT_VAL_NX51_gpio_tc12        0x00000000U

#define MSK_NX51_gpio_tc12_val         0xffffffffU
#define SRT_NX51_gpio_tc12_val         0
#define DFLT_VAL_NX51_gpio_tc12_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc12_val 0x00000000U

/* all used bits of 'NX51_gpio_tc12': */
#define MSK_USED_BITS_NX51_gpio_tc12 0xffffffffU

enum {
	BFW_NX51_gpio_tc12_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC12_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc12_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC12_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC12_BIT_T bf;
} NX51_GPIO_TC12_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc13 */
/* => GPIO pin 13 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc13         0x000000B4U
#define Adr_NX51_gpio_motion_gpio_tc13 0x101404B4U
#define Adr_NX51_gpio_gpio_tc13        0x1018CAB4U
#define DFLT_VAL_NX51_gpio_tc13        0x00000000U

#define MSK_NX51_gpio_tc13_val         0xffffffffU
#define SRT_NX51_gpio_tc13_val         0
#define DFLT_VAL_NX51_gpio_tc13_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc13_val 0x00000000U

/* all used bits of 'NX51_gpio_tc13': */
#define MSK_USED_BITS_NX51_gpio_tc13 0xffffffffU

enum {
	BFW_NX51_gpio_tc13_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC13_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc13_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC13_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC13_BIT_T bf;
} NX51_GPIO_TC13_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc14 */
/* => GPIO pin 14 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc14         0x000000B8U
#define Adr_NX51_gpio_motion_gpio_tc14 0x101404B8U
#define Adr_NX51_gpio_gpio_tc14        0x1018CAB8U
#define DFLT_VAL_NX51_gpio_tc14        0x00000000U

#define MSK_NX51_gpio_tc14_val         0xffffffffU
#define SRT_NX51_gpio_tc14_val         0
#define DFLT_VAL_NX51_gpio_tc14_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc14_val 0x00000000U

/* all used bits of 'NX51_gpio_tc14': */
#define MSK_USED_BITS_NX51_gpio_tc14 0xffffffffU

enum {
	BFW_NX51_gpio_tc14_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC14_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc14_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC14_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC14_BIT_T bf;
} NX51_GPIO_TC14_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc15 */
/* => GPIO pin 15 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc15         0x000000BCU
#define Adr_NX51_gpio_motion_gpio_tc15 0x101404BCU
#define Adr_NX51_gpio_gpio_tc15        0x1018CABCU
#define DFLT_VAL_NX51_gpio_tc15        0x00000000U

#define MSK_NX51_gpio_tc15_val         0xffffffffU
#define SRT_NX51_gpio_tc15_val         0
#define DFLT_VAL_NX51_gpio_tc15_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc15_val 0x00000000U

/* all used bits of 'NX51_gpio_tc15': */
#define MSK_USED_BITS_NX51_gpio_tc15 0xffffffffU

enum {
	BFW_NX51_gpio_tc15_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC15_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc15_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC15_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC15_BIT_T bf;
} NX51_GPIO_TC15_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc16 */
/* => GPIO pin 16 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc16         0x000000C0U
#define Adr_NX51_gpio_motion_gpio_tc16 0x101404C0U
#define Adr_NX51_gpio_gpio_tc16        0x1018CAC0U
#define DFLT_VAL_NX51_gpio_tc16        0x00000000U

#define MSK_NX51_gpio_tc16_val         0xffffffffU
#define SRT_NX51_gpio_tc16_val         0
#define DFLT_VAL_NX51_gpio_tc16_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc16_val 0x00000000U

/* all used bits of 'NX51_gpio_tc16': */
#define MSK_USED_BITS_NX51_gpio_tc16 0xffffffffU

enum {
	BFW_NX51_gpio_tc16_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC16_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc16_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC16_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC16_BIT_T bf;
} NX51_GPIO_TC16_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc17 */
/* => GPIO pin 17 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc17         0x000000C4U
#define Adr_NX51_gpio_motion_gpio_tc17 0x101404C4U
#define Adr_NX51_gpio_gpio_tc17        0x1018CAC4U
#define DFLT_VAL_NX51_gpio_tc17        0x00000000U

#define MSK_NX51_gpio_tc17_val         0xffffffffU
#define SRT_NX51_gpio_tc17_val         0
#define DFLT_VAL_NX51_gpio_tc17_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc17_val 0x00000000U

/* all used bits of 'NX51_gpio_tc17': */
#define MSK_USED_BITS_NX51_gpio_tc17 0xffffffffU

enum {
	BFW_NX51_gpio_tc17_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC17_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc17_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC17_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC17_BIT_T bf;
} NX51_GPIO_TC17_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc18 */
/* => GPIO pin 18 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc18         0x000000C8U
#define Adr_NX51_gpio_motion_gpio_tc18 0x101404C8U
#define Adr_NX51_gpio_gpio_tc18        0x1018CAC8U
#define DFLT_VAL_NX51_gpio_tc18        0x00000000U

#define MSK_NX51_gpio_tc18_val         0xffffffffU
#define SRT_NX51_gpio_tc18_val         0
#define DFLT_VAL_NX51_gpio_tc18_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc18_val 0x00000000U

/* all used bits of 'NX51_gpio_tc18': */
#define MSK_USED_BITS_NX51_gpio_tc18 0xffffffffU

enum {
	BFW_NX51_gpio_tc18_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC18_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc18_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC18_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC18_BIT_T bf;
} NX51_GPIO_TC18_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc19 */
/* => GPIO pin 19 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc19         0x000000CCU
#define Adr_NX51_gpio_motion_gpio_tc19 0x101404CCU
#define Adr_NX51_gpio_gpio_tc19        0x1018CACCU
#define DFLT_VAL_NX51_gpio_tc19        0x00000000U

#define MSK_NX51_gpio_tc19_val         0xffffffffU
#define SRT_NX51_gpio_tc19_val         0
#define DFLT_VAL_NX51_gpio_tc19_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc19_val 0x00000000U

/* all used bits of 'NX51_gpio_tc19': */
#define MSK_USED_BITS_NX51_gpio_tc19 0xffffffffU

enum {
	BFW_NX51_gpio_tc19_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC19_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc19_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC19_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC19_BIT_T bf;
} NX51_GPIO_TC19_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc20 */
/* => GPIO pin 20 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc20         0x000000D0U
#define Adr_NX51_gpio_motion_gpio_tc20 0x101404D0U
#define Adr_NX51_gpio_gpio_tc20        0x1018CAD0U
#define DFLT_VAL_NX51_gpio_tc20        0x00000000U

#define MSK_NX51_gpio_tc20_val         0xffffffffU
#define SRT_NX51_gpio_tc20_val         0
#define DFLT_VAL_NX51_gpio_tc20_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc20_val 0x00000000U

/* all used bits of 'NX51_gpio_tc20': */
#define MSK_USED_BITS_NX51_gpio_tc20 0xffffffffU

enum {
	BFW_NX51_gpio_tc20_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC20_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc20_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC20_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC20_BIT_T bf;
} NX51_GPIO_TC20_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc21 */
/* => GPIO pin 21 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc21         0x000000D4U
#define Adr_NX51_gpio_motion_gpio_tc21 0x101404D4U
#define Adr_NX51_gpio_gpio_tc21        0x1018CAD4U
#define DFLT_VAL_NX51_gpio_tc21        0x00000000U

#define MSK_NX51_gpio_tc21_val         0xffffffffU
#define SRT_NX51_gpio_tc21_val         0
#define DFLT_VAL_NX51_gpio_tc21_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc21_val 0x00000000U

/* all used bits of 'NX51_gpio_tc21': */
#define MSK_USED_BITS_NX51_gpio_tc21 0xffffffffU

enum {
	BFW_NX51_gpio_tc21_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC21_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc21_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC21_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC21_BIT_T bf;
} NX51_GPIO_TC21_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc22 */
/* => GPIO pin 22 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc22         0x000000D8U
#define Adr_NX51_gpio_motion_gpio_tc22 0x101404D8U
#define Adr_NX51_gpio_gpio_tc22        0x1018CAD8U
#define DFLT_VAL_NX51_gpio_tc22        0x00000000U

#define MSK_NX51_gpio_tc22_val         0xffffffffU
#define SRT_NX51_gpio_tc22_val         0
#define DFLT_VAL_NX51_gpio_tc22_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc22_val 0x00000000U

/* all used bits of 'NX51_gpio_tc22': */
#define MSK_USED_BITS_NX51_gpio_tc22 0xffffffffU

enum {
	BFW_NX51_gpio_tc22_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC22_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc22_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC22_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC22_BIT_T bf;
} NX51_GPIO_TC22_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc23 */
/* => GPIO pin 23 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc23         0x000000DCU
#define Adr_NX51_gpio_motion_gpio_tc23 0x101404DCU
#define Adr_NX51_gpio_gpio_tc23        0x1018CADCU
#define DFLT_VAL_NX51_gpio_tc23        0x00000000U

#define MSK_NX51_gpio_tc23_val         0xffffffffU
#define SRT_NX51_gpio_tc23_val         0
#define DFLT_VAL_NX51_gpio_tc23_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc23_val 0x00000000U

/* all used bits of 'NX51_gpio_tc23': */
#define MSK_USED_BITS_NX51_gpio_tc23 0xffffffffU

enum {
	BFW_NX51_gpio_tc23_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC23_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc23_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC23_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC23_BIT_T bf;
} NX51_GPIO_TC23_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc24 */
/* => GPIO pin 24 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc24         0x000000E0U
#define Adr_NX51_gpio_motion_gpio_tc24 0x101404E0U
#define Adr_NX51_gpio_gpio_tc24        0x1018CAE0U
#define DFLT_VAL_NX51_gpio_tc24        0x00000000U

#define MSK_NX51_gpio_tc24_val         0xffffffffU
#define SRT_NX51_gpio_tc24_val         0
#define DFLT_VAL_NX51_gpio_tc24_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc24_val 0x00000000U

/* all used bits of 'NX51_gpio_tc24': */
#define MSK_USED_BITS_NX51_gpio_tc24 0xffffffffU

enum {
	BFW_NX51_gpio_tc24_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC24_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc24_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC24_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC24_BIT_T bf;
} NX51_GPIO_TC24_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc25 */
/* => GPIO pin 25 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc25         0x000000E4U
#define Adr_NX51_gpio_motion_gpio_tc25 0x101404E4U
#define Adr_NX51_gpio_gpio_tc25        0x1018CAE4U
#define DFLT_VAL_NX51_gpio_tc25        0x00000000U

#define MSK_NX51_gpio_tc25_val         0xffffffffU
#define SRT_NX51_gpio_tc25_val         0
#define DFLT_VAL_NX51_gpio_tc25_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc25_val 0x00000000U

/* all used bits of 'NX51_gpio_tc25': */
#define MSK_USED_BITS_NX51_gpio_tc25 0xffffffffU

enum {
	BFW_NX51_gpio_tc25_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC25_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc25_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC25_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC25_BIT_T bf;
} NX51_GPIO_TC25_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc26 */
/* => GPIO pin 26 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc26         0x000000E8U
#define Adr_NX51_gpio_motion_gpio_tc26 0x101404E8U
#define Adr_NX51_gpio_gpio_tc26        0x1018CAE8U
#define DFLT_VAL_NX51_gpio_tc26        0x00000000U

#define MSK_NX51_gpio_tc26_val         0xffffffffU
#define SRT_NX51_gpio_tc26_val         0
#define DFLT_VAL_NX51_gpio_tc26_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc26_val 0x00000000U

/* all used bits of 'NX51_gpio_tc26': */
#define MSK_USED_BITS_NX51_gpio_tc26 0xffffffffU

enum {
	BFW_NX51_gpio_tc26_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC26_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc26_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC26_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC26_BIT_T bf;
} NX51_GPIO_TC26_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc27 */
/* => GPIO pin 27 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc27         0x000000ECU
#define Adr_NX51_gpio_motion_gpio_tc27 0x101404ECU
#define Adr_NX51_gpio_gpio_tc27        0x1018CAECU
#define DFLT_VAL_NX51_gpio_tc27        0x00000000U

#define MSK_NX51_gpio_tc27_val         0xffffffffU
#define SRT_NX51_gpio_tc27_val         0
#define DFLT_VAL_NX51_gpio_tc27_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc27_val 0x00000000U

/* all used bits of 'NX51_gpio_tc27': */
#define MSK_USED_BITS_NX51_gpio_tc27 0xffffffffU

enum {
	BFW_NX51_gpio_tc27_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC27_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc27_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC27_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC27_BIT_T bf;
} NX51_GPIO_TC27_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc28 */
/* => GPIO pin 28 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc28         0x000000F0U
#define Adr_NX51_gpio_motion_gpio_tc28 0x101404F0U
#define Adr_NX51_gpio_gpio_tc28        0x1018CAF0U
#define DFLT_VAL_NX51_gpio_tc28        0x00000000U

#define MSK_NX51_gpio_tc28_val         0xffffffffU
#define SRT_NX51_gpio_tc28_val         0
#define DFLT_VAL_NX51_gpio_tc28_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc28_val 0x00000000U

/* all used bits of 'NX51_gpio_tc28': */
#define MSK_USED_BITS_NX51_gpio_tc28 0xffffffffU

enum {
	BFW_NX51_gpio_tc28_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC28_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc28_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC28_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC28_BIT_T bf;
} NX51_GPIO_TC28_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc29 */
/* => GPIO pin 29 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc29         0x000000F4U
#define Adr_NX51_gpio_motion_gpio_tc29 0x101404F4U
#define Adr_NX51_gpio_gpio_tc29        0x1018CAF4U
#define DFLT_VAL_NX51_gpio_tc29        0x00000000U

#define MSK_NX51_gpio_tc29_val         0xffffffffU
#define SRT_NX51_gpio_tc29_val         0
#define DFLT_VAL_NX51_gpio_tc29_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc29_val 0x00000000U

/* all used bits of 'NX51_gpio_tc29': */
#define MSK_USED_BITS_NX51_gpio_tc29 0xffffffffU

enum {
	BFW_NX51_gpio_tc29_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC29_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc29_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC29_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC29_BIT_T bf;
} NX51_GPIO_TC29_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc30 */
/* => GPIO pin 30 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc30         0x000000F8U
#define Adr_NX51_gpio_motion_gpio_tc30 0x101404F8U
#define Adr_NX51_gpio_gpio_tc30        0x1018CAF8U
#define DFLT_VAL_NX51_gpio_tc30        0x00000000U

#define MSK_NX51_gpio_tc30_val         0xffffffffU
#define SRT_NX51_gpio_tc30_val         0
#define DFLT_VAL_NX51_gpio_tc30_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc30_val 0x00000000U

/* all used bits of 'NX51_gpio_tc30': */
#define MSK_USED_BITS_NX51_gpio_tc30 0xffffffffU

enum {
	BFW_NX51_gpio_tc30_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC30_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc30_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC30_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC30_BIT_T bf;
} NX51_GPIO_TC30_T;

/* --------------------------------------------------------------------- */
/* Register gpio_tc31 */
/* => GPIO pin 31 threshold or capture register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_tc31         0x000000FCU
#define Adr_NX51_gpio_motion_gpio_tc31 0x101404FCU
#define Adr_NX51_gpio_gpio_tc31        0x1018CAFCU
#define DFLT_VAL_NX51_gpio_tc31        0x00000000U

#define MSK_NX51_gpio_tc31_val         0xffffffffU
#define SRT_NX51_gpio_tc31_val         0
#define DFLT_VAL_NX51_gpio_tc31_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_tc31_val 0x00000000U

/* all used bits of 'NX51_gpio_tc31': */
#define MSK_USED_BITS_NX51_gpio_tc31 0xffffffffU

enum {
	BFW_NX51_gpio_tc31_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_TC31_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_tc31_val; /* analog to gpio_tc0 */
} NX51_GPIO_TC31_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_TC31_BIT_T bf;
} NX51_GPIO_TC31_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter0_ctrl */
/* => GPIO counter0 control register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter0_ctrl         0x00000100U
#define Adr_NX51_gpio_motion_gpio_counter0_ctrl 0x10140500U
#define Adr_NX51_gpio_gpio_counter0_ctrl        0x1018CB00U
#define DFLT_VAL_NX51_gpio_counter0_ctrl        0x00000000U

#define MSK_NX51_gpio_counter0_ctrl_run               0x00000001U
#define SRT_NX51_gpio_counter0_ctrl_run               0
#define DFLT_VAL_NX51_gpio_counter0_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_ctrl_run       0x00000000U
#define MSK_NX51_gpio_counter0_ctrl_sym_nasym         0x00000002U
#define SRT_NX51_gpio_counter0_ctrl_sym_nasym         1
#define DFLT_VAL_NX51_gpio_counter0_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_ctrl_sym_nasym 0x00000000U
#define MSK_NX51_gpio_counter0_ctrl_irq_en            0x00000004U
#define SRT_NX51_gpio_counter0_ctrl_irq_en            2
#define DFLT_VAL_NX51_gpio_counter0_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_ctrl_irq_en    0x00000000U
#define MSK_NX51_gpio_counter0_ctrl_sel_event         0x00000008U
#define SRT_NX51_gpio_counter0_ctrl_sel_event         3
#define DFLT_VAL_NX51_gpio_counter0_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_ctrl_sel_event 0x00000000U
#define MSK_NX51_gpio_counter0_ctrl_once              0x00000010U
#define SRT_NX51_gpio_counter0_ctrl_once              4
#define DFLT_VAL_NX51_gpio_counter0_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_ctrl_once      0x00000000U
#define MSK_NX51_gpio_counter0_ctrl_event_act         0x00000060U
#define SRT_NX51_gpio_counter0_ctrl_event_act         5
#define DFLT_VAL_NX51_gpio_counter0_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_ctrl_event_act 0x00000000U
#define MSK_NX51_gpio_counter0_ctrl_gpio_ref          0x00000f80U
#define SRT_NX51_gpio_counter0_ctrl_gpio_ref          7
#define DFLT_VAL_NX51_gpio_counter0_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX51_gpio_counter0_ctrl': */
#define MSK_USED_BITS_NX51_gpio_counter0_ctrl 0x00000fffU

enum {
	BFW_NX51_gpio_counter0_ctrl_run       = 1,  /* [0] */
	BFW_NX51_gpio_counter0_ctrl_sym_nasym = 1,  /* [1] */
	BFW_NX51_gpio_counter0_ctrl_irq_en    = 1,  /* [2] */
	BFW_NX51_gpio_counter0_ctrl_sel_event = 1,  /* [3] */
	BFW_NX51_gpio_counter0_ctrl_once      = 1,  /* [4] */
	BFW_NX51_gpio_counter0_ctrl_event_act = 2,  /* [6:5] */
	BFW_NX51_gpio_counter0_ctrl_gpio_ref  = 5,  /* [11:7] */
	BFW_NX51_gpio_counter0_ctrl_reserved1 = 20  /* [31:12] */
};

typedef struct NX51_GPIO_COUNTER0_CTRL_BIT_Ttag {
	unsigned int run       : BFW_NX51_gpio_counter0_ctrl_run;       /* 1: start counter, counter is running                                                                        */
	                                                                /* 0: stop counter                                                                                             */
	unsigned int sym_nasym : BFW_NX51_gpio_counter0_ctrl_sym_nasym; /* 1: symmetric mode (triangle)                                                                                */
	                                                                /* 0: asymmetric mode (sawtooth)                                                                               */
	unsigned int irq_en    : BFW_NX51_gpio_counter0_ctrl_irq_en;    /* 1: enable interrupt request on sel_event                                                                    */
	                                                                /* 0: disable interrupt request                                                                                */
	unsigned int sel_event : BFW_NX51_gpio_counter0_ctrl_sel_event; /* select external event                                                                                       */
	                                                                /* 0: high level, invert gpio in gpio_cfg register to select low level                                         */
	                                                                /* 1: pos. edge, invert gpio in gpio_cfg register to select neg. edge                                          */
	unsigned int once      : BFW_NX51_gpio_counter0_ctrl_once;      /* 1: count once (reset run bit after 1 period)                                                                */
	                                                                /* 0: count continue                                                                                           */
	unsigned int event_act : BFW_NX51_gpio_counter0_ctrl_event_act; /* Define action of selected external event (dependant on sel_event, gpio_ref)                                 */
	                                                                /* 00: count every clock cycle, ignore external events                                                         */
	                                                                /* 01: count only on external event (edge or level according to sel_event bit)                                 */
	                                                                /* 10: enable watchdog mode of counter (external event resets without IRQ, overflow generates IRQ).            */
	                                                                /* 11: enable automatic run by external event (set run bit at external event, used for DC-DC PWM in once mode) */
	unsigned int gpio_ref  : BFW_NX51_gpio_counter0_ctrl_gpio_ref;  /* gpio reference (0 - 31)                                                                                     */
	unsigned int reserved1 : BFW_NX51_gpio_counter0_ctrl_reserved1; /* reserved                                                                                                    */
} NX51_GPIO_COUNTER0_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_GPIO_COUNTER0_CTRL_BIT_T bf;
} NX51_GPIO_COUNTER0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter1_ctrl */
/* => GPIO counter1 control register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter1_ctrl         0x00000104U
#define Adr_NX51_gpio_motion_gpio_counter1_ctrl 0x10140504U
#define Adr_NX51_gpio_gpio_counter1_ctrl        0x1018CB04U
#define DFLT_VAL_NX51_gpio_counter1_ctrl        0x00000000U

#define MSK_NX51_gpio_counter1_ctrl_run               0x00000001U
#define SRT_NX51_gpio_counter1_ctrl_run               0
#define DFLT_VAL_NX51_gpio_counter1_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_ctrl_run       0x00000000U
#define MSK_NX51_gpio_counter1_ctrl_sym_nasym         0x00000002U
#define SRT_NX51_gpio_counter1_ctrl_sym_nasym         1
#define DFLT_VAL_NX51_gpio_counter1_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_ctrl_sym_nasym 0x00000000U
#define MSK_NX51_gpio_counter1_ctrl_irq_en            0x00000004U
#define SRT_NX51_gpio_counter1_ctrl_irq_en            2
#define DFLT_VAL_NX51_gpio_counter1_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_ctrl_irq_en    0x00000000U
#define MSK_NX51_gpio_counter1_ctrl_sel_event         0x00000008U
#define SRT_NX51_gpio_counter1_ctrl_sel_event         3
#define DFLT_VAL_NX51_gpio_counter1_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_ctrl_sel_event 0x00000000U
#define MSK_NX51_gpio_counter1_ctrl_once              0x00000010U
#define SRT_NX51_gpio_counter1_ctrl_once              4
#define DFLT_VAL_NX51_gpio_counter1_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_ctrl_once      0x00000000U
#define MSK_NX51_gpio_counter1_ctrl_event_act         0x00000060U
#define SRT_NX51_gpio_counter1_ctrl_event_act         5
#define DFLT_VAL_NX51_gpio_counter1_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_ctrl_event_act 0x00000000U
#define MSK_NX51_gpio_counter1_ctrl_gpio_ref          0x00000f80U
#define SRT_NX51_gpio_counter1_ctrl_gpio_ref          7
#define DFLT_VAL_NX51_gpio_counter1_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX51_gpio_counter1_ctrl': */
#define MSK_USED_BITS_NX51_gpio_counter1_ctrl 0x00000fffU

enum {
	BFW_NX51_gpio_counter1_ctrl_run       = 1,  /* [0] */
	BFW_NX51_gpio_counter1_ctrl_sym_nasym = 1,  /* [1] */
	BFW_NX51_gpio_counter1_ctrl_irq_en    = 1,  /* [2] */
	BFW_NX51_gpio_counter1_ctrl_sel_event = 1,  /* [3] */
	BFW_NX51_gpio_counter1_ctrl_once      = 1,  /* [4] */
	BFW_NX51_gpio_counter1_ctrl_event_act = 2,  /* [6:5] */
	BFW_NX51_gpio_counter1_ctrl_gpio_ref  = 5,  /* [11:7] */
	BFW_NX51_gpio_counter1_ctrl_reserved1 = 20  /* [31:12] */
};

typedef struct NX51_GPIO_COUNTER1_CTRL_BIT_Ttag {
	unsigned int run       : BFW_NX51_gpio_counter1_ctrl_run;       /* analog to gpio_counter0_ctrl */
	unsigned int sym_nasym : BFW_NX51_gpio_counter1_ctrl_sym_nasym; /* analog to gpio_counter0_ctrl */
	unsigned int irq_en    : BFW_NX51_gpio_counter1_ctrl_irq_en;    /* analog to gpio_counter0_ctrl */
	unsigned int sel_event : BFW_NX51_gpio_counter1_ctrl_sel_event; /* analog to gpio_counter0_ctrl */
	unsigned int once      : BFW_NX51_gpio_counter1_ctrl_once;      /* analog to gpio_counter0_ctrl */
	unsigned int event_act : BFW_NX51_gpio_counter1_ctrl_event_act; /* analog to gpio_counter0_ctrl */
	unsigned int gpio_ref  : BFW_NX51_gpio_counter1_ctrl_gpio_ref;  /* analog to gpio_counter0_ctrl */
	unsigned int reserved1 : BFW_NX51_gpio_counter1_ctrl_reserved1; /* reserved                     */
} NX51_GPIO_COUNTER1_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_GPIO_COUNTER1_CTRL_BIT_T bf;
} NX51_GPIO_COUNTER1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter2_ctrl */
/* => GPIO counter2 control register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter2_ctrl         0x00000108U
#define Adr_NX51_gpio_motion_gpio_counter2_ctrl 0x10140508U
#define Adr_NX51_gpio_gpio_counter2_ctrl        0x1018CB08U
#define DFLT_VAL_NX51_gpio_counter2_ctrl        0x00000000U

#define MSK_NX51_gpio_counter2_ctrl_run               0x00000001U
#define SRT_NX51_gpio_counter2_ctrl_run               0
#define DFLT_VAL_NX51_gpio_counter2_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_ctrl_run       0x00000000U
#define MSK_NX51_gpio_counter2_ctrl_sym_nasym         0x00000002U
#define SRT_NX51_gpio_counter2_ctrl_sym_nasym         1
#define DFLT_VAL_NX51_gpio_counter2_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_ctrl_sym_nasym 0x00000000U
#define MSK_NX51_gpio_counter2_ctrl_irq_en            0x00000004U
#define SRT_NX51_gpio_counter2_ctrl_irq_en            2
#define DFLT_VAL_NX51_gpio_counter2_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_ctrl_irq_en    0x00000000U
#define MSK_NX51_gpio_counter2_ctrl_sel_event         0x00000008U
#define SRT_NX51_gpio_counter2_ctrl_sel_event         3
#define DFLT_VAL_NX51_gpio_counter2_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_ctrl_sel_event 0x00000000U
#define MSK_NX51_gpio_counter2_ctrl_once              0x00000010U
#define SRT_NX51_gpio_counter2_ctrl_once              4
#define DFLT_VAL_NX51_gpio_counter2_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_ctrl_once      0x00000000U
#define MSK_NX51_gpio_counter2_ctrl_event_act         0x00000060U
#define SRT_NX51_gpio_counter2_ctrl_event_act         5
#define DFLT_VAL_NX51_gpio_counter2_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_ctrl_event_act 0x00000000U
#define MSK_NX51_gpio_counter2_ctrl_gpio_ref          0x00000f80U
#define SRT_NX51_gpio_counter2_ctrl_gpio_ref          7
#define DFLT_VAL_NX51_gpio_counter2_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX51_gpio_counter2_ctrl': */
#define MSK_USED_BITS_NX51_gpio_counter2_ctrl 0x00000fffU

enum {
	BFW_NX51_gpio_counter2_ctrl_run       = 1,  /* [0] */
	BFW_NX51_gpio_counter2_ctrl_sym_nasym = 1,  /* [1] */
	BFW_NX51_gpio_counter2_ctrl_irq_en    = 1,  /* [2] */
	BFW_NX51_gpio_counter2_ctrl_sel_event = 1,  /* [3] */
	BFW_NX51_gpio_counter2_ctrl_once      = 1,  /* [4] */
	BFW_NX51_gpio_counter2_ctrl_event_act = 2,  /* [6:5] */
	BFW_NX51_gpio_counter2_ctrl_gpio_ref  = 5,  /* [11:7] */
	BFW_NX51_gpio_counter2_ctrl_reserved1 = 20  /* [31:12] */
};

typedef struct NX51_GPIO_COUNTER2_CTRL_BIT_Ttag {
	unsigned int run       : BFW_NX51_gpio_counter2_ctrl_run;       /* analog to gpio_counter0_ctrl */
	unsigned int sym_nasym : BFW_NX51_gpio_counter2_ctrl_sym_nasym; /* analog to gpio_counter0_ctrl */
	unsigned int irq_en    : BFW_NX51_gpio_counter2_ctrl_irq_en;    /* analog to gpio_counter0_ctrl */
	unsigned int sel_event : BFW_NX51_gpio_counter2_ctrl_sel_event; /* analog to gpio_counter0_ctrl */
	unsigned int once      : BFW_NX51_gpio_counter2_ctrl_once;      /* analog to gpio_counter0_ctrl */
	unsigned int event_act : BFW_NX51_gpio_counter2_ctrl_event_act; /* analog to gpio_counter0_ctrl */
	unsigned int gpio_ref  : BFW_NX51_gpio_counter2_ctrl_gpio_ref;  /* analog to gpio_counter0_ctrl */
	unsigned int reserved1 : BFW_NX51_gpio_counter2_ctrl_reserved1; /* reserved                     */
} NX51_GPIO_COUNTER2_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_GPIO_COUNTER2_CTRL_BIT_T bf;
} NX51_GPIO_COUNTER2_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter3_ctrl */
/* => GPIO counter3 control register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter3_ctrl         0x0000010CU
#define Adr_NX51_gpio_motion_gpio_counter3_ctrl 0x1014050CU
#define Adr_NX51_gpio_gpio_counter3_ctrl        0x1018CB0CU
#define DFLT_VAL_NX51_gpio_counter3_ctrl        0x00000000U

#define MSK_NX51_gpio_counter3_ctrl_run               0x00000001U
#define SRT_NX51_gpio_counter3_ctrl_run               0
#define DFLT_VAL_NX51_gpio_counter3_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_ctrl_run       0x00000000U
#define MSK_NX51_gpio_counter3_ctrl_sym_nasym         0x00000002U
#define SRT_NX51_gpio_counter3_ctrl_sym_nasym         1
#define DFLT_VAL_NX51_gpio_counter3_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_ctrl_sym_nasym 0x00000000U
#define MSK_NX51_gpio_counter3_ctrl_irq_en            0x00000004U
#define SRT_NX51_gpio_counter3_ctrl_irq_en            2
#define DFLT_VAL_NX51_gpio_counter3_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_ctrl_irq_en    0x00000000U
#define MSK_NX51_gpio_counter3_ctrl_sel_event         0x00000008U
#define SRT_NX51_gpio_counter3_ctrl_sel_event         3
#define DFLT_VAL_NX51_gpio_counter3_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_ctrl_sel_event 0x00000000U
#define MSK_NX51_gpio_counter3_ctrl_once              0x00000010U
#define SRT_NX51_gpio_counter3_ctrl_once              4
#define DFLT_VAL_NX51_gpio_counter3_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_ctrl_once      0x00000000U
#define MSK_NX51_gpio_counter3_ctrl_event_act         0x00000060U
#define SRT_NX51_gpio_counter3_ctrl_event_act         5
#define DFLT_VAL_NX51_gpio_counter3_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_ctrl_event_act 0x00000000U
#define MSK_NX51_gpio_counter3_ctrl_gpio_ref          0x00000f80U
#define SRT_NX51_gpio_counter3_ctrl_gpio_ref          7
#define DFLT_VAL_NX51_gpio_counter3_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX51_gpio_counter3_ctrl': */
#define MSK_USED_BITS_NX51_gpio_counter3_ctrl 0x00000fffU

enum {
	BFW_NX51_gpio_counter3_ctrl_run       = 1,  /* [0] */
	BFW_NX51_gpio_counter3_ctrl_sym_nasym = 1,  /* [1] */
	BFW_NX51_gpio_counter3_ctrl_irq_en    = 1,  /* [2] */
	BFW_NX51_gpio_counter3_ctrl_sel_event = 1,  /* [3] */
	BFW_NX51_gpio_counter3_ctrl_once      = 1,  /* [4] */
	BFW_NX51_gpio_counter3_ctrl_event_act = 2,  /* [6:5] */
	BFW_NX51_gpio_counter3_ctrl_gpio_ref  = 5,  /* [11:7] */
	BFW_NX51_gpio_counter3_ctrl_reserved1 = 20  /* [31:12] */
};

typedef struct NX51_GPIO_COUNTER3_CTRL_BIT_Ttag {
	unsigned int run       : BFW_NX51_gpio_counter3_ctrl_run;       /* analog to gpio_counter0_ctrl */
	unsigned int sym_nasym : BFW_NX51_gpio_counter3_ctrl_sym_nasym; /* analog to gpio_counter0_ctrl */
	unsigned int irq_en    : BFW_NX51_gpio_counter3_ctrl_irq_en;    /* analog to gpio_counter0_ctrl */
	unsigned int sel_event : BFW_NX51_gpio_counter3_ctrl_sel_event; /* analog to gpio_counter0_ctrl */
	unsigned int once      : BFW_NX51_gpio_counter3_ctrl_once;      /* analog to gpio_counter0_ctrl */
	unsigned int event_act : BFW_NX51_gpio_counter3_ctrl_event_act; /* analog to gpio_counter0_ctrl */
	unsigned int gpio_ref  : BFW_NX51_gpio_counter3_ctrl_gpio_ref;  /* analog to gpio_counter0_ctrl */
	unsigned int reserved1 : BFW_NX51_gpio_counter3_ctrl_reserved1; /* reserved                     */
} NX51_GPIO_COUNTER3_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_GPIO_COUNTER3_CTRL_BIT_T bf;
} NX51_GPIO_COUNTER3_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter4_ctrl */
/* => GPIO counter4 control register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter4_ctrl         0x00000110U
#define Adr_NX51_gpio_motion_gpio_counter4_ctrl 0x10140510U
#define Adr_NX51_gpio_gpio_counter4_ctrl        0x1018CB10U
#define DFLT_VAL_NX51_gpio_counter4_ctrl        0x00000000U

#define MSK_NX51_gpio_counter4_ctrl_run               0x00000001U
#define SRT_NX51_gpio_counter4_ctrl_run               0
#define DFLT_VAL_NX51_gpio_counter4_ctrl_run          0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_ctrl_run       0x00000000U
#define MSK_NX51_gpio_counter4_ctrl_sym_nasym         0x00000002U
#define SRT_NX51_gpio_counter4_ctrl_sym_nasym         1
#define DFLT_VAL_NX51_gpio_counter4_ctrl_sym_nasym    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_ctrl_sym_nasym 0x00000000U
#define MSK_NX51_gpio_counter4_ctrl_irq_en            0x00000004U
#define SRT_NX51_gpio_counter4_ctrl_irq_en            2
#define DFLT_VAL_NX51_gpio_counter4_ctrl_irq_en       0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_ctrl_irq_en    0x00000000U
#define MSK_NX51_gpio_counter4_ctrl_sel_event         0x00000008U
#define SRT_NX51_gpio_counter4_ctrl_sel_event         3
#define DFLT_VAL_NX51_gpio_counter4_ctrl_sel_event    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_ctrl_sel_event 0x00000000U
#define MSK_NX51_gpio_counter4_ctrl_once              0x00000010U
#define SRT_NX51_gpio_counter4_ctrl_once              4
#define DFLT_VAL_NX51_gpio_counter4_ctrl_once         0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_ctrl_once      0x00000000U
#define MSK_NX51_gpio_counter4_ctrl_event_act         0x00000060U
#define SRT_NX51_gpio_counter4_ctrl_event_act         5
#define DFLT_VAL_NX51_gpio_counter4_ctrl_event_act    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_ctrl_event_act 0x00000000U
#define MSK_NX51_gpio_counter4_ctrl_gpio_ref          0x00000f80U
#define SRT_NX51_gpio_counter4_ctrl_gpio_ref          7
#define DFLT_VAL_NX51_gpio_counter4_ctrl_gpio_ref     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_ctrl_gpio_ref  0x00000000U

/* all used bits of 'NX51_gpio_counter4_ctrl': */
#define MSK_USED_BITS_NX51_gpio_counter4_ctrl 0x00000fffU

enum {
	BFW_NX51_gpio_counter4_ctrl_run       = 1,  /* [0] */
	BFW_NX51_gpio_counter4_ctrl_sym_nasym = 1,  /* [1] */
	BFW_NX51_gpio_counter4_ctrl_irq_en    = 1,  /* [2] */
	BFW_NX51_gpio_counter4_ctrl_sel_event = 1,  /* [3] */
	BFW_NX51_gpio_counter4_ctrl_once      = 1,  /* [4] */
	BFW_NX51_gpio_counter4_ctrl_event_act = 2,  /* [6:5] */
	BFW_NX51_gpio_counter4_ctrl_gpio_ref  = 5,  /* [11:7] */
	BFW_NX51_gpio_counter4_ctrl_reserved1 = 20  /* [31:12] */
};

typedef struct NX51_GPIO_COUNTER4_CTRL_BIT_Ttag {
	unsigned int run       : BFW_NX51_gpio_counter4_ctrl_run;       /* analog to gpio_counter0_ctrl */
	unsigned int sym_nasym : BFW_NX51_gpio_counter4_ctrl_sym_nasym; /* analog to gpio_counter0_ctrl */
	unsigned int irq_en    : BFW_NX51_gpio_counter4_ctrl_irq_en;    /* analog to gpio_counter0_ctrl */
	unsigned int sel_event : BFW_NX51_gpio_counter4_ctrl_sel_event; /* analog to gpio_counter0_ctrl */
	unsigned int once      : BFW_NX51_gpio_counter4_ctrl_once;      /* analog to gpio_counter0_ctrl */
	unsigned int event_act : BFW_NX51_gpio_counter4_ctrl_event_act; /* analog to gpio_counter0_ctrl */
	unsigned int gpio_ref  : BFW_NX51_gpio_counter4_ctrl_gpio_ref;  /* analog to gpio_counter0_ctrl */
	unsigned int reserved1 : BFW_NX51_gpio_counter4_ctrl_reserved1; /* reserved                     */
} NX51_GPIO_COUNTER4_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_GPIO_COUNTER4_CTRL_BIT_T bf;
} NX51_GPIO_COUNTER4_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter0_max */
/* => GPIO counter0 max value */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter0_max         0x00000114U
#define Adr_NX51_gpio_motion_gpio_counter0_max 0x10140514U
#define Adr_NX51_gpio_gpio_counter0_max        0x1018CB14U
#define DFLT_VAL_NX51_gpio_counter0_max        0x00000000U

#define MSK_NX51_gpio_counter0_max_val         0xffffffffU
#define SRT_NX51_gpio_counter0_max_val         0
#define DFLT_VAL_NX51_gpio_counter0_max_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_max_val 0x00000000U

/* all used bits of 'NX51_gpio_counter0_max': */
#define MSK_USED_BITS_NX51_gpio_counter0_max 0xffffffffU

enum {
	BFW_NX51_gpio_counter0_max_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER0_MAX_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter0_max_val; /* Asymmetric mode: counting period in cc + 1 */
	                                                   /* Symmetric mode: counting period in cc      */
} NX51_GPIO_COUNTER0_MAX_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER0_MAX_BIT_T bf;
} NX51_GPIO_COUNTER0_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter1_max */
/* => GPIO counter1 max value */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter1_max         0x00000118U
#define Adr_NX51_gpio_motion_gpio_counter1_max 0x10140518U
#define Adr_NX51_gpio_gpio_counter1_max        0x1018CB18U
#define DFLT_VAL_NX51_gpio_counter1_max        0x00000000U

#define MSK_NX51_gpio_counter1_max_val         0xffffffffU
#define SRT_NX51_gpio_counter1_max_val         0
#define DFLT_VAL_NX51_gpio_counter1_max_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_max_val 0x00000000U

/* all used bits of 'NX51_gpio_counter1_max': */
#define MSK_USED_BITS_NX51_gpio_counter1_max 0xffffffffU

enum {
	BFW_NX51_gpio_counter1_max_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER1_MAX_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter1_max_val; /* Asymmetric mode: counting period in cc + 1 */
	                                                   /* Symmetric mode: counting period in cc      */
} NX51_GPIO_COUNTER1_MAX_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER1_MAX_BIT_T bf;
} NX51_GPIO_COUNTER1_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter2_max */
/* => GPIO counter2 max value */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter2_max         0x0000011CU
#define Adr_NX51_gpio_motion_gpio_counter2_max 0x1014051CU
#define Adr_NX51_gpio_gpio_counter2_max        0x1018CB1CU
#define DFLT_VAL_NX51_gpio_counter2_max        0x00000000U

#define MSK_NX51_gpio_counter2_max_val         0xffffffffU
#define SRT_NX51_gpio_counter2_max_val         0
#define DFLT_VAL_NX51_gpio_counter2_max_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_max_val 0x00000000U

/* all used bits of 'NX51_gpio_counter2_max': */
#define MSK_USED_BITS_NX51_gpio_counter2_max 0xffffffffU

enum {
	BFW_NX51_gpio_counter2_max_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER2_MAX_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter2_max_val; /* Asymmetric mode: counting period in cc + 1 */
	                                                   /* Symmetric mode: counting period in cc      */
} NX51_GPIO_COUNTER2_MAX_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER2_MAX_BIT_T bf;
} NX51_GPIO_COUNTER2_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter3_max */
/* => GPIO counter3 max value */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter3_max         0x00000120U
#define Adr_NX51_gpio_motion_gpio_counter3_max 0x10140520U
#define Adr_NX51_gpio_gpio_counter3_max        0x1018CB20U
#define DFLT_VAL_NX51_gpio_counter3_max        0x00000000U

#define MSK_NX51_gpio_counter3_max_val         0xffffffffU
#define SRT_NX51_gpio_counter3_max_val         0
#define DFLT_VAL_NX51_gpio_counter3_max_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_max_val 0x00000000U

/* all used bits of 'NX51_gpio_counter3_max': */
#define MSK_USED_BITS_NX51_gpio_counter3_max 0xffffffffU

enum {
	BFW_NX51_gpio_counter3_max_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER3_MAX_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter3_max_val; /* Asymmetric mode: counting period in cc + 1 */
	                                                   /* Symmetric mode: counting period in cc      */
} NX51_GPIO_COUNTER3_MAX_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER3_MAX_BIT_T bf;
} NX51_GPIO_COUNTER3_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter4_max */
/* => GPIO counter4 max value */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter4_max         0x00000124U
#define Adr_NX51_gpio_motion_gpio_counter4_max 0x10140524U
#define Adr_NX51_gpio_gpio_counter4_max        0x1018CB24U
#define DFLT_VAL_NX51_gpio_counter4_max        0x00000000U

#define MSK_NX51_gpio_counter4_max_val         0xffffffffU
#define SRT_NX51_gpio_counter4_max_val         0
#define DFLT_VAL_NX51_gpio_counter4_max_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_max_val 0x00000000U

/* all used bits of 'NX51_gpio_counter4_max': */
#define MSK_USED_BITS_NX51_gpio_counter4_max 0xffffffffU

enum {
	BFW_NX51_gpio_counter4_max_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER4_MAX_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter4_max_val; /* Asymmetric mode: counting period in cc + 1 */
	                                                   /* Symmetric mode: counting period in cc      */
} NX51_GPIO_COUNTER4_MAX_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER4_MAX_BIT_T bf;
} NX51_GPIO_COUNTER4_MAX_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter0_cnt */
/* => GPIO counter0 current value */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter0_cnt         0x00000128U
#define Adr_NX51_gpio_motion_gpio_counter0_cnt 0x10140528U
#define Adr_NX51_gpio_gpio_counter0_cnt        0x1018CB28U
#define DFLT_VAL_NX51_gpio_counter0_cnt        0x00000000U

#define MSK_NX51_gpio_counter0_cnt_val         0xffffffffU
#define SRT_NX51_gpio_counter0_cnt_val         0
#define DFLT_VAL_NX51_gpio_counter0_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter0_cnt_val 0x00000000U

/* all used bits of 'NX51_gpio_counter0_cnt': */
#define MSK_USED_BITS_NX51_gpio_counter0_cnt 0xffffffffU

enum {
	BFW_NX51_gpio_counter0_cnt_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER0_CNT_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter0_cnt_val; /* curent counter value */
} NX51_GPIO_COUNTER0_CNT_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER0_CNT_BIT_T bf;
} NX51_GPIO_COUNTER0_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter1_cnt */
/* => GPIO counter1 current value: */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter1_cnt         0x0000012CU
#define Adr_NX51_gpio_motion_gpio_counter1_cnt 0x1014052CU
#define Adr_NX51_gpio_gpio_counter1_cnt        0x1018CB2CU
#define DFLT_VAL_NX51_gpio_counter1_cnt        0x00000000U

#define MSK_NX51_gpio_counter1_cnt_val         0xffffffffU
#define SRT_NX51_gpio_counter1_cnt_val         0
#define DFLT_VAL_NX51_gpio_counter1_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter1_cnt_val 0x00000000U

/* all used bits of 'NX51_gpio_counter1_cnt': */
#define MSK_USED_BITS_NX51_gpio_counter1_cnt 0xffffffffU

enum {
	BFW_NX51_gpio_counter1_cnt_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER1_CNT_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter1_cnt_val; /* curent counter value */
} NX51_GPIO_COUNTER1_CNT_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER1_CNT_BIT_T bf;
} NX51_GPIO_COUNTER1_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter2_cnt */
/* => GPIO counter2 current value: */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter2_cnt         0x00000130U
#define Adr_NX51_gpio_motion_gpio_counter2_cnt 0x10140530U
#define Adr_NX51_gpio_gpio_counter2_cnt        0x1018CB30U
#define DFLT_VAL_NX51_gpio_counter2_cnt        0x00000000U

#define MSK_NX51_gpio_counter2_cnt_val         0xffffffffU
#define SRT_NX51_gpio_counter2_cnt_val         0
#define DFLT_VAL_NX51_gpio_counter2_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter2_cnt_val 0x00000000U

/* all used bits of 'NX51_gpio_counter2_cnt': */
#define MSK_USED_BITS_NX51_gpio_counter2_cnt 0xffffffffU

enum {
	BFW_NX51_gpio_counter2_cnt_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER2_CNT_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter2_cnt_val; /* curent counter value */
} NX51_GPIO_COUNTER2_CNT_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER2_CNT_BIT_T bf;
} NX51_GPIO_COUNTER2_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter3_cnt */
/* => GPIO counter3 current value: */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter3_cnt         0x00000134U
#define Adr_NX51_gpio_motion_gpio_counter3_cnt 0x10140534U
#define Adr_NX51_gpio_gpio_counter3_cnt        0x1018CB34U
#define DFLT_VAL_NX51_gpio_counter3_cnt        0x00000000U

#define MSK_NX51_gpio_counter3_cnt_val         0xffffffffU
#define SRT_NX51_gpio_counter3_cnt_val         0
#define DFLT_VAL_NX51_gpio_counter3_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter3_cnt_val 0x00000000U

/* all used bits of 'NX51_gpio_counter3_cnt': */
#define MSK_USED_BITS_NX51_gpio_counter3_cnt 0xffffffffU

enum {
	BFW_NX51_gpio_counter3_cnt_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER3_CNT_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter3_cnt_val; /* curent counter value */
} NX51_GPIO_COUNTER3_CNT_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER3_CNT_BIT_T bf;
} NX51_GPIO_COUNTER3_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_counter4_cnt */
/* => GPIO counter4 current value: */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_counter4_cnt         0x00000138U
#define Adr_NX51_gpio_motion_gpio_counter4_cnt 0x10140538U
#define Adr_NX51_gpio_gpio_counter4_cnt        0x1018CB38U
#define DFLT_VAL_NX51_gpio_counter4_cnt        0x00000000U

#define MSK_NX51_gpio_counter4_cnt_val         0xffffffffU
#define SRT_NX51_gpio_counter4_cnt_val         0
#define DFLT_VAL_NX51_gpio_counter4_cnt_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_counter4_cnt_val 0x00000000U

/* all used bits of 'NX51_gpio_counter4_cnt': */
#define MSK_USED_BITS_NX51_gpio_counter4_cnt 0xffffffffU

enum {
	BFW_NX51_gpio_counter4_cnt_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_COUNTER4_CNT_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_counter4_cnt_val; /* curent counter value */
} NX51_GPIO_COUNTER4_CNT_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_COUNTER4_CNT_BIT_T bf;
} NX51_GPIO_COUNTER4_CNT_T;

/* --------------------------------------------------------------------- */
/* Register gpio_line */
/* => GPIO line register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_line         0x0000013CU
#define Adr_NX51_gpio_motion_gpio_line 0x1014053CU
#define Adr_NX51_gpio_gpio_line        0x1018CB3CU
#define DFLT_VAL_NX51_gpio_line        0x00000000U

#define MSK_NX51_gpio_line_val         0xffffffffU
#define SRT_NX51_gpio_line_val         0
#define DFLT_VAL_NX51_gpio_line_val    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_line_val 0x00000000U

/* all used bits of 'NX51_gpio_line': */
#define MSK_USED_BITS_NX51_gpio_line 0xffffffffU

enum {
	BFW_NX51_gpio_line_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_LINE_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_line_val; /* gpio output values */
} NX51_GPIO_LINE_BIT_T;

typedef union {
	unsigned int         val;
	NX51_GPIO_LINE_BIT_T bf;
} NX51_GPIO_LINE_T;

/* --------------------------------------------------------------------- */
/* Register gpio_in */
/* => GPIO latched register */
/*    This register is accessible via intlogic and intlogic_motion address area. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_in         0x00000140U
#define Adr_NX51_gpio_motion_gpio_in 0x10140540U
#define Adr_NX51_gpio_gpio_in        0x1018CB40U

#define MSK_NX51_gpio_in_val 0xffffffffU
#define SRT_NX51_gpio_in_val 0

/* all used bits of 'NX51_gpio_in': */
#define MSK_USED_BITS_NX51_gpio_in 0xffffffffU

enum {
	BFW_NX51_gpio_in_val = 32  /* [31:0] */
};

typedef struct NX51_GPIO_IN_BIT_Ttag {
	unsigned int val : BFW_NX51_gpio_in_val; /* gpio input values */
} NX51_GPIO_IN_BIT_T;

typedef union {
	unsigned int       val;
	NX51_GPIO_IN_BIT_T bf;
} NX51_GPIO_IN_T;

/* --------------------------------------------------------------------- */
/* Register gpio_irq_raw */
/* => GPIO Raw IRQ register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_irq_raw         0x00000144U
#define Adr_NX51_gpio_motion_gpio_irq_raw 0x10140544U
#define Adr_NX51_gpio_gpio_irq_raw        0x1018CB44U
#define DFLT_VAL_NX51_gpio_irq_raw        0x00000000U

#define MSK_NX51_gpio_irq_raw_gpio0          0x00000001U
#define SRT_NX51_gpio_irq_raw_gpio0          0
#define DFLT_VAL_NX51_gpio_irq_raw_gpio0     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio0  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio1          0x00000002U
#define SRT_NX51_gpio_irq_raw_gpio1          1
#define DFLT_VAL_NX51_gpio_irq_raw_gpio1     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio1  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio2          0x00000004U
#define SRT_NX51_gpio_irq_raw_gpio2          2
#define DFLT_VAL_NX51_gpio_irq_raw_gpio2     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio2  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio3          0x00000008U
#define SRT_NX51_gpio_irq_raw_gpio3          3
#define DFLT_VAL_NX51_gpio_irq_raw_gpio3     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio3  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio4          0x00000010U
#define SRT_NX51_gpio_irq_raw_gpio4          4
#define DFLT_VAL_NX51_gpio_irq_raw_gpio4     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio4  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio5          0x00000020U
#define SRT_NX51_gpio_irq_raw_gpio5          5
#define DFLT_VAL_NX51_gpio_irq_raw_gpio5     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio5  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio6          0x00000040U
#define SRT_NX51_gpio_irq_raw_gpio6          6
#define DFLT_VAL_NX51_gpio_irq_raw_gpio6     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio6  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio7          0x00000080U
#define SRT_NX51_gpio_irq_raw_gpio7          7
#define DFLT_VAL_NX51_gpio_irq_raw_gpio7     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio7  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio8          0x00000100U
#define SRT_NX51_gpio_irq_raw_gpio8          8
#define DFLT_VAL_NX51_gpio_irq_raw_gpio8     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio8  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio9          0x00000200U
#define SRT_NX51_gpio_irq_raw_gpio9          9
#define DFLT_VAL_NX51_gpio_irq_raw_gpio9     0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio9  0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio10         0x00000400U
#define SRT_NX51_gpio_irq_raw_gpio10         10
#define DFLT_VAL_NX51_gpio_irq_raw_gpio10    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio10 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio11         0x00000800U
#define SRT_NX51_gpio_irq_raw_gpio11         11
#define DFLT_VAL_NX51_gpio_irq_raw_gpio11    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio11 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio12         0x00001000U
#define SRT_NX51_gpio_irq_raw_gpio12         12
#define DFLT_VAL_NX51_gpio_irq_raw_gpio12    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio12 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio13         0x00002000U
#define SRT_NX51_gpio_irq_raw_gpio13         13
#define DFLT_VAL_NX51_gpio_irq_raw_gpio13    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio13 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio14         0x00004000U
#define SRT_NX51_gpio_irq_raw_gpio14         14
#define DFLT_VAL_NX51_gpio_irq_raw_gpio14    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio14 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio15         0x00008000U
#define SRT_NX51_gpio_irq_raw_gpio15         15
#define DFLT_VAL_NX51_gpio_irq_raw_gpio15    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio15 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio16         0x00010000U
#define SRT_NX51_gpio_irq_raw_gpio16         16
#define DFLT_VAL_NX51_gpio_irq_raw_gpio16    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio16 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio17         0x00020000U
#define SRT_NX51_gpio_irq_raw_gpio17         17
#define DFLT_VAL_NX51_gpio_irq_raw_gpio17    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio17 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio18         0x00040000U
#define SRT_NX51_gpio_irq_raw_gpio18         18
#define DFLT_VAL_NX51_gpio_irq_raw_gpio18    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio18 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio19         0x00080000U
#define SRT_NX51_gpio_irq_raw_gpio19         19
#define DFLT_VAL_NX51_gpio_irq_raw_gpio19    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio19 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio20         0x00100000U
#define SRT_NX51_gpio_irq_raw_gpio20         20
#define DFLT_VAL_NX51_gpio_irq_raw_gpio20    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio20 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio21         0x00200000U
#define SRT_NX51_gpio_irq_raw_gpio21         21
#define DFLT_VAL_NX51_gpio_irq_raw_gpio21    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio21 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio22         0x00400000U
#define SRT_NX51_gpio_irq_raw_gpio22         22
#define DFLT_VAL_NX51_gpio_irq_raw_gpio22    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio22 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio23         0x00800000U
#define SRT_NX51_gpio_irq_raw_gpio23         23
#define DFLT_VAL_NX51_gpio_irq_raw_gpio23    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio23 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio24         0x01000000U
#define SRT_NX51_gpio_irq_raw_gpio24         24
#define DFLT_VAL_NX51_gpio_irq_raw_gpio24    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio24 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio25         0x02000000U
#define SRT_NX51_gpio_irq_raw_gpio25         25
#define DFLT_VAL_NX51_gpio_irq_raw_gpio25    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio25 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio26         0x04000000U
#define SRT_NX51_gpio_irq_raw_gpio26         26
#define DFLT_VAL_NX51_gpio_irq_raw_gpio26    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio26 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio27         0x08000000U
#define SRT_NX51_gpio_irq_raw_gpio27         27
#define DFLT_VAL_NX51_gpio_irq_raw_gpio27    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio27 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio28         0x10000000U
#define SRT_NX51_gpio_irq_raw_gpio28         28
#define DFLT_VAL_NX51_gpio_irq_raw_gpio28    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio28 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio29         0x20000000U
#define SRT_NX51_gpio_irq_raw_gpio29         29
#define DFLT_VAL_NX51_gpio_irq_raw_gpio29    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio29 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio30         0x40000000U
#define SRT_NX51_gpio_irq_raw_gpio30         30
#define DFLT_VAL_NX51_gpio_irq_raw_gpio30    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio30 0x00000000U
#define MSK_NX51_gpio_irq_raw_gpio31         0x80000000U
#define SRT_NX51_gpio_irq_raw_gpio31         31
#define DFLT_VAL_NX51_gpio_irq_raw_gpio31    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_raw_gpio31 0x00000000U

/* all used bits of 'NX51_gpio_irq_raw': */
#define MSK_USED_BITS_NX51_gpio_irq_raw 0xffffffffU

enum {
	BFW_NX51_gpio_irq_raw_gpio0  = 1, /* [0] */
	BFW_NX51_gpio_irq_raw_gpio1  = 1, /* [1] */
	BFW_NX51_gpio_irq_raw_gpio2  = 1, /* [2] */
	BFW_NX51_gpio_irq_raw_gpio3  = 1, /* [3] */
	BFW_NX51_gpio_irq_raw_gpio4  = 1, /* [4] */
	BFW_NX51_gpio_irq_raw_gpio5  = 1, /* [5] */
	BFW_NX51_gpio_irq_raw_gpio6  = 1, /* [6] */
	BFW_NX51_gpio_irq_raw_gpio7  = 1, /* [7] */
	BFW_NX51_gpio_irq_raw_gpio8  = 1, /* [8] */
	BFW_NX51_gpio_irq_raw_gpio9  = 1, /* [9] */
	BFW_NX51_gpio_irq_raw_gpio10 = 1, /* [10] */
	BFW_NX51_gpio_irq_raw_gpio11 = 1, /* [11] */
	BFW_NX51_gpio_irq_raw_gpio12 = 1, /* [12] */
	BFW_NX51_gpio_irq_raw_gpio13 = 1, /* [13] */
	BFW_NX51_gpio_irq_raw_gpio14 = 1, /* [14] */
	BFW_NX51_gpio_irq_raw_gpio15 = 1, /* [15] */
	BFW_NX51_gpio_irq_raw_gpio16 = 1, /* [16] */
	BFW_NX51_gpio_irq_raw_gpio17 = 1, /* [17] */
	BFW_NX51_gpio_irq_raw_gpio18 = 1, /* [18] */
	BFW_NX51_gpio_irq_raw_gpio19 = 1, /* [19] */
	BFW_NX51_gpio_irq_raw_gpio20 = 1, /* [20] */
	BFW_NX51_gpio_irq_raw_gpio21 = 1, /* [21] */
	BFW_NX51_gpio_irq_raw_gpio22 = 1, /* [22] */
	BFW_NX51_gpio_irq_raw_gpio23 = 1, /* [23] */
	BFW_NX51_gpio_irq_raw_gpio24 = 1, /* [24] */
	BFW_NX51_gpio_irq_raw_gpio25 = 1, /* [25] */
	BFW_NX51_gpio_irq_raw_gpio26 = 1, /* [26] */
	BFW_NX51_gpio_irq_raw_gpio27 = 1, /* [27] */
	BFW_NX51_gpio_irq_raw_gpio28 = 1, /* [28] */
	BFW_NX51_gpio_irq_raw_gpio29 = 1, /* [29] */
	BFW_NX51_gpio_irq_raw_gpio30 = 1, /* [30] */
	BFW_NX51_gpio_irq_raw_gpio31 = 1  /* [31] */
};

typedef struct NX51_GPIO_IRQ_RAW_BIT_Ttag {
	unsigned int gpio0  : BFW_NX51_gpio_irq_raw_gpio0;  /* interrupt bit for GPIO0  */
	unsigned int gpio1  : BFW_NX51_gpio_irq_raw_gpio1;  /* interrupt bit for GPIO1  */
	unsigned int gpio2  : BFW_NX51_gpio_irq_raw_gpio2;  /* interrupt bit for GPIO2  */
	unsigned int gpio3  : BFW_NX51_gpio_irq_raw_gpio3;  /* interrupt bit for GPIO3  */
	unsigned int gpio4  : BFW_NX51_gpio_irq_raw_gpio4;  /* interrupt bit for GPIO4  */
	unsigned int gpio5  : BFW_NX51_gpio_irq_raw_gpio5;  /* interrupt bit for GPIO5  */
	unsigned int gpio6  : BFW_NX51_gpio_irq_raw_gpio6;  /* interrupt bit for GPIO6  */
	unsigned int gpio7  : BFW_NX51_gpio_irq_raw_gpio7;  /* interrupt bit for GPIO7  */
	unsigned int gpio8  : BFW_NX51_gpio_irq_raw_gpio8;  /* interrupt bit for GPIO8  */
	unsigned int gpio9  : BFW_NX51_gpio_irq_raw_gpio9;  /* interrupt bit for GPIO9  */
	unsigned int gpio10 : BFW_NX51_gpio_irq_raw_gpio10; /* interrupt bit for GPIO10 */
	unsigned int gpio11 : BFW_NX51_gpio_irq_raw_gpio11; /* interrupt bit for GPIO11 */
	unsigned int gpio12 : BFW_NX51_gpio_irq_raw_gpio12; /* interrupt bit for GPIO12 */
	unsigned int gpio13 : BFW_NX51_gpio_irq_raw_gpio13; /* interrupt bit for GPIO13 */
	unsigned int gpio14 : BFW_NX51_gpio_irq_raw_gpio14; /* interrupt bit for GPIO14 */
	unsigned int gpio15 : BFW_NX51_gpio_irq_raw_gpio15; /* interrupt bit for GPIO15 */
	unsigned int gpio16 : BFW_NX51_gpio_irq_raw_gpio16; /* interrupt bit for GPIO16 */
	unsigned int gpio17 : BFW_NX51_gpio_irq_raw_gpio17; /* interrupt bit for GPIO17 */
	unsigned int gpio18 : BFW_NX51_gpio_irq_raw_gpio18; /* interrupt bit for GPIO18 */
	unsigned int gpio19 : BFW_NX51_gpio_irq_raw_gpio19; /* interrupt bit for GPIO19 */
	unsigned int gpio20 : BFW_NX51_gpio_irq_raw_gpio20; /* interrupt bit for GPIO20 */
	unsigned int gpio21 : BFW_NX51_gpio_irq_raw_gpio21; /* interrupt bit for GPIO21 */
	unsigned int gpio22 : BFW_NX51_gpio_irq_raw_gpio22; /* interrupt bit for GPIO22 */
	unsigned int gpio23 : BFW_NX51_gpio_irq_raw_gpio23; /* interrupt bit for GPIO23 */
	unsigned int gpio24 : BFW_NX51_gpio_irq_raw_gpio24; /* interrupt bit for GPIO24 */
	unsigned int gpio25 : BFW_NX51_gpio_irq_raw_gpio25; /* interrupt bit for GPIO25 */
	unsigned int gpio26 : BFW_NX51_gpio_irq_raw_gpio26; /* interrupt bit for GPIO26 */
	unsigned int gpio27 : BFW_NX51_gpio_irq_raw_gpio27; /* interrupt bit for GPIO27 */
	unsigned int gpio28 : BFW_NX51_gpio_irq_raw_gpio28; /* interrupt bit for GPIO28 */
	unsigned int gpio29 : BFW_NX51_gpio_irq_raw_gpio29; /* interrupt bit for GPIO29 */
	unsigned int gpio30 : BFW_NX51_gpio_irq_raw_gpio30; /* interrupt bit for GPIO30 */
	unsigned int gpio31 : BFW_NX51_gpio_irq_raw_gpio31; /* interrupt bit for GPIO31 */
} NX51_GPIO_IRQ_RAW_BIT_T;

typedef union {
	unsigned int            val;
	NX51_GPIO_IRQ_RAW_BIT_T bf;
} NX51_GPIO_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register gpio_irq_masked */
/* => GPIO Masked IRQ register: */
/*    This register exists twice for intlogic(ARM) and intlogic_motion(xPIC) address area. */
/*    Read access shows status of masked IRQs (as connected to VIC/ARM for intlogic or as connected to XPIC_VIC/xPIC for intlogic_motion) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_irq_masked         0x00000148U
#define Adr_NX51_gpio_motion_gpio_irq_masked 0x10140548U
#define Adr_NX51_gpio_gpio_irq_masked        0x1018CB48U

#define MSK_NX51_gpio_irq_masked_gpio 0xffffffffU
#define SRT_NX51_gpio_irq_masked_gpio 0

/* all used bits of 'NX51_gpio_irq_masked': */
#define MSK_USED_BITS_NX51_gpio_irq_masked 0xffffffffU

enum {
	BFW_NX51_gpio_irq_masked_gpio = 32  /* [31:0] */
};

typedef struct NX51_GPIO_IRQ_MASKED_BIT_Ttag {
	unsigned int gpio : BFW_NX51_gpio_irq_masked_gpio; /* One bit per GPIO */
} NX51_GPIO_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int               val;
	NX51_GPIO_IRQ_MASKED_BIT_T bf;
} NX51_GPIO_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register gpio_irq_mask_set */
/* => GPIO interrupt mask set: */
/*    The IRQ mask register exists twice for intlogic(ARM) and intlogic_motion(xPIC) address area. */
/*    The intlogic IRQ mask enables interrupt requests for ARM, the intlogic_motion IRQ mask enables interrupt requests for xPIC. */
/*    As the single bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to gpio_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_irq_mask_set         0x0000014CU
#define Adr_NX51_gpio_motion_gpio_irq_mask_set 0x1014054CU
#define Adr_NX51_gpio_gpio_irq_mask_set        0x1018CB4CU
#define DFLT_VAL_NX51_gpio_irq_mask_set        0x00000000U

#define MSK_NX51_gpio_irq_mask_set_gpio         0xffffffffU
#define SRT_NX51_gpio_irq_mask_set_gpio         0
#define DFLT_VAL_NX51_gpio_irq_mask_set_gpio    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_mask_set_gpio 0x00000000U

/* all used bits of 'NX51_gpio_irq_mask_set': */
#define MSK_USED_BITS_NX51_gpio_irq_mask_set 0xffffffffU

enum {
	BFW_NX51_gpio_irq_mask_set_gpio = 32  /* [31:0] */
};

typedef struct NX51_GPIO_IRQ_MASK_SET_BIT_Ttag {
	unsigned int gpio : BFW_NX51_gpio_irq_mask_set_gpio; /* One bit per GPIO */
} NX51_GPIO_IRQ_MASK_SET_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_IRQ_MASK_SET_BIT_T bf;
} NX51_GPIO_IRQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register gpio_irq_mask_rst */
/* => GPIO interrupt mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources. */
/*    As irq_msk_set this address exists twice for intlogic(ARM) and intlogic_motion(xPIC) address area. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_gpio_irq_mask_rst         0x00000150U
#define Adr_NX51_gpio_motion_gpio_irq_mask_rst 0x10140550U
#define Adr_NX51_gpio_gpio_irq_mask_rst        0x1018CB50U
#define DFLT_VAL_NX51_gpio_irq_mask_rst        0x00000000U

#define MSK_NX51_gpio_irq_mask_rst_gpio         0xffffffffU
#define SRT_NX51_gpio_irq_mask_rst_gpio         0
#define DFLT_VAL_NX51_gpio_irq_mask_rst_gpio    0x00000000U
#define DFLT_BF_VAL_NX51_gpio_irq_mask_rst_gpio 0x00000000U

/* all used bits of 'NX51_gpio_irq_mask_rst': */
#define MSK_USED_BITS_NX51_gpio_irq_mask_rst 0xffffffffU

enum {
	BFW_NX51_gpio_irq_mask_rst_gpio = 32  /* [31:0] */
};

typedef struct NX51_GPIO_IRQ_MASK_RST_BIT_Ttag {
	unsigned int gpio : BFW_NX51_gpio_irq_mask_rst_gpio; /* One bit per GPIO */
} NX51_GPIO_IRQ_MASK_RST_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_GPIO_IRQ_MASK_RST_BIT_T bf;
} NX51_GPIO_IRQ_MASK_RST_T;

/* --------------------------------------------------------------------- */
/* Register cnt_irq_raw */
/* => Counter Raw IRQ register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cnt_irq_raw         0x00000154U
#define Adr_NX51_gpio_motion_cnt_irq_raw 0x10140554U
#define Adr_NX51_gpio_cnt_irq_raw        0x1018CB54U
#define DFLT_VAL_NX51_cnt_irq_raw        0x00000000U

#define MSK_NX51_cnt_irq_raw_cnt0         0x00000001U
#define SRT_NX51_cnt_irq_raw_cnt0         0
#define DFLT_VAL_NX51_cnt_irq_raw_cnt0    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_raw_cnt0 0x00000000U
#define MSK_NX51_cnt_irq_raw_cnt1         0x00000002U
#define SRT_NX51_cnt_irq_raw_cnt1         1
#define DFLT_VAL_NX51_cnt_irq_raw_cnt1    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_raw_cnt1 0x00000000U
#define MSK_NX51_cnt_irq_raw_cnt2         0x00000004U
#define SRT_NX51_cnt_irq_raw_cnt2         2
#define DFLT_VAL_NX51_cnt_irq_raw_cnt2    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_raw_cnt2 0x00000000U
#define MSK_NX51_cnt_irq_raw_cnt3         0x00000008U
#define SRT_NX51_cnt_irq_raw_cnt3         3
#define DFLT_VAL_NX51_cnt_irq_raw_cnt3    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_raw_cnt3 0x00000000U
#define MSK_NX51_cnt_irq_raw_cnt4         0x00000010U
#define SRT_NX51_cnt_irq_raw_cnt4         4
#define DFLT_VAL_NX51_cnt_irq_raw_cnt4    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_raw_cnt4 0x00000000U

/* all used bits of 'NX51_cnt_irq_raw': */
#define MSK_USED_BITS_NX51_cnt_irq_raw 0x0000001fU

enum {
	BFW_NX51_cnt_irq_raw_cnt0      = 1,  /* [0] */
	BFW_NX51_cnt_irq_raw_cnt1      = 1,  /* [1] */
	BFW_NX51_cnt_irq_raw_cnt2      = 1,  /* [2] */
	BFW_NX51_cnt_irq_raw_cnt3      = 1,  /* [3] */
	BFW_NX51_cnt_irq_raw_cnt4      = 1,  /* [4] */
	BFW_NX51_cnt_irq_raw_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_CNT_IRQ_RAW_BIT_Ttag {
	unsigned int cnt0      : BFW_NX51_cnt_irq_raw_cnt0;      /* interrupt bit for counter0 */
	unsigned int cnt1      : BFW_NX51_cnt_irq_raw_cnt1;      /* interrupt bit for counter1 */
	unsigned int cnt2      : BFW_NX51_cnt_irq_raw_cnt2;      /* interrupt bit for counter2 */
	unsigned int cnt3      : BFW_NX51_cnt_irq_raw_cnt3;      /* interrupt bit for counter3 */
	unsigned int cnt4      : BFW_NX51_cnt_irq_raw_cnt4;      /* interrupt bit for counter4 */
	unsigned int reserved1 : BFW_NX51_cnt_irq_raw_reserved1; /* reserved                   */
} NX51_CNT_IRQ_RAW_BIT_T;

typedef union {
	unsigned int           val;
	NX51_CNT_IRQ_RAW_BIT_T bf;
} NX51_CNT_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register cnt_irq_masked */
/* => Counter Masked IRQ register: */
/*    This register exists twice for intlogic(ARM) and intlogic_motion(xPIC) address area. */
/*    Read access shows status of masked IRQs (as connected to VIC/ARM for intlogic or as connected to XPIC_VIC/xPIC for intlogic_motion) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cnt_irq_masked         0x00000158U
#define Adr_NX51_gpio_motion_cnt_irq_masked 0x10140558U
#define Adr_NX51_gpio_cnt_irq_masked        0x1018CB58U

#define MSK_NX51_cnt_irq_masked_cnt0 0x00000001U
#define SRT_NX51_cnt_irq_masked_cnt0 0
#define MSK_NX51_cnt_irq_masked_cnt1 0x00000002U
#define SRT_NX51_cnt_irq_masked_cnt1 1
#define MSK_NX51_cnt_irq_masked_cnt2 0x00000004U
#define SRT_NX51_cnt_irq_masked_cnt2 2
#define MSK_NX51_cnt_irq_masked_cnt3 0x00000008U
#define SRT_NX51_cnt_irq_masked_cnt3 3
#define MSK_NX51_cnt_irq_masked_cnt4 0x00000010U
#define SRT_NX51_cnt_irq_masked_cnt4 4

/* all used bits of 'NX51_cnt_irq_masked': */
#define MSK_USED_BITS_NX51_cnt_irq_masked 0x0000001fU

enum {
	BFW_NX51_cnt_irq_masked_cnt0      = 1,  /* [0] */
	BFW_NX51_cnt_irq_masked_cnt1      = 1,  /* [1] */
	BFW_NX51_cnt_irq_masked_cnt2      = 1,  /* [2] */
	BFW_NX51_cnt_irq_masked_cnt3      = 1,  /* [3] */
	BFW_NX51_cnt_irq_masked_cnt4      = 1,  /* [4] */
	BFW_NX51_cnt_irq_masked_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_CNT_IRQ_MASKED_BIT_Ttag {
	unsigned int cnt0      : BFW_NX51_cnt_irq_masked_cnt0;      /* interrupt bit for counter0 */
	unsigned int cnt1      : BFW_NX51_cnt_irq_masked_cnt1;      /* interrupt bit for counter1 */
	unsigned int cnt2      : BFW_NX51_cnt_irq_masked_cnt2;      /* interrupt bit for counter2 */
	unsigned int cnt3      : BFW_NX51_cnt_irq_masked_cnt3;      /* interrupt bit for counter3 */
	unsigned int cnt4      : BFW_NX51_cnt_irq_masked_cnt4;      /* interrupt bit for counter4 */
	unsigned int reserved1 : BFW_NX51_cnt_irq_masked_reserved1; /* reserved                   */
} NX51_CNT_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int              val;
	NX51_CNT_IRQ_MASKED_BIT_T bf;
} NX51_CNT_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register cnt_irq_mask_set */
/* => Counter interrupt mask seet: */
/*    The IRQ mask register exists twice for intlogic(ARM) and intlogic_motion(xPIC) address area. */
/*    The intlogic IRQ mask enables interrupt requests for ARM, the intlogic_motion IRQ mask enables interrupt requests for xPIC. */
/*    As the single bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to cnt_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cnt_irq_mask_set         0x0000015CU
#define Adr_NX51_gpio_motion_cnt_irq_mask_set 0x1014055CU
#define Adr_NX51_gpio_cnt_irq_mask_set        0x1018CB5CU
#define DFLT_VAL_NX51_cnt_irq_mask_set        0x00000000U

#define MSK_NX51_cnt_irq_mask_set_cnt0         0x00000001U
#define SRT_NX51_cnt_irq_mask_set_cnt0         0
#define DFLT_VAL_NX51_cnt_irq_mask_set_cnt0    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_set_cnt0 0x00000000U
#define MSK_NX51_cnt_irq_mask_set_cnt1         0x00000002U
#define SRT_NX51_cnt_irq_mask_set_cnt1         1
#define DFLT_VAL_NX51_cnt_irq_mask_set_cnt1    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_set_cnt1 0x00000000U
#define MSK_NX51_cnt_irq_mask_set_cnt2         0x00000004U
#define SRT_NX51_cnt_irq_mask_set_cnt2         2
#define DFLT_VAL_NX51_cnt_irq_mask_set_cnt2    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_set_cnt2 0x00000000U
#define MSK_NX51_cnt_irq_mask_set_cnt3         0x00000008U
#define SRT_NX51_cnt_irq_mask_set_cnt3         3
#define DFLT_VAL_NX51_cnt_irq_mask_set_cnt3    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_set_cnt3 0x00000000U
#define MSK_NX51_cnt_irq_mask_set_cnt4         0x00000010U
#define SRT_NX51_cnt_irq_mask_set_cnt4         4
#define DFLT_VAL_NX51_cnt_irq_mask_set_cnt4    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_set_cnt4 0x00000000U

/* all used bits of 'NX51_cnt_irq_mask_set': */
#define MSK_USED_BITS_NX51_cnt_irq_mask_set 0x0000001fU

enum {
	BFW_NX51_cnt_irq_mask_set_cnt0      = 1,  /* [0] */
	BFW_NX51_cnt_irq_mask_set_cnt1      = 1,  /* [1] */
	BFW_NX51_cnt_irq_mask_set_cnt2      = 1,  /* [2] */
	BFW_NX51_cnt_irq_mask_set_cnt3      = 1,  /* [3] */
	BFW_NX51_cnt_irq_mask_set_cnt4      = 1,  /* [4] */
	BFW_NX51_cnt_irq_mask_set_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_CNT_IRQ_MASK_SET_BIT_Ttag {
	unsigned int cnt0      : BFW_NX51_cnt_irq_mask_set_cnt0;      /* counter0 interrupt mask bit */
	unsigned int cnt1      : BFW_NX51_cnt_irq_mask_set_cnt1;      /* counter1 interrupt mask bit */
	unsigned int cnt2      : BFW_NX51_cnt_irq_mask_set_cnt2;      /* counter2 interrupt mask bit */
	unsigned int cnt3      : BFW_NX51_cnt_irq_mask_set_cnt3;      /* counter3 interrupt mask bit */
	unsigned int cnt4      : BFW_NX51_cnt_irq_mask_set_cnt4;      /* counter4 interrupt mask bit */
	unsigned int reserved1 : BFW_NX51_cnt_irq_mask_set_reserved1; /* reserved                    */
} NX51_CNT_IRQ_MASK_SET_BIT_T;

typedef union {
	unsigned int                val;
	NX51_CNT_IRQ_MASK_SET_BIT_T bf;
} NX51_CNT_IRQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register cnt_irq_mask_rst */
/* => Counter interrupt mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources. */
/*    As irq_msk_set this address exists twice for intlogic(ARM) and intlogic_motion(xPIC) address area. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cnt_irq_mask_rst         0x00000160U
#define Adr_NX51_gpio_motion_cnt_irq_mask_rst 0x10140560U
#define Adr_NX51_gpio_cnt_irq_mask_rst        0x1018CB60U
#define DFLT_VAL_NX51_cnt_irq_mask_rst        0x00000000U

#define MSK_NX51_cnt_irq_mask_rst_cnt0         0x00000001U
#define SRT_NX51_cnt_irq_mask_rst_cnt0         0
#define DFLT_VAL_NX51_cnt_irq_mask_rst_cnt0    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_rst_cnt0 0x00000000U
#define MSK_NX51_cnt_irq_mask_rst_cnt1         0x00000002U
#define SRT_NX51_cnt_irq_mask_rst_cnt1         1
#define DFLT_VAL_NX51_cnt_irq_mask_rst_cnt1    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_rst_cnt1 0x00000000U
#define MSK_NX51_cnt_irq_mask_rst_cnt2         0x00000004U
#define SRT_NX51_cnt_irq_mask_rst_cnt2         2
#define DFLT_VAL_NX51_cnt_irq_mask_rst_cnt2    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_rst_cnt2 0x00000000U
#define MSK_NX51_cnt_irq_mask_rst_cnt3         0x00000008U
#define SRT_NX51_cnt_irq_mask_rst_cnt3         3
#define DFLT_VAL_NX51_cnt_irq_mask_rst_cnt3    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_rst_cnt3 0x00000000U
#define MSK_NX51_cnt_irq_mask_rst_cnt4         0x00000010U
#define SRT_NX51_cnt_irq_mask_rst_cnt4         4
#define DFLT_VAL_NX51_cnt_irq_mask_rst_cnt4    0x00000000U
#define DFLT_BF_VAL_NX51_cnt_irq_mask_rst_cnt4 0x00000000U

/* all used bits of 'NX51_cnt_irq_mask_rst': */
#define MSK_USED_BITS_NX51_cnt_irq_mask_rst 0x0000001fU

enum {
	BFW_NX51_cnt_irq_mask_rst_cnt0      = 1,  /* [0] */
	BFW_NX51_cnt_irq_mask_rst_cnt1      = 1,  /* [1] */
	BFW_NX51_cnt_irq_mask_rst_cnt2      = 1,  /* [2] */
	BFW_NX51_cnt_irq_mask_rst_cnt3      = 1,  /* [3] */
	BFW_NX51_cnt_irq_mask_rst_cnt4      = 1,  /* [4] */
	BFW_NX51_cnt_irq_mask_rst_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_CNT_IRQ_MASK_RST_BIT_Ttag {
	unsigned int cnt0      : BFW_NX51_cnt_irq_mask_rst_cnt0;      /* counter0 interrupt mask bit */
	unsigned int cnt1      : BFW_NX51_cnt_irq_mask_rst_cnt1;      /* counter1 interrupt mask bit */
	unsigned int cnt2      : BFW_NX51_cnt_irq_mask_rst_cnt2;      /* counter2 interrupt mask bit */
	unsigned int cnt3      : BFW_NX51_cnt_irq_mask_rst_cnt3;      /* counter3 interrupt mask bit */
	unsigned int cnt4      : BFW_NX51_cnt_irq_mask_rst_cnt4;      /* counter4 interrupt mask bit */
	unsigned int reserved1 : BFW_NX51_cnt_irq_mask_rst_reserved1; /* reserved                    */
} NX51_CNT_IRQ_MASK_RST_BIT_T;

typedef union {
	unsigned int                val;
	NX51_CNT_IRQ_MASK_RST_BIT_T bf;
} NX51_CNT_IRQ_MASK_RST_T;


/* ===================================================================== */

/* Area of io_link */

/* ===================================================================== */

#define Addr_NX51_io_link 0x10140700U

/* ===================================================================== */

/* AREA xlink */
/* Area of xlink0, xlink1, xlink2, xlink3, xlink4, xlink5, xlink6, xlink7 */

/* ===================================================================== */

#define Addr_NX51_xlink0 0x10140700U
#define Addr_NX51_xlink1 0x10140710U
#define Addr_NX51_xlink2 0x10140720U
#define Addr_NX51_xlink3 0x10140730U
#define Addr_NX51_xlink4 0x10140740U
#define Addr_NX51_xlink5 0x10140750U
#define Addr_NX51_xlink6 0x10140760U
#define Addr_NX51_xlink7 0x10140770U

/* --------------------------------------------------------------------- */
/* Register xlink_cfg */
/* => configuration register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xlink_cfg    0x00000000U
#define Adr_NX51_xlink0_xlink_cfg 0x10140700U
#define Adr_NX51_xlink1_xlink_cfg 0x10140710U
#define Adr_NX51_xlink2_xlink_cfg 0x10140720U
#define Adr_NX51_xlink3_xlink_cfg 0x10140730U
#define Adr_NX51_xlink4_xlink_cfg 0x10140740U
#define Adr_NX51_xlink5_xlink_cfg 0x10140750U
#define Adr_NX51_xlink6_xlink_cfg 0x10140760U
#define Adr_NX51_xlink7_xlink_cfg 0x10140770U
#define DFLT_VAL_NX51_xlink_cfg   0xb4a0001bU

#define MSK_NX51_xlink_cfg_rate_inc           0x0000ffffU
#define SRT_NX51_xlink_cfg_rate_inc           0
#define DFLT_VAL_NX51_xlink_cfg_rate_inc      0x0000001bU
#define DFLT_BF_VAL_NX51_xlink_cfg_rate_inc   0x0000001bU
#define MSK_NX51_xlink_cfg_xlink_en           0x00010000U
#define SRT_NX51_xlink_cfg_xlink_en           16
#define DFLT_VAL_NX51_xlink_cfg_xlink_en      0x00000000U
#define DFLT_BF_VAL_NX51_xlink_cfg_xlink_en   0x00000000U
#define MSK_NX51_xlink_cfg_fb_en              0x00020000U
#define SRT_NX51_xlink_cfg_fb_en              17
#define DFLT_VAL_NX51_xlink_cfg_fb_en         0x00000000U
#define DFLT_BF_VAL_NX51_xlink_cfg_fb_en      0x00000000U
#define MSK_NX51_xlink_cfg_bclk2oe_en         0x00040000U
#define SRT_NX51_xlink_cfg_bclk2oe_en         18
#define DFLT_VAL_NX51_xlink_cfg_bclk2oe_en    0x00000000U
#define DFLT_BF_VAL_NX51_xlink_cfg_bclk2oe_en 0x00000000U
#define MSK_NX51_xlink_cfg_cnt_da             0x00080000U
#define SRT_NX51_xlink_cfg_cnt_da             19
#define DFLT_VAL_NX51_xlink_cfg_cnt_da        0x00000000U
#define DFLT_BF_VAL_NX51_xlink_cfg_cnt_da     0x00000000U
#define MSK_NX51_xlink_cfg_bits2rec           0x00f00000U
#define SRT_NX51_xlink_cfg_bits2rec           20
#define DFLT_VAL_NX51_xlink_cfg_bits2rec      0x00a00000U
#define DFLT_BF_VAL_NX51_xlink_cfg_bits2rec   0x0000000aU
#define MSK_NX51_xlink_cfg_start_spl          0x0f000000U
#define SRT_NX51_xlink_cfg_start_spl          24
#define DFLT_VAL_NX51_xlink_cfg_start_spl     0x04000000U
#define DFLT_BF_VAL_NX51_xlink_cfg_start_spl  0x00000004U
#define MSK_NX51_xlink_cfg_end_spl            0xf0000000U
#define SRT_NX51_xlink_cfg_end_spl            28
#define DFLT_VAL_NX51_xlink_cfg_end_spl       0xb0000000U
#define DFLT_BF_VAL_NX51_xlink_cfg_end_spl    0x0000000bU

/* all used bits of 'NX51_xlink_cfg': */
#define MSK_USED_BITS_NX51_xlink_cfg 0xffffffffU

enum {
	BFW_NX51_xlink_cfg_rate_inc   = 16, /* [15:0] */
	BFW_NX51_xlink_cfg_xlink_en   = 1,  /* [16] */
	BFW_NX51_xlink_cfg_fb_en      = 1,  /* [17] */
	BFW_NX51_xlink_cfg_bclk2oe_en = 1,  /* [18] */
	BFW_NX51_xlink_cfg_cnt_da     = 1,  /* [19] */
	BFW_NX51_xlink_cfg_bits2rec   = 4,  /* [23:20] */
	BFW_NX51_xlink_cfg_start_spl  = 4,  /* [27:24] */
	BFW_NX51_xlink_cfg_end_spl    = 4   /* [31:28] */
};

typedef struct NX51_XLINK_CFG_BIT_Ttag {
	unsigned int rate_inc   : BFW_NX51_xlink_cfg_rate_inc;   /* bitrate compare value                                                      */
	                                                         /* for bit clock counter (bit_cnt)                                            */
	                                                         /* BITRATE = 100e6/(rate_inc)                                                 */
	                                                         /* typical settings for IOLINK:                                               */
	                                                         /* {| cols=4                                                                  */
	                                                         /* BIT_RATE | rate_inc | clock period | calc: 1/BIT_RATE                      */
	                                                         /* 4800     | 0x5160   | 208,33 us    | 208,3333us                            */
	                                                         /* 38400    | 0xa2b    |  26,04 us    |  26,04167us                           */
	                                                         /* 230400   | 0x1b1    |   4,34 us    |   4,340278us                          */
	                                                         /* ...      |          |                                                      */
	                                                         /* invalid:                                                                   */
	                                                         /*      0   | 0        | 0            | 0                                     */
	                                                         /* }                                                                          */
	unsigned int xlink_en   : BFW_NX51_xlink_cfg_xlink_en;   /* disable the output enable, and activity                                    */
	unsigned int fb_en      : BFW_NX51_xlink_cfg_fb_en;      /* test feature, enable internal feedback                                     */
	unsigned int bclk2oe_en : BFW_NX51_xlink_cfg_bclk2oe_en; /* test feature, do not set this bit!                                         */
	unsigned int cnt_da     : BFW_NX51_xlink_cfg_cnt_da;     /* test feature, do not set this bit!                                         */
	unsigned int bits2rec   : BFW_NX51_xlink_cfg_bits2rec;   /* count of bits to receive                                                   */
	                                                         /* note: the reset value expect: 1stopbit, 8databits, 1paritybit and 1stopbit */
	unsigned int start_spl  : BFW_NX51_xlink_cfg_start_spl;  /* start sample point for receive data                                        */
	                                                         /* a sample period is defined as 1/16 of the bitrate period                   */
	                                                         /* range: 0x0 - 0xf                                                           */
	                                                         /* note: settings for start_spl and end_spl                                   */
	                                                         /*       should always fulfill the condition:                                 */
	                                                         /*       (start_spl < end_spl)                                                */
	unsigned int end_spl    : BFW_NX51_xlink_cfg_end_spl;    /* end sample point  for receive data                                         */
} NX51_XLINK_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XLINK_CFG_BIT_T bf;
} NX51_XLINK_CFG_T;

/* --------------------------------------------------------------------- */
/* Register xlink_tx */
/* => xlink transmit register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xlink_tx    0x00000004U
#define Adr_NX51_xlink0_xlink_tx 0x10140704U
#define Adr_NX51_xlink1_xlink_tx 0x10140714U
#define Adr_NX51_xlink2_xlink_tx 0x10140724U
#define Adr_NX51_xlink3_xlink_tx 0x10140734U
#define Adr_NX51_xlink4_xlink_tx 0x10140744U
#define Adr_NX51_xlink5_xlink_tx 0x10140754U
#define Adr_NX51_xlink6_xlink_tx 0x10140764U
#define Adr_NX51_xlink7_xlink_tx 0x10140774U
#define DFLT_VAL_NX51_xlink_tx   0x00030000U

#define MSK_NX51_xlink_tx_hold            0x0000ffffU
#define SRT_NX51_xlink_tx_hold            0
#define DFLT_VAL_NX51_xlink_tx_hold       0x00000000U
#define DFLT_BF_VAL_NX51_xlink_tx_hold    0x00000000U
#define MSK_NX51_xlink_tx_rdy_ro          0x00010000U
#define SRT_NX51_xlink_tx_rdy_ro          16
#define DFLT_VAL_NX51_xlink_tx_rdy_ro     0x00010000U
#define DFLT_BF_VAL_NX51_xlink_tx_rdy_ro  0x00000001U
#define MSK_NX51_xlink_tx_idle_ro         0x00020000U
#define SRT_NX51_xlink_tx_idle_ro         17
#define DFLT_VAL_NX51_xlink_tx_idle_ro    0x00020000U
#define DFLT_BF_VAL_NX51_xlink_tx_idle_ro 0x00000001U

/* all used bits of 'NX51_xlink_tx': */
#define MSK_USED_BITS_NX51_xlink_tx 0x0003ffffU

enum {
	BFW_NX51_xlink_tx_hold      = 16, /* [15:0] */
	BFW_NX51_xlink_tx_rdy_ro    = 1,  /* [16] */
	BFW_NX51_xlink_tx_idle_ro   = 1,  /* [17] */
	BFW_NX51_xlink_tx_reserved1 = 14  /* [31:18] */
};

typedef struct NX51_XLINK_TX_BIT_Ttag {
	unsigned int hold      : BFW_NX51_xlink_tx_hold;      /* hold register                                                                    */
	                                                      /*   format for a valid serial DATA sequence:                                       */
	                                                      /*   <-ctrl.DATA-><------------------- serial DATA -------------------->            */
	                                                      /*   { END_BIT:1 }[{STOPBIT:1}{DATABITS max. 12:0101..0010}{STARTBIT:0}]            */
	                                                      /*   notes:                                                                         */
	                                                      /*   ENDBIT is a hardware marker to stop the shifting, and will not be transmitted. */
	                                                      /*   this condition implied, than all other not used bits should be zero            */
	unsigned int rdy_ro    : BFW_NX51_xlink_tx_rdy_ro;    /* TX buffer ready (valid on ready)                                                 */
	                                                      /*  0 TX buffer not ready                                                           */
	                                                      /*  1 TX buffer ready                                                               */
	unsigned int idle_ro   : BFW_NX51_xlink_tx_idle_ro;   /* indicates no activity on tx                                                      */
	unsigned int reserved1 : BFW_NX51_xlink_tx_reserved1; /* reserved                                                                         */
} NX51_XLINK_TX_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XLINK_TX_BIT_T bf;
} NX51_XLINK_TX_T;

/* --------------------------------------------------------------------- */
/* Register xlink_rx */
/* => xlink RX register */
/*    writing to the register, reset the ready bit, the overflow bit and the sampling error bit */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xlink_rx    0x00000008U
#define Adr_NX51_xlink0_xlink_rx 0x10140708U
#define Adr_NX51_xlink1_xlink_rx 0x10140718U
#define Adr_NX51_xlink2_xlink_rx 0x10140728U
#define Adr_NX51_xlink3_xlink_rx 0x10140738U
#define Adr_NX51_xlink4_xlink_rx 0x10140748U
#define Adr_NX51_xlink5_xlink_rx 0x10140758U
#define Adr_NX51_xlink6_xlink_rx 0x10140768U
#define Adr_NX51_xlink7_xlink_rx 0x10140778U
#define DFLT_VAL_NX51_xlink_rx   0x0000ffffU

#define MSK_NX51_xlink_rx_hold_ro            0x0000ffffU
#define SRT_NX51_xlink_rx_hold_ro            0
#define DFLT_VAL_NX51_xlink_rx_hold_ro       0x0000ffffU
#define DFLT_BF_VAL_NX51_xlink_rx_hold_ro    0x0000ffffU
#define MSK_NX51_xlink_rx_rdy_ro             0x00010000U
#define SRT_NX51_xlink_rx_rdy_ro             16
#define DFLT_VAL_NX51_xlink_rx_rdy_ro        0x00000000U
#define DFLT_BF_VAL_NX51_xlink_rx_rdy_ro     0x00000000U
#define MSK_NX51_xlink_rx_rxd_ro             0x00080000U
#define SRT_NX51_xlink_rx_rxd_ro             19
#define DFLT_VAL_NX51_xlink_rx_rxd_ro        0x00000000U
#define DFLT_BF_VAL_NX51_xlink_rx_rxd_ro     0x00000000U
#define MSK_NX51_xlink_rx_ovf_err_ro         0x00100000U
#define SRT_NX51_xlink_rx_ovf_err_ro         20
#define DFLT_VAL_NX51_xlink_rx_ovf_err_ro    0x00000000U
#define DFLT_BF_VAL_NX51_xlink_rx_ovf_err_ro 0x00000000U
#define MSK_NX51_xlink_rx_spl_err_ro         0x00200000U
#define SRT_NX51_xlink_rx_spl_err_ro         21
#define DFLT_VAL_NX51_xlink_rx_spl_err_ro    0x00000000U
#define DFLT_BF_VAL_NX51_xlink_rx_spl_err_ro 0x00000000U

/* all used bits of 'NX51_xlink_rx': */
#define MSK_USED_BITS_NX51_xlink_rx 0x0039ffffU

enum {
	BFW_NX51_xlink_rx_hold_ro    = 16, /* [15:0] */
	BFW_NX51_xlink_rx_rdy_ro     = 1,  /* [16] */
	BFW_NX51_xlink_rx_reserved1  = 2,  /* [18:17] */
	BFW_NX51_xlink_rx_rxd_ro     = 1,  /* [19] */
	BFW_NX51_xlink_rx_ovf_err_ro = 1,  /* [20] */
	BFW_NX51_xlink_rx_spl_err_ro = 1,  /* [21] */
	BFW_NX51_xlink_rx_reserved2  = 10  /* [31:22] */
};

typedef struct NX51_XLINK_RX_BIT_Ttag {
	unsigned int hold_ro    : BFW_NX51_xlink_rx_hold_ro;    /* RX byte (when valid)                                */
	                                                        /*   hold[15:0] is used to shift in RX(LSB first!)     */
	                                                        /*   the amount of shifted bits is defined by bits2rec */
	                                                        /*   shift order is bit15 downto bit0                  */
	unsigned int rdy_ro     : BFW_NX51_xlink_rx_rdy_ro;     /* RX buffer ready (valid on ready)                    */
	                                                        /*  0 RX buffer not ready                              */
	                                                        /*  1 RX buffer ready                                  */
	unsigned int reserved1  : BFW_NX51_xlink_rx_reserved1;  /* reserved                                            */
	unsigned int rxd_ro     : BFW_NX51_xlink_rx_rxd_ro;     /* current status of rx data                           */
	unsigned int ovf_err_ro : BFW_NX51_xlink_rx_ovf_err_ro; /* overflow error on received data                     */
	unsigned int spl_err_ro : BFW_NX51_xlink_rx_spl_err_ro; /* sampling error detected                             */
	                                                        /* if the amount of sampled bits (HI or LOW)           */
	                                                        /* do not fulfill the condition:                       */
	                                                        /* (end_spl - start_spl) < (count of HI/LOW bits)      */
	unsigned int reserved2  : BFW_NX51_xlink_rx_reserved2;  /* reserved                                            */
} NX51_XLINK_RX_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XLINK_RX_BIT_T bf;
} NX51_XLINK_RX_T;

/* --------------------------------------------------------------------- */
/* Register xlink_stat */
/* => xlink status register & io control */
/*    writing to this register set the bit clock counter to zero! */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xlink_stat    0x0000000CU
#define Adr_NX51_xlink0_xlink_stat 0x1014070CU
#define Adr_NX51_xlink1_xlink_stat 0x1014071CU
#define Adr_NX51_xlink2_xlink_stat 0x1014072CU
#define Adr_NX51_xlink3_xlink_stat 0x1014073CU
#define Adr_NX51_xlink4_xlink_stat 0x1014074CU
#define Adr_NX51_xlink5_xlink_stat 0x1014075CU
#define Adr_NX51_xlink6_xlink_stat 0x1014076CU
#define Adr_NX51_xlink7_xlink_stat 0x1014077CU
#define DFLT_VAL_NX51_xlink_stat   0x01000000U

#define MSK_NX51_xlink_stat_bit_cnt_ro         0x0000ffffU
#define SRT_NX51_xlink_stat_bit_cnt_ro         0
#define DFLT_VAL_NX51_xlink_stat_bit_cnt_ro    0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_bit_cnt_ro 0x00000000U
#define MSK_NX51_xlink_stat_bit_clk_ro         0x00010000U
#define SRT_NX51_xlink_stat_bit_clk_ro         16
#define DFLT_VAL_NX51_xlink_stat_bit_clk_ro    0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_bit_clk_ro 0x00000000U
#define MSK_NX51_xlink_stat_txo_ro             0x00020000U
#define SRT_NX51_xlink_stat_txo_ro             17
#define DFLT_VAL_NX51_xlink_stat_txo_ro        0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_txo_ro     0x00000000U
#define MSK_NX51_xlink_stat_rxo_ro             0x00040000U
#define SRT_NX51_xlink_stat_rxo_ro             18
#define DFLT_VAL_NX51_xlink_stat_rxo_ro        0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_rxo_ro     0x00000000U
#define MSK_NX51_xlink_stat_txoe_ro            0x00080000U
#define SRT_NX51_xlink_stat_txoe_ro            19
#define DFLT_VAL_NX51_xlink_stat_txoe_ro       0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_txoe_ro    0x00000000U
#define MSK_NX51_xlink_stat_io_mode            0x00100000U
#define SRT_NX51_xlink_stat_io_mode            20
#define DFLT_VAL_NX51_xlink_stat_io_mode       0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_io_mode    0x00000000U
#define MSK_NX51_xlink_stat_set_tx             0x00200000U
#define SRT_NX51_xlink_stat_set_tx             21
#define DFLT_VAL_NX51_xlink_stat_set_tx        0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_set_tx     0x00000000U
#define MSK_NX51_xlink_stat_set_txoe           0x00400000U
#define SRT_NX51_xlink_stat_set_txoe           22
#define DFLT_VAL_NX51_xlink_stat_set_txoe      0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_set_txoe   0x00000000U
#define MSK_NX51_xlink_stat_set_wakeup         0x00800000U
#define SRT_NX51_xlink_stat_set_wakeup         23
#define DFLT_VAL_NX51_xlink_stat_set_wakeup    0x00000000U
#define DFLT_BF_VAL_NX51_xlink_stat_set_wakeup 0x00000000U
#define MSK_NX51_xlink_stat_filter_en          0x01000000U
#define SRT_NX51_xlink_stat_filter_en          24
#define DFLT_VAL_NX51_xlink_stat_filter_en     0x01000000U
#define DFLT_BF_VAL_NX51_xlink_stat_filter_en  0x00000001U

/* all used bits of 'NX51_xlink_stat': */
#define MSK_USED_BITS_NX51_xlink_stat 0x01ffffffU

enum {
	BFW_NX51_xlink_stat_bit_cnt_ro = 16, /* [15:0] */
	BFW_NX51_xlink_stat_bit_clk_ro = 1,  /* [16] */
	BFW_NX51_xlink_stat_txo_ro     = 1,  /* [17] */
	BFW_NX51_xlink_stat_rxo_ro     = 1,  /* [18] */
	BFW_NX51_xlink_stat_txoe_ro    = 1,  /* [19] */
	BFW_NX51_xlink_stat_io_mode    = 1,  /* [20] */
	BFW_NX51_xlink_stat_set_tx     = 1,  /* [21] */
	BFW_NX51_xlink_stat_set_txoe   = 1,  /* [22] */
	BFW_NX51_xlink_stat_set_wakeup = 1,  /* [23] */
	BFW_NX51_xlink_stat_filter_en  = 1,  /* [24] */
	BFW_NX51_xlink_stat_reserved1  = 7   /* [31:25] */
};

typedef struct NX51_XLINK_STAT_BIT_Ttag {
	unsigned int bit_cnt_ro : BFW_NX51_xlink_stat_bit_cnt_ro; /* status of bit clock counter                 */
	unsigned int bit_clk_ro : BFW_NX51_xlink_stat_bit_clk_ro; /* status of bit clock signal                  */
	unsigned int txo_ro     : BFW_NX51_xlink_stat_txo_ro;     /* status of tx output                         */
	unsigned int rxo_ro     : BFW_NX51_xlink_stat_rxo_ro;     /* status of rx input                          */
	unsigned int txoe_ro    : BFW_NX51_xlink_stat_txoe_ro;    /* status of tx output enable                  */
	unsigned int io_mode    : BFW_NX51_xlink_stat_io_mode;    /* enable the io mode on tx and wakeup         */
	                                                          /* 0 : disable io function on tx, txoe, wakeup */
	                                                          /* 1 : enable io function on tx, txoe, wakeup  */
	unsigned int set_tx     : BFW_NX51_xlink_stat_set_tx;     /* set the tx port,                            */
	unsigned int set_txoe   : BFW_NX51_xlink_stat_set_txoe;   /* set the tx output enable                    */
	unsigned int set_wakeup : BFW_NX51_xlink_stat_set_wakeup; /* set the wakeup port                         */
	unsigned int filter_en  : BFW_NX51_xlink_stat_filter_en;  /* enable 3 majority ruling filter             */
	unsigned int reserved1  : BFW_NX51_xlink_stat_reserved1;  /* reserved                                    */
} NX51_XLINK_STAT_BIT_T;

typedef union {
	unsigned int          val;
	NX51_XLINK_STAT_BIT_T bf;
} NX51_XLINK_STAT_T;


/* ===================================================================== */

/* Area of io_link_irq */

/* ===================================================================== */

#define Addr_NX51_io_link_irq 0x10140780U

/* --------------------------------------------------------------------- */
/* Register io_link_irq_raw */
/* => IO-Link raw interrupts: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_link_irq_raw         0x00000000U
#define Adr_NX51_io_link_irq_io_link_irq_raw 0x10140780U
#define Adr_NX51_io_link_irq_raw             0x10140780U
#define DFLT_VAL_NX51_io_link_irq_raw        0x00000000U

#define MSK_NX51_io_link_irq_raw_xlink0_tx_next          0x00000001U
#define SRT_NX51_io_link_irq_raw_xlink0_tx_next          0
#define DFLT_VAL_NX51_io_link_irq_raw_xlink0_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink0_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink0_rx_next          0x00000002U
#define SRT_NX51_io_link_irq_raw_xlink0_rx_next          1
#define DFLT_VAL_NX51_io_link_irq_raw_xlink0_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink0_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink0_shift_en         0x00000004U
#define SRT_NX51_io_link_irq_raw_xlink0_shift_en         2
#define DFLT_VAL_NX51_io_link_irq_raw_xlink0_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink0_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink1_tx_next          0x00000010U
#define SRT_NX51_io_link_irq_raw_xlink1_tx_next          4
#define DFLT_VAL_NX51_io_link_irq_raw_xlink1_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink1_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink1_rx_next          0x00000020U
#define SRT_NX51_io_link_irq_raw_xlink1_rx_next          5
#define DFLT_VAL_NX51_io_link_irq_raw_xlink1_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink1_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink1_shift_en         0x00000040U
#define SRT_NX51_io_link_irq_raw_xlink1_shift_en         6
#define DFLT_VAL_NX51_io_link_irq_raw_xlink1_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink1_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink2_tx_next          0x00000100U
#define SRT_NX51_io_link_irq_raw_xlink2_tx_next          8
#define DFLT_VAL_NX51_io_link_irq_raw_xlink2_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink2_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink2_rx_next          0x00000200U
#define SRT_NX51_io_link_irq_raw_xlink2_rx_next          9
#define DFLT_VAL_NX51_io_link_irq_raw_xlink2_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink2_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink2_shift_en         0x00000400U
#define SRT_NX51_io_link_irq_raw_xlink2_shift_en         10
#define DFLT_VAL_NX51_io_link_irq_raw_xlink2_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink2_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink3_tx_next          0x00001000U
#define SRT_NX51_io_link_irq_raw_xlink3_tx_next          12
#define DFLT_VAL_NX51_io_link_irq_raw_xlink3_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink3_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink3_rx_next          0x00002000U
#define SRT_NX51_io_link_irq_raw_xlink3_rx_next          13
#define DFLT_VAL_NX51_io_link_irq_raw_xlink3_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink3_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink3_shift_en         0x00004000U
#define SRT_NX51_io_link_irq_raw_xlink3_shift_en         14
#define DFLT_VAL_NX51_io_link_irq_raw_xlink3_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink3_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink4_tx_next          0x00010000U
#define SRT_NX51_io_link_irq_raw_xlink4_tx_next          16
#define DFLT_VAL_NX51_io_link_irq_raw_xlink4_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink4_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink4_rx_next          0x00020000U
#define SRT_NX51_io_link_irq_raw_xlink4_rx_next          17
#define DFLT_VAL_NX51_io_link_irq_raw_xlink4_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink4_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink4_shift_en         0x00040000U
#define SRT_NX51_io_link_irq_raw_xlink4_shift_en         18
#define DFLT_VAL_NX51_io_link_irq_raw_xlink4_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink4_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink5_tx_next          0x00100000U
#define SRT_NX51_io_link_irq_raw_xlink5_tx_next          20
#define DFLT_VAL_NX51_io_link_irq_raw_xlink5_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink5_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink5_rx_next          0x00200000U
#define SRT_NX51_io_link_irq_raw_xlink5_rx_next          21
#define DFLT_VAL_NX51_io_link_irq_raw_xlink5_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink5_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink5_shift_en         0x00400000U
#define SRT_NX51_io_link_irq_raw_xlink5_shift_en         22
#define DFLT_VAL_NX51_io_link_irq_raw_xlink5_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink5_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink6_tx_next          0x01000000U
#define SRT_NX51_io_link_irq_raw_xlink6_tx_next          24
#define DFLT_VAL_NX51_io_link_irq_raw_xlink6_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink6_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink6_rx_next          0x02000000U
#define SRT_NX51_io_link_irq_raw_xlink6_rx_next          25
#define DFLT_VAL_NX51_io_link_irq_raw_xlink6_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink6_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink6_shift_en         0x04000000U
#define SRT_NX51_io_link_irq_raw_xlink6_shift_en         26
#define DFLT_VAL_NX51_io_link_irq_raw_xlink6_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink6_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink7_tx_next          0x10000000U
#define SRT_NX51_io_link_irq_raw_xlink7_tx_next          28
#define DFLT_VAL_NX51_io_link_irq_raw_xlink7_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink7_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink7_rx_next          0x20000000U
#define SRT_NX51_io_link_irq_raw_xlink7_rx_next          29
#define DFLT_VAL_NX51_io_link_irq_raw_xlink7_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink7_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_raw_xlink7_shift_en         0x40000000U
#define SRT_NX51_io_link_irq_raw_xlink7_shift_en         30
#define DFLT_VAL_NX51_io_link_irq_raw_xlink7_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_raw_xlink7_shift_en 0x00000000U

/* all used bits of 'NX51_io_link_irq_raw': */
#define MSK_USED_BITS_NX51_io_link_irq_raw 0x77777777U

enum {
	BFW_NX51_io_link_irq_raw_xlink0_tx_next  = 1, /* [0] */
	BFW_NX51_io_link_irq_raw_xlink0_rx_next  = 1, /* [1] */
	BFW_NX51_io_link_irq_raw_xlink0_shift_en = 1, /* [2] */
	BFW_NX51_io_link_irq_raw_reserved1       = 1, /* [3] */
	BFW_NX51_io_link_irq_raw_xlink1_tx_next  = 1, /* [4] */
	BFW_NX51_io_link_irq_raw_xlink1_rx_next  = 1, /* [5] */
	BFW_NX51_io_link_irq_raw_xlink1_shift_en = 1, /* [6] */
	BFW_NX51_io_link_irq_raw_reserved2       = 1, /* [7] */
	BFW_NX51_io_link_irq_raw_xlink2_tx_next  = 1, /* [8] */
	BFW_NX51_io_link_irq_raw_xlink2_rx_next  = 1, /* [9] */
	BFW_NX51_io_link_irq_raw_xlink2_shift_en = 1, /* [10] */
	BFW_NX51_io_link_irq_raw_reserved3       = 1, /* [11] */
	BFW_NX51_io_link_irq_raw_xlink3_tx_next  = 1, /* [12] */
	BFW_NX51_io_link_irq_raw_xlink3_rx_next  = 1, /* [13] */
	BFW_NX51_io_link_irq_raw_xlink3_shift_en = 1, /* [14] */
	BFW_NX51_io_link_irq_raw_reserved4       = 1, /* [15] */
	BFW_NX51_io_link_irq_raw_xlink4_tx_next  = 1, /* [16] */
	BFW_NX51_io_link_irq_raw_xlink4_rx_next  = 1, /* [17] */
	BFW_NX51_io_link_irq_raw_xlink4_shift_en = 1, /* [18] */
	BFW_NX51_io_link_irq_raw_reserved5       = 1, /* [19] */
	BFW_NX51_io_link_irq_raw_xlink5_tx_next  = 1, /* [20] */
	BFW_NX51_io_link_irq_raw_xlink5_rx_next  = 1, /* [21] */
	BFW_NX51_io_link_irq_raw_xlink5_shift_en = 1, /* [22] */
	BFW_NX51_io_link_irq_raw_reserved6       = 1, /* [23] */
	BFW_NX51_io_link_irq_raw_xlink6_tx_next  = 1, /* [24] */
	BFW_NX51_io_link_irq_raw_xlink6_rx_next  = 1, /* [25] */
	BFW_NX51_io_link_irq_raw_xlink6_shift_en = 1, /* [26] */
	BFW_NX51_io_link_irq_raw_reserved7       = 1, /* [27] */
	BFW_NX51_io_link_irq_raw_xlink7_tx_next  = 1, /* [28] */
	BFW_NX51_io_link_irq_raw_xlink7_rx_next  = 1, /* [29] */
	BFW_NX51_io_link_irq_raw_xlink7_shift_en = 1, /* [30] */
	BFW_NX51_io_link_irq_raw_reserved8       = 1  /* [31] */
};

typedef struct NX51_IO_LINK_IRQ_RAW_BIT_Ttag {
	unsigned int xlink0_tx_next  : BFW_NX51_io_link_irq_raw_xlink0_tx_next;  /* tx_next interrupt  */
	unsigned int xlink0_rx_next  : BFW_NX51_io_link_irq_raw_xlink0_rx_next;  /* rx_next interrupt  */
	unsigned int xlink0_shift_en : BFW_NX51_io_link_irq_raw_xlink0_shift_en; /* shift_en interrupt */
	unsigned int reserved1       : BFW_NX51_io_link_irq_raw_reserved1;       /* reserved           */
	unsigned int xlink1_tx_next  : BFW_NX51_io_link_irq_raw_xlink1_tx_next;  /* tx_next interrupt  */
	unsigned int xlink1_rx_next  : BFW_NX51_io_link_irq_raw_xlink1_rx_next;  /* rx_next interrupt  */
	unsigned int xlink1_shift_en : BFW_NX51_io_link_irq_raw_xlink1_shift_en; /* shift_en interrupt */
	unsigned int reserved2       : BFW_NX51_io_link_irq_raw_reserved2;       /* reserved           */
	unsigned int xlink2_tx_next  : BFW_NX51_io_link_irq_raw_xlink2_tx_next;  /* tx_next interrupt  */
	unsigned int xlink2_rx_next  : BFW_NX51_io_link_irq_raw_xlink2_rx_next;  /* rx_next interrupt  */
	unsigned int xlink2_shift_en : BFW_NX51_io_link_irq_raw_xlink2_shift_en; /* shift_en interrupt */
	unsigned int reserved3       : BFW_NX51_io_link_irq_raw_reserved3;       /* reserved           */
	unsigned int xlink3_tx_next  : BFW_NX51_io_link_irq_raw_xlink3_tx_next;  /* tx_next interrupt  */
	unsigned int xlink3_rx_next  : BFW_NX51_io_link_irq_raw_xlink3_rx_next;  /* rx_next interrupt  */
	unsigned int xlink3_shift_en : BFW_NX51_io_link_irq_raw_xlink3_shift_en; /* shift_en interrupt */
	unsigned int reserved4       : BFW_NX51_io_link_irq_raw_reserved4;       /* reserved           */
	unsigned int xlink4_tx_next  : BFW_NX51_io_link_irq_raw_xlink4_tx_next;  /* tx_next interrupt  */
	unsigned int xlink4_rx_next  : BFW_NX51_io_link_irq_raw_xlink4_rx_next;  /* rx_next interrupt  */
	unsigned int xlink4_shift_en : BFW_NX51_io_link_irq_raw_xlink4_shift_en; /* shift_en interrupt */
	unsigned int reserved5       : BFW_NX51_io_link_irq_raw_reserved5;       /* reserved           */
	unsigned int xlink5_tx_next  : BFW_NX51_io_link_irq_raw_xlink5_tx_next;  /* tx_next interrupt  */
	unsigned int xlink5_rx_next  : BFW_NX51_io_link_irq_raw_xlink5_rx_next;  /* rx_next interrupt  */
	unsigned int xlink5_shift_en : BFW_NX51_io_link_irq_raw_xlink5_shift_en; /* shift_en interrupt */
	unsigned int reserved6       : BFW_NX51_io_link_irq_raw_reserved6;       /* reserved           */
	unsigned int xlink6_tx_next  : BFW_NX51_io_link_irq_raw_xlink6_tx_next;  /* tx_next interrupt  */
	unsigned int xlink6_rx_next  : BFW_NX51_io_link_irq_raw_xlink6_rx_next;  /* rx_next interrupt  */
	unsigned int xlink6_shift_en : BFW_NX51_io_link_irq_raw_xlink6_shift_en; /* shift_en interrupt */
	unsigned int reserved7       : BFW_NX51_io_link_irq_raw_reserved7;       /* reserved           */
	unsigned int xlink7_tx_next  : BFW_NX51_io_link_irq_raw_xlink7_tx_next;  /* tx_next interrupt  */
	unsigned int xlink7_rx_next  : BFW_NX51_io_link_irq_raw_xlink7_rx_next;  /* rx_next interrupt  */
	unsigned int xlink7_shift_en : BFW_NX51_io_link_irq_raw_xlink7_shift_en; /* shift_en interrupt */
	unsigned int reserved8       : BFW_NX51_io_link_irq_raw_reserved8;       /* reserved           */
} NX51_IO_LINK_IRQ_RAW_BIT_T;

typedef union {
	unsigned int               val;
	NX51_IO_LINK_IRQ_RAW_BIT_T bf;
} NX51_IO_LINK_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register io_link_irq_masked */
/* => IO-Link Masked IRQ register */
/*    Shows status of masked IRQs (as connected to ARM/xPIC) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_link_irq_masked         0x00000004U
#define Adr_NX51_io_link_irq_io_link_irq_masked 0x10140784U
#define Adr_NX51_io_link_irq_masked             0x10140784U

#define MSK_NX51_io_link_irq_masked_xlink0_tx_next  0x00000001U
#define SRT_NX51_io_link_irq_masked_xlink0_tx_next  0
#define MSK_NX51_io_link_irq_masked_xlink0_rx_next  0x00000002U
#define SRT_NX51_io_link_irq_masked_xlink0_rx_next  1
#define MSK_NX51_io_link_irq_masked_xlink0_shift_en 0x00000004U
#define SRT_NX51_io_link_irq_masked_xlink0_shift_en 2
#define MSK_NX51_io_link_irq_masked_xlink1_tx_next  0x00000010U
#define SRT_NX51_io_link_irq_masked_xlink1_tx_next  4
#define MSK_NX51_io_link_irq_masked_xlink1_rx_next  0x00000020U
#define SRT_NX51_io_link_irq_masked_xlink1_rx_next  5
#define MSK_NX51_io_link_irq_masked_xlink1_shift_en 0x00000040U
#define SRT_NX51_io_link_irq_masked_xlink1_shift_en 6
#define MSK_NX51_io_link_irq_masked_xlink2_tx_next  0x00000100U
#define SRT_NX51_io_link_irq_masked_xlink2_tx_next  8
#define MSK_NX51_io_link_irq_masked_xlink2_rx_next  0x00000200U
#define SRT_NX51_io_link_irq_masked_xlink2_rx_next  9
#define MSK_NX51_io_link_irq_masked_xlink2_shift_en 0x00000400U
#define SRT_NX51_io_link_irq_masked_xlink2_shift_en 10
#define MSK_NX51_io_link_irq_masked_xlink3_tx_next  0x00001000U
#define SRT_NX51_io_link_irq_masked_xlink3_tx_next  12
#define MSK_NX51_io_link_irq_masked_xlink3_rx_next  0x00002000U
#define SRT_NX51_io_link_irq_masked_xlink3_rx_next  13
#define MSK_NX51_io_link_irq_masked_xlink3_shift_en 0x00004000U
#define SRT_NX51_io_link_irq_masked_xlink3_shift_en 14
#define MSK_NX51_io_link_irq_masked_xlink4_tx_next  0x00010000U
#define SRT_NX51_io_link_irq_masked_xlink4_tx_next  16
#define MSK_NX51_io_link_irq_masked_xlink4_rx_next  0x00020000U
#define SRT_NX51_io_link_irq_masked_xlink4_rx_next  17
#define MSK_NX51_io_link_irq_masked_xlink4_shift_en 0x00040000U
#define SRT_NX51_io_link_irq_masked_xlink4_shift_en 18
#define MSK_NX51_io_link_irq_masked_xlink5_tx_next  0x00100000U
#define SRT_NX51_io_link_irq_masked_xlink5_tx_next  20
#define MSK_NX51_io_link_irq_masked_xlink5_rx_next  0x00200000U
#define SRT_NX51_io_link_irq_masked_xlink5_rx_next  21
#define MSK_NX51_io_link_irq_masked_xlink5_shift_en 0x00400000U
#define SRT_NX51_io_link_irq_masked_xlink5_shift_en 22
#define MSK_NX51_io_link_irq_masked_xlink6_tx_next  0x01000000U
#define SRT_NX51_io_link_irq_masked_xlink6_tx_next  24
#define MSK_NX51_io_link_irq_masked_xlink6_rx_next  0x02000000U
#define SRT_NX51_io_link_irq_masked_xlink6_rx_next  25
#define MSK_NX51_io_link_irq_masked_xlink6_shift_en 0x04000000U
#define SRT_NX51_io_link_irq_masked_xlink6_shift_en 26
#define MSK_NX51_io_link_irq_masked_xlink7_tx_next  0x10000000U
#define SRT_NX51_io_link_irq_masked_xlink7_tx_next  28
#define MSK_NX51_io_link_irq_masked_xlink7_rx_next  0x20000000U
#define SRT_NX51_io_link_irq_masked_xlink7_rx_next  29
#define MSK_NX51_io_link_irq_masked_xlink7_shift_en 0x40000000U
#define SRT_NX51_io_link_irq_masked_xlink7_shift_en 30

/* all used bits of 'NX51_io_link_irq_masked': */
#define MSK_USED_BITS_NX51_io_link_irq_masked 0x77777777U

enum {
	BFW_NX51_io_link_irq_masked_xlink0_tx_next  = 1, /* [0] */
	BFW_NX51_io_link_irq_masked_xlink0_rx_next  = 1, /* [1] */
	BFW_NX51_io_link_irq_masked_xlink0_shift_en = 1, /* [2] */
	BFW_NX51_io_link_irq_masked_reserved1       = 1, /* [3] */
	BFW_NX51_io_link_irq_masked_xlink1_tx_next  = 1, /* [4] */
	BFW_NX51_io_link_irq_masked_xlink1_rx_next  = 1, /* [5] */
	BFW_NX51_io_link_irq_masked_xlink1_shift_en = 1, /* [6] */
	BFW_NX51_io_link_irq_masked_reserved2       = 1, /* [7] */
	BFW_NX51_io_link_irq_masked_xlink2_tx_next  = 1, /* [8] */
	BFW_NX51_io_link_irq_masked_xlink2_rx_next  = 1, /* [9] */
	BFW_NX51_io_link_irq_masked_xlink2_shift_en = 1, /* [10] */
	BFW_NX51_io_link_irq_masked_reserved3       = 1, /* [11] */
	BFW_NX51_io_link_irq_masked_xlink3_tx_next  = 1, /* [12] */
	BFW_NX51_io_link_irq_masked_xlink3_rx_next  = 1, /* [13] */
	BFW_NX51_io_link_irq_masked_xlink3_shift_en = 1, /* [14] */
	BFW_NX51_io_link_irq_masked_reserved4       = 1, /* [15] */
	BFW_NX51_io_link_irq_masked_xlink4_tx_next  = 1, /* [16] */
	BFW_NX51_io_link_irq_masked_xlink4_rx_next  = 1, /* [17] */
	BFW_NX51_io_link_irq_masked_xlink4_shift_en = 1, /* [18] */
	BFW_NX51_io_link_irq_masked_reserved5       = 1, /* [19] */
	BFW_NX51_io_link_irq_masked_xlink5_tx_next  = 1, /* [20] */
	BFW_NX51_io_link_irq_masked_xlink5_rx_next  = 1, /* [21] */
	BFW_NX51_io_link_irq_masked_xlink5_shift_en = 1, /* [22] */
	BFW_NX51_io_link_irq_masked_reserved6       = 1, /* [23] */
	BFW_NX51_io_link_irq_masked_xlink6_tx_next  = 1, /* [24] */
	BFW_NX51_io_link_irq_masked_xlink6_rx_next  = 1, /* [25] */
	BFW_NX51_io_link_irq_masked_xlink6_shift_en = 1, /* [26] */
	BFW_NX51_io_link_irq_masked_reserved7       = 1, /* [27] */
	BFW_NX51_io_link_irq_masked_xlink7_tx_next  = 1, /* [28] */
	BFW_NX51_io_link_irq_masked_xlink7_rx_next  = 1, /* [29] */
	BFW_NX51_io_link_irq_masked_xlink7_shift_en = 1, /* [30] */
	BFW_NX51_io_link_irq_masked_reserved8       = 1  /* [31] */
};

typedef struct NX51_IO_LINK_IRQ_MASKED_BIT_Ttag {
	unsigned int xlink0_tx_next  : BFW_NX51_io_link_irq_masked_xlink0_tx_next;  /* tx_next interrupt  */
	unsigned int xlink0_rx_next  : BFW_NX51_io_link_irq_masked_xlink0_rx_next;  /* rx_next interrupt  */
	unsigned int xlink0_shift_en : BFW_NX51_io_link_irq_masked_xlink0_shift_en; /* shift_en interrupt */
	unsigned int reserved1       : BFW_NX51_io_link_irq_masked_reserved1;       /* reserved           */
	unsigned int xlink1_tx_next  : BFW_NX51_io_link_irq_masked_xlink1_tx_next;  /* tx_next interrupt  */
	unsigned int xlink1_rx_next  : BFW_NX51_io_link_irq_masked_xlink1_rx_next;  /* rx_next interrupt  */
	unsigned int xlink1_shift_en : BFW_NX51_io_link_irq_masked_xlink1_shift_en; /* shift_en interrupt */
	unsigned int reserved2       : BFW_NX51_io_link_irq_masked_reserved2;       /* reserved           */
	unsigned int xlink2_tx_next  : BFW_NX51_io_link_irq_masked_xlink2_tx_next;  /* tx_next interrupt  */
	unsigned int xlink2_rx_next  : BFW_NX51_io_link_irq_masked_xlink2_rx_next;  /* rx_next interrupt  */
	unsigned int xlink2_shift_en : BFW_NX51_io_link_irq_masked_xlink2_shift_en; /* shift_en interrupt */
	unsigned int reserved3       : BFW_NX51_io_link_irq_masked_reserved3;       /* reserved           */
	unsigned int xlink3_tx_next  : BFW_NX51_io_link_irq_masked_xlink3_tx_next;  /* tx_next interrupt  */
	unsigned int xlink3_rx_next  : BFW_NX51_io_link_irq_masked_xlink3_rx_next;  /* rx_next interrupt  */
	unsigned int xlink3_shift_en : BFW_NX51_io_link_irq_masked_xlink3_shift_en; /* shift_en interrupt */
	unsigned int reserved4       : BFW_NX51_io_link_irq_masked_reserved4;       /* reserved           */
	unsigned int xlink4_tx_next  : BFW_NX51_io_link_irq_masked_xlink4_tx_next;  /* tx_next interrupt  */
	unsigned int xlink4_rx_next  : BFW_NX51_io_link_irq_masked_xlink4_rx_next;  /* rx_next interrupt  */
	unsigned int xlink4_shift_en : BFW_NX51_io_link_irq_masked_xlink4_shift_en; /* shift_en interrupt */
	unsigned int reserved5       : BFW_NX51_io_link_irq_masked_reserved5;       /* reserved           */
	unsigned int xlink5_tx_next  : BFW_NX51_io_link_irq_masked_xlink5_tx_next;  /* tx_next interrupt  */
	unsigned int xlink5_rx_next  : BFW_NX51_io_link_irq_masked_xlink5_rx_next;  /* rx_next interrupt  */
	unsigned int xlink5_shift_en : BFW_NX51_io_link_irq_masked_xlink5_shift_en; /* shift_en interrupt */
	unsigned int reserved6       : BFW_NX51_io_link_irq_masked_reserved6;       /* reserved           */
	unsigned int xlink6_tx_next  : BFW_NX51_io_link_irq_masked_xlink6_tx_next;  /* tx_next interrupt  */
	unsigned int xlink6_rx_next  : BFW_NX51_io_link_irq_masked_xlink6_rx_next;  /* rx_next interrupt  */
	unsigned int xlink6_shift_en : BFW_NX51_io_link_irq_masked_xlink6_shift_en; /* shift_en interrupt */
	unsigned int reserved7       : BFW_NX51_io_link_irq_masked_reserved7;       /* reserved           */
	unsigned int xlink7_tx_next  : BFW_NX51_io_link_irq_masked_xlink7_tx_next;  /* tx_next interrupt  */
	unsigned int xlink7_rx_next  : BFW_NX51_io_link_irq_masked_xlink7_rx_next;  /* rx_next interrupt  */
	unsigned int xlink7_shift_en : BFW_NX51_io_link_irq_masked_xlink7_shift_en; /* shift_en interrupt */
	unsigned int reserved8       : BFW_NX51_io_link_irq_masked_reserved8;       /* reserved           */
} NX51_IO_LINK_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_IO_LINK_IRQ_MASKED_BIT_T bf;
} NX51_IO_LINK_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register io_link_irq_msk_set */
/* => IO-Link interrupt mask enable: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to io_link_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_link_irq_msk_set         0x00000008U
#define Adr_NX51_io_link_irq_io_link_irq_msk_set 0x10140788U
#define Adr_NX51_io_link_irq_msk_set             0x10140788U
#define DFLT_VAL_NX51_io_link_irq_msk_set        0x00000000U

#define MSK_NX51_io_link_irq_msk_set_xlink0_tx_next          0x00000001U
#define SRT_NX51_io_link_irq_msk_set_xlink0_tx_next          0
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink0_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink0_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink0_rx_next          0x00000002U
#define SRT_NX51_io_link_irq_msk_set_xlink0_rx_next          1
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink0_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink0_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink0_shift_en         0x00000004U
#define SRT_NX51_io_link_irq_msk_set_xlink0_shift_en         2
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink0_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink0_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink1_tx_next          0x00000010U
#define SRT_NX51_io_link_irq_msk_set_xlink1_tx_next          4
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink1_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink1_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink1_rx_next          0x00000020U
#define SRT_NX51_io_link_irq_msk_set_xlink1_rx_next          5
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink1_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink1_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink1_shift_en         0x00000040U
#define SRT_NX51_io_link_irq_msk_set_xlink1_shift_en         6
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink1_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink1_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink2_tx_next          0x00000100U
#define SRT_NX51_io_link_irq_msk_set_xlink2_tx_next          8
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink2_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink2_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink2_rx_next          0x00000200U
#define SRT_NX51_io_link_irq_msk_set_xlink2_rx_next          9
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink2_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink2_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink2_shift_en         0x00000400U
#define SRT_NX51_io_link_irq_msk_set_xlink2_shift_en         10
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink2_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink2_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink3_tx_next          0x00001000U
#define SRT_NX51_io_link_irq_msk_set_xlink3_tx_next          12
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink3_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink3_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink3_rx_next          0x00002000U
#define SRT_NX51_io_link_irq_msk_set_xlink3_rx_next          13
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink3_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink3_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink3_shift_en         0x00004000U
#define SRT_NX51_io_link_irq_msk_set_xlink3_shift_en         14
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink3_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink3_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink4_tx_next          0x00010000U
#define SRT_NX51_io_link_irq_msk_set_xlink4_tx_next          16
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink4_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink4_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink4_rx_next          0x00020000U
#define SRT_NX51_io_link_irq_msk_set_xlink4_rx_next          17
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink4_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink4_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink4_shift_en         0x00040000U
#define SRT_NX51_io_link_irq_msk_set_xlink4_shift_en         18
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink4_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink4_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink5_tx_next          0x00100000U
#define SRT_NX51_io_link_irq_msk_set_xlink5_tx_next          20
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink5_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink5_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink5_rx_next          0x00200000U
#define SRT_NX51_io_link_irq_msk_set_xlink5_rx_next          21
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink5_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink5_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink5_shift_en         0x00400000U
#define SRT_NX51_io_link_irq_msk_set_xlink5_shift_en         22
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink5_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink5_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink6_tx_next          0x01000000U
#define SRT_NX51_io_link_irq_msk_set_xlink6_tx_next          24
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink6_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink6_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink6_rx_next          0x02000000U
#define SRT_NX51_io_link_irq_msk_set_xlink6_rx_next          25
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink6_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink6_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink6_shift_en         0x04000000U
#define SRT_NX51_io_link_irq_msk_set_xlink6_shift_en         26
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink6_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink6_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink7_tx_next          0x10000000U
#define SRT_NX51_io_link_irq_msk_set_xlink7_tx_next          28
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink7_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink7_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink7_rx_next          0x20000000U
#define SRT_NX51_io_link_irq_msk_set_xlink7_rx_next          29
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink7_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink7_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_set_xlink7_shift_en         0x40000000U
#define SRT_NX51_io_link_irq_msk_set_xlink7_shift_en         30
#define DFLT_VAL_NX51_io_link_irq_msk_set_xlink7_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_set_xlink7_shift_en 0x00000000U

/* all used bits of 'NX51_io_link_irq_msk_set': */
#define MSK_USED_BITS_NX51_io_link_irq_msk_set 0x77777777U

enum {
	BFW_NX51_io_link_irq_msk_set_xlink0_tx_next  = 1, /* [0] */
	BFW_NX51_io_link_irq_msk_set_xlink0_rx_next  = 1, /* [1] */
	BFW_NX51_io_link_irq_msk_set_xlink0_shift_en = 1, /* [2] */
	BFW_NX51_io_link_irq_msk_set_reserved1       = 1, /* [3] */
	BFW_NX51_io_link_irq_msk_set_xlink1_tx_next  = 1, /* [4] */
	BFW_NX51_io_link_irq_msk_set_xlink1_rx_next  = 1, /* [5] */
	BFW_NX51_io_link_irq_msk_set_xlink1_shift_en = 1, /* [6] */
	BFW_NX51_io_link_irq_msk_set_reserved2       = 1, /* [7] */
	BFW_NX51_io_link_irq_msk_set_xlink2_tx_next  = 1, /* [8] */
	BFW_NX51_io_link_irq_msk_set_xlink2_rx_next  = 1, /* [9] */
	BFW_NX51_io_link_irq_msk_set_xlink2_shift_en = 1, /* [10] */
	BFW_NX51_io_link_irq_msk_set_reserved3       = 1, /* [11] */
	BFW_NX51_io_link_irq_msk_set_xlink3_tx_next  = 1, /* [12] */
	BFW_NX51_io_link_irq_msk_set_xlink3_rx_next  = 1, /* [13] */
	BFW_NX51_io_link_irq_msk_set_xlink3_shift_en = 1, /* [14] */
	BFW_NX51_io_link_irq_msk_set_reserved4       = 1, /* [15] */
	BFW_NX51_io_link_irq_msk_set_xlink4_tx_next  = 1, /* [16] */
	BFW_NX51_io_link_irq_msk_set_xlink4_rx_next  = 1, /* [17] */
	BFW_NX51_io_link_irq_msk_set_xlink4_shift_en = 1, /* [18] */
	BFW_NX51_io_link_irq_msk_set_reserved5       = 1, /* [19] */
	BFW_NX51_io_link_irq_msk_set_xlink5_tx_next  = 1, /* [20] */
	BFW_NX51_io_link_irq_msk_set_xlink5_rx_next  = 1, /* [21] */
	BFW_NX51_io_link_irq_msk_set_xlink5_shift_en = 1, /* [22] */
	BFW_NX51_io_link_irq_msk_set_reserved6       = 1, /* [23] */
	BFW_NX51_io_link_irq_msk_set_xlink6_tx_next  = 1, /* [24] */
	BFW_NX51_io_link_irq_msk_set_xlink6_rx_next  = 1, /* [25] */
	BFW_NX51_io_link_irq_msk_set_xlink6_shift_en = 1, /* [26] */
	BFW_NX51_io_link_irq_msk_set_reserved7       = 1, /* [27] */
	BFW_NX51_io_link_irq_msk_set_xlink7_tx_next  = 1, /* [28] */
	BFW_NX51_io_link_irq_msk_set_xlink7_rx_next  = 1, /* [29] */
	BFW_NX51_io_link_irq_msk_set_xlink7_shift_en = 1, /* [30] */
	BFW_NX51_io_link_irq_msk_set_reserved8       = 1  /* [31] */
};

typedef struct NX51_IO_LINK_IRQ_MSK_SET_BIT_Ttag {
	unsigned int xlink0_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink0_tx_next;  /* tx_next interrupt  */
	unsigned int xlink0_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink0_rx_next;  /* rx_next interrupt  */
	unsigned int xlink0_shift_en : BFW_NX51_io_link_irq_msk_set_xlink0_shift_en; /* shift_en interrupt */
	unsigned int reserved1       : BFW_NX51_io_link_irq_msk_set_reserved1;       /* reserved           */
	unsigned int xlink1_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink1_tx_next;  /* tx_next interrupt  */
	unsigned int xlink1_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink1_rx_next;  /* rx_next interrupt  */
	unsigned int xlink1_shift_en : BFW_NX51_io_link_irq_msk_set_xlink1_shift_en; /* shift_en interrupt */
	unsigned int reserved2       : BFW_NX51_io_link_irq_msk_set_reserved2;       /* reserved           */
	unsigned int xlink2_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink2_tx_next;  /* tx_next interrupt  */
	unsigned int xlink2_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink2_rx_next;  /* rx_next interrupt  */
	unsigned int xlink2_shift_en : BFW_NX51_io_link_irq_msk_set_xlink2_shift_en; /* shift_en interrupt */
	unsigned int reserved3       : BFW_NX51_io_link_irq_msk_set_reserved3;       /* reserved           */
	unsigned int xlink3_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink3_tx_next;  /* tx_next interrupt  */
	unsigned int xlink3_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink3_rx_next;  /* rx_next interrupt  */
	unsigned int xlink3_shift_en : BFW_NX51_io_link_irq_msk_set_xlink3_shift_en; /* shift_en interrupt */
	unsigned int reserved4       : BFW_NX51_io_link_irq_msk_set_reserved4;       /* reserved           */
	unsigned int xlink4_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink4_tx_next;  /* tx_next interrupt  */
	unsigned int xlink4_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink4_rx_next;  /* rx_next interrupt  */
	unsigned int xlink4_shift_en : BFW_NX51_io_link_irq_msk_set_xlink4_shift_en; /* shift_en interrupt */
	unsigned int reserved5       : BFW_NX51_io_link_irq_msk_set_reserved5;       /* reserved           */
	unsigned int xlink5_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink5_tx_next;  /* tx_next interrupt  */
	unsigned int xlink5_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink5_rx_next;  /* rx_next interrupt  */
	unsigned int xlink5_shift_en : BFW_NX51_io_link_irq_msk_set_xlink5_shift_en; /* shift_en interrupt */
	unsigned int reserved6       : BFW_NX51_io_link_irq_msk_set_reserved6;       /* reserved           */
	unsigned int xlink6_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink6_tx_next;  /* tx_next interrupt  */
	unsigned int xlink6_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink6_rx_next;  /* rx_next interrupt  */
	unsigned int xlink6_shift_en : BFW_NX51_io_link_irq_msk_set_xlink6_shift_en; /* shift_en interrupt */
	unsigned int reserved7       : BFW_NX51_io_link_irq_msk_set_reserved7;       /* reserved           */
	unsigned int xlink7_tx_next  : BFW_NX51_io_link_irq_msk_set_xlink7_tx_next;  /* tx_next interrupt  */
	unsigned int xlink7_rx_next  : BFW_NX51_io_link_irq_msk_set_xlink7_rx_next;  /* rx_next interrupt  */
	unsigned int xlink7_shift_en : BFW_NX51_io_link_irq_msk_set_xlink7_shift_en; /* shift_en interrupt */
	unsigned int reserved8       : BFW_NX51_io_link_irq_msk_set_reserved8;       /* reserved           */
} NX51_IO_LINK_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_IO_LINK_IRQ_MSK_SET_BIT_T bf;
} NX51_IO_LINK_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register io_link_irq_msk_reset */
/* => IO-Link interrupt mask disable: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_link_irq_msk_reset         0x0000000CU
#define Adr_NX51_io_link_irq_io_link_irq_msk_reset 0x1014078CU
#define Adr_NX51_io_link_irq_msk_reset             0x1014078CU
#define DFLT_VAL_NX51_io_link_irq_msk_reset        0x00000000U

#define MSK_NX51_io_link_irq_msk_reset_xlink0_tx_next          0x00000001U
#define SRT_NX51_io_link_irq_msk_reset_xlink0_tx_next          0
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink0_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink0_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink0_rx_next          0x00000002U
#define SRT_NX51_io_link_irq_msk_reset_xlink0_rx_next          1
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink0_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink0_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink0_shift_en         0x00000004U
#define SRT_NX51_io_link_irq_msk_reset_xlink0_shift_en         2
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink0_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink0_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink1_tx_next          0x00000010U
#define SRT_NX51_io_link_irq_msk_reset_xlink1_tx_next          4
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink1_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink1_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink1_rx_next          0x00000020U
#define SRT_NX51_io_link_irq_msk_reset_xlink1_rx_next          5
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink1_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink1_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink1_shift_en         0x00000040U
#define SRT_NX51_io_link_irq_msk_reset_xlink1_shift_en         6
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink1_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink1_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink2_tx_next          0x00000100U
#define SRT_NX51_io_link_irq_msk_reset_xlink2_tx_next          8
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink2_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink2_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink2_rx_next          0x00000200U
#define SRT_NX51_io_link_irq_msk_reset_xlink2_rx_next          9
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink2_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink2_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink2_shift_en         0x00000400U
#define SRT_NX51_io_link_irq_msk_reset_xlink2_shift_en         10
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink2_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink2_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink3_tx_next          0x00001000U
#define SRT_NX51_io_link_irq_msk_reset_xlink3_tx_next          12
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink3_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink3_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink3_rx_next          0x00002000U
#define SRT_NX51_io_link_irq_msk_reset_xlink3_rx_next          13
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink3_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink3_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink3_shift_en         0x00004000U
#define SRT_NX51_io_link_irq_msk_reset_xlink3_shift_en         14
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink3_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink3_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink4_tx_next          0x00010000U
#define SRT_NX51_io_link_irq_msk_reset_xlink4_tx_next          16
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink4_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink4_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink4_rx_next          0x00020000U
#define SRT_NX51_io_link_irq_msk_reset_xlink4_rx_next          17
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink4_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink4_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink4_shift_en         0x00040000U
#define SRT_NX51_io_link_irq_msk_reset_xlink4_shift_en         18
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink4_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink4_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink5_tx_next          0x00100000U
#define SRT_NX51_io_link_irq_msk_reset_xlink5_tx_next          20
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink5_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink5_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink5_rx_next          0x00200000U
#define SRT_NX51_io_link_irq_msk_reset_xlink5_rx_next          21
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink5_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink5_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink5_shift_en         0x00400000U
#define SRT_NX51_io_link_irq_msk_reset_xlink5_shift_en         22
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink5_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink5_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink6_tx_next          0x01000000U
#define SRT_NX51_io_link_irq_msk_reset_xlink6_tx_next          24
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink6_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink6_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink6_rx_next          0x02000000U
#define SRT_NX51_io_link_irq_msk_reset_xlink6_rx_next          25
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink6_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink6_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink6_shift_en         0x04000000U
#define SRT_NX51_io_link_irq_msk_reset_xlink6_shift_en         26
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink6_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink6_shift_en 0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink7_tx_next          0x10000000U
#define SRT_NX51_io_link_irq_msk_reset_xlink7_tx_next          28
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink7_tx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink7_tx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink7_rx_next          0x20000000U
#define SRT_NX51_io_link_irq_msk_reset_xlink7_rx_next          29
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink7_rx_next     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink7_rx_next  0x00000000U
#define MSK_NX51_io_link_irq_msk_reset_xlink7_shift_en         0x40000000U
#define SRT_NX51_io_link_irq_msk_reset_xlink7_shift_en         30
#define DFLT_VAL_NX51_io_link_irq_msk_reset_xlink7_shift_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_msk_reset_xlink7_shift_en 0x00000000U

/* all used bits of 'NX51_io_link_irq_msk_reset': */
#define MSK_USED_BITS_NX51_io_link_irq_msk_reset 0x77777777U

enum {
	BFW_NX51_io_link_irq_msk_reset_xlink0_tx_next  = 1, /* [0] */
	BFW_NX51_io_link_irq_msk_reset_xlink0_rx_next  = 1, /* [1] */
	BFW_NX51_io_link_irq_msk_reset_xlink0_shift_en = 1, /* [2] */
	BFW_NX51_io_link_irq_msk_reset_reserved1       = 1, /* [3] */
	BFW_NX51_io_link_irq_msk_reset_xlink1_tx_next  = 1, /* [4] */
	BFW_NX51_io_link_irq_msk_reset_xlink1_rx_next  = 1, /* [5] */
	BFW_NX51_io_link_irq_msk_reset_xlink1_shift_en = 1, /* [6] */
	BFW_NX51_io_link_irq_msk_reset_reserved2       = 1, /* [7] */
	BFW_NX51_io_link_irq_msk_reset_xlink2_tx_next  = 1, /* [8] */
	BFW_NX51_io_link_irq_msk_reset_xlink2_rx_next  = 1, /* [9] */
	BFW_NX51_io_link_irq_msk_reset_xlink2_shift_en = 1, /* [10] */
	BFW_NX51_io_link_irq_msk_reset_reserved3       = 1, /* [11] */
	BFW_NX51_io_link_irq_msk_reset_xlink3_tx_next  = 1, /* [12] */
	BFW_NX51_io_link_irq_msk_reset_xlink3_rx_next  = 1, /* [13] */
	BFW_NX51_io_link_irq_msk_reset_xlink3_shift_en = 1, /* [14] */
	BFW_NX51_io_link_irq_msk_reset_reserved4       = 1, /* [15] */
	BFW_NX51_io_link_irq_msk_reset_xlink4_tx_next  = 1, /* [16] */
	BFW_NX51_io_link_irq_msk_reset_xlink4_rx_next  = 1, /* [17] */
	BFW_NX51_io_link_irq_msk_reset_xlink4_shift_en = 1, /* [18] */
	BFW_NX51_io_link_irq_msk_reset_reserved5       = 1, /* [19] */
	BFW_NX51_io_link_irq_msk_reset_xlink5_tx_next  = 1, /* [20] */
	BFW_NX51_io_link_irq_msk_reset_xlink5_rx_next  = 1, /* [21] */
	BFW_NX51_io_link_irq_msk_reset_xlink5_shift_en = 1, /* [22] */
	BFW_NX51_io_link_irq_msk_reset_reserved6       = 1, /* [23] */
	BFW_NX51_io_link_irq_msk_reset_xlink6_tx_next  = 1, /* [24] */
	BFW_NX51_io_link_irq_msk_reset_xlink6_rx_next  = 1, /* [25] */
	BFW_NX51_io_link_irq_msk_reset_xlink6_shift_en = 1, /* [26] */
	BFW_NX51_io_link_irq_msk_reset_reserved7       = 1, /* [27] */
	BFW_NX51_io_link_irq_msk_reset_xlink7_tx_next  = 1, /* [28] */
	BFW_NX51_io_link_irq_msk_reset_xlink7_rx_next  = 1, /* [29] */
	BFW_NX51_io_link_irq_msk_reset_xlink7_shift_en = 1, /* [30] */
	BFW_NX51_io_link_irq_msk_reset_reserved8       = 1  /* [31] */
};

typedef struct NX51_IO_LINK_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int xlink0_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink0_tx_next;  /* tx_next interrupt  */
	unsigned int xlink0_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink0_rx_next;  /* rx_next interrupt  */
	unsigned int xlink0_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink0_shift_en; /* shift_en interrupt */
	unsigned int reserved1       : BFW_NX51_io_link_irq_msk_reset_reserved1;       /* reserved           */
	unsigned int xlink1_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink1_tx_next;  /* tx_next interrupt  */
	unsigned int xlink1_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink1_rx_next;  /* rx_next interrupt  */
	unsigned int xlink1_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink1_shift_en; /* shift_en interrupt */
	unsigned int reserved2       : BFW_NX51_io_link_irq_msk_reset_reserved2;       /* reserved           */
	unsigned int xlink2_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink2_tx_next;  /* tx_next interrupt  */
	unsigned int xlink2_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink2_rx_next;  /* rx_next interrupt  */
	unsigned int xlink2_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink2_shift_en; /* shift_en interrupt */
	unsigned int reserved3       : BFW_NX51_io_link_irq_msk_reset_reserved3;       /* reserved           */
	unsigned int xlink3_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink3_tx_next;  /* tx_next interrupt  */
	unsigned int xlink3_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink3_rx_next;  /* rx_next interrupt  */
	unsigned int xlink3_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink3_shift_en; /* shift_en interrupt */
	unsigned int reserved4       : BFW_NX51_io_link_irq_msk_reset_reserved4;       /* reserved           */
	unsigned int xlink4_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink4_tx_next;  /* tx_next interrupt  */
	unsigned int xlink4_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink4_rx_next;  /* rx_next interrupt  */
	unsigned int xlink4_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink4_shift_en; /* shift_en interrupt */
	unsigned int reserved5       : BFW_NX51_io_link_irq_msk_reset_reserved5;       /* reserved           */
	unsigned int xlink5_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink5_tx_next;  /* tx_next interrupt  */
	unsigned int xlink5_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink5_rx_next;  /* rx_next interrupt  */
	unsigned int xlink5_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink5_shift_en; /* shift_en interrupt */
	unsigned int reserved6       : BFW_NX51_io_link_irq_msk_reset_reserved6;       /* reserved           */
	unsigned int xlink6_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink6_tx_next;  /* tx_next interrupt  */
	unsigned int xlink6_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink6_rx_next;  /* rx_next interrupt  */
	unsigned int xlink6_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink6_shift_en; /* shift_en interrupt */
	unsigned int reserved7       : BFW_NX51_io_link_irq_msk_reset_reserved7;       /* reserved           */
	unsigned int xlink7_tx_next  : BFW_NX51_io_link_irq_msk_reset_xlink7_tx_next;  /* tx_next interrupt  */
	unsigned int xlink7_rx_next  : BFW_NX51_io_link_irq_msk_reset_xlink7_rx_next;  /* rx_next interrupt  */
	unsigned int xlink7_shift_en : BFW_NX51_io_link_irq_msk_reset_xlink7_shift_en; /* shift_en interrupt */
	unsigned int reserved8       : BFW_NX51_io_link_irq_msk_reset_reserved8;       /* reserved           */
} NX51_IO_LINK_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_IO_LINK_IRQ_MSK_RESET_BIT_T bf;
} NX51_IO_LINK_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register io_link_irq_enable */
/* => IO-Link processor enable: */
/*    Enable all irqs for xpic and/or arm */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_link_irq_enable         0x00000010U
#define Adr_NX51_io_link_irq_io_link_irq_enable 0x10140790U
#define Adr_NX51_io_link_irq_enable             0x10140790U
#define DFLT_VAL_NX51_io_link_irq_enable        0x00000002U

#define MSK_NX51_io_link_irq_enable_arm_en          0x00000001U
#define SRT_NX51_io_link_irq_enable_arm_en          0
#define DFLT_VAL_NX51_io_link_irq_enable_arm_en     0x00000000U
#define DFLT_BF_VAL_NX51_io_link_irq_enable_arm_en  0x00000000U
#define MSK_NX51_io_link_irq_enable_xpic_en         0x00000002U
#define SRT_NX51_io_link_irq_enable_xpic_en         1
#define DFLT_VAL_NX51_io_link_irq_enable_xpic_en    0x00000002U
#define DFLT_BF_VAL_NX51_io_link_irq_enable_xpic_en 0x00000001U

/* all used bits of 'NX51_io_link_irq_enable': */
#define MSK_USED_BITS_NX51_io_link_irq_enable 0x00000003U

enum {
	BFW_NX51_io_link_irq_enable_arm_en    = 1,  /* [0] */
	BFW_NX51_io_link_irq_enable_xpic_en   = 1,  /* [1] */
	BFW_NX51_io_link_irq_enable_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_IO_LINK_IRQ_ENABLE_BIT_Ttag {
	unsigned int arm_en    : BFW_NX51_io_link_irq_enable_arm_en;    /* enable interrupts to ARM  */
	unsigned int xpic_en   : BFW_NX51_io_link_irq_enable_xpic_en;   /* enable interrupts to xPIC */
	unsigned int reserved1 : BFW_NX51_io_link_irq_enable_reserved1; /* reserved                  */
} NX51_IO_LINK_IRQ_ENABLE_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_IO_LINK_IRQ_ENABLE_BIT_T bf;
} NX51_IO_LINK_IRQ_ENABLE_T;


/* ===================================================================== */

/* AREA spi */
/* Area of spi_motion */

/* ===================================================================== */

#define Addr_NX51_spi_motion 0x10140800U
#define NX51_NETX_SPI1_AREA  0x10140800U

/* --------------------------------------------------------------------- */
/* Register spi_cr0 */
/* => spi control register 0 */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_cr0        0x00000000U
#define Adr_NX51_spi_motion_spi_cr0 0x10140800U
#define Adr_NX51_spi_cr0            0x10140800U
#define DFLT_VAL_NX51_spi_cr0       0x80080007U

#define MSK_NX51_spi_cr0_datasize                0x0000000fU
#define SRT_NX51_spi_cr0_datasize                0
#define DFLT_VAL_NX51_spi_cr0_datasize           0x00000007U
#define DFLT_BF_VAL_NX51_spi_cr0_datasize        0x00000007U
#define MSK_NX51_spi_cr0_SPO                     0x00000040U
#define SRT_NX51_spi_cr0_SPO                     6
#define DFLT_VAL_NX51_spi_cr0_SPO                0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr0_SPO             0x00000000U
#define MSK_NX51_spi_cr0_SPH                     0x00000080U
#define SRT_NX51_spi_cr0_SPH                     7
#define DFLT_VAL_NX51_spi_cr0_SPH                0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr0_SPH             0x00000000U
#define MSK_NX51_spi_cr0_sck_muladd              0x000fff00U
#define SRT_NX51_spi_cr0_sck_muladd              8
#define DFLT_VAL_NX51_spi_cr0_sck_muladd         0x00080000U
#define DFLT_BF_VAL_NX51_spi_cr0_sck_muladd      0x00000800U
#define MSK_NX51_spi_cr0_format                  0x03000000U
#define SRT_NX51_spi_cr0_format                  24
#define DFLT_VAL_NX51_spi_cr0_format             0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr0_format          0x00000000U
#define MSK_NX51_spi_cr0_filter_in               0x08000000U
#define SRT_NX51_spi_cr0_filter_in               27
#define DFLT_VAL_NX51_spi_cr0_filter_in          0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr0_filter_in       0x00000000U
#define MSK_NX51_spi_cr0_slave_sig_early         0x10000000U
#define SRT_NX51_spi_cr0_slave_sig_early         28
#define DFLT_VAL_NX51_spi_cr0_slave_sig_early    0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr0_slave_sig_early 0x00000000U
#define MSK_NX51_spi_cr0_netx100_comp            0x80000000U
#define SRT_NX51_spi_cr0_netx100_comp            31
#define DFLT_VAL_NX51_spi_cr0_netx100_comp       0x80000000U
#define DFLT_BF_VAL_NX51_spi_cr0_netx100_comp    0x00000001U

/* all used bits of 'NX51_spi_cr0': */
#define MSK_USED_BITS_NX51_spi_cr0 0x9b0fffcfU

enum {
	BFW_NX51_spi_cr0_datasize        = 4,  /* [3:0] */
	BFW_NX51_spi_cr0_reserved1       = 2,  /* [5:4] */
	BFW_NX51_spi_cr0_SPO             = 1,  /* [6] */
	BFW_NX51_spi_cr0_SPH             = 1,  /* [7] */
	BFW_NX51_spi_cr0_sck_muladd      = 12, /* [19:8] */
	BFW_NX51_spi_cr0_reserved2       = 4,  /* [23:20] */
	BFW_NX51_spi_cr0_format          = 2,  /* [25:24] */
	BFW_NX51_spi_cr0_reserved3       = 1,  /* [26] */
	BFW_NX51_spi_cr0_filter_in       = 1,  /* [27] */
	BFW_NX51_spi_cr0_slave_sig_early = 1,  /* [28] */
	BFW_NX51_spi_cr0_reserved4       = 2,  /* [30:29] */
	BFW_NX51_spi_cr0_netx100_comp    = 1   /* [31] */
};

typedef struct NX51_SPI_CR0_BIT_Ttag {
	unsigned int datasize        : BFW_NX51_spi_cr0_datasize;        /* DSS: data size select (transfer size = datasize + 1 bits)                                                          */
	                                                                 /* 0000...0010: reserved                                                                                              */
	                                                                 /* 0011:  4 bit                                                                                                       */
	                                                                 /* 0100:  5 bit                                                                                                       */
	                                                                 /* ...                                                                                                                */
	                                                                 /* 0111:  8 bit                                                                                                       */
	                                                                 /* ...                                                                                                                */
	                                                                 /* 1111: 16 bit                                                                                                       */
	                                                                 /* Note:                                                                                                              */
	                                                                 /*    16 bit TX-data-loss bug of netX50/netX5 is fixed since netX10.                                                  */
	unsigned int reserved1       : BFW_NX51_spi_cr0_reserved1;       /* reserved                                                                                                           */
	unsigned int SPO             : BFW_NX51_spi_cr0_SPO;             /* serial clock polarity (netx500: CR_cpol)                                                                           */
	                                                                 /* 0: idle: clock is low, first edge is rising                                                                        */
	                                                                 /* 1: idle: clock is high, first edge is falling                                                                      */
	unsigned int SPH             : BFW_NX51_spi_cr0_SPH;             /* serial clock phase (netx500: CR_ncpha)                                                                             */
	                                                                 /* 1: sample data at second clock edge edge, data is generated half a clock phase before sampling                     */
	                                                                 /* 0: sample data at first clock edge edge, data is generated half a clock phase before sampling                      */
	unsigned int sck_muladd      : BFW_NX51_spi_cr0_sck_muladd;      /* Serial clock rate multiply add value for master spi_sck generation.                                                */
	                                                                 /* spi_sck-frequency: f_spi_sck = (sck_muladd * 100)/4096 [MHz].                                                      */
	                                                                 /* Default value 0x800 equals 50MHz SPI clock rate.                                                                   */
	                                                                 /* All serial clock rates are derived from 100MHz netX system clock. Hence all serial clock phases are multiples      */
	                                                                 /* of 10ns. That leads to non-constant serial clock phases when a clock rate is programmed which can not generated    */
	                                                                 /* by 100MHz/(2*n) without remainder. E.g. programming 0x4CC here will lead to a mean clock-rate of 30MHz however     */
	                                                                 /* single clock high and low phase of 10ns and clock periods of 30ns will occur. This must be considered for          */
	                                                                 /* serial device selection. E.g. using a 30MHz device which requires 33ns minimum clock period and a duty cycle       */
	                                                                 /* of 50% will fail.                                                                                                  */
	                                                                 /* Note. If sck_muladd is set to zero, SPI transfer will freeze.                                                      */
	                                                                 /* in slave-mode SPI-clock must not exceed (system-frequency/4) if correct data sampling should be always guaranteed. */
	unsigned int reserved2       : BFW_NX51_spi_cr0_reserved2;       /* reserved                                                                                                           */
	unsigned int format          : BFW_NX51_spi_cr0_format;          /* frame format                                                                                                       */
	                                                                 /* 00: Motorola SPI frame format                                                                                      */
	                                                                 /* 01..11: reserved                                                                                                   */
	unsigned int reserved3       : BFW_NX51_spi_cr0_reserved3;       /* reserved                                                                                                           */
	unsigned int filter_in       : BFW_NX51_spi_cr0_filter_in;       /* Receive-data is sampled every 10ns (100MHz system clock). If this bit is set, the                                  */
	                                                                 /* stored receive value will be the result of a majority decision of the three sampling points                        */
	                                                                 /* around a SPI-clock edge (if two or more '1s! were sampled a '1' will be stored, else a '0' will                    */
	                                                                 /* be stored. In slave mode FSS and SPI-clock edges will also be detected by oversampling if this bit is set:         */
	                                                                 /* An edge will be detected if the majority-result of thre subsequent sampled values toggles.                         */
	                                                                 /* Input filtering should be used for sck_muladd<=0x200 (i.e. below 12.5MHz). For higher frequencies                  */
	                                                                 /* stable signal phases are too short.                                                                                */
	unsigned int slave_sig_early : BFW_NX51_spi_cr0_slave_sig_early; /* Generate MISO in slavemode 1 spi_sck clock edge earlier than Spec-defined.                                         */
	                                                                 /* This is to compensate Pad/sampling-delays on fast data rates.                                                      */
	                                                                 /* If filter_in is enabled, it takes in worst case 3 system clocks to generate MISO after SCK.                        */
	                                                                 /* If filter_in is disabled, it takes in worst case 2 system clocks to generate MISO after SCK.                       */
	unsigned int reserved4       : BFW_NX51_spi_cr0_reserved4;       /* reserved                                                                                                           */
	unsigned int netx100_comp    : BFW_NX51_spi_cr0_netx100_comp;    /* use netx100/500-compatible SPI mode:                                                                               */
	                                                                 /* 0: start transfer after writing data                                                                               */
	                                                                 /* 1: start transfer after setting CR_write or CR_read                                                                */
} NX51_SPI_CR0_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SPI_CR0_BIT_T bf;
} NX51_SPI_CR0_T;

/* --------------------------------------------------------------------- */
/* Register spi_cr1 */
/* => spi control register 0 */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_cr1        0x00000004U
#define Adr_NX51_spi_motion_spi_cr1 0x10140804U
#define Adr_NX51_spi_cr1            0x10140804U
#define DFLT_VAL_NX51_spi_cr1       0x08080000U

#define MSK_NX51_spi_cr1_LBM                 0x00000001U
#define SRT_NX51_spi_cr1_LBM                 0
#define DFLT_VAL_NX51_spi_cr1_LBM            0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_LBM         0x00000000U
#define MSK_NX51_spi_cr1_SSE                 0x00000002U
#define SRT_NX51_spi_cr1_SSE                 1
#define DFLT_VAL_NX51_spi_cr1_SSE            0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_SSE         0x00000000U
#define MSK_NX51_spi_cr1_MS                  0x00000004U
#define SRT_NX51_spi_cr1_MS                  2
#define DFLT_VAL_NX51_spi_cr1_MS             0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_MS          0x00000000U
#define MSK_NX51_spi_cr1_SOD                 0x00000008U
#define SRT_NX51_spi_cr1_SOD                 3
#define DFLT_VAL_NX51_spi_cr1_SOD            0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_SOD         0x00000000U
#define MSK_NX51_spi_cr1_fss                 0x00000700U
#define SRT_NX51_spi_cr1_fss                 8
#define DFLT_VAL_NX51_spi_cr1_fss            0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_fss         0x00000000U
#define MSK_NX51_spi_cr1_fss_static          0x00000800U
#define SRT_NX51_spi_cr1_fss_static          11
#define DFLT_VAL_NX51_spi_cr1_fss_static     0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_fss_static  0x00000000U
#define MSK_NX51_spi_cr1_tx_fifo_wm          0x000f0000U
#define SRT_NX51_spi_cr1_tx_fifo_wm          16
#define DFLT_VAL_NX51_spi_cr1_tx_fifo_wm     0x00080000U
#define DFLT_BF_VAL_NX51_spi_cr1_tx_fifo_wm  0x00000008U
#define MSK_NX51_spi_cr1_tx_fifo_clr         0x00100000U
#define SRT_NX51_spi_cr1_tx_fifo_clr         20
#define DFLT_VAL_NX51_spi_cr1_tx_fifo_clr    0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_tx_fifo_clr 0x00000000U
#define MSK_NX51_spi_cr1_rx_fifo_wm          0x0f000000U
#define SRT_NX51_spi_cr1_rx_fifo_wm          24
#define DFLT_VAL_NX51_spi_cr1_rx_fifo_wm     0x08000000U
#define DFLT_BF_VAL_NX51_spi_cr1_rx_fifo_wm  0x00000008U
#define MSK_NX51_spi_cr1_rx_fifo_clr         0x10000000U
#define SRT_NX51_spi_cr1_rx_fifo_clr         28
#define DFLT_VAL_NX51_spi_cr1_rx_fifo_clr    0x00000000U
#define DFLT_BF_VAL_NX51_spi_cr1_rx_fifo_clr 0x00000000U

/* all used bits of 'NX51_spi_cr1': */
#define MSK_USED_BITS_NX51_spi_cr1 0x1f1f0f0fU

enum {
	BFW_NX51_spi_cr1_LBM         = 1, /* [0] */
	BFW_NX51_spi_cr1_SSE         = 1, /* [1] */
	BFW_NX51_spi_cr1_MS          = 1, /* [2] */
	BFW_NX51_spi_cr1_SOD         = 1, /* [3] */
	BFW_NX51_spi_cr1_reserved1   = 4, /* [7:4] */
	BFW_NX51_spi_cr1_fss         = 3, /* [10:8] */
	BFW_NX51_spi_cr1_fss_static  = 1, /* [11] */
	BFW_NX51_spi_cr1_reserved2   = 4, /* [15:12] */
	BFW_NX51_spi_cr1_tx_fifo_wm  = 4, /* [19:16] */
	BFW_NX51_spi_cr1_tx_fifo_clr = 1, /* [20] */
	BFW_NX51_spi_cr1_reserved3   = 3, /* [23:21] */
	BFW_NX51_spi_cr1_rx_fifo_wm  = 4, /* [27:24] */
	BFW_NX51_spi_cr1_rx_fifo_clr = 1, /* [28] */
	BFW_NX51_spi_cr1_reserved4   = 3  /* [31:29] */
};

typedef struct NX51_SPI_CR1_BIT_Ttag {
	unsigned int LBM         : BFW_NX51_spi_cr1_LBM;         /* loop back mode                                                                                            */
	                                                         /* 0: internal loop back disabled                                                                            */
	                                                         /* 1: internal loop back enabled, spi_cr0.filter_in must be set for loopback function                        */
	unsigned int SSE         : BFW_NX51_spi_cr1_SSE;         /* SPI enable.                                                                                               */
	                                                         /* 0: interface disabled                                                                                     */
	                                                         /* 1: interface enabled                                                                                      */
	unsigned int MS          : BFW_NX51_spi_cr1_MS;          /* mode select:                                                                                              */
	                                                         /* 0: device is configured as master                                                                         */
	                                                         /* 1: device is configured as slave                                                                          */
	unsigned int SOD         : BFW_NX51_spi_cr1_SOD;         /* slave mode output disable (to connect multibe slaves to opne master)                                      */
	                                                         /* 0: SPI-MISO can be driven in slave mode                                                                   */
	                                                         /* 1: SPI-MISO is not driven in slave mode                                                                   */
	unsigned int reserved1   : BFW_NX51_spi_cr1_reserved1;   /* reserved                                                                                                  */
	unsigned int fss         : BFW_NX51_spi_cr1_fss;         /* extended: Frame or slave select (up to 3 devices can be assigned directly,                                */
	                                                         /* up to 8 devices can be assigned if an external demultiplexer is used if device is master.                 */
	                                                         /* For active low slave select (e.g. Motorola SPI frame format) the bits will be inverted before output.     */
	                                                         /* If device is slave, the programmed value is a mask to selet which slave-fss-input should be considered.   */
	                                                         /* e.g.: "010" : fss[1] is slave frame or select input.                                                      */
	unsigned int fss_static  : BFW_NX51_spi_cr1_fss_static;  /* SPI static chipselect                                                                                     */
	                                                         /* 0: SPI-chipselect will be toggled automatically at data frame begin/end according to fss and FRF0         */
	                                                         /* 1: SPI-chipselect will be set statically according to fss and FRF0                                        */
	                                                         /* If fss is set to statically, fss must be toggled manually after each data frame in Motorola SPI mode when */
	                                                         /* SPH is 0 for spec compatibility!                                                                          */
	unsigned int reserved2   : BFW_NX51_spi_cr1_reserved2;   /* reserved                                                                                                  */
	unsigned int tx_fifo_wm  : BFW_NX51_spi_cr1_tx_fifo_wm;  /* transmit FIFO watermark for IRQ-generation                                                                */
	unsigned int tx_fifo_clr : BFW_NX51_spi_cr1_tx_fifo_clr; /* extended: writing "1" to this bit will clear the transmit-FIFOs                                           */
	                                                         /* There must be at least 1 system-clock idle after clear before writing new data to the FIFO.               */
	unsigned int reserved3   : BFW_NX51_spi_cr1_reserved3;   /* reserved                                                                                                  */
	unsigned int rx_fifo_wm  : BFW_NX51_spi_cr1_rx_fifo_wm;  /* receive FIFO watermark for IRQ-generation                                                                 */
	unsigned int rx_fifo_clr : BFW_NX51_spi_cr1_rx_fifo_clr; /* extended: writing "1" to this bit will clear the receive-FIFOs                                            */
	unsigned int reserved4   : BFW_NX51_spi_cr1_reserved4;   /* reserved                                                                                                  */
} NX51_SPI_CR1_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SPI_CR1_BIT_T bf;
} NX51_SPI_CR1_T;

/* --------------------------------------------------------------------- */
/* Register spi_dr */
/* => spi data register (DR) */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    read access: received data byte is delivered from receive FIFO */
/*    write access: send data byte is written to send FIFO */
/*    Both, receive and transmit FIFO have a depth of 16. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_dr        0x00000008U
#define Adr_NX51_spi_motion_spi_dr 0x10140808U
#define Adr_NX51_spi_dr            0x10140808U
#define DFLT_VAL_NX51_spi_dr       0x00000000U

#define MSK_NX51_spi_dr_data         0x0001ffffU
#define SRT_NX51_spi_dr_data         0
#define DFLT_VAL_NX51_spi_dr_data    0x00000000U
#define DFLT_BF_VAL_NX51_spi_dr_data 0x00000000U

/* all used bits of 'NX51_spi_dr': */
#define MSK_USED_BITS_NX51_spi_dr 0x0001ffffU

enum {
	BFW_NX51_spi_dr_data      = 17, /* [16:0] */
	BFW_NX51_spi_dr_reserved1 = 15  /* [31:17] */
};

typedef struct NX51_SPI_DR_BIT_Ttag {
	unsigned int data      : BFW_NX51_spi_dr_data;      /* Transmit data, must be right aligned on writing, only bits according to spi_cr0.DSS are considered                    */
	                                                    /* Receive data will be delivered right aligned, unused bits (spi_cr0.DSS < 0xF) will be "0".                            */
	                                                    /* In slavemode transmit data is requested from the FIFO when the last bit of the current                                */
	                                                    /* transfer-word ist set to spi_miso.                                                                                    */
	                                                    /* If no next transimt data could be read from the FIFO until current words last bit was transfered,                     */
	                                                    /* FIFO underrun will occure if FSS does not go inactive (last word was transfer end) at the next detected spi_sck-edge. */
	unsigned int reserved1 : BFW_NX51_spi_dr_reserved1; /* reserved                                                                                                              */
} NX51_SPI_DR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SPI_DR_BIT_T bf;
} NX51_SPI_DR_T;

/* --------------------------------------------------------------------- */
/* Register spi_sr */
/* => read only spi status register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    SPI master mode: MISO-input-data will be stored in the receive FIFO, transmit FIFO generates MOSI-output-data */
/*    SPI slave mode: MOSI-input-data will be stored in the receive FIFO, transmit FIFO generates MISO-output-data */
/*    Shows the current status of the spi interface. */
/*    Both, receive and transmit FIFO have a depth of 16. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_sr        0x0000000CU
#define Adr_NX51_spi_motion_spi_sr 0x1014080CU
#define Adr_NX51_spi_sr            0x1014080CU

#define MSK_NX51_spi_sr_TFE              0x00000001U
#define SRT_NX51_spi_sr_TFE              0
#define MSK_NX51_spi_sr_TNF              0x00000002U
#define SRT_NX51_spi_sr_TNF              1
#define MSK_NX51_spi_sr_RNE              0x00000004U
#define SRT_NX51_spi_sr_RNE              2
#define MSK_NX51_spi_sr_RFF              0x00000008U
#define SRT_NX51_spi_sr_RFF              3
#define MSK_NX51_spi_sr_BSY              0x00000010U
#define SRT_NX51_spi_sr_BSY              4
#define MSK_NX51_spi_sr_tx_fifo_level    0x001f0000U
#define SRT_NX51_spi_sr_tx_fifo_level    16
#define MSK_NX51_spi_sr_tx_fifo_err_ovfl 0x00400000U
#define SRT_NX51_spi_sr_tx_fifo_err_ovfl 22
#define MSK_NX51_spi_sr_tx_fifo_err_undr 0x00800000U
#define SRT_NX51_spi_sr_tx_fifo_err_undr 23
#define MSK_NX51_spi_sr_rx_fifo_level    0x1f000000U
#define SRT_NX51_spi_sr_rx_fifo_level    24
#define MSK_NX51_spi_sr_rx_fifo_err_ovfl 0x40000000U
#define SRT_NX51_spi_sr_rx_fifo_err_ovfl 30
#define MSK_NX51_spi_sr_rx_fifo_err_undr 0x80000000U
#define SRT_NX51_spi_sr_rx_fifo_err_undr 31

/* all used bits of 'NX51_spi_sr': */
#define MSK_USED_BITS_NX51_spi_sr 0xdfdf001fU

enum {
	BFW_NX51_spi_sr_TFE              = 1,  /* [0] */
	BFW_NX51_spi_sr_TNF              = 1,  /* [1] */
	BFW_NX51_spi_sr_RNE              = 1,  /* [2] */
	BFW_NX51_spi_sr_RFF              = 1,  /* [3] */
	BFW_NX51_spi_sr_BSY              = 1,  /* [4] */
	BFW_NX51_spi_sr_reserved1        = 11, /* [15:5] */
	BFW_NX51_spi_sr_tx_fifo_level    = 5,  /* [20:16] */
	BFW_NX51_spi_sr_reserved2        = 1,  /* [21] */
	BFW_NX51_spi_sr_tx_fifo_err_ovfl = 1,  /* [22] */
	BFW_NX51_spi_sr_tx_fifo_err_undr = 1,  /* [23] */
	BFW_NX51_spi_sr_rx_fifo_level    = 5,  /* [28:24] */
	BFW_NX51_spi_sr_reserved3        = 1,  /* [29] */
	BFW_NX51_spi_sr_rx_fifo_err_ovfl = 1,  /* [30] */
	BFW_NX51_spi_sr_rx_fifo_err_undr = 1   /* [31] */
};

typedef struct NX51_SPI_SR_BIT_Ttag {
	unsigned int TFE              : BFW_NX51_spi_sr_TFE;              /* transmit FIFO is empty (1 if empty)                                                         */
	unsigned int TNF              : BFW_NX51_spi_sr_TNF;              /* transmit FIFO is not full (0 if full)                                                       */
	unsigned int RNE              : BFW_NX51_spi_sr_RNE;              /* receive FIFO is not empty (0 if empty)                                                      */
	unsigned int RFF              : BFW_NX51_spi_sr_RFF;              /* receive FIFO is full (1 if full)                                                            */
	unsigned int BSY              : BFW_NX51_spi_sr_BSY;              /* device busy (1 if data is currently transmitted/received or the transmit FIFO is not empty) */
	unsigned int reserved1        : BFW_NX51_spi_sr_reserved1;        /* reserved                                                                                    */
	unsigned int tx_fifo_level    : BFW_NX51_spi_sr_tx_fifo_level;    /* extended: transmit FIFO level (number of words to transmit are left in FIFO)                */
	unsigned int reserved2        : BFW_NX51_spi_sr_reserved2;        /* reserved                                                                                    */
	unsigned int tx_fifo_err_ovfl : BFW_NX51_spi_sr_tx_fifo_err_ovfl; /* extended: transmit FIFO overflow error occured, data is lost                                */
	unsigned int tx_fifo_err_undr : BFW_NX51_spi_sr_tx_fifo_err_undr; /* extended: transmit FIFO underrun error occured, data is lost                                */
	unsigned int rx_fifo_level    : BFW_NX51_spi_sr_rx_fifo_level;    /* extended: receive FIFO level (number of received words to read out are left in FIFO)        */
	unsigned int reserved3        : BFW_NX51_spi_sr_reserved3;        /* reserved                                                                                    */
	unsigned int rx_fifo_err_ovfl : BFW_NX51_spi_sr_rx_fifo_err_ovfl; /* extended: receive FIFO overflow error occured, data is lost                                 */
	unsigned int rx_fifo_err_undr : BFW_NX51_spi_sr_rx_fifo_err_undr; /* extended: receive FIFO underrun error occured, data is lost                                 */
} NX51_SPI_SR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SPI_SR_BIT_T bf;
} NX51_SPI_SR_T;

/* --------------------------------------------------------------------- */
/* Register spi_cpsr */
/* => Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    spi clock prescale register */
/*    No clock predeviding is done. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_cpsr        0x00000010U
#define Adr_NX51_spi_motion_spi_cpsr 0x10140810U
#define Adr_NX51_spi_cpsr            0x10140810U
#define DFLT_VAL_NX51_spi_cpsr       0x00000000U

#define MSK_NX51_spi_cpsr_CPSDVSR         0x000000ffU
#define SRT_NX51_spi_cpsr_CPSDVSR         0
#define DFLT_VAL_NX51_spi_cpsr_CPSDVSR    0x00000000U
#define DFLT_BF_VAL_NX51_spi_cpsr_CPSDVSR 0x00000000U

/* all used bits of 'NX51_spi_cpsr': */
#define MSK_USED_BITS_NX51_spi_cpsr 0x000000ffU

enum {
	BFW_NX51_spi_cpsr_CPSDVSR   = 8,  /* [7:0] */
	BFW_NX51_spi_cpsr_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_SPI_CPSR_BIT_Ttag {
	unsigned int CPSDVSR   : BFW_NX51_spi_cpsr_CPSDVSR;   /* obsolet  */
	unsigned int reserved1 : BFW_NX51_spi_cpsr_reserved1; /* reserved */
} NX51_SPI_CPSR_BIT_T;

typedef union {
	unsigned int        val;
	NX51_SPI_CPSR_BIT_T bf;
} NX51_SPI_CPSR_T;

/* --------------------------------------------------------------------- */
/* Register spi_imsc */
/* => spi interrupt mask set or clear register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    AND-mask */
/*    Both, receive and transmit FIFO have a depth of 16. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_imsc        0x00000014U
#define Adr_NX51_spi_motion_spi_imsc 0x10140814U
#define Adr_NX51_spi_imsc            0x10140814U
#define DFLT_VAL_NX51_spi_imsc       0x00000000U

#define MSK_NX51_spi_imsc_RORIM          0x00000001U
#define SRT_NX51_spi_imsc_RORIM          0
#define DFLT_VAL_NX51_spi_imsc_RORIM     0x00000000U
#define DFLT_BF_VAL_NX51_spi_imsc_RORIM  0x00000000U
#define MSK_NX51_spi_imsc_RTIM           0x00000002U
#define SRT_NX51_spi_imsc_RTIM           1
#define DFLT_VAL_NX51_spi_imsc_RTIM      0x00000000U
#define DFLT_BF_VAL_NX51_spi_imsc_RTIM   0x00000000U
#define MSK_NX51_spi_imsc_RXIM           0x00000004U
#define SRT_NX51_spi_imsc_RXIM           2
#define DFLT_VAL_NX51_spi_imsc_RXIM      0x00000000U
#define DFLT_BF_VAL_NX51_spi_imsc_RXIM   0x00000000U
#define MSK_NX51_spi_imsc_TXIM           0x00000008U
#define SRT_NX51_spi_imsc_TXIM           3
#define DFLT_VAL_NX51_spi_imsc_TXIM      0x00000000U
#define DFLT_BF_VAL_NX51_spi_imsc_TXIM   0x00000000U
#define MSK_NX51_spi_imsc_rxneim         0x00000010U
#define SRT_NX51_spi_imsc_rxneim         4
#define DFLT_VAL_NX51_spi_imsc_rxneim    0x00000000U
#define DFLT_BF_VAL_NX51_spi_imsc_rxneim 0x00000000U
#define MSK_NX51_spi_imsc_rxfim          0x00000020U
#define SRT_NX51_spi_imsc_rxfim          5
#define DFLT_VAL_NX51_spi_imsc_rxfim     0x00000000U
#define DFLT_BF_VAL_NX51_spi_imsc_rxfim  0x00000000U
#define MSK_NX51_spi_imsc_txeim          0x00000040U
#define SRT_NX51_spi_imsc_txeim          6
#define DFLT_VAL_NX51_spi_imsc_txeim     0x00000000U
#define DFLT_BF_VAL_NX51_spi_imsc_txeim  0x00000000U

/* all used bits of 'NX51_spi_imsc': */
#define MSK_USED_BITS_NX51_spi_imsc 0x0000007fU

enum {
	BFW_NX51_spi_imsc_RORIM     = 1,  /* [0] */
	BFW_NX51_spi_imsc_RTIM      = 1,  /* [1] */
	BFW_NX51_spi_imsc_RXIM      = 1,  /* [2] */
	BFW_NX51_spi_imsc_TXIM      = 1,  /* [3] */
	BFW_NX51_spi_imsc_rxneim    = 1,  /* [4] */
	BFW_NX51_spi_imsc_rxfim     = 1,  /* [5] */
	BFW_NX51_spi_imsc_txeim     = 1,  /* [6] */
	BFW_NX51_spi_imsc_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_SPI_IMSC_BIT_Ttag {
	unsigned int RORIM     : BFW_NX51_spi_imsc_RORIM;     /* receive FIFO overrun interrupt mask                                */
	unsigned int RTIM      : BFW_NX51_spi_imsc_RTIM;      /* receive timeout interrupt mask                                     */
	unsigned int RXIM      : BFW_NX51_spi_imsc_RXIM;      /* receive FIFO interrupt mask                                        */
	unsigned int TXIM      : BFW_NX51_spi_imsc_TXIM;      /* transmit FIFO interrupt mask                                       */
	unsigned int rxneim    : BFW_NX51_spi_imsc_rxneim;    /* receive FIFO not empty interrupt mask (for netx100/500 compliance) */
	unsigned int rxfim     : BFW_NX51_spi_imsc_rxfim;     /* receive FIFO full interrupt mask (for netx100/500 compliance)      */
	unsigned int txeim     : BFW_NX51_spi_imsc_txeim;     /* transmit FIFO empty interrupt mask (for netx100/500 compliance)    */
	unsigned int reserved1 : BFW_NX51_spi_imsc_reserved1; /* reserved                                                           */
} NX51_SPI_IMSC_BIT_T;

typedef union {
	unsigned int        val;
	NX51_SPI_IMSC_BIT_T bf;
} NX51_SPI_IMSC_T;

/* --------------------------------------------------------------------- */
/* Register spi_ris */
/* => spi interrupt state before masking register (raw interrupt) */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    Both, receive and transmit FIFO have a depth of 16. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_ris        0x00000018U
#define Adr_NX51_spi_motion_spi_ris 0x10140818U
#define Adr_NX51_spi_ris            0x10140818U

#define MSK_NX51_spi_ris_RORRIS  0x00000001U
#define SRT_NX51_spi_ris_RORRIS  0
#define MSK_NX51_spi_ris_RTRIS   0x00000002U
#define SRT_NX51_spi_ris_RTRIS   1
#define MSK_NX51_spi_ris_RXRIS   0x00000004U
#define SRT_NX51_spi_ris_RXRIS   2
#define MSK_NX51_spi_ris_TXRIS   0x00000008U
#define SRT_NX51_spi_ris_TXRIS   3
#define MSK_NX51_spi_ris_rxneris 0x00000010U
#define SRT_NX51_spi_ris_rxneris 4
#define MSK_NX51_spi_ris_rxfris  0x00000020U
#define SRT_NX51_spi_ris_rxfris  5
#define MSK_NX51_spi_ris_txeris  0x00000040U
#define SRT_NX51_spi_ris_txeris  6

/* all used bits of 'NX51_spi_ris': */
#define MSK_USED_BITS_NX51_spi_ris 0x0000007fU

enum {
	BFW_NX51_spi_ris_RORRIS    = 1,  /* [0] */
	BFW_NX51_spi_ris_RTRIS     = 1,  /* [1] */
	BFW_NX51_spi_ris_RXRIS     = 1,  /* [2] */
	BFW_NX51_spi_ris_TXRIS     = 1,  /* [3] */
	BFW_NX51_spi_ris_rxneris   = 1,  /* [4] */
	BFW_NX51_spi_ris_rxfris    = 1,  /* [5] */
	BFW_NX51_spi_ris_txeris    = 1,  /* [6] */
	BFW_NX51_spi_ris_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_SPI_RIS_BIT_Ttag {
	unsigned int RORRIS    : BFW_NX51_spi_ris_RORRIS;    /* unmasked receive FIFO overrun interrupt state                                */
	                                                     /* 1: receive FIFO overun error ocuured                                         */
	                                                     /* 0: no receive FIFO overrun error occured                                     */
	unsigned int RTRIS     : BFW_NX51_spi_ris_RTRIS;     /* unmasked receive timeout interrupt state                                     */
	                                                     /* timeout period are 32 SPI-clock periods depending on adr_spi_cr0.SCR         */
	                                                     /* 1: receive FIFO is not empty and not read out in the passed timeout period   */
	                                                     /* 0: receive FIFO is empty or read during the last timout period               */
	unsigned int RXRIS     : BFW_NX51_spi_ris_RXRIS;     /* unmasked receive FIFO interrupt state                                        */
	                                                     /* 1: receive FIFO is higher than spi_cr1.rx_fifo_wm                            */
	                                                     /* 0: receive FIFO is equals or is below spi_cr1.rx_fifo_wm                     */
	unsigned int TXRIS     : BFW_NX51_spi_ris_TXRIS;     /* unmasked transmit FIFO interrupt state                                       */
	                                                     /* 1: transmit FIFO level is below spi_cr1.tx_fifo_wm                           */
	                                                     /* 0: transmit FIFO equals or is higher than spi_cr1.tx_fifo_wm                 */
	unsigned int rxneris   : BFW_NX51_spi_ris_rxneris;   /* unmasked receive FIFO not empty interrupt state (for netx100/500 compliance) */
	                                                     /* 1: receive FIFO is not empty                                                 */
	                                                     /* 0: receive FIFO is empty                                                     */
	unsigned int rxfris    : BFW_NX51_spi_ris_rxfris;    /* unmasked receive FIFO full interrupt state (for netx100/500 compliance)      */
	                                                     /* 1: receive FIFO is full                                                      */
	                                                     /* 0: receive FIFO is not full                                                  */
	unsigned int txeris    : BFW_NX51_spi_ris_txeris;    /* unmasked transmit FIFO empty interrupt state (for netx100/500 compliance)    */
	                                                     /* 1: transmit FIFO is empty                                                    */
	                                                     /* 0: transmit FIFO is not empty                                                */
	unsigned int reserved1 : BFW_NX51_spi_ris_reserved1; /* reserved                                                                     */
} NX51_SPI_RIS_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SPI_RIS_BIT_T bf;
} NX51_SPI_RIS_T;

/* --------------------------------------------------------------------- */
/* Register spi_mis */
/* => spi interrupt status register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    Both, receive and transmit FIFO have a depth of 16. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_mis        0x0000001CU
#define Adr_NX51_spi_motion_spi_mis 0x1014081CU
#define Adr_NX51_spi_mis            0x1014081CU

#define MSK_NX51_spi_mis_RORMIS  0x00000001U
#define SRT_NX51_spi_mis_RORMIS  0
#define MSK_NX51_spi_mis_RTMIS   0x00000002U
#define SRT_NX51_spi_mis_RTMIS   1
#define MSK_NX51_spi_mis_RXMIS   0x00000004U
#define SRT_NX51_spi_mis_RXMIS   2
#define MSK_NX51_spi_mis_TXMIS   0x00000008U
#define SRT_NX51_spi_mis_TXMIS   3
#define MSK_NX51_spi_mis_rxnemis 0x00000010U
#define SRT_NX51_spi_mis_rxnemis 4
#define MSK_NX51_spi_mis_rxfmis  0x00000020U
#define SRT_NX51_spi_mis_rxfmis  5
#define MSK_NX51_spi_mis_txemis  0x00000040U
#define SRT_NX51_spi_mis_txemis  6

/* all used bits of 'NX51_spi_mis': */
#define MSK_USED_BITS_NX51_spi_mis 0x0000007fU

enum {
	BFW_NX51_spi_mis_RORMIS    = 1,  /* [0] */
	BFW_NX51_spi_mis_RTMIS     = 1,  /* [1] */
	BFW_NX51_spi_mis_RXMIS     = 1,  /* [2] */
	BFW_NX51_spi_mis_TXMIS     = 1,  /* [3] */
	BFW_NX51_spi_mis_rxnemis   = 1,  /* [4] */
	BFW_NX51_spi_mis_rxfmis    = 1,  /* [5] */
	BFW_NX51_spi_mis_txemis    = 1,  /* [6] */
	BFW_NX51_spi_mis_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_SPI_MIS_BIT_Ttag {
	unsigned int RORMIS    : BFW_NX51_spi_mis_RORMIS;    /* masked receive FIFO overrun interrupt state                                */
	unsigned int RTMIS     : BFW_NX51_spi_mis_RTMIS;     /* masked receive timeout interrupt state                                     */
	unsigned int RXMIS     : BFW_NX51_spi_mis_RXMIS;     /* masked receive FIFO interrupt state                                        */
	unsigned int TXMIS     : BFW_NX51_spi_mis_TXMIS;     /* masked transmit FIFO interrupt state                                       */
	unsigned int rxnemis   : BFW_NX51_spi_mis_rxnemis;   /* masked receive FIFO not empty interrupt state (for netx100/500 compliance) */
	unsigned int rxfmis    : BFW_NX51_spi_mis_rxfmis;    /* masked receive FIFO full interrupt state (for netx100/500 compliance)      */
	unsigned int txemis    : BFW_NX51_spi_mis_txemis;    /* masked transmit FIFO empty interrupt state (for netx100/500 compliance)    */
	unsigned int reserved1 : BFW_NX51_spi_mis_reserved1; /* reserved                                                                   */
} NX51_SPI_MIS_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SPI_MIS_BIT_T bf;
} NX51_SPI_MIS_T;

/* --------------------------------------------------------------------- */
/* Register spi_icr */
/* => spi interrupt clear register */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    interrupt is cleard by writing "1" to the according bit */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_icr        0x00000020U
#define Adr_NX51_spi_motion_spi_icr 0x10140820U
#define Adr_NX51_spi_icr            0x10140820U
#define DFLT_VAL_NX51_spi_icr       0x00000000U

#define MSK_NX51_spi_icr_RORIC          0x00000001U
#define SRT_NX51_spi_icr_RORIC          0
#define DFLT_VAL_NX51_spi_icr_RORIC     0x00000000U
#define DFLT_BF_VAL_NX51_spi_icr_RORIC  0x00000000U
#define MSK_NX51_spi_icr_RTIC           0x00000002U
#define SRT_NX51_spi_icr_RTIC           1
#define DFLT_VAL_NX51_spi_icr_RTIC      0x00000000U
#define DFLT_BF_VAL_NX51_spi_icr_RTIC   0x00000000U
#define MSK_NX51_spi_icr_RXIC           0x00000004U
#define SRT_NX51_spi_icr_RXIC           2
#define DFLT_VAL_NX51_spi_icr_RXIC      0x00000000U
#define DFLT_BF_VAL_NX51_spi_icr_RXIC   0x00000000U
#define MSK_NX51_spi_icr_TXIC           0x00000008U
#define SRT_NX51_spi_icr_TXIC           3
#define DFLT_VAL_NX51_spi_icr_TXIC      0x00000000U
#define DFLT_BF_VAL_NX51_spi_icr_TXIC   0x00000000U
#define MSK_NX51_spi_icr_rxneic         0x00000010U
#define SRT_NX51_spi_icr_rxneic         4
#define DFLT_VAL_NX51_spi_icr_rxneic    0x00000000U
#define DFLT_BF_VAL_NX51_spi_icr_rxneic 0x00000000U
#define MSK_NX51_spi_icr_rxfic          0x00000020U
#define SRT_NX51_spi_icr_rxfic          5
#define DFLT_VAL_NX51_spi_icr_rxfic     0x00000000U
#define DFLT_BF_VAL_NX51_spi_icr_rxfic  0x00000000U
#define MSK_NX51_spi_icr_txeic          0x00000040U
#define SRT_NX51_spi_icr_txeic          6
#define DFLT_VAL_NX51_spi_icr_txeic     0x00000000U
#define DFLT_BF_VAL_NX51_spi_icr_txeic  0x00000000U

/* all used bits of 'NX51_spi_icr': */
#define MSK_USED_BITS_NX51_spi_icr 0x0000007fU

enum {
	BFW_NX51_spi_icr_RORIC     = 1,  /* [0] */
	BFW_NX51_spi_icr_RTIC      = 1,  /* [1] */
	BFW_NX51_spi_icr_RXIC      = 1,  /* [2] */
	BFW_NX51_spi_icr_TXIC      = 1,  /* [3] */
	BFW_NX51_spi_icr_rxneic    = 1,  /* [4] */
	BFW_NX51_spi_icr_rxfic     = 1,  /* [5] */
	BFW_NX51_spi_icr_txeic     = 1,  /* [6] */
	BFW_NX51_spi_icr_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_SPI_ICR_BIT_Ttag {
	unsigned int RORIC     : BFW_NX51_spi_icr_RORIC;     /* clear receive FIFO overrun interrupt                                */
	                                                     /* writing '1' here will clear the receive FIFO                        */
	unsigned int RTIC      : BFW_NX51_spi_icr_RTIC;      /* clear receive FIFO overrun interrupt                                */
	unsigned int RXIC      : BFW_NX51_spi_icr_RXIC;      /* PL022 extention: clear receive FIFO interrupt                       */
	unsigned int TXIC      : BFW_NX51_spi_icr_TXIC;      /* PL022 extention: clear transmit FIFO interrupt                      */
	unsigned int rxneic    : BFW_NX51_spi_icr_rxneic;    /* clear receive FIFO not empty interrupt (for netx100/500 compliance) */
	unsigned int rxfic     : BFW_NX51_spi_icr_rxfic;     /* clear receive FIFO full interrupt (for netx100/500 compliance)      */
	unsigned int txeic     : BFW_NX51_spi_icr_txeic;     /* clear transmit FIFO empty interrupt (for netx100/500 compliance)    */
	unsigned int reserved1 : BFW_NX51_spi_icr_reserved1; /* reserved                                                            */
} NX51_SPI_ICR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SPI_ICR_BIT_T bf;
} NX51_SPI_ICR_T;

/* --------------------------------------------------------------------- */
/* Register spi_irq_cpu_sel */
/* => Interrupt CPU select register */
/*    Select CPU (xPIC or ARM), which gets Interrupts from this SPI instance. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_irq_cpu_sel        0x00000024U
#define Adr_NX51_spi_motion_spi_irq_cpu_sel 0x10140824U
#define Adr_NX51_spi_irq_cpu_sel            0x10140824U
#define DFLT_VAL_NX51_spi_irq_cpu_sel       0x00000001U

#define MSK_NX51_spi_irq_cpu_sel_arm          0x00000001U
#define SRT_NX51_spi_irq_cpu_sel_arm          0
#define DFLT_VAL_NX51_spi_irq_cpu_sel_arm     0x00000001U
#define DFLT_BF_VAL_NX51_spi_irq_cpu_sel_arm  0x00000001U
#define MSK_NX51_spi_irq_cpu_sel_xpic         0x00000002U
#define SRT_NX51_spi_irq_cpu_sel_xpic         1
#define DFLT_VAL_NX51_spi_irq_cpu_sel_xpic    0x00000000U
#define DFLT_BF_VAL_NX51_spi_irq_cpu_sel_xpic 0x00000000U

/* all used bits of 'NX51_spi_irq_cpu_sel': */
#define MSK_USED_BITS_NX51_spi_irq_cpu_sel 0x00000003U

enum {
	BFW_NX51_spi_irq_cpu_sel_arm       = 1,  /* [0] */
	BFW_NX51_spi_irq_cpu_sel_xpic      = 1,  /* [1] */
	BFW_NX51_spi_irq_cpu_sel_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_SPI_IRQ_CPU_SEL_BIT_Ttag {
	unsigned int arm       : BFW_NX51_spi_irq_cpu_sel_arm;       /* Enable for IRQ signal to ARM  */
	unsigned int xpic      : BFW_NX51_spi_irq_cpu_sel_xpic;      /* Enable for IRQ signal to xPIC */
	unsigned int reserved1 : BFW_NX51_spi_irq_cpu_sel_reserved1; /* reserved                      */
} NX51_SPI_IRQ_CPU_SEL_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SPI_IRQ_CPU_SEL_BIT_T bf;
} NX51_SPI_IRQ_CPU_SEL_T;

/* --------------------------------------------------------------------- */
/* Register spi_dmacr */
/* => spi DMA control register */
/*    Only single transfer requests will be generated by this module. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_dmacr        0x00000028U
#define Adr_NX51_spi_motion_spi_dmacr 0x10140828U
#define Adr_NX51_spi_dmacr            0x10140828U
#define DFLT_VAL_NX51_spi_dmacr       0x00000000U

#define MSK_NX51_spi_dmacr_RXDMAE         0x00000001U
#define SRT_NX51_spi_dmacr_RXDMAE         0
#define DFLT_VAL_NX51_spi_dmacr_RXDMAE    0x00000000U
#define DFLT_BF_VAL_NX51_spi_dmacr_RXDMAE 0x00000000U
#define MSK_NX51_spi_dmacr_TXDMAE         0x00000002U
#define SRT_NX51_spi_dmacr_TXDMAE         1
#define DFLT_VAL_NX51_spi_dmacr_TXDMAE    0x00000000U
#define DFLT_BF_VAL_NX51_spi_dmacr_TXDMAE 0x00000000U

/* all used bits of 'NX51_spi_dmacr': */
#define MSK_USED_BITS_NX51_spi_dmacr 0x00000003U

enum {
	BFW_NX51_spi_dmacr_RXDMAE    = 1,  /* [0] */
	BFW_NX51_spi_dmacr_TXDMAE    = 1,  /* [1] */
	BFW_NX51_spi_dmacr_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_SPI_DMACR_BIT_Ttag {
	unsigned int RXDMAE    : BFW_NX51_spi_dmacr_RXDMAE;    /* enable DMA for SPI-receive data                                                                                  */
	                                                       /* A request will be generated if RX-FIFO is not empty and spi_cr1.SSE (module enable) is set.                      */
	                                                       /* Burst request to DMA-Ctrl will be done if the RX-FIFO contains at least 4 words (set DMA-burst-size to 4)        */
	                                                       /* If this bit is reset or the module is disabled, DMA-request will also be reset.                                  */
	                                                       /* note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module                                      */
	unsigned int TXDMAE    : BFW_NX51_spi_dmacr_TXDMAE;    /* enable DMA for SPI-transmit data                                                                                 */
	                                                       /* A request will be generated if TX-FIFO is not full and spi_cr1.SSE (module enable) is set.                       */
	                                                       /* Burst request to DMA-Ctrl will be done if at least 4 words are writable to the TX-FIFO (set DMA-burst-size to 4) */
	                                                       /* If this bit is reset or the module is disabled, DMA-request will also be reset.                                  */
	                                                       /* note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module                                      */
	unsigned int reserved1 : BFW_NX51_spi_dmacr_reserved1; /* reserved                                                                                                         */
} NX51_SPI_DMACR_BIT_T;

typedef union {
	unsigned int         val;
	NX51_SPI_DMACR_BIT_T bf;
} NX51_SPI_DMACR_T;

/* --------------------------------------------------------------------- */
/* Register spi_data_register */
/* => netx100/500 compliant spi data register (DR) */
/*    Registers 0x30..0x3C can be used instead of registers 0x00...0x24 to keep netx50 software compliant to netx100/500 */
/*    2 data bytes with valid bits */
/*    During write-access data_byte_1 and dr_valid1 must not be used. dr_valid0 must be set. */
/*    In netx50 and later versions both, receive and transmit FIFO have a depth of 16, fill-values are fixed to 4. To keep software */
/*    compatible, not more than 8 bytes should be in netx100/500-FIFOs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_data_register        0x00000030U
#define Adr_NX51_spi_motion_spi_data_register 0x10140830U
#define Adr_NX51_spi_data_register            0x10140830U
#define DFLT_VAL_NX51_spi_data_register       0x00000000U

#define MSK_NX51_spi_data_register_data_byte_0         0x000000ffU
#define SRT_NX51_spi_data_register_data_byte_0         0
#define DFLT_VAL_NX51_spi_data_register_data_byte_0    0x00000000U
#define DFLT_BF_VAL_NX51_spi_data_register_data_byte_0 0x00000000U
#define MSK_NX51_spi_data_register_data_byte_1         0x0000ff00U
#define SRT_NX51_spi_data_register_data_byte_1         8
#define DFLT_VAL_NX51_spi_data_register_data_byte_1    0x00000000U
#define DFLT_BF_VAL_NX51_spi_data_register_data_byte_1 0x00000000U
#define MSK_NX51_spi_data_register_dr_valid0           0x00010000U
#define SRT_NX51_spi_data_register_dr_valid0           16
#define DFLT_VAL_NX51_spi_data_register_dr_valid0      0x00000000U
#define DFLT_BF_VAL_NX51_spi_data_register_dr_valid0   0x00000000U
#define MSK_NX51_spi_data_register_dr_valid1           0x00020000U
#define SRT_NX51_spi_data_register_dr_valid1           17
#define DFLT_VAL_NX51_spi_data_register_dr_valid1      0x00000000U
#define DFLT_BF_VAL_NX51_spi_data_register_dr_valid1   0x00000000U

/* all used bits of 'NX51_spi_data_register': */
#define MSK_USED_BITS_NX51_spi_data_register 0x0003ffffU

enum {
	BFW_NX51_spi_data_register_data_byte_0 = 8,  /* [7:0] */
	BFW_NX51_spi_data_register_data_byte_1 = 8,  /* [15:8] */
	BFW_NX51_spi_data_register_dr_valid0   = 1,  /* [16] */
	BFW_NX51_spi_data_register_dr_valid1   = 1,  /* [17] */
	BFW_NX51_spi_data_register_reserved1   = 14  /* [31:18] */
};

typedef struct NX51_SPI_DATA_REGISTER_BIT_Ttag {
	unsigned int data_byte_0 : BFW_NX51_spi_data_register_data_byte_0; /* data byte 0                                                                     */
	unsigned int data_byte_1 : BFW_NX51_spi_data_register_data_byte_1; /* obsolet, don't use                                                              */
	unsigned int dr_valid0   : BFW_NX51_spi_data_register_dr_valid0;   /* valid bit for data_byte_0                                                       */
	                                                                   /* This bit shows if data_byte_0 Is valid and must be set during FIFO write access */
	unsigned int dr_valid1   : BFW_NX51_spi_data_register_dr_valid1;   /* obsolet, always 0                                                               */
	unsigned int reserved1   : BFW_NX51_spi_data_register_reserved1;   /* reserved                                                                        */
} NX51_SPI_DATA_REGISTER_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_SPI_DATA_REGISTER_BIT_T bf;
} NX51_SPI_DATA_REGISTER_T;

/* --------------------------------------------------------------------- */
/* Register spi_status_register */
/* => netx100/500 compliant spi status register (SR): */
/*    Shows the actual status of the spi interface. */
/*    Bits 24..18 show occured interrupts, */
/*    writing ones into these bits deletes the interrupts. */
/*    Writing into other bits has no effect. */
/*    In netx50 and later versions both, receive and transmit FIFO have a depth of 16, fill-values are fixed to 4. To keep software */
/*    compatible, not more than 8 bytes should be in netx100/500-FIFOs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_status_register        0x00000034U
#define Adr_NX51_spi_motion_spi_status_register 0x10140834U
#define Adr_NX51_spi_status_register            0x10140834U

#define MSK_NX51_spi_status_register_SR_in_fuel_val  0x000001ffU
#define SRT_NX51_spi_status_register_SR_in_fuel_val  0
#define MSK_NX51_spi_status_register_SR_out_fuel_val 0x0003fe00U
#define SRT_NX51_spi_status_register_SR_out_fuel_val 9
#define MSK_NX51_spi_status_register_SR_in_fuel      0x00040000U
#define SRT_NX51_spi_status_register_SR_in_fuel      18
#define MSK_NX51_spi_status_register_SR_in_recdata   0x00080000U
#define SRT_NX51_spi_status_register_SR_in_recdata   19
#define MSK_NX51_spi_status_register_SR_in_full      0x00100000U
#define SRT_NX51_spi_status_register_SR_in_full      20
#define MSK_NX51_spi_status_register_SR_out_fuel     0x00200000U
#define SRT_NX51_spi_status_register_SR_out_fuel     21
#define MSK_NX51_spi_status_register_SR_out_fw       0x00400000U
#define SRT_NX51_spi_status_register_SR_out_fw       22
#define MSK_NX51_spi_status_register_SR_out_empty    0x00800000U
#define SRT_NX51_spi_status_register_SR_out_empty    23
#define MSK_NX51_spi_status_register_SR_out_full     0x01000000U
#define SRT_NX51_spi_status_register_SR_out_full     24
#define MSK_NX51_spi_status_register_SR_selected     0x02000000U
#define SRT_NX51_spi_status_register_SR_selected     25

/* all used bits of 'NX51_spi_status_register': */
#define MSK_USED_BITS_NX51_spi_status_register 0x03ffffffU

enum {
	BFW_NX51_spi_status_register_SR_in_fuel_val  = 9, /* [8:0] */
	BFW_NX51_spi_status_register_SR_out_fuel_val = 9, /* [17:9] */
	BFW_NX51_spi_status_register_SR_in_fuel      = 1, /* [18] */
	BFW_NX51_spi_status_register_SR_in_recdata   = 1, /* [19] */
	BFW_NX51_spi_status_register_SR_in_full      = 1, /* [20] */
	BFW_NX51_spi_status_register_SR_out_fuel     = 1, /* [21] */
	BFW_NX51_spi_status_register_SR_out_fw       = 1, /* [22] */
	BFW_NX51_spi_status_register_SR_out_empty    = 1, /* [23] */
	BFW_NX51_spi_status_register_SR_out_full     = 1, /* [24] */
	BFW_NX51_spi_status_register_SR_selected     = 1, /* [25] */
	BFW_NX51_spi_status_register_reserved1       = 6  /* [31:26] */
};

typedef struct NX51_SPI_STATUS_REGISTER_BIT_Ttag {
	unsigned int SR_in_fuel_val  : BFW_NX51_spi_status_register_SR_in_fuel_val;  /* input FIFO fill value (number of bytes)                                                              */
	unsigned int SR_out_fuel_val : BFW_NX51_spi_status_register_SR_out_fuel_val; /* output FIFO fill vlaue (number of bytes)                                                             */
	unsigned int SR_in_fuel      : BFW_NX51_spi_status_register_SR_in_fuel;      /* adjustable fill value of input FIFO reached (equals adr_spi_ris.RXRIS in netx50 and later versions)  */
	unsigned int SR_in_recdata   : BFW_NX51_spi_status_register_SR_in_recdata;   /* valid data bytes in input FIFO (equals adr_spi_ris.rxneris in netx50 and later versions)             */
	unsigned int SR_in_full      : BFW_NX51_spi_status_register_SR_in_full;      /* input FIFO is full (equals adr_spi_ris.rxfris in netx50 and later versions)                          */
	unsigned int SR_out_fuel     : BFW_NX51_spi_status_register_SR_out_fuel;     /* adjustable fill value of output FIFO reached (equals adr_spi_ris.TXRIS in netx50 and later versions) */
	unsigned int SR_out_fw       : BFW_NX51_spi_status_register_SR_out_fw;       /* netx is writing data to fast into output FIFO. This is only with netx100/500 an IRQ.                 */
	                                                                             /* (equals adr_spi_sr.tx_fifo_err_ovfl in netx50 and later versions)                                    */
	unsigned int SR_out_empty    : BFW_NX51_spi_status_register_SR_out_empty;    /* output FIFO is empty in slave mode. (equals adr_spi_ris.txeris in netx50 and later versions)         */
	unsigned int SR_out_full     : BFW_NX51_spi_status_register_SR_out_full;     /* output FIFO is full .This is only with netx100/500 an IRQ.                                           */
	unsigned int SR_selected     : BFW_NX51_spi_status_register_SR_selected;     /* external master has access to spi-interface                                                          */
	unsigned int reserved1       : BFW_NX51_spi_status_register_reserved1;       /* reserved                                                                                             */
} NX51_SPI_STATUS_REGISTER_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_SPI_STATUS_REGISTER_BIT_T bf;
} NX51_SPI_STATUS_REGISTER_T;

/* --------------------------------------------------------------------- */
/* Register spi_control_register */
/* => netx100/500 compliant spi control register (CR) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_control_register        0x00000038U
#define Adr_NX51_spi_motion_spi_control_register 0x10140838U
#define Adr_NX51_spi_control_register            0x10140838U
#define DFLT_VAL_NX51_spi_control_register       0x00000000U

#define MSK_NX51_spi_control_register_CR_softreset           0x00000001U
#define SRT_NX51_spi_control_register_CR_softreset           0
#define DFLT_VAL_NX51_spi_control_register_CR_softreset      0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_softreset   0x00000000U
#define MSK_NX51_spi_control_register_CR_speed               0x0000001eU
#define SRT_NX51_spi_control_register_CR_speed               1
#define DFLT_VAL_NX51_spi_control_register_CR_speed          0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_speed       0x00000000U
#define MSK_NX51_spi_control_register_CR_read                0x00000040U
#define SRT_NX51_spi_control_register_CR_read                6
#define DFLT_VAL_NX51_spi_control_register_CR_read           0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_read        0x00000000U
#define MSK_NX51_spi_control_register_CR_write               0x00000080U
#define SRT_NX51_spi_control_register_CR_write               7
#define DFLT_VAL_NX51_spi_control_register_CR_write          0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_write       0x00000000U
#define MSK_NX51_spi_control_register_CR_ss                  0x00000700U
#define SRT_NX51_spi_control_register_CR_ss                  8
#define DFLT_VAL_NX51_spi_control_register_CR_ss             0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_ss          0x00000000U
#define MSK_NX51_spi_control_register_CS_mode                0x00000800U
#define SRT_NX51_spi_control_register_CS_mode                11
#define DFLT_VAL_NX51_spi_control_register_CS_mode           0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CS_mode        0x00000000U
#define MSK_NX51_spi_control_register_CR_clr_infifo          0x00100000U
#define SRT_NX51_spi_control_register_CR_clr_infifo          20
#define DFLT_VAL_NX51_spi_control_register_CR_clr_infifo     0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_clr_infifo  0x00000000U
#define MSK_NX51_spi_control_register_CR_clr_outfifo         0x00200000U
#define SRT_NX51_spi_control_register_CR_clr_outfifo         21
#define DFLT_VAL_NX51_spi_control_register_CR_clr_outfifo    0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_clr_outfifo 0x00000000U
#define MSK_NX51_spi_control_register_CR_burstdelay          0x01c00000U
#define SRT_NX51_spi_control_register_CR_burstdelay          22
#define DFLT_VAL_NX51_spi_control_register_CR_burstdelay     0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_burstdelay  0x00000000U
#define MSK_NX51_spi_control_register_CR_burst               0x0e000000U
#define SRT_NX51_spi_control_register_CR_burst               25
#define DFLT_VAL_NX51_spi_control_register_CR_burst          0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_burst       0x00000000U
#define MSK_NX51_spi_control_register_CR_ncpha               0x10000000U
#define SRT_NX51_spi_control_register_CR_ncpha               28
#define DFLT_VAL_NX51_spi_control_register_CR_ncpha          0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_ncpha       0x00000000U
#define MSK_NX51_spi_control_register_CR_cpol                0x20000000U
#define SRT_NX51_spi_control_register_CR_cpol                29
#define DFLT_VAL_NX51_spi_control_register_CR_cpol           0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_cpol        0x00000000U
#define MSK_NX51_spi_control_register_CR_ms                  0x40000000U
#define SRT_NX51_spi_control_register_CR_ms                  30
#define DFLT_VAL_NX51_spi_control_register_CR_ms             0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_ms          0x00000000U
#define MSK_NX51_spi_control_register_CR_en                  0x80000000U
#define SRT_NX51_spi_control_register_CR_en                  31
#define DFLT_VAL_NX51_spi_control_register_CR_en             0x00000000U
#define DFLT_BF_VAL_NX51_spi_control_register_CR_en          0x00000000U

/* all used bits of 'NX51_spi_control_register': */
#define MSK_USED_BITS_NX51_spi_control_register 0xfff00fdfU

enum {
	BFW_NX51_spi_control_register_CR_softreset   = 1, /* [0] */
	BFW_NX51_spi_control_register_CR_speed       = 4, /* [4:1] */
	BFW_NX51_spi_control_register_reserved1      = 1, /* [5] */
	BFW_NX51_spi_control_register_CR_read        = 1, /* [6] */
	BFW_NX51_spi_control_register_CR_write       = 1, /* [7] */
	BFW_NX51_spi_control_register_CR_ss          = 3, /* [10:8] */
	BFW_NX51_spi_control_register_CS_mode        = 1, /* [11] */
	BFW_NX51_spi_control_register_reserved2      = 8, /* [19:12] */
	BFW_NX51_spi_control_register_CR_clr_infifo  = 1, /* [20] */
	BFW_NX51_spi_control_register_CR_clr_outfifo = 1, /* [21] */
	BFW_NX51_spi_control_register_CR_burstdelay  = 3, /* [24:22] */
	BFW_NX51_spi_control_register_CR_burst       = 3, /* [27:25] */
	BFW_NX51_spi_control_register_CR_ncpha       = 1, /* [28] */
	BFW_NX51_spi_control_register_CR_cpol        = 1, /* [29] */
	BFW_NX51_spi_control_register_CR_ms          = 1, /* [30] */
	BFW_NX51_spi_control_register_CR_en          = 1  /* [31] */
};

typedef struct NX51_SPI_CONTROL_REGISTER_BIT_Ttag {
	unsigned int CR_softreset   : BFW_NX51_spi_control_register_CR_softreset;   /* write only: no function in netx100/netx500; later Versions: clears IRQs and FIFOs                             */
	unsigned int CR_speed       : BFW_NX51_spi_control_register_CR_speed;       /* clock devider for SPI clock (2 - 2^16)                                                                        */
	                                                                            /* If SPI Clock-rate is changed by adr_spi_cr0.SCR, this value will not be updated an may be incorrect           */
	                                                                            /* There are 16 different SPI Clocks to choose:                                                                  */
	                                                                            /* 0000: 0,025 MHz    Note: Not compatible to netx100/500. "0000" freezes spi_clk in netx100/500.                */
	                                                                            /* 0001: 0,05 MHz                                                                                                */
	                                                                            /* 0010: 0,1 MHz                                                                                                 */
	                                                                            /* 0011: 0,2 MHz                                                                                                 */
	                                                                            /* 0100: 0,5 MHz                                                                                                 */
	                                                                            /* 0101: 1 MHz                                                                                                   */
	                                                                            /* 0110: 1,25 MHz                                                                                                */
	                                                                            /* 0111: 2 MHz                                                                                                   */
	                                                                            /* 1000: 2,5 MHz                                                                                                 */
	                                                                            /* 1001: 3,3333 MHz                                                                                              */
	                                                                            /* 1010: 5 MHz                                                                                                   */
	                                                                            /* 1011:10 MHz                                                                                                   */
	                                                                            /* 1100:12,5 MHz                                                                                                 */
	                                                                            /* 1101:16,6666 MHz                                                                                              */
	                                                                            /* 1110:25 MHz                                                                                                   */
	                                                                            /* 1111:50 MHz                                                                                                   */
	unsigned int reserved1      : BFW_NX51_spi_control_register_reserved1;      /* reserved                                                                                                      */
	unsigned int CR_read        : BFW_NX51_spi_control_register_CR_read;        /* netx100/netx500 only, in later versions always "1":  1: enable spi interface read data                        */
	unsigned int CR_write       : BFW_NX51_spi_control_register_CR_write;       /* netx100/netx500 only, in later versions always "1":  1: enable spi interface write data                       */
	unsigned int CR_ss          : BFW_NX51_spi_control_register_CR_ss;          /* external slave select                                                                                         */
	unsigned int CS_mode        : BFW_NX51_spi_control_register_CS_mode;        /* 1: chip select is generated automatically by the internal state machine                                       */
	                                                                            /* 0: chip select is directly controlled by software (see bits CR_ss).                                           */
	unsigned int reserved2      : BFW_NX51_spi_control_register_reserved2;      /* reserved                                                                                                      */
	unsigned int CR_clr_infifo  : BFW_NX51_spi_control_register_CR_clr_infifo;  /* clear input FIFO                                                                                              */
	unsigned int CR_clr_outfifo : BFW_NX51_spi_control_register_CR_clr_outfifo; /* clear output FIFO                                                                                             */
	unsigned int CR_burstdelay  : BFW_NX51_spi_control_register_CR_burstdelay;  /* netx100/netx500 only, obsolet in later versions: delay between transmittion of 2 data bytes                   */
	                                                                            /* (0 to 7 SCK cycles)                                                                                           */
	unsigned int CR_burst       : BFW_NX51_spi_control_register_CR_burst;       /* netx100/netx500 only, obsolet in later versions: burst lenght = 2^CR_burst                                    */
	unsigned int CR_ncpha       : BFW_NX51_spi_control_register_CR_ncpha;       /* SPI clock phase mode (Note: meaning of this bit is inverted to functionality of bit SPH in spi_cr0 register): */
	                                                                            /* 0:change data to secondary spi_sck edge                                                                       */
	                                                                            /*   data are active to primary spi_sck edge                                                                     */
	                                                                            /* 1:change data to primary spi_sck edge                                                                         */
	                                                                            /*   data are active to secondary spi_sck edge                                                                   */
	unsigned int CR_cpol        : BFW_NX51_spi_control_register_CR_cpol;        /* 1:falling edge of spi_sck is primary                                                                          */
	                                                                            /* 0:rising edge of spi_sck is primary                                                                           */
	unsigned int CR_ms          : BFW_NX51_spi_control_register_CR_ms;          /* 1:master mode 0:slave mode                                                                                    */
	unsigned int CR_en          : BFW_NX51_spi_control_register_CR_en;          /* 1:enable 0:disable spi interface                                                                              */
} NX51_SPI_CONTROL_REGISTER_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_SPI_CONTROL_REGISTER_BIT_T bf;
} NX51_SPI_CONTROL_REGISTER_T;

/* --------------------------------------------------------------------- */
/* Register spi_interrupt_control_register */
/* => netx100/500 compliant spi interrupt control register (IR) */
/*    In netx50 and later versions both, receive and transmit FIFO have a depth of 16, fill-values are fixed to 4. To keep software */
/*    compatible, not more than 8 bytes should be in netx100/500-FIFOs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_spi_interrupt_control_register        0x0000003CU
#define Adr_NX51_spi_motion_spi_interrupt_control_register 0x1014083CU
#define Adr_NX51_spi_interrupt_control_register            0x1014083CU
#define DFLT_VAL_NX51_spi_interrupt_control_register       0x00000000U

#define MSK_NX51_spi_interrupt_control_register_IR_in_fuel               0x000001ffU
#define SRT_NX51_spi_interrupt_control_register_IR_in_fuel               0
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_in_fuel          0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_in_fuel       0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_out_fuel              0x0003fe00U
#define SRT_NX51_spi_interrupt_control_register_IR_out_fuel              9
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_out_fuel         0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_out_fuel      0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_in_fuel_en            0x00040000U
#define SRT_NX51_spi_interrupt_control_register_IR_in_fuel_en            18
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_in_fuel_en       0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_in_fuel_en    0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_in_recdata_en         0x00080000U
#define SRT_NX51_spi_interrupt_control_register_IR_in_recdata_en         19
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_in_recdata_en    0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_in_recdata_en 0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_in_full_en            0x00100000U
#define SRT_NX51_spi_interrupt_control_register_IR_in_full_en            20
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_in_full_en       0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_in_full_en    0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_out_fuel_en           0x00200000U
#define SRT_NX51_spi_interrupt_control_register_IR_out_fuel_en           21
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_out_fuel_en      0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_out_fuel_en   0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_out_fw_en             0x00400000U
#define SRT_NX51_spi_interrupt_control_register_IR_out_fw_en             22
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_out_fw_en        0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_out_fw_en     0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_out_empty_en          0x00800000U
#define SRT_NX51_spi_interrupt_control_register_IR_out_empty_en          23
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_out_empty_en     0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_out_empty_en  0x00000000U
#define MSK_NX51_spi_interrupt_control_register_IR_out_full_en           0x01000000U
#define SRT_NX51_spi_interrupt_control_register_IR_out_full_en           24
#define DFLT_VAL_NX51_spi_interrupt_control_register_IR_out_full_en      0x00000000U
#define DFLT_BF_VAL_NX51_spi_interrupt_control_register_IR_out_full_en   0x00000000U

/* all used bits of 'NX51_spi_interrupt_control_register': */
#define MSK_USED_BITS_NX51_spi_interrupt_control_register 0x01ffffffU

enum {
	BFW_NX51_spi_interrupt_control_register_IR_in_fuel       = 9, /* [8:0] */
	BFW_NX51_spi_interrupt_control_register_IR_out_fuel      = 9, /* [17:9] */
	BFW_NX51_spi_interrupt_control_register_IR_in_fuel_en    = 1, /* [18] */
	BFW_NX51_spi_interrupt_control_register_IR_in_recdata_en = 1, /* [19] */
	BFW_NX51_spi_interrupt_control_register_IR_in_full_en    = 1, /* [20] */
	BFW_NX51_spi_interrupt_control_register_IR_out_fuel_en   = 1, /* [21] */
	BFW_NX51_spi_interrupt_control_register_IR_out_fw_en     = 1, /* [22] */
	BFW_NX51_spi_interrupt_control_register_IR_out_empty_en  = 1, /* [23] */
	BFW_NX51_spi_interrupt_control_register_IR_out_full_en   = 1, /* [24] */
	BFW_NX51_spi_interrupt_control_register_reserved1        = 7  /* [31:25] */
};

typedef struct NX51_SPI_INTERRUPT_CONTROL_REGISTER_BIT_Ttag {
	unsigned int IR_in_fuel       : BFW_NX51_spi_interrupt_control_register_IR_in_fuel;       /* adjustable watermark level of input FIFO                                             */
	unsigned int IR_out_fuel      : BFW_NX51_spi_interrupt_control_register_IR_out_fuel;      /* adjustable watermark level of output FIFO                                            */
	unsigned int IR_in_fuel_en    : BFW_NX51_spi_interrupt_control_register_IR_in_fuel_en;    /* IRQ enable for irq_spi(0)  (equals adr_spi_imsc.RXIM in netx50 and later versions)   */
	unsigned int IR_in_recdata_en : BFW_NX51_spi_interrupt_control_register_IR_in_recdata_en; /* IRQ enable for irq_spi(1)  (equals adr_spi_imsc.txneim in netx50 and later versions) */
	unsigned int IR_in_full_en    : BFW_NX51_spi_interrupt_control_register_IR_in_full_en;    /* IRQ enable for irq_spi(2)  (equals adr_spi_imsc.txfim in netx50 and later versions)  */
	unsigned int IR_out_fuel_en   : BFW_NX51_spi_interrupt_control_register_IR_out_fuel_en;   /* IRQ enable for irq_spi(3)  (equals adr_spi_imsc.TXIM in netx50 and later versions)   */
	unsigned int IR_out_fw_en     : BFW_NX51_spi_interrupt_control_register_IR_out_fw_en;     /* IRQ enable for irq_spi(4), netx100/netx500 only, always "0" in later versions        */
	unsigned int IR_out_empty_en  : BFW_NX51_spi_interrupt_control_register_IR_out_empty_en;  /* IRQ enable for irq_spi(5)  (equals adr_spi_imsc.rxeim in netx50 and later versions)  */
	unsigned int IR_out_full_en   : BFW_NX51_spi_interrupt_control_register_IR_out_full_en;   /* IRQ enable for irq_spi(6), netx100/netx500 only, always "0" in later versions        */
	unsigned int reserved1        : BFW_NX51_spi_interrupt_control_register_reserved1;        /* reserved                                                                             */
} NX51_SPI_INTERRUPT_CONTROL_REGISTER_BIT_T;

typedef union {
	unsigned int                              val;
	NX51_SPI_INTERRUPT_CONTROL_REGISTER_BIT_T bf;
} NX51_SPI_INTERRUPT_CONTROL_REGISTER_T;


/* ===================================================================== */

/* Area of xpic_timer */

/* ===================================================================== */

#define Addr_NX51_xpic_timer 0x10140880U

/* --------------------------------------------------------------------- */
/* Register xpic_timer_config_timer0 */
/* => xPIC TIMER Config register0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_config_timer0        0x00000000U
#define Adr_NX51_xpic_timer_xpic_timer_config_timer0 0x10140880U
#define Adr_NX51_xpic_timer_config_timer0            0x10140880U
#define DFLT_VAL_NX51_xpic_timer_config_timer0       0x00000000U

#define MSK_NX51_xpic_timer_config_timer0_mode         0x00000003U
#define SRT_NX51_xpic_timer_config_timer0_mode         0
#define DFLT_VAL_NX51_xpic_timer_config_timer0_mode    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_config_timer0_mode 0x00000000U

/* all used bits of 'NX51_xpic_timer_config_timer0': */
#define MSK_USED_BITS_NX51_xpic_timer_config_timer0 0x00000003U

enum {
	BFW_NX51_xpic_timer_config_timer0_mode      = 2,  /* [1:0] */
	BFW_NX51_xpic_timer_config_timer0_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_XPIC_TIMER_CONFIG_TIMER0_BIT_Ttag {
	unsigned int mode      : BFW_NX51_xpic_timer_config_timer0_mode;      /* Timer0                                                               */
	                                                                      /*       2'b00 : Timer stops at 0                                       */
	                                                                      /*       2'b01 : Timer is preload with value from preload register at 0 */
	                                                                      /*       2'b10 : Timer (value) compare with systime (once)              */
	                                                                      /*       2'b11 : Timer (value) compare with systime_uc (once)           */
	unsigned int reserved1 : BFW_NX51_xpic_timer_config_timer0_reserved1; /* reserved                                                             */
} NX51_XPIC_TIMER_CONFIG_TIMER0_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_TIMER_CONFIG_TIMER0_BIT_T bf;
} NX51_XPIC_TIMER_CONFIG_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_config_timer1 */
/* => xPIC TIMER Config register1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_config_timer1        0x00000004U
#define Adr_NX51_xpic_timer_xpic_timer_config_timer1 0x10140884U
#define Adr_NX51_xpic_timer_config_timer1            0x10140884U
#define DFLT_VAL_NX51_xpic_timer_config_timer1       0x00000000U

#define MSK_NX51_xpic_timer_config_timer1_mode         0x00000003U
#define SRT_NX51_xpic_timer_config_timer1_mode         0
#define DFLT_VAL_NX51_xpic_timer_config_timer1_mode    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_config_timer1_mode 0x00000000U

/* all used bits of 'NX51_xpic_timer_config_timer1': */
#define MSK_USED_BITS_NX51_xpic_timer_config_timer1 0x00000003U

enum {
	BFW_NX51_xpic_timer_config_timer1_mode      = 2,  /* [1:0] */
	BFW_NX51_xpic_timer_config_timer1_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_XPIC_TIMER_CONFIG_TIMER1_BIT_Ttag {
	unsigned int mode      : BFW_NX51_xpic_timer_config_timer1_mode;      /* Timer1                                                               */
	                                                                      /*       2'b00 : Timer stops at 0                                       */
	                                                                      /*       2'b01 : Timer is preload with value from preload register at 0 */
	                                                                      /*       2'b10 : Timer (value) compare with systime (once)              */
	                                                                      /*       2'b11 : Timer (value) compare with systime_uc (once)           */
	unsigned int reserved1 : BFW_NX51_xpic_timer_config_timer1_reserved1; /* reserved                                                             */
} NX51_XPIC_TIMER_CONFIG_TIMER1_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_TIMER_CONFIG_TIMER1_BIT_T bf;
} NX51_XPIC_TIMER_CONFIG_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_config_timer2 */
/* => xPIC TIMER Config register2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_config_timer2        0x00000008U
#define Adr_NX51_xpic_timer_xpic_timer_config_timer2 0x10140888U
#define Adr_NX51_xpic_timer_config_timer2            0x10140888U
#define DFLT_VAL_NX51_xpic_timer_config_timer2       0x00000000U

#define MSK_NX51_xpic_timer_config_timer2_mode         0x00000003U
#define SRT_NX51_xpic_timer_config_timer2_mode         0
#define DFLT_VAL_NX51_xpic_timer_config_timer2_mode    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_config_timer2_mode 0x00000000U

/* all used bits of 'NX51_xpic_timer_config_timer2': */
#define MSK_USED_BITS_NX51_xpic_timer_config_timer2 0x00000003U

enum {
	BFW_NX51_xpic_timer_config_timer2_mode      = 2,  /* [1:0] */
	BFW_NX51_xpic_timer_config_timer2_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_XPIC_TIMER_CONFIG_TIMER2_BIT_Ttag {
	unsigned int mode      : BFW_NX51_xpic_timer_config_timer2_mode;      /* Timer2                                                               */
	                                                                      /*       2'b00 : Timer stops at 0                                       */
	                                                                      /*       2'b01 : Timer is preload with value from preload register at 0 */
	                                                                      /*       2'b10 : Timer (value) compare with systime (once)              */
	                                                                      /*       2'b11 : Timer (value) compare with systime_uc (once)           */
	unsigned int reserved1 : BFW_NX51_xpic_timer_config_timer2_reserved1; /* reserved                                                             */
} NX51_XPIC_TIMER_CONFIG_TIMER2_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_TIMER_CONFIG_TIMER2_BIT_T bf;
} NX51_XPIC_TIMER_CONFIG_TIMER2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_preload_timer0 */
/* => xPIC TIMER Timer 0 preload */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_preload_timer0        0x0000000CU
#define Adr_NX51_xpic_timer_xpic_timer_preload_timer0 0x1014088CU
#define Adr_NX51_xpic_timer_preload_timer0            0x1014088CU
#define DFLT_VAL_NX51_xpic_timer_preload_timer0       0x00000000U

#define MSK_NX51_xpic_timer_preload_timer0_val         0xffffffffU
#define SRT_NX51_xpic_timer_preload_timer0_val         0
#define DFLT_VAL_NX51_xpic_timer_preload_timer0_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_preload_timer0_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_preload_timer0': */
#define MSK_USED_BITS_NX51_xpic_timer_preload_timer0 0xffffffffU

enum {
	BFW_NX51_xpic_timer_preload_timer0_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_PRELOAD_TIMER0_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_preload_timer0_val; /* preload value */
} NX51_XPIC_TIMER_PRELOAD_TIMER0_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_XPIC_TIMER_PRELOAD_TIMER0_BIT_T bf;
} NX51_XPIC_TIMER_PRELOAD_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_preload_timer1 */
/* => xPIC TIMER Timer 1 preload */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_preload_timer1        0x00000010U
#define Adr_NX51_xpic_timer_xpic_timer_preload_timer1 0x10140890U
#define Adr_NX51_xpic_timer_preload_timer1            0x10140890U
#define DFLT_VAL_NX51_xpic_timer_preload_timer1       0x00000000U

#define MSK_NX51_xpic_timer_preload_timer1_val         0xffffffffU
#define SRT_NX51_xpic_timer_preload_timer1_val         0
#define DFLT_VAL_NX51_xpic_timer_preload_timer1_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_preload_timer1_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_preload_timer1': */
#define MSK_USED_BITS_NX51_xpic_timer_preload_timer1 0xffffffffU

enum {
	BFW_NX51_xpic_timer_preload_timer1_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_PRELOAD_TIMER1_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_preload_timer1_val; /*  preload value */
} NX51_XPIC_TIMER_PRELOAD_TIMER1_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_XPIC_TIMER_PRELOAD_TIMER1_BIT_T bf;
} NX51_XPIC_TIMER_PRELOAD_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_preload_timer2 */
/* => xPIC TIMER Timer 2 preload */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_preload_timer2        0x00000014U
#define Adr_NX51_xpic_timer_xpic_timer_preload_timer2 0x10140894U
#define Adr_NX51_xpic_timer_preload_timer2            0x10140894U
#define DFLT_VAL_NX51_xpic_timer_preload_timer2       0x00000000U

#define MSK_NX51_xpic_timer_preload_timer2_val         0xffffffffU
#define SRT_NX51_xpic_timer_preload_timer2_val         0
#define DFLT_VAL_NX51_xpic_timer_preload_timer2_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_preload_timer2_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_preload_timer2': */
#define MSK_USED_BITS_NX51_xpic_timer_preload_timer2 0xffffffffU

enum {
	BFW_NX51_xpic_timer_preload_timer2_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_PRELOAD_TIMER2_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_preload_timer2_val; /* preload value */
} NX51_XPIC_TIMER_PRELOAD_TIMER2_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_XPIC_TIMER_PRELOAD_TIMER2_BIT_T bf;
} NX51_XPIC_TIMER_PRELOAD_TIMER2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_timer0 */
/* => xPIC TIMER Timer 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_timer0        0x00000018U
#define Adr_NX51_xpic_timer_xpic_timer_timer0 0x10140898U
#define Adr_NX51_xpic_timer_timer0            0x10140898U
#define DFLT_VAL_NX51_xpic_timer_timer0       0x00000000U

#define MSK_NX51_xpic_timer_timer0_val         0xffffffffU
#define SRT_NX51_xpic_timer_timer0_val         0
#define DFLT_VAL_NX51_xpic_timer_timer0_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_timer0_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_timer0': */
#define MSK_USED_BITS_NX51_xpic_timer_timer0 0xffffffffU

enum {
	BFW_NX51_xpic_timer_timer0_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_TIMER0_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_timer0_val; /* actual value of timer / systime compare value */
} NX51_XPIC_TIMER_TIMER0_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_TIMER_TIMER0_BIT_T bf;
} NX51_XPIC_TIMER_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_timer1 */
/* => xPIC TIMER Timer 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_timer1        0x0000001CU
#define Adr_NX51_xpic_timer_xpic_timer_timer1 0x1014089CU
#define Adr_NX51_xpic_timer_timer1            0x1014089CU
#define DFLT_VAL_NX51_xpic_timer_timer1       0x00000000U

#define MSK_NX51_xpic_timer_timer1_val         0xffffffffU
#define SRT_NX51_xpic_timer_timer1_val         0
#define DFLT_VAL_NX51_xpic_timer_timer1_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_timer1_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_timer1': */
#define MSK_USED_BITS_NX51_xpic_timer_timer1 0xffffffffU

enum {
	BFW_NX51_xpic_timer_timer1_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_TIMER1_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_timer1_val; /* actual value of timer / systime compare value */
} NX51_XPIC_TIMER_TIMER1_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_TIMER_TIMER1_BIT_T bf;
} NX51_XPIC_TIMER_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_timer2 */
/* => xPIC TIMER Timer 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_timer2        0x00000020U
#define Adr_NX51_xpic_timer_xpic_timer_timer2 0x101408A0U
#define Adr_NX51_xpic_timer_timer2            0x101408A0U
#define DFLT_VAL_NX51_xpic_timer_timer2       0x00000000U

#define MSK_NX51_xpic_timer_timer2_val         0xffffffffU
#define SRT_NX51_xpic_timer_timer2_val         0
#define DFLT_VAL_NX51_xpic_timer_timer2_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_timer2_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_timer2': */
#define MSK_USED_BITS_NX51_xpic_timer_timer2 0xffffffffU

enum {
	BFW_NX51_xpic_timer_timer2_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_TIMER2_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_timer2_val; /* actual value of timer / systime compare value */
} NX51_XPIC_TIMER_TIMER2_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_TIMER_TIMER2_BIT_T bf;
} NX51_XPIC_TIMER_TIMER2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_irq_raw */
/* => xPIC_TIMER Raw IRQ register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_irq_raw        0x00000024U
#define Adr_NX51_xpic_timer_xpic_timer_irq_raw 0x101408A4U
#define Adr_NX51_xpic_timer_irq_raw            0x101408A4U
#define DFLT_VAL_NX51_xpic_timer_irq_raw       0x00000000U

#define MSK_NX51_xpic_timer_irq_raw_timer0_irq               0x00000001U
#define SRT_NX51_xpic_timer_irq_raw_timer0_irq               0
#define DFLT_VAL_NX51_xpic_timer_irq_raw_timer0_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_raw_timer0_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_raw_timer1_irq               0x00000002U
#define SRT_NX51_xpic_timer_irq_raw_timer1_irq               1
#define DFLT_VAL_NX51_xpic_timer_irq_raw_timer1_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_raw_timer1_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_raw_timer2_irq               0x00000004U
#define SRT_NX51_xpic_timer_irq_raw_timer2_irq               2
#define DFLT_VAL_NX51_xpic_timer_irq_raw_timer2_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_raw_timer2_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_raw_systime_s_irq            0x00000008U
#define SRT_NX51_xpic_timer_irq_raw_systime_s_irq            3
#define DFLT_VAL_NX51_xpic_timer_irq_raw_systime_s_irq       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_raw_systime_s_irq    0x00000000U
#define MSK_NX51_xpic_timer_irq_raw_systime_uc_s_irq         0x00000010U
#define SRT_NX51_xpic_timer_irq_raw_systime_uc_s_irq         4
#define DFLT_VAL_NX51_xpic_timer_irq_raw_systime_uc_s_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_raw_systime_uc_s_irq 0x00000000U

/* all used bits of 'NX51_xpic_timer_irq_raw': */
#define MSK_USED_BITS_NX51_xpic_timer_irq_raw 0x0000001fU

enum {
	BFW_NX51_xpic_timer_irq_raw_timer0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_timer_irq_raw_timer1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_timer_irq_raw_timer2_irq       = 1,  /* [2] */
	BFW_NX51_xpic_timer_irq_raw_systime_s_irq    = 1,  /* [3] */
	BFW_NX51_xpic_timer_irq_raw_systime_uc_s_irq = 1,  /* [4] */
	BFW_NX51_xpic_timer_irq_raw_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_TIMER_IRQ_RAW_BIT_Ttag {
	unsigned int timer0_irq       : BFW_NX51_xpic_timer_irq_raw_timer0_irq;       /* Timer 0 Interrupt      */
	unsigned int timer1_irq       : BFW_NX51_xpic_timer_irq_raw_timer1_irq;       /* Timer 1 Interrupt      */
	unsigned int timer2_irq       : BFW_NX51_xpic_timer_irq_raw_timer2_irq;       /* Timer 2 Interrupt      */
	unsigned int systime_s_irq    : BFW_NX51_xpic_timer_irq_raw_systime_s_irq;    /* Systime_s Interrupt    */
	unsigned int systime_uc_s_irq : BFW_NX51_xpic_timer_irq_raw_systime_uc_s_irq; /* Systime_uc_s Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_timer_irq_raw_reserved1;        /* reserved               */
} NX51_XPIC_TIMER_IRQ_RAW_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XPIC_TIMER_IRQ_RAW_BIT_T bf;
} NX51_XPIC_TIMER_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_irq_masked */
/* => xPIC_TIMER Masked IRQ register: */
/*    Shows status of masked IRQs (as connected to xPIC) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_irq_masked        0x00000028U
#define Adr_NX51_xpic_timer_xpic_timer_irq_masked 0x101408A8U
#define Adr_NX51_xpic_timer_irq_masked            0x101408A8U

#define MSK_NX51_xpic_timer_irq_masked_timer0_irq       0x00000001U
#define SRT_NX51_xpic_timer_irq_masked_timer0_irq       0
#define MSK_NX51_xpic_timer_irq_masked_timer1_irq       0x00000002U
#define SRT_NX51_xpic_timer_irq_masked_timer1_irq       1
#define MSK_NX51_xpic_timer_irq_masked_timer2_irq       0x00000004U
#define SRT_NX51_xpic_timer_irq_masked_timer2_irq       2
#define MSK_NX51_xpic_timer_irq_masked_systime_s_irq    0x00000008U
#define SRT_NX51_xpic_timer_irq_masked_systime_s_irq    3
#define MSK_NX51_xpic_timer_irq_masked_systime_uc_s_irq 0x00000010U
#define SRT_NX51_xpic_timer_irq_masked_systime_uc_s_irq 4

/* all used bits of 'NX51_xpic_timer_irq_masked': */
#define MSK_USED_BITS_NX51_xpic_timer_irq_masked 0x0000001fU

enum {
	BFW_NX51_xpic_timer_irq_masked_timer0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_timer_irq_masked_timer1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_timer_irq_masked_timer2_irq       = 1,  /* [2] */
	BFW_NX51_xpic_timer_irq_masked_systime_s_irq    = 1,  /* [3] */
	BFW_NX51_xpic_timer_irq_masked_systime_uc_s_irq = 1,  /* [4] */
	BFW_NX51_xpic_timer_irq_masked_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_TIMER_IRQ_MASKED_BIT_Ttag {
	unsigned int timer0_irq       : BFW_NX51_xpic_timer_irq_masked_timer0_irq;       /* Timer 0 Interrupt      */
	unsigned int timer1_irq       : BFW_NX51_xpic_timer_irq_masked_timer1_irq;       /* Timer 1 Interrupt      */
	unsigned int timer2_irq       : BFW_NX51_xpic_timer_irq_masked_timer2_irq;       /* Timer 2 Interrupt      */
	unsigned int systime_s_irq    : BFW_NX51_xpic_timer_irq_masked_systime_s_irq;    /* Systime_s Interrupt    */
	unsigned int systime_uc_s_irq : BFW_NX51_xpic_timer_irq_masked_systime_uc_s_irq; /* Systime_uc_s Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_timer_irq_masked_reserved1;        /* reserved               */
} NX51_XPIC_TIMER_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_TIMER_IRQ_MASKED_BIT_T bf;
} NX51_XPIC_TIMER_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_irq_msk_set */
/* => xPIC_TIMER interrupt mask enable: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source) */
/*    Write access with '0' does not influence this bit */
/*    Read access shows actual interrupt mask */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_irq_msk_set        0x0000002CU
#define Adr_NX51_xpic_timer_xpic_timer_irq_msk_set 0x101408ACU
#define Adr_NX51_xpic_timer_irq_msk_set            0x101408ACU
#define DFLT_VAL_NX51_xpic_timer_irq_msk_set       0x00000000U

#define MSK_NX51_xpic_timer_irq_msk_set_timer0_irq               0x00000001U
#define SRT_NX51_xpic_timer_irq_msk_set_timer0_irq               0
#define DFLT_VAL_NX51_xpic_timer_irq_msk_set_timer0_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_set_timer0_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_set_timer1_irq               0x00000002U
#define SRT_NX51_xpic_timer_irq_msk_set_timer1_irq               1
#define DFLT_VAL_NX51_xpic_timer_irq_msk_set_timer1_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_set_timer1_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_set_timer2_irq               0x00000004U
#define SRT_NX51_xpic_timer_irq_msk_set_timer2_irq               2
#define DFLT_VAL_NX51_xpic_timer_irq_msk_set_timer2_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_set_timer2_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_set_systime_s_irq            0x00000008U
#define SRT_NX51_xpic_timer_irq_msk_set_systime_s_irq            3
#define DFLT_VAL_NX51_xpic_timer_irq_msk_set_systime_s_irq       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_set_systime_s_irq    0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_set_systime_uc_s_irq         0x00000010U
#define SRT_NX51_xpic_timer_irq_msk_set_systime_uc_s_irq         4
#define DFLT_VAL_NX51_xpic_timer_irq_msk_set_systime_uc_s_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_set_systime_uc_s_irq 0x00000000U

/* all used bits of 'NX51_xpic_timer_irq_msk_set': */
#define MSK_USED_BITS_NX51_xpic_timer_irq_msk_set 0x0000001fU

enum {
	BFW_NX51_xpic_timer_irq_msk_set_timer0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_timer_irq_msk_set_timer1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_timer_irq_msk_set_timer2_irq       = 1,  /* [2] */
	BFW_NX51_xpic_timer_irq_msk_set_systime_s_irq    = 1,  /* [3] */
	BFW_NX51_xpic_timer_irq_msk_set_systime_uc_s_irq = 1,  /* [4] */
	BFW_NX51_xpic_timer_irq_msk_set_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_TIMER_IRQ_MSK_SET_BIT_Ttag {
	unsigned int timer0_irq       : BFW_NX51_xpic_timer_irq_msk_set_timer0_irq;       /* Timer 0 Interrupt      */
	unsigned int timer1_irq       : BFW_NX51_xpic_timer_irq_msk_set_timer1_irq;       /* Timer 1 Interrupt      */
	unsigned int timer2_irq       : BFW_NX51_xpic_timer_irq_msk_set_timer2_irq;       /* Timer 2 Interrupt      */
	unsigned int systime_s_irq    : BFW_NX51_xpic_timer_irq_msk_set_systime_s_irq;    /* Systime_s Interrupt    */
	unsigned int systime_uc_s_irq : BFW_NX51_xpic_timer_irq_msk_set_systime_uc_s_irq; /* Systime_uc_s Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_timer_irq_msk_set_reserved1;        /* reserved               */
} NX51_XPIC_TIMER_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_TIMER_IRQ_MSK_SET_BIT_T bf;
} NX51_XPIC_TIMER_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_irq_msk_reset */
/* => xPIC_TIMER interrupt mask disable: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source) */
/*    Write access with '0' does not influence this bit */
/*    Read access shows actual interrupt mask */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_irq_msk_reset        0x00000030U
#define Adr_NX51_xpic_timer_xpic_timer_irq_msk_reset 0x101408B0U
#define Adr_NX51_xpic_timer_irq_msk_reset            0x101408B0U
#define DFLT_VAL_NX51_xpic_timer_irq_msk_reset       0x00000000U

#define MSK_NX51_xpic_timer_irq_msk_reset_timer0_irq               0x00000001U
#define SRT_NX51_xpic_timer_irq_msk_reset_timer0_irq               0
#define DFLT_VAL_NX51_xpic_timer_irq_msk_reset_timer0_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_reset_timer0_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_reset_timer1_irq               0x00000002U
#define SRT_NX51_xpic_timer_irq_msk_reset_timer1_irq               1
#define DFLT_VAL_NX51_xpic_timer_irq_msk_reset_timer1_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_reset_timer1_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_reset_timer2_irq               0x00000004U
#define SRT_NX51_xpic_timer_irq_msk_reset_timer2_irq               2
#define DFLT_VAL_NX51_xpic_timer_irq_msk_reset_timer2_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_reset_timer2_irq       0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_reset_systime_s_irq            0x00000008U
#define SRT_NX51_xpic_timer_irq_msk_reset_systime_s_irq            3
#define DFLT_VAL_NX51_xpic_timer_irq_msk_reset_systime_s_irq       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_reset_systime_s_irq    0x00000000U
#define MSK_NX51_xpic_timer_irq_msk_reset_systime_uc_s_irq         0x00000010U
#define SRT_NX51_xpic_timer_irq_msk_reset_systime_uc_s_irq         4
#define DFLT_VAL_NX51_xpic_timer_irq_msk_reset_systime_uc_s_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_irq_msk_reset_systime_uc_s_irq 0x00000000U

/* all used bits of 'NX51_xpic_timer_irq_msk_reset': */
#define MSK_USED_BITS_NX51_xpic_timer_irq_msk_reset 0x0000001fU

enum {
	BFW_NX51_xpic_timer_irq_msk_reset_timer0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_timer_irq_msk_reset_timer1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_timer_irq_msk_reset_timer2_irq       = 1,  /* [2] */
	BFW_NX51_xpic_timer_irq_msk_reset_systime_s_irq    = 1,  /* [3] */
	BFW_NX51_xpic_timer_irq_msk_reset_systime_uc_s_irq = 1,  /* [4] */
	BFW_NX51_xpic_timer_irq_msk_reset_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_TIMER_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int timer0_irq       : BFW_NX51_xpic_timer_irq_msk_reset_timer0_irq;       /* Timer 0 Interrupt      */
	unsigned int timer1_irq       : BFW_NX51_xpic_timer_irq_msk_reset_timer1_irq;       /* Timer 1 Interrupt      */
	unsigned int timer2_irq       : BFW_NX51_xpic_timer_irq_msk_reset_timer2_irq;       /* Timer 2 Interrupt      */
	unsigned int systime_s_irq    : BFW_NX51_xpic_timer_irq_msk_reset_systime_s_irq;    /* Systime_s Interrupt    */
	unsigned int systime_uc_s_irq : BFW_NX51_xpic_timer_irq_msk_reset_systime_uc_s_irq; /* Systime_uc_s Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_timer_irq_msk_reset_reserved1;        /* reserved               */
} NX51_XPIC_TIMER_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_TIMER_IRQ_MSK_RESET_BIT_T bf;
} NX51_XPIC_TIMER_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_systime_s */
/* => xPIC_TIMER upper SYSTIME register */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    This register should be dedicated to accesses via xPIC. */
/*    ARM software should access systime via arm_timer_systime_s. */
/*    Host software should access systime via DPM at systime_s. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_systime_s        0x00000034U
#define Adr_NX51_xpic_timer_xpic_timer_systime_s 0x101408B4U
#define Adr_NX51_xpic_timer_systime_s            0x101408B4U

#define MSK_NX51_xpic_timer_systime_s_val 0xffffffffU
#define SRT_NX51_xpic_timer_systime_s_val 0

/* all used bits of 'NX51_xpic_timer_systime_s': */
#define MSK_USED_BITS_NX51_xpic_timer_systime_s 0xffffffffU

enum {
	BFW_NX51_xpic_timer_systime_s_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_SYSTIME_S_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_systime_s_val; /* Systime high:                                               */
	                                                      /* Sample systime_ns at read access to systime_s.              */
	                                                      /* Value is incremented, if systime_ns reaches systime_border. */
} NX51_XPIC_TIMER_SYSTIME_S_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_XPIC_TIMER_SYSTIME_S_BIT_T bf;
} NX51_XPIC_TIMER_SYSTIME_S_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_systime_ns */
/* => xPIC_TIMER lower SYSTIME register */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    If no systime_s is read before (e.g. at 2nd read access of systime_ns), the actual value of systime_ns is read. */
/*    This register should be dedicated to accesses via xPIC. */
/*    ARM software should access systime via arm_timer_systime_ns. */
/*    Host software should access systime via DPM at systime_ns. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_systime_ns        0x00000038U
#define Adr_NX51_xpic_timer_xpic_timer_systime_ns 0x101408B8U
#define Adr_NX51_xpic_timer_systime_ns            0x101408B8U

#define MSK_NX51_xpic_timer_systime_ns_val 0xffffffffU
#define SRT_NX51_xpic_timer_systime_ns_val 0

/* all used bits of 'NX51_xpic_timer_systime_ns': */
#define MSK_USED_BITS_NX51_xpic_timer_systime_ns 0xffffffffU

enum {
	BFW_NX51_xpic_timer_systime_ns_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_SYSTIME_NS_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_systime_ns_val; /* Systime low:                                                        */
	                                                       /* Sample systime_ns at read access to systime_s.                      */
	                                                       /* Without sample read systime_s, read the actual value of systime_ns. */
} NX51_XPIC_TIMER_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_TIMER_SYSTIME_NS_BIT_T bf;
} NX51_XPIC_TIMER_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_compare_systime_s_value */
/* => xPIC_TIMER SYSTIME sec compare register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_compare_systime_s_value        0x0000003CU
#define Adr_NX51_xpic_timer_xpic_timer_compare_systime_s_value 0x101408BCU
#define Adr_NX51_xpic_timer_compare_systime_s_value            0x101408BCU
#define DFLT_VAL_NX51_xpic_timer_compare_systime_s_value       0x00000000U

#define MSK_NX51_xpic_timer_compare_systime_s_value_val         0xffffffffU
#define SRT_NX51_xpic_timer_compare_systime_s_value_val         0
#define DFLT_VAL_NX51_xpic_timer_compare_systime_s_value_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_compare_systime_s_value_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_compare_systime_s_value': */
#define MSK_USED_BITS_NX51_xpic_timer_compare_systime_s_value 0xffffffffU

enum {
	BFW_NX51_xpic_timer_compare_systime_s_value_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_COMPARE_SYSTIME_S_VALUE_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_compare_systime_s_value_val; /* Compare value with systime_s (seconds):             */
	                                                                    /* Systime_s_compare_irq is set, if systime_s matches. */
} NX51_XPIC_TIMER_COMPARE_SYSTIME_S_VALUE_BIT_T;

typedef union {
	unsigned int                                  val;
	NX51_XPIC_TIMER_COMPARE_SYSTIME_S_VALUE_BIT_T bf;
} NX51_XPIC_TIMER_COMPARE_SYSTIME_S_VALUE_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_systime_uc_s */
/* => xPIC_TIMER upper SYSTIME_UC register */
/*    To allow consistent values of systime_uc_s and systime_uc_ns, lower bits of systime_uc is latched to systime_uc_ns, when systime_uc_s is read. */
/*    This register should be dedicated to accesses via xPIC. */
/*    ARM software should access systime_uc via arm_timer_systime_uc_s. */
/*    Host software should access systime_uc via DPM at systime_uc_s. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_systime_uc_s        0x00000040U
#define Adr_NX51_xpic_timer_xpic_timer_systime_uc_s 0x101408C0U
#define Adr_NX51_xpic_timer_systime_uc_s            0x101408C0U

#define MSK_NX51_xpic_timer_systime_uc_s_val 0xffffffffU
#define SRT_NX51_xpic_timer_systime_uc_s_val 0

/* all used bits of 'NX51_xpic_timer_systime_uc_s': */
#define MSK_USED_BITS_NX51_xpic_timer_systime_uc_s 0xffffffffU

enum {
	BFW_NX51_xpic_timer_systime_uc_s_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_SYSTIME_UC_S_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_systime_uc_s_val; /* Systime_uc high:                                                  */
	                                                         /* Sample systime_uc_ns at read access to systime_uc_s.              */
	                                                         /* Value is incremented, if systime_uc_ns reaches systime_uc_border. */
} NX51_XPIC_TIMER_SYSTIME_UC_S_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_XPIC_TIMER_SYSTIME_UC_S_BIT_T bf;
} NX51_XPIC_TIMER_SYSTIME_UC_S_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_systime_uc_ns */
/* => xPIC_TIMER lower SYSTIME_UC register */
/*    To allow consistent values of systime_uc_s and systime_uc_ns, lower bits of systime_uc is latched to systime_uc_ns, when systime_uc_s is read. */
/*    If no systime_uc_s is read before (e.g. at 2nd read access of systime_uc_ns), the actual value of systime_uc_ns is read. */
/*    This register should be dedicated to accesses via xPIC. */
/*    ARM software should access systime_uc via arm_timer_systime_uc_ns. */
/*    Host software should access systime_uc via DPM at systime_uc_ns. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_systime_uc_ns        0x00000044U
#define Adr_NX51_xpic_timer_xpic_timer_systime_uc_ns 0x101408C4U
#define Adr_NX51_xpic_timer_systime_uc_ns            0x101408C4U

#define MSK_NX51_xpic_timer_systime_uc_ns_val 0xffffffffU
#define SRT_NX51_xpic_timer_systime_uc_ns_val 0

/* all used bits of 'NX51_xpic_timer_systime_uc_ns': */
#define MSK_USED_BITS_NX51_xpic_timer_systime_uc_ns 0xffffffffU

enum {
	BFW_NX51_xpic_timer_systime_uc_ns_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_SYSTIME_UC_NS_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_systime_uc_ns_val; /* Systime_uc low:                                                           */
	                                                          /* Sample systime_uc_ns at read access to systime_uc_s.                      */
	                                                          /* Without sample read systime_uc_s, read the actual value of systime_uc_ns. */
} NX51_XPIC_TIMER_SYSTIME_UC_NS_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_TIMER_SYSTIME_UC_NS_BIT_T bf;
} NX51_XPIC_TIMER_SYSTIME_UC_NS_T;

/* --------------------------------------------------------------------- */
/* Register xpic_timer_compare_systime_uc_s_value */
/* => xPIC_TIMER SYSTIME_UC sec compare register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_timer_compare_systime_uc_s_value        0x00000048U
#define Adr_NX51_xpic_timer_xpic_timer_compare_systime_uc_s_value 0x101408C8U
#define Adr_NX51_xpic_timer_compare_systime_uc_s_value            0x101408C8U
#define DFLT_VAL_NX51_xpic_timer_compare_systime_uc_s_value       0x00000000U

#define MSK_NX51_xpic_timer_compare_systime_uc_s_value_val         0xffffffffU
#define SRT_NX51_xpic_timer_compare_systime_uc_s_value_val         0
#define DFLT_VAL_NX51_xpic_timer_compare_systime_uc_s_value_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_timer_compare_systime_uc_s_value_val 0x00000000U

/* all used bits of 'NX51_xpic_timer_compare_systime_uc_s_value': */
#define MSK_USED_BITS_NX51_xpic_timer_compare_systime_uc_s_value 0xffffffffU

enum {
	BFW_NX51_xpic_timer_compare_systime_uc_s_value_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_TIMER_COMPARE_SYSTIME_UC_S_VALUE_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_timer_compare_systime_uc_s_value_val; /* Compare value with systime_uc_s (seconds):                */
	                                                                       /* systime_uc_s_compare_irq is set, if systime_uc_s matches. */
} NX51_XPIC_TIMER_COMPARE_SYSTIME_UC_S_VALUE_BIT_T;

typedef union {
	unsigned int                                     val;
	NX51_XPIC_TIMER_COMPARE_SYSTIME_UC_S_VALUE_BIT_T bf;
} NX51_XPIC_TIMER_COMPARE_SYSTIME_UC_S_VALUE_T;


/* ===================================================================== */

/* Area of xpic_vic */

/* ===================================================================== */

#define Addr_NX51_xpic_vic 0x10140900U

/* --------------------------------------------------------------------- */
/* Register xpic_vic_config */
/* => XPIC VIC Configuration register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_config      0x00000000U
#define Adr_NX51_xpic_vic_xpic_vic_config 0x10140900U
#define Adr_NX51_xpic_vic_config          0x10140900U
#define DFLT_VAL_NX51_xpic_vic_config     0x00000000U

#define MSK_NX51_xpic_vic_config_enable         0x00000001U
#define SRT_NX51_xpic_vic_config_enable         0
#define DFLT_VAL_NX51_xpic_vic_config_enable    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_config_enable 0x00000000U
#define MSK_NX51_xpic_vic_config_table          0x00000002U
#define SRT_NX51_xpic_vic_config_table          1
#define DFLT_VAL_NX51_xpic_vic_config_table     0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_config_table  0x00000000U

/* all used bits of 'NX51_xpic_vic_config': */
#define MSK_USED_BITS_NX51_xpic_vic_config 0x00000003U

enum {
	BFW_NX51_xpic_vic_config_enable    = 1,  /* [0] */
	BFW_NX51_xpic_vic_config_table     = 1,  /* [1] */
	BFW_NX51_xpic_vic_config_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_XPIC_VIC_CONFIG_BIT_Ttag {
	unsigned int enable    : BFW_NX51_xpic_vic_config_enable;    /* global enable of xPIC VIC (0: disable/ 1: enable)              */
	unsigned int table     : BFW_NX51_xpic_vic_config_table;     /* use far or near Table                                          */
	                                                             /* 0 = Base Pointer Addr for IRQ Jmp Table + (n*4) DWORD Table    */
	                                                             /* 1 = Base Pointer Addr for IRQ Jmp Table + (n*16) 4 DWORD Table */
	                                                             /* n = IRQ vector number                                          */
	unsigned int reserved1 : BFW_NX51_xpic_vic_config_reserved1; /* reserved                                                       */
} NX51_XPIC_VIC_CONFIG_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XPIC_VIC_CONFIG_BIT_T bf;
} NX51_XPIC_VIC_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_raw_intr0 */
/* => XPIC VIC Raw0 interrupt status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_raw_intr0      0x00000004U
#define Adr_NX51_xpic_vic_xpic_vic_raw_intr0 0x10140904U
#define Adr_NX51_xpic_vic_raw_intr0          0x10140904U

#define MSK_NX51_xpic_vic_raw_intr0_sw0        0x00000001U
#define SRT_NX51_xpic_vic_raw_intr0_sw0        0
#define MSK_NX51_xpic_vic_raw_intr0_timer0     0x00000002U
#define SRT_NX51_xpic_vic_raw_intr0_timer0     1
#define MSK_NX51_xpic_vic_raw_intr0_timer1     0x00000004U
#define SRT_NX51_xpic_vic_raw_intr0_timer1     2
#define MSK_NX51_xpic_vic_raw_intr0_gpio_timer 0x00000008U
#define SRT_NX51_xpic_vic_raw_intr0_gpio_timer 3
#define MSK_NX51_xpic_vic_raw_intr0_timer2     0x00000010U
#define SRT_NX51_xpic_vic_raw_intr0_timer2     4
#define MSK_NX51_xpic_vic_raw_intr0_systime_s  0x00000020U
#define SRT_NX51_xpic_vic_raw_intr0_systime_s  5
#define MSK_NX51_xpic_vic_raw_intr0_gpio31     0x00000040U
#define SRT_NX51_xpic_vic_raw_intr0_gpio31     6
#define MSK_NX51_xpic_vic_raw_intr0_watchdog   0x00000080U
#define SRT_NX51_xpic_vic_raw_intr0_watchdog   7
#define MSK_NX51_xpic_vic_raw_intr0_uart0      0x00000100U
#define SRT_NX51_xpic_vic_raw_intr0_uart0      8
#define MSK_NX51_xpic_vic_raw_intr0_uart1      0x00000200U
#define SRT_NX51_xpic_vic_raw_intr0_uart1      9
#define MSK_NX51_xpic_vic_raw_intr0_uart2      0x00000400U
#define SRT_NX51_xpic_vic_raw_intr0_uart2      10
#define MSK_NX51_xpic_vic_raw_intr0_usb        0x00000800U
#define SRT_NX51_xpic_vic_raw_intr0_usb        11
#define MSK_NX51_xpic_vic_raw_intr0_spi        0x00001000U
#define SRT_NX51_xpic_vic_raw_intr0_spi        12
#define MSK_NX51_xpic_vic_raw_intr0_i2c        0x00002000U
#define SRT_NX51_xpic_vic_raw_intr0_i2c        13
#define MSK_NX51_xpic_vic_raw_intr0_reserved14 0x00004000U
#define SRT_NX51_xpic_vic_raw_intr0_reserved14 14
#define MSK_NX51_xpic_vic_raw_intr0_hif        0x00008000U
#define SRT_NX51_xpic_vic_raw_intr0_hif        15
#define MSK_NX51_xpic_vic_raw_intr0_gpio       0x00010000U
#define SRT_NX51_xpic_vic_raw_intr0_gpio       16
#define MSK_NX51_xpic_vic_raw_intr0_com0       0x00020000U
#define SRT_NX51_xpic_vic_raw_intr0_com0       17
#define MSK_NX51_xpic_vic_raw_intr0_com1       0x00040000U
#define SRT_NX51_xpic_vic_raw_intr0_com1       18
#define MSK_NX51_xpic_vic_raw_intr0_com2       0x00080000U
#define SRT_NX51_xpic_vic_raw_intr0_com2       19
#define MSK_NX51_xpic_vic_raw_intr0_com3       0x00100000U
#define SRT_NX51_xpic_vic_raw_intr0_com3       20
#define MSK_NX51_xpic_vic_raw_intr0_msync0     0x00200000U
#define SRT_NX51_xpic_vic_raw_intr0_msync0     21
#define MSK_NX51_xpic_vic_raw_intr0_msync1     0x00400000U
#define SRT_NX51_xpic_vic_raw_intr0_msync1     22
#define MSK_NX51_xpic_vic_raw_intr0_msync2     0x00800000U
#define SRT_NX51_xpic_vic_raw_intr0_msync2     23
#define MSK_NX51_xpic_vic_raw_intr0_msync3     0x01000000U
#define SRT_NX51_xpic_vic_raw_intr0_msync3     24
#define MSK_NX51_xpic_vic_raw_intr0_int_phy    0x02000000U
#define SRT_NX51_xpic_vic_raw_intr0_int_phy    25
#define MSK_NX51_xpic_vic_raw_intr0_sysstate   0x04000000U
#define SRT_NX51_xpic_vic_raw_intr0_sysstate   26
#define MSK_NX51_xpic_vic_raw_intr0_dmac       0x08000000U
#define SRT_NX51_xpic_vic_raw_intr0_dmac       27
#define MSK_NX51_xpic_vic_raw_intr0_trigger_lt 0x10000000U
#define SRT_NX51_xpic_vic_raw_intr0_trigger_lt 28
#define MSK_NX51_xpic_vic_raw_intr0_can        0x20000000U
#define SRT_NX51_xpic_vic_raw_intr0_can        29
#define MSK_NX51_xpic_vic_raw_intr0_osac       0x40000000U
#define SRT_NX51_xpic_vic_raw_intr0_osac       30
#define MSK_NX51_xpic_vic_raw_intr0_reserved31 0x80000000U
#define SRT_NX51_xpic_vic_raw_intr0_reserved31 31

/* all used bits of 'NX51_xpic_vic_raw_intr0': */
#define MSK_USED_BITS_NX51_xpic_vic_raw_intr0 0xffffffffU

enum {
	BFW_NX51_xpic_vic_raw_intr0_sw0        = 1, /* [0] */
	BFW_NX51_xpic_vic_raw_intr0_timer0     = 1, /* [1] */
	BFW_NX51_xpic_vic_raw_intr0_timer1     = 1, /* [2] */
	BFW_NX51_xpic_vic_raw_intr0_gpio_timer = 1, /* [3] */
	BFW_NX51_xpic_vic_raw_intr0_timer2     = 1, /* [4] */
	BFW_NX51_xpic_vic_raw_intr0_systime_s  = 1, /* [5] */
	BFW_NX51_xpic_vic_raw_intr0_gpio31     = 1, /* [6] */
	BFW_NX51_xpic_vic_raw_intr0_watchdog   = 1, /* [7] */
	BFW_NX51_xpic_vic_raw_intr0_uart0      = 1, /* [8] */
	BFW_NX51_xpic_vic_raw_intr0_uart1      = 1, /* [9] */
	BFW_NX51_xpic_vic_raw_intr0_uart2      = 1, /* [10] */
	BFW_NX51_xpic_vic_raw_intr0_usb        = 1, /* [11] */
	BFW_NX51_xpic_vic_raw_intr0_spi        = 1, /* [12] */
	BFW_NX51_xpic_vic_raw_intr0_i2c        = 1, /* [13] */
	BFW_NX51_xpic_vic_raw_intr0_reserved14 = 1, /* [14] */
	BFW_NX51_xpic_vic_raw_intr0_hif        = 1, /* [15] */
	BFW_NX51_xpic_vic_raw_intr0_gpio       = 1, /* [16] */
	BFW_NX51_xpic_vic_raw_intr0_com0       = 1, /* [17] */
	BFW_NX51_xpic_vic_raw_intr0_com1       = 1, /* [18] */
	BFW_NX51_xpic_vic_raw_intr0_com2       = 1, /* [19] */
	BFW_NX51_xpic_vic_raw_intr0_com3       = 1, /* [20] */
	BFW_NX51_xpic_vic_raw_intr0_msync0     = 1, /* [21] */
	BFW_NX51_xpic_vic_raw_intr0_msync1     = 1, /* [22] */
	BFW_NX51_xpic_vic_raw_intr0_msync2     = 1, /* [23] */
	BFW_NX51_xpic_vic_raw_intr0_msync3     = 1, /* [24] */
	BFW_NX51_xpic_vic_raw_intr0_int_phy    = 1, /* [25] */
	BFW_NX51_xpic_vic_raw_intr0_sysstate   = 1, /* [26] */
	BFW_NX51_xpic_vic_raw_intr0_dmac       = 1, /* [27] */
	BFW_NX51_xpic_vic_raw_intr0_trigger_lt = 1, /* [28] */
	BFW_NX51_xpic_vic_raw_intr0_can        = 1, /* [29] */
	BFW_NX51_xpic_vic_raw_intr0_osac       = 1, /* [30] */
	BFW_NX51_xpic_vic_raw_intr0_reserved31 = 1  /* [31] */
};

typedef struct NX51_XPIC_VIC_RAW_INTR0_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_xpic_vic_raw_intr0_sw0;        /* Reserved for Software Interrupt                                                          */
	unsigned int timer0     : BFW_NX51_xpic_vic_raw_intr0_timer0;     /* xPIC Timer0 from XPIC_TIMER Module                                                       */
	                                                                  /* Real time operating system timer, Windows CE required                                    */
	unsigned int timer1     : BFW_NX51_xpic_vic_raw_intr0_timer1;     /* xPIC Timer1 from XPIC_TIMER Module                                                       */
	unsigned int gpio_timer : BFW_NX51_xpic_vic_raw_intr0_gpio_timer; /* GPIO Timer0-4                                                                            */
	                                                                  /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion))                    */
	unsigned int timer2     : BFW_NX51_xpic_vic_raw_intr0_timer2;     /* xPIC Timer2 from XPIC_TIMER Module                                                       */
	unsigned int systime_s  : BFW_NX51_xpic_vic_raw_intr0_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                                         */
	unsigned int gpio31     : BFW_NX51_xpic_vic_raw_intr0_gpio31;     /* external interrupt 31, Windows CE required (NMI)                                         */
	unsigned int watchdog   : BFW_NX51_xpic_vic_raw_intr0_watchdog;   /* Watchdog IRQ from XPIC_WDG module                                                        */
	unsigned int uart0      : BFW_NX51_xpic_vic_raw_intr0_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                                        */
	unsigned int uart1      : BFW_NX51_xpic_vic_raw_intr0_uart1;      /* UART 1                                                                                   */
	unsigned int uart2      : BFW_NX51_xpic_vic_raw_intr0_uart2;      /* UART 2                                                                                   */
	unsigned int usb        : BFW_NX51_xpic_vic_raw_intr0_usb;        /* USB interrupt                                                                            */
	unsigned int spi        : BFW_NX51_xpic_vic_raw_intr0_spi;        /* combined SPI0, SPI1 interrupt                                                            */
	unsigned int i2c        : BFW_NX51_xpic_vic_raw_intr0_i2c;        /* combined I2C0, I2C1 interrupt                                                            */
	unsigned int reserved14 : BFW_NX51_xpic_vic_raw_intr0_reserved14; /* reserved for netX compatibility (LCD)                                                    */
	unsigned int hif        : BFW_NX51_xpic_vic_raw_intr0_hif;        /* combined HIF interrupt: DPM, Handshake-Cells (HANDSHAKE_CTRL) and HIF PIOs (HIF_IO_CTRL) */
	unsigned int gpio       : BFW_NX51_xpic_vic_raw_intr0_gpio;       /* Other external Interrupts from GPIO 0-30 / IOLINK                                        */
	unsigned int com0       : BFW_NX51_xpic_vic_raw_intr0_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                                             */
	unsigned int com1       : BFW_NX51_xpic_vic_raw_intr0_com1;       /* Communication channel 1 (= |xpec0_irq[11:0])                                             */
	unsigned int com2       : BFW_NX51_xpic_vic_raw_intr0_com2;       /* reserved for netX compatibility (com2)                                                   */
	unsigned int com3       : BFW_NX51_xpic_vic_raw_intr0_com3;       /* reserved  (com3)                                                                         */
	unsigned int msync0     : BFW_NX51_xpic_vic_raw_intr0_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                                   */
	unsigned int msync1     : BFW_NX51_xpic_vic_raw_intr0_msync1;     /* Motion synchronization channel 1 (= |xpec0_irq[15:12])                                   */
	unsigned int msync2     : BFW_NX51_xpic_vic_raw_intr0_msync2;     /* reserved for netX compatibility (msync2)                                                 */
	unsigned int msync3     : BFW_NX51_xpic_vic_raw_intr0_msync3;     /* reserved for SW IRQ from ARM to xPIC                                                     */
	unsigned int int_phy    : BFW_NX51_xpic_vic_raw_intr0_int_phy;    /* Interrupt from internal Phy                                                              */
	unsigned int sysstate   : BFW_NX51_xpic_vic_raw_intr0_sysstate;   /* License error or extmem_timeout                                                          */
	unsigned int dmac       : BFW_NX51_xpic_vic_raw_intr0_dmac;       /* DMA controller                                                                           */
	unsigned int trigger_lt : BFW_NX51_xpic_vic_raw_intr0_trigger_lt; /* trigger_lt                                                                               */
	unsigned int can        : BFW_NX51_xpic_vic_raw_intr0_can;        /* CAN IRQ                                                                                  */
	unsigned int osac       : BFW_NX51_xpic_vic_raw_intr0_osac;       /* OSAC nfifo or scheduler                                                                  */
	unsigned int reserved31 : BFW_NX51_xpic_vic_raw_intr0_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                                         */
} NX51_XPIC_VIC_RAW_INTR0_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XPIC_VIC_RAW_INTR0_BIT_T bf;
} NX51_XPIC_VIC_RAW_INTR0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_raw_intr1 */
/* => XPIC VIC Raw1 interrupt status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_raw_intr1      0x00000008U
#define Adr_NX51_xpic_vic_xpic_vic_raw_intr1 0x10140908U
#define Adr_NX51_xpic_vic_raw_intr1          0x10140908U

#define MSK_NX51_xpic_vic_raw_intr1_gpio7          0x00000001U
#define SRT_NX51_xpic_vic_raw_intr1_gpio7          0
#define MSK_NX51_xpic_vic_raw_intr1_gpio8          0x00000002U
#define SRT_NX51_xpic_vic_raw_intr1_gpio8          1
#define MSK_NX51_xpic_vic_raw_intr1_gpio9          0x00000004U
#define SRT_NX51_xpic_vic_raw_intr1_gpio9          2
#define MSK_NX51_xpic_vic_raw_intr1_gpio10         0x00000008U
#define SRT_NX51_xpic_vic_raw_intr1_gpio10         3
#define MSK_NX51_xpic_vic_raw_intr1_gpio11         0x00000010U
#define SRT_NX51_xpic_vic_raw_intr1_gpio11         4
#define MSK_NX51_xpic_vic_raw_intr1_gpio12         0x00000020U
#define SRT_NX51_xpic_vic_raw_intr1_gpio12         5
#define MSK_NX51_xpic_vic_raw_intr1_gpio13         0x00000040U
#define SRT_NX51_xpic_vic_raw_intr1_gpio13         6
#define MSK_NX51_xpic_vic_raw_intr1_gpio14         0x00000080U
#define SRT_NX51_xpic_vic_raw_intr1_gpio14         7
#define MSK_NX51_xpic_vic_raw_intr1_gpio15         0x00000100U
#define SRT_NX51_xpic_vic_raw_intr1_gpio15         8
#define MSK_NX51_xpic_vic_raw_intr1_gpio16         0x00000200U
#define SRT_NX51_xpic_vic_raw_intr1_gpio16         9
#define MSK_NX51_xpic_vic_raw_intr1_gpio_timer2    0x00000400U
#define SRT_NX51_xpic_vic_raw_intr1_gpio_timer2    10
#define MSK_NX51_xpic_vic_raw_intr1_gpio_timer3    0x00000800U
#define SRT_NX51_xpic_vic_raw_intr1_gpio_timer3    11
#define MSK_NX51_xpic_vic_raw_intr1_gpio_timer4    0x00001000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio_timer4    12
#define MSK_NX51_xpic_vic_raw_intr1_spi0           0x00002000U
#define SRT_NX51_xpic_vic_raw_intr1_spi0           13
#define MSK_NX51_xpic_vic_raw_intr1_spi1           0x00004000U
#define SRT_NX51_xpic_vic_raw_intr1_spi1           14
#define MSK_NX51_xpic_vic_raw_intr1_gpio_timer0    0x00008000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio_timer0    15
#define MSK_NX51_xpic_vic_raw_intr1_gpio_timer1    0x00010000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio_timer1    16
#define MSK_NX51_xpic_vic_raw_intr1_gpio0          0x00020000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio0          17
#define MSK_NX51_xpic_vic_raw_intr1_gpio1          0x00040000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio1          18
#define MSK_NX51_xpic_vic_raw_intr1_gpio2          0x00080000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio2          19
#define MSK_NX51_xpic_vic_raw_intr1_gpio3          0x00100000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio3          20
#define MSK_NX51_xpic_vic_raw_intr1_gpio4          0x00200000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio4          21
#define MSK_NX51_xpic_vic_raw_intr1_gpio5          0x00400000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio5          22
#define MSK_NX51_xpic_vic_raw_intr1_gpio6          0x00800000U
#define SRT_NX51_xpic_vic_raw_intr1_gpio6          23
#define MSK_NX51_xpic_vic_raw_intr1_reserved24     0x01000000U
#define SRT_NX51_xpic_vic_raw_intr1_reserved24     24
#define MSK_NX51_xpic_vic_raw_intr1_reserved25     0x02000000U
#define SRT_NX51_xpic_vic_raw_intr1_reserved25     25
#define MSK_NX51_xpic_vic_raw_intr1_reserved26     0x04000000U
#define SRT_NX51_xpic_vic_raw_intr1_reserved26     26
#define MSK_NX51_xpic_vic_raw_intr1_reserved27     0x08000000U
#define SRT_NX51_xpic_vic_raw_intr1_reserved27     27
#define MSK_NX51_xpic_vic_raw_intr1_eth            0x10000000U
#define SRT_NX51_xpic_vic_raw_intr1_eth            28
#define MSK_NX51_xpic_vic_raw_intr1_osac_nfifo     0x20000000U
#define SRT_NX51_xpic_vic_raw_intr1_osac_nfifo     29
#define MSK_NX51_xpic_vic_raw_intr1_osac_scheduler 0x40000000U
#define SRT_NX51_xpic_vic_raw_intr1_osac_scheduler 30
#define MSK_NX51_xpic_vic_raw_intr1_misalign       0x80000000U
#define SRT_NX51_xpic_vic_raw_intr1_misalign       31

/* all used bits of 'NX51_xpic_vic_raw_intr1': */
#define MSK_USED_BITS_NX51_xpic_vic_raw_intr1 0xffffffffU

enum {
	BFW_NX51_xpic_vic_raw_intr1_gpio7          = 1, /* [0] */
	BFW_NX51_xpic_vic_raw_intr1_gpio8          = 1, /* [1] */
	BFW_NX51_xpic_vic_raw_intr1_gpio9          = 1, /* [2] */
	BFW_NX51_xpic_vic_raw_intr1_gpio10         = 1, /* [3] */
	BFW_NX51_xpic_vic_raw_intr1_gpio11         = 1, /* [4] */
	BFW_NX51_xpic_vic_raw_intr1_gpio12         = 1, /* [5] */
	BFW_NX51_xpic_vic_raw_intr1_gpio13         = 1, /* [6] */
	BFW_NX51_xpic_vic_raw_intr1_gpio14         = 1, /* [7] */
	BFW_NX51_xpic_vic_raw_intr1_gpio15         = 1, /* [8] */
	BFW_NX51_xpic_vic_raw_intr1_gpio16         = 1, /* [9] */
	BFW_NX51_xpic_vic_raw_intr1_gpio_timer2    = 1, /* [10] */
	BFW_NX51_xpic_vic_raw_intr1_gpio_timer3    = 1, /* [11] */
	BFW_NX51_xpic_vic_raw_intr1_gpio_timer4    = 1, /* [12] */
	BFW_NX51_xpic_vic_raw_intr1_spi0           = 1, /* [13] */
	BFW_NX51_xpic_vic_raw_intr1_spi1           = 1, /* [14] */
	BFW_NX51_xpic_vic_raw_intr1_gpio_timer0    = 1, /* [15] */
	BFW_NX51_xpic_vic_raw_intr1_gpio_timer1    = 1, /* [16] */
	BFW_NX51_xpic_vic_raw_intr1_gpio0          = 1, /* [17] */
	BFW_NX51_xpic_vic_raw_intr1_gpio1          = 1, /* [18] */
	BFW_NX51_xpic_vic_raw_intr1_gpio2          = 1, /* [19] */
	BFW_NX51_xpic_vic_raw_intr1_gpio3          = 1, /* [20] */
	BFW_NX51_xpic_vic_raw_intr1_gpio4          = 1, /* [21] */
	BFW_NX51_xpic_vic_raw_intr1_gpio5          = 1, /* [22] */
	BFW_NX51_xpic_vic_raw_intr1_gpio6          = 1, /* [23] */
	BFW_NX51_xpic_vic_raw_intr1_reserved24     = 1, /* [24] */
	BFW_NX51_xpic_vic_raw_intr1_reserved25     = 1, /* [25] */
	BFW_NX51_xpic_vic_raw_intr1_reserved26     = 1, /* [26] */
	BFW_NX51_xpic_vic_raw_intr1_reserved27     = 1, /* [27] */
	BFW_NX51_xpic_vic_raw_intr1_eth            = 1, /* [28] */
	BFW_NX51_xpic_vic_raw_intr1_osac_nfifo     = 1, /* [29] */
	BFW_NX51_xpic_vic_raw_intr1_osac_scheduler = 1, /* [30] */
	BFW_NX51_xpic_vic_raw_intr1_misalign       = 1  /* [31] */
};

typedef struct NX51_XPIC_VIC_RAW_INTR1_BIT_Ttag {
	unsigned int gpio7          : BFW_NX51_xpic_vic_raw_intr1_gpio7;          /* gpio7                  */
	unsigned int gpio8          : BFW_NX51_xpic_vic_raw_intr1_gpio8;          /* gpio8                  */
	unsigned int gpio9          : BFW_NX51_xpic_vic_raw_intr1_gpio9;          /* gpio9                  */
	unsigned int gpio10         : BFW_NX51_xpic_vic_raw_intr1_gpio10;         /* gpio10                 */
	unsigned int gpio11         : BFW_NX51_xpic_vic_raw_intr1_gpio11;         /* gpio11                 */
	unsigned int gpio12         : BFW_NX51_xpic_vic_raw_intr1_gpio12;         /* gpio12                 */
	unsigned int gpio13         : BFW_NX51_xpic_vic_raw_intr1_gpio13;         /* gpio13                 */
	unsigned int gpio14         : BFW_NX51_xpic_vic_raw_intr1_gpio14;         /* gpio14                 */
	unsigned int gpio15         : BFW_NX51_xpic_vic_raw_intr1_gpio15;         /* gpio15                 */
	unsigned int gpio16         : BFW_NX51_xpic_vic_raw_intr1_gpio16;         /* gpio16                 */
	unsigned int gpio_timer2    : BFW_NX51_xpic_vic_raw_intr1_gpio_timer2;    /* gpio_timer2            */
	unsigned int gpio_timer3    : BFW_NX51_xpic_vic_raw_intr1_gpio_timer3;    /* gpio_timer3            */
	unsigned int gpio_timer4    : BFW_NX51_xpic_vic_raw_intr1_gpio_timer4;    /* gpio_timer4            */
	unsigned int spi0           : BFW_NX51_xpic_vic_raw_intr1_spi0;           /* spi0                   */
	unsigned int spi1           : BFW_NX51_xpic_vic_raw_intr1_spi1;           /* spi1                   */
	unsigned int gpio_timer0    : BFW_NX51_xpic_vic_raw_intr1_gpio_timer0;    /* gpio_timer0            */
	unsigned int gpio_timer1    : BFW_NX51_xpic_vic_raw_intr1_gpio_timer1;    /* gpio_timer1            */
	unsigned int gpio0          : BFW_NX51_xpic_vic_raw_intr1_gpio0;          /* gpio0                  */
	unsigned int gpio1          : BFW_NX51_xpic_vic_raw_intr1_gpio1;          /* gpio1                  */
	unsigned int gpio2          : BFW_NX51_xpic_vic_raw_intr1_gpio2;          /* gpio2                  */
	unsigned int gpio3          : BFW_NX51_xpic_vic_raw_intr1_gpio3;          /* gpio3                  */
	unsigned int gpio4          : BFW_NX51_xpic_vic_raw_intr1_gpio4;          /* gpio4                  */
	unsigned int gpio5          : BFW_NX51_xpic_vic_raw_intr1_gpio5;          /* gpio5                  */
	unsigned int gpio6          : BFW_NX51_xpic_vic_raw_intr1_gpio6;          /* gpio6                  */
	unsigned int reserved24     : BFW_NX51_xpic_vic_raw_intr1_reserved24;     /* reserved               */
	unsigned int reserved25     : BFW_NX51_xpic_vic_raw_intr1_reserved25;     /* reserved               */
	unsigned int reserved26     : BFW_NX51_xpic_vic_raw_intr1_reserved26;     /* reserved               */
	unsigned int reserved27     : BFW_NX51_xpic_vic_raw_intr1_reserved27;     /* reserved               */
	unsigned int eth            : BFW_NX51_xpic_vic_raw_intr1_eth;            /* ETH module             */
	unsigned int osac_nfifo     : BFW_NX51_xpic_vic_raw_intr1_osac_nfifo;     /* osac_nfifo             */
	unsigned int osac_scheduler : BFW_NX51_xpic_vic_raw_intr1_osac_scheduler; /* osac_scheduler         */
	unsigned int misalign       : BFW_NX51_xpic_vic_raw_intr1_misalign;       /* xPIC data misalignment */
} NX51_XPIC_VIC_RAW_INTR1_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XPIC_VIC_RAW_INTR1_BIT_T bf;
} NX51_XPIC_VIC_RAW_INTR1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint0_set */
/* => XPIC VIC Software0 interrupt set register: */
/*    Read status or set IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_softint0_set      0x0000000CU
#define Adr_NX51_xpic_vic_xpic_vic_softint0_set 0x1014090CU
#define Adr_NX51_xpic_vic_softint0_set          0x1014090CU
#define DFLT_VAL_NX51_xpic_vic_softint0_set     0x00000000U

#define MSK_NX51_xpic_vic_softint0_set_sw0                0x00000001U
#define SRT_NX51_xpic_vic_softint0_set_sw0                0
#define DFLT_VAL_NX51_xpic_vic_softint0_set_sw0           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_sw0        0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_timer0             0x00000002U
#define SRT_NX51_xpic_vic_softint0_set_timer0             1
#define DFLT_VAL_NX51_xpic_vic_softint0_set_timer0        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_timer0     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_timer1             0x00000004U
#define SRT_NX51_xpic_vic_softint0_set_timer1             2
#define DFLT_VAL_NX51_xpic_vic_softint0_set_timer1        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_timer1     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_gpio_timer         0x00000008U
#define SRT_NX51_xpic_vic_softint0_set_gpio_timer         3
#define DFLT_VAL_NX51_xpic_vic_softint0_set_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_gpio_timer 0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_timer2             0x00000010U
#define SRT_NX51_xpic_vic_softint0_set_timer2             4
#define DFLT_VAL_NX51_xpic_vic_softint0_set_timer2        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_timer2     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_systime_s          0x00000020U
#define SRT_NX51_xpic_vic_softint0_set_systime_s          5
#define DFLT_VAL_NX51_xpic_vic_softint0_set_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_systime_s  0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_gpio31             0x00000040U
#define SRT_NX51_xpic_vic_softint0_set_gpio31             6
#define DFLT_VAL_NX51_xpic_vic_softint0_set_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_gpio31     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_watchdog           0x00000080U
#define SRT_NX51_xpic_vic_softint0_set_watchdog           7
#define DFLT_VAL_NX51_xpic_vic_softint0_set_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_watchdog   0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_uart0              0x00000100U
#define SRT_NX51_xpic_vic_softint0_set_uart0              8
#define DFLT_VAL_NX51_xpic_vic_softint0_set_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_uart0      0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_uart1              0x00000200U
#define SRT_NX51_xpic_vic_softint0_set_uart1              9
#define DFLT_VAL_NX51_xpic_vic_softint0_set_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_uart1      0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_uart2              0x00000400U
#define SRT_NX51_xpic_vic_softint0_set_uart2              10
#define DFLT_VAL_NX51_xpic_vic_softint0_set_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_uart2      0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_usb                0x00000800U
#define SRT_NX51_xpic_vic_softint0_set_usb                11
#define DFLT_VAL_NX51_xpic_vic_softint0_set_usb           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_usb        0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_spi                0x00001000U
#define SRT_NX51_xpic_vic_softint0_set_spi                12
#define DFLT_VAL_NX51_xpic_vic_softint0_set_spi           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_spi        0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_i2c                0x00002000U
#define SRT_NX51_xpic_vic_softint0_set_i2c                13
#define DFLT_VAL_NX51_xpic_vic_softint0_set_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_i2c        0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_reserved14         0x00004000U
#define SRT_NX51_xpic_vic_softint0_set_reserved14         14
#define DFLT_VAL_NX51_xpic_vic_softint0_set_reserved14    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_reserved14 0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_hif                0x00008000U
#define SRT_NX51_xpic_vic_softint0_set_hif                15
#define DFLT_VAL_NX51_xpic_vic_softint0_set_hif           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_hif        0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_gpio               0x00010000U
#define SRT_NX51_xpic_vic_softint0_set_gpio               16
#define DFLT_VAL_NX51_xpic_vic_softint0_set_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_gpio       0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_com0               0x00020000U
#define SRT_NX51_xpic_vic_softint0_set_com0               17
#define DFLT_VAL_NX51_xpic_vic_softint0_set_com0          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_com0       0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_com1               0x00040000U
#define SRT_NX51_xpic_vic_softint0_set_com1               18
#define DFLT_VAL_NX51_xpic_vic_softint0_set_com1          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_com1       0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_com2               0x00080000U
#define SRT_NX51_xpic_vic_softint0_set_com2               19
#define DFLT_VAL_NX51_xpic_vic_softint0_set_com2          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_com2       0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_com3               0x00100000U
#define SRT_NX51_xpic_vic_softint0_set_com3               20
#define DFLT_VAL_NX51_xpic_vic_softint0_set_com3          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_com3       0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_msync0             0x00200000U
#define SRT_NX51_xpic_vic_softint0_set_msync0             21
#define DFLT_VAL_NX51_xpic_vic_softint0_set_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_msync0     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_msync1             0x00400000U
#define SRT_NX51_xpic_vic_softint0_set_msync1             22
#define DFLT_VAL_NX51_xpic_vic_softint0_set_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_msync1     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_msync2             0x00800000U
#define SRT_NX51_xpic_vic_softint0_set_msync2             23
#define DFLT_VAL_NX51_xpic_vic_softint0_set_msync2        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_msync2     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_msync3             0x01000000U
#define SRT_NX51_xpic_vic_softint0_set_msync3             24
#define DFLT_VAL_NX51_xpic_vic_softint0_set_msync3        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_msync3     0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_int_phy            0x02000000U
#define SRT_NX51_xpic_vic_softint0_set_int_phy            25
#define DFLT_VAL_NX51_xpic_vic_softint0_set_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_int_phy    0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_sysstate           0x04000000U
#define SRT_NX51_xpic_vic_softint0_set_sysstate           26
#define DFLT_VAL_NX51_xpic_vic_softint0_set_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_sysstate   0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_dmac               0x08000000U
#define SRT_NX51_xpic_vic_softint0_set_dmac               27
#define DFLT_VAL_NX51_xpic_vic_softint0_set_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_dmac       0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_trigger_lt         0x10000000U
#define SRT_NX51_xpic_vic_softint0_set_trigger_lt         28
#define DFLT_VAL_NX51_xpic_vic_softint0_set_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_trigger_lt 0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_can                0x20000000U
#define SRT_NX51_xpic_vic_softint0_set_can                29
#define DFLT_VAL_NX51_xpic_vic_softint0_set_can           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_can        0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_osac               0x40000000U
#define SRT_NX51_xpic_vic_softint0_set_osac               30
#define DFLT_VAL_NX51_xpic_vic_softint0_set_osac          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_osac       0x00000000U
#define MSK_NX51_xpic_vic_softint0_set_reserved31         0x80000000U
#define SRT_NX51_xpic_vic_softint0_set_reserved31         31
#define DFLT_VAL_NX51_xpic_vic_softint0_set_reserved31    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_set_reserved31 0x00000000U

/* all used bits of 'NX51_xpic_vic_softint0_set': */
#define MSK_USED_BITS_NX51_xpic_vic_softint0_set 0xffffffffU

enum {
	BFW_NX51_xpic_vic_softint0_set_sw0        = 1, /* [0] */
	BFW_NX51_xpic_vic_softint0_set_timer0     = 1, /* [1] */
	BFW_NX51_xpic_vic_softint0_set_timer1     = 1, /* [2] */
	BFW_NX51_xpic_vic_softint0_set_gpio_timer = 1, /* [3] */
	BFW_NX51_xpic_vic_softint0_set_timer2     = 1, /* [4] */
	BFW_NX51_xpic_vic_softint0_set_systime_s  = 1, /* [5] */
	BFW_NX51_xpic_vic_softint0_set_gpio31     = 1, /* [6] */
	BFW_NX51_xpic_vic_softint0_set_watchdog   = 1, /* [7] */
	BFW_NX51_xpic_vic_softint0_set_uart0      = 1, /* [8] */
	BFW_NX51_xpic_vic_softint0_set_uart1      = 1, /* [9] */
	BFW_NX51_xpic_vic_softint0_set_uart2      = 1, /* [10] */
	BFW_NX51_xpic_vic_softint0_set_usb        = 1, /* [11] */
	BFW_NX51_xpic_vic_softint0_set_spi        = 1, /* [12] */
	BFW_NX51_xpic_vic_softint0_set_i2c        = 1, /* [13] */
	BFW_NX51_xpic_vic_softint0_set_reserved14 = 1, /* [14] */
	BFW_NX51_xpic_vic_softint0_set_hif        = 1, /* [15] */
	BFW_NX51_xpic_vic_softint0_set_gpio       = 1, /* [16] */
	BFW_NX51_xpic_vic_softint0_set_com0       = 1, /* [17] */
	BFW_NX51_xpic_vic_softint0_set_com1       = 1, /* [18] */
	BFW_NX51_xpic_vic_softint0_set_com2       = 1, /* [19] */
	BFW_NX51_xpic_vic_softint0_set_com3       = 1, /* [20] */
	BFW_NX51_xpic_vic_softint0_set_msync0     = 1, /* [21] */
	BFW_NX51_xpic_vic_softint0_set_msync1     = 1, /* [22] */
	BFW_NX51_xpic_vic_softint0_set_msync2     = 1, /* [23] */
	BFW_NX51_xpic_vic_softint0_set_msync3     = 1, /* [24] */
	BFW_NX51_xpic_vic_softint0_set_int_phy    = 1, /* [25] */
	BFW_NX51_xpic_vic_softint0_set_sysstate   = 1, /* [26] */
	BFW_NX51_xpic_vic_softint0_set_dmac       = 1, /* [27] */
	BFW_NX51_xpic_vic_softint0_set_trigger_lt = 1, /* [28] */
	BFW_NX51_xpic_vic_softint0_set_can        = 1, /* [29] */
	BFW_NX51_xpic_vic_softint0_set_osac       = 1, /* [30] */
	BFW_NX51_xpic_vic_softint0_set_reserved31 = 1  /* [31] */
};

typedef struct NX51_XPIC_VIC_SOFTINT0_SET_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_xpic_vic_softint0_set_sw0;        /* Reserved for Software Interrupt                                                          */
	unsigned int timer0     : BFW_NX51_xpic_vic_softint0_set_timer0;     /* xPIC Timer0 from XPIC_TIMER Module                                                       */
	                                                                     /* Real time operating system timer, Windows CE required                                    */
	unsigned int timer1     : BFW_NX51_xpic_vic_softint0_set_timer1;     /* xPIC Timer1 from XPIC_TIMER Module                                                       */
	unsigned int gpio_timer : BFW_NX51_xpic_vic_softint0_set_gpio_timer; /* GPIO Timer0-4                                                                            */
	                                                                     /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion))                    */
	unsigned int timer2     : BFW_NX51_xpic_vic_softint0_set_timer2;     /* xPIC Timer2 from XPIC_TIMER Module                                                       */
	unsigned int systime_s  : BFW_NX51_xpic_vic_softint0_set_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                                         */
	unsigned int gpio31     : BFW_NX51_xpic_vic_softint0_set_gpio31;     /* external interrupt 31, Windows CE required (NMI)                                         */
	unsigned int watchdog   : BFW_NX51_xpic_vic_softint0_set_watchdog;   /* Watchdog IRQ from XPIC_WDG module                                                        */
	unsigned int uart0      : BFW_NX51_xpic_vic_softint0_set_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                                        */
	unsigned int uart1      : BFW_NX51_xpic_vic_softint0_set_uart1;      /* UART 1                                                                                   */
	unsigned int uart2      : BFW_NX51_xpic_vic_softint0_set_uart2;      /* UART 2                                                                                   */
	unsigned int usb        : BFW_NX51_xpic_vic_softint0_set_usb;        /* USB interrupt                                                                            */
	unsigned int spi        : BFW_NX51_xpic_vic_softint0_set_spi;        /* combined SPI0, SPI1 interrupt                                                            */
	unsigned int i2c        : BFW_NX51_xpic_vic_softint0_set_i2c;        /* combined I2C0, I2C1 interrupt                                                            */
	unsigned int reserved14 : BFW_NX51_xpic_vic_softint0_set_reserved14; /* reserved for netX compatibility (LCD)                                                    */
	unsigned int hif        : BFW_NX51_xpic_vic_softint0_set_hif;        /* combined HIF interrupt: DPM, Handshake-Cells (HANDSHAKE_CTRL) and HIF PIOs (HIF_IO_CTRL) */
	unsigned int gpio       : BFW_NX51_xpic_vic_softint0_set_gpio;       /* Other external Interrupts from GPIO 0-30 / IOLINK                                        */
	unsigned int com0       : BFW_NX51_xpic_vic_softint0_set_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                                             */
	unsigned int com1       : BFW_NX51_xpic_vic_softint0_set_com1;       /* Communication channel 1 (= |xpec0_irq[11:0])                                             */
	unsigned int com2       : BFW_NX51_xpic_vic_softint0_set_com2;       /* reserved for netX compatibility (com2)                                                   */
	unsigned int com3       : BFW_NX51_xpic_vic_softint0_set_com3;       /* reserved  (com3)                                                                         */
	unsigned int msync0     : BFW_NX51_xpic_vic_softint0_set_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                                   */
	unsigned int msync1     : BFW_NX51_xpic_vic_softint0_set_msync1;     /* Motion synchronization channel 1 (= |xpec0_irq[15:12])                                   */
	unsigned int msync2     : BFW_NX51_xpic_vic_softint0_set_msync2;     /* reserved for netX compatibility (msync2)                                                 */
	unsigned int msync3     : BFW_NX51_xpic_vic_softint0_set_msync3;     /* reserved for SW IRQ from ARM to xPIC                                                     */
	unsigned int int_phy    : BFW_NX51_xpic_vic_softint0_set_int_phy;    /* Interrupt from internal Phy                                                              */
	unsigned int sysstate   : BFW_NX51_xpic_vic_softint0_set_sysstate;   /* License error or extmem_timeout                                                          */
	unsigned int dmac       : BFW_NX51_xpic_vic_softint0_set_dmac;       /* DMA controller                                                                           */
	unsigned int trigger_lt : BFW_NX51_xpic_vic_softint0_set_trigger_lt; /* trigger_lt                                                                               */
	unsigned int can        : BFW_NX51_xpic_vic_softint0_set_can;        /* CAN IRQ                                                                                  */
	unsigned int osac       : BFW_NX51_xpic_vic_softint0_set_osac;       /* OSAC nfifo or scheduler                                                                  */
	unsigned int reserved31 : BFW_NX51_xpic_vic_softint0_set_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                                         */
} NX51_XPIC_VIC_SOFTINT0_SET_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_SOFTINT0_SET_BIT_T bf;
} NX51_XPIC_VIC_SOFTINT0_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint1_set */
/* => XPIC VIC Software1 interrupt set register: */
/*    Read status or set IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_softint1_set      0x00000010U
#define Adr_NX51_xpic_vic_xpic_vic_softint1_set 0x10140910U
#define Adr_NX51_xpic_vic_softint1_set          0x10140910U
#define DFLT_VAL_NX51_xpic_vic_softint1_set     0x00000000U

#define MSK_NX51_xpic_vic_softint1_set_gpio7                  0x00000001U
#define SRT_NX51_xpic_vic_softint1_set_gpio7                  0
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio7             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio7          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio8                  0x00000002U
#define SRT_NX51_xpic_vic_softint1_set_gpio8                  1
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio8             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio8          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio9                  0x00000004U
#define SRT_NX51_xpic_vic_softint1_set_gpio9                  2
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio9             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio9          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio10                 0x00000008U
#define SRT_NX51_xpic_vic_softint1_set_gpio10                 3
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio10            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio10         0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio11                 0x00000010U
#define SRT_NX51_xpic_vic_softint1_set_gpio11                 4
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio11            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio11         0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio12                 0x00000020U
#define SRT_NX51_xpic_vic_softint1_set_gpio12                 5
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio12            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio12         0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio13                 0x00000040U
#define SRT_NX51_xpic_vic_softint1_set_gpio13                 6
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio13            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio13         0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio14                 0x00000080U
#define SRT_NX51_xpic_vic_softint1_set_gpio14                 7
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio14            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio14         0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio15                 0x00000100U
#define SRT_NX51_xpic_vic_softint1_set_gpio15                 8
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio15            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio15         0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio16                 0x00000200U
#define SRT_NX51_xpic_vic_softint1_set_gpio16                 9
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio16            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio16         0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio_timer2            0x00000400U
#define SRT_NX51_xpic_vic_softint1_set_gpio_timer2            10
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio_timer2       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio_timer2    0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio_timer3            0x00000800U
#define SRT_NX51_xpic_vic_softint1_set_gpio_timer3            11
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio_timer3       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio_timer3    0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio_timer4            0x00001000U
#define SRT_NX51_xpic_vic_softint1_set_gpio_timer4            12
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio_timer4       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio_timer4    0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_spi0                   0x00002000U
#define SRT_NX51_xpic_vic_softint1_set_spi0                   13
#define DFLT_VAL_NX51_xpic_vic_softint1_set_spi0              0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_spi0           0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_spi1                   0x00004000U
#define SRT_NX51_xpic_vic_softint1_set_spi1                   14
#define DFLT_VAL_NX51_xpic_vic_softint1_set_spi1              0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_spi1           0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio_timer0            0x00008000U
#define SRT_NX51_xpic_vic_softint1_set_gpio_timer0            15
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio_timer0       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio_timer0    0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio_timer1            0x00010000U
#define SRT_NX51_xpic_vic_softint1_set_gpio_timer1            16
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio_timer1       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio_timer1    0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio0                  0x00020000U
#define SRT_NX51_xpic_vic_softint1_set_gpio0                  17
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio0             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio0          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio1                  0x00040000U
#define SRT_NX51_xpic_vic_softint1_set_gpio1                  18
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio1             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio1          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio2                  0x00080000U
#define SRT_NX51_xpic_vic_softint1_set_gpio2                  19
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio2             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio2          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio3                  0x00100000U
#define SRT_NX51_xpic_vic_softint1_set_gpio3                  20
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio3             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio3          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio4                  0x00200000U
#define SRT_NX51_xpic_vic_softint1_set_gpio4                  21
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio4             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio4          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio5                  0x00400000U
#define SRT_NX51_xpic_vic_softint1_set_gpio5                  22
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio5             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio5          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_gpio6                  0x00800000U
#define SRT_NX51_xpic_vic_softint1_set_gpio6                  23
#define DFLT_VAL_NX51_xpic_vic_softint1_set_gpio6             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_gpio6          0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_reserved24             0x01000000U
#define SRT_NX51_xpic_vic_softint1_set_reserved24             24
#define DFLT_VAL_NX51_xpic_vic_softint1_set_reserved24        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_reserved24     0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_reserved25             0x02000000U
#define SRT_NX51_xpic_vic_softint1_set_reserved25             25
#define DFLT_VAL_NX51_xpic_vic_softint1_set_reserved25        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_reserved25     0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_reserved26             0x04000000U
#define SRT_NX51_xpic_vic_softint1_set_reserved26             26
#define DFLT_VAL_NX51_xpic_vic_softint1_set_reserved26        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_reserved26     0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_reserved27             0x08000000U
#define SRT_NX51_xpic_vic_softint1_set_reserved27             27
#define DFLT_VAL_NX51_xpic_vic_softint1_set_reserved27        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_reserved27     0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_eth                    0x10000000U
#define SRT_NX51_xpic_vic_softint1_set_eth                    28
#define DFLT_VAL_NX51_xpic_vic_softint1_set_eth               0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_eth            0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_osac_nfifo             0x20000000U
#define SRT_NX51_xpic_vic_softint1_set_osac_nfifo             29
#define DFLT_VAL_NX51_xpic_vic_softint1_set_osac_nfifo        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_osac_nfifo     0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_osac_scheduler         0x40000000U
#define SRT_NX51_xpic_vic_softint1_set_osac_scheduler         30
#define DFLT_VAL_NX51_xpic_vic_softint1_set_osac_scheduler    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_osac_scheduler 0x00000000U
#define MSK_NX51_xpic_vic_softint1_set_misalign               0x80000000U
#define SRT_NX51_xpic_vic_softint1_set_misalign               31
#define DFLT_VAL_NX51_xpic_vic_softint1_set_misalign          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_set_misalign       0x00000000U

/* all used bits of 'NX51_xpic_vic_softint1_set': */
#define MSK_USED_BITS_NX51_xpic_vic_softint1_set 0xffffffffU

enum {
	BFW_NX51_xpic_vic_softint1_set_gpio7          = 1, /* [0] */
	BFW_NX51_xpic_vic_softint1_set_gpio8          = 1, /* [1] */
	BFW_NX51_xpic_vic_softint1_set_gpio9          = 1, /* [2] */
	BFW_NX51_xpic_vic_softint1_set_gpio10         = 1, /* [3] */
	BFW_NX51_xpic_vic_softint1_set_gpio11         = 1, /* [4] */
	BFW_NX51_xpic_vic_softint1_set_gpio12         = 1, /* [5] */
	BFW_NX51_xpic_vic_softint1_set_gpio13         = 1, /* [6] */
	BFW_NX51_xpic_vic_softint1_set_gpio14         = 1, /* [7] */
	BFW_NX51_xpic_vic_softint1_set_gpio15         = 1, /* [8] */
	BFW_NX51_xpic_vic_softint1_set_gpio16         = 1, /* [9] */
	BFW_NX51_xpic_vic_softint1_set_gpio_timer2    = 1, /* [10] */
	BFW_NX51_xpic_vic_softint1_set_gpio_timer3    = 1, /* [11] */
	BFW_NX51_xpic_vic_softint1_set_gpio_timer4    = 1, /* [12] */
	BFW_NX51_xpic_vic_softint1_set_spi0           = 1, /* [13] */
	BFW_NX51_xpic_vic_softint1_set_spi1           = 1, /* [14] */
	BFW_NX51_xpic_vic_softint1_set_gpio_timer0    = 1, /* [15] */
	BFW_NX51_xpic_vic_softint1_set_gpio_timer1    = 1, /* [16] */
	BFW_NX51_xpic_vic_softint1_set_gpio0          = 1, /* [17] */
	BFW_NX51_xpic_vic_softint1_set_gpio1          = 1, /* [18] */
	BFW_NX51_xpic_vic_softint1_set_gpio2          = 1, /* [19] */
	BFW_NX51_xpic_vic_softint1_set_gpio3          = 1, /* [20] */
	BFW_NX51_xpic_vic_softint1_set_gpio4          = 1, /* [21] */
	BFW_NX51_xpic_vic_softint1_set_gpio5          = 1, /* [22] */
	BFW_NX51_xpic_vic_softint1_set_gpio6          = 1, /* [23] */
	BFW_NX51_xpic_vic_softint1_set_reserved24     = 1, /* [24] */
	BFW_NX51_xpic_vic_softint1_set_reserved25     = 1, /* [25] */
	BFW_NX51_xpic_vic_softint1_set_reserved26     = 1, /* [26] */
	BFW_NX51_xpic_vic_softint1_set_reserved27     = 1, /* [27] */
	BFW_NX51_xpic_vic_softint1_set_eth            = 1, /* [28] */
	BFW_NX51_xpic_vic_softint1_set_osac_nfifo     = 1, /* [29] */
	BFW_NX51_xpic_vic_softint1_set_osac_scheduler = 1, /* [30] */
	BFW_NX51_xpic_vic_softint1_set_misalign       = 1  /* [31] */
};

typedef struct NX51_XPIC_VIC_SOFTINT1_SET_BIT_Ttag {
	unsigned int gpio7          : BFW_NX51_xpic_vic_softint1_set_gpio7;          /* gpio7                  */
	unsigned int gpio8          : BFW_NX51_xpic_vic_softint1_set_gpio8;          /* gpio8                  */
	unsigned int gpio9          : BFW_NX51_xpic_vic_softint1_set_gpio9;          /* gpio9                  */
	unsigned int gpio10         : BFW_NX51_xpic_vic_softint1_set_gpio10;         /* gpio10                 */
	unsigned int gpio11         : BFW_NX51_xpic_vic_softint1_set_gpio11;         /* gpio11                 */
	unsigned int gpio12         : BFW_NX51_xpic_vic_softint1_set_gpio12;         /* gpio12                 */
	unsigned int gpio13         : BFW_NX51_xpic_vic_softint1_set_gpio13;         /* gpio13                 */
	unsigned int gpio14         : BFW_NX51_xpic_vic_softint1_set_gpio14;         /* gpio14                 */
	unsigned int gpio15         : BFW_NX51_xpic_vic_softint1_set_gpio15;         /* gpio15                 */
	unsigned int gpio16         : BFW_NX51_xpic_vic_softint1_set_gpio16;         /* gpio16                 */
	unsigned int gpio_timer2    : BFW_NX51_xpic_vic_softint1_set_gpio_timer2;    /* gpio_timer2            */
	unsigned int gpio_timer3    : BFW_NX51_xpic_vic_softint1_set_gpio_timer3;    /* gpio_timer3            */
	unsigned int gpio_timer4    : BFW_NX51_xpic_vic_softint1_set_gpio_timer4;    /* gpio_timer4            */
	unsigned int spi0           : BFW_NX51_xpic_vic_softint1_set_spi0;           /* spi0                   */
	unsigned int spi1           : BFW_NX51_xpic_vic_softint1_set_spi1;           /* spi1                   */
	unsigned int gpio_timer0    : BFW_NX51_xpic_vic_softint1_set_gpio_timer0;    /* gpio_timer0            */
	unsigned int gpio_timer1    : BFW_NX51_xpic_vic_softint1_set_gpio_timer1;    /* gpio_timer1            */
	unsigned int gpio0          : BFW_NX51_xpic_vic_softint1_set_gpio0;          /* gpio0                  */
	unsigned int gpio1          : BFW_NX51_xpic_vic_softint1_set_gpio1;          /* gpio1                  */
	unsigned int gpio2          : BFW_NX51_xpic_vic_softint1_set_gpio2;          /* gpio2                  */
	unsigned int gpio3          : BFW_NX51_xpic_vic_softint1_set_gpio3;          /* gpio3                  */
	unsigned int gpio4          : BFW_NX51_xpic_vic_softint1_set_gpio4;          /* gpio4                  */
	unsigned int gpio5          : BFW_NX51_xpic_vic_softint1_set_gpio5;          /* gpio5                  */
	unsigned int gpio6          : BFW_NX51_xpic_vic_softint1_set_gpio6;          /* gpio6                  */
	unsigned int reserved24     : BFW_NX51_xpic_vic_softint1_set_reserved24;     /* reserved               */
	unsigned int reserved25     : BFW_NX51_xpic_vic_softint1_set_reserved25;     /* reserved               */
	unsigned int reserved26     : BFW_NX51_xpic_vic_softint1_set_reserved26;     /* reserved               */
	unsigned int reserved27     : BFW_NX51_xpic_vic_softint1_set_reserved27;     /* reserved               */
	unsigned int eth            : BFW_NX51_xpic_vic_softint1_set_eth;            /* ETH module             */
	unsigned int osac_nfifo     : BFW_NX51_xpic_vic_softint1_set_osac_nfifo;     /* osac_nfifo             */
	unsigned int osac_scheduler : BFW_NX51_xpic_vic_softint1_set_osac_scheduler; /* osac_scheduler         */
	unsigned int misalign       : BFW_NX51_xpic_vic_softint1_set_misalign;       /* xPIC data misalignment */
} NX51_XPIC_VIC_SOFTINT1_SET_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_SOFTINT1_SET_BIT_T bf;
} NX51_XPIC_VIC_SOFTINT1_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint0_reset */
/* => XPIC VIC Software0 interrupt reset register: */
/*    Read status or reset IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_softint0_reset      0x00000014U
#define Adr_NX51_xpic_vic_xpic_vic_softint0_reset 0x10140914U
#define Adr_NX51_xpic_vic_softint0_reset          0x10140914U
#define DFLT_VAL_NX51_xpic_vic_softint0_reset     0x00000000U

#define MSK_NX51_xpic_vic_softint0_reset_sw0                0x00000001U
#define SRT_NX51_xpic_vic_softint0_reset_sw0                0
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_sw0           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_sw0        0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_timer0             0x00000002U
#define SRT_NX51_xpic_vic_softint0_reset_timer0             1
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_timer0        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_timer0     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_timer1             0x00000004U
#define SRT_NX51_xpic_vic_softint0_reset_timer1             2
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_timer1        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_timer1     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_gpio_timer         0x00000008U
#define SRT_NX51_xpic_vic_softint0_reset_gpio_timer         3
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_gpio_timer 0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_timer2             0x00000010U
#define SRT_NX51_xpic_vic_softint0_reset_timer2             4
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_timer2        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_timer2     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_systime_s          0x00000020U
#define SRT_NX51_xpic_vic_softint0_reset_systime_s          5
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_systime_s  0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_gpio31             0x00000040U
#define SRT_NX51_xpic_vic_softint0_reset_gpio31             6
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_gpio31     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_watchdog           0x00000080U
#define SRT_NX51_xpic_vic_softint0_reset_watchdog           7
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_watchdog   0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_uart0              0x00000100U
#define SRT_NX51_xpic_vic_softint0_reset_uart0              8
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_uart0      0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_uart1              0x00000200U
#define SRT_NX51_xpic_vic_softint0_reset_uart1              9
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_uart1      0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_uart2              0x00000400U
#define SRT_NX51_xpic_vic_softint0_reset_uart2              10
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_uart2      0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_usb                0x00000800U
#define SRT_NX51_xpic_vic_softint0_reset_usb                11
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_usb           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_usb        0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_spi                0x00001000U
#define SRT_NX51_xpic_vic_softint0_reset_spi                12
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_spi           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_spi        0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_i2c                0x00002000U
#define SRT_NX51_xpic_vic_softint0_reset_i2c                13
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_i2c        0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_reserved14         0x00004000U
#define SRT_NX51_xpic_vic_softint0_reset_reserved14         14
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_reserved14    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_reserved14 0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_hif                0x00008000U
#define SRT_NX51_xpic_vic_softint0_reset_hif                15
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_hif           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_hif        0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_gpio               0x00010000U
#define SRT_NX51_xpic_vic_softint0_reset_gpio               16
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_gpio       0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_com0               0x00020000U
#define SRT_NX51_xpic_vic_softint0_reset_com0               17
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_com0          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_com0       0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_com1               0x00040000U
#define SRT_NX51_xpic_vic_softint0_reset_com1               18
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_com1          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_com1       0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_com2               0x00080000U
#define SRT_NX51_xpic_vic_softint0_reset_com2               19
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_com2          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_com2       0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_com3               0x00100000U
#define SRT_NX51_xpic_vic_softint0_reset_com3               20
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_com3          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_com3       0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_msync0             0x00200000U
#define SRT_NX51_xpic_vic_softint0_reset_msync0             21
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_msync0     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_msync1             0x00400000U
#define SRT_NX51_xpic_vic_softint0_reset_msync1             22
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_msync1     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_msync2             0x00800000U
#define SRT_NX51_xpic_vic_softint0_reset_msync2             23
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_msync2        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_msync2     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_msync3             0x01000000U
#define SRT_NX51_xpic_vic_softint0_reset_msync3             24
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_msync3        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_msync3     0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_int_phy            0x02000000U
#define SRT_NX51_xpic_vic_softint0_reset_int_phy            25
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_int_phy    0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_sysstate           0x04000000U
#define SRT_NX51_xpic_vic_softint0_reset_sysstate           26
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_sysstate   0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_dmac               0x08000000U
#define SRT_NX51_xpic_vic_softint0_reset_dmac               27
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_dmac       0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_trigger_lt         0x10000000U
#define SRT_NX51_xpic_vic_softint0_reset_trigger_lt         28
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_trigger_lt 0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_can                0x20000000U
#define SRT_NX51_xpic_vic_softint0_reset_can                29
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_can           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_can        0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_osac               0x40000000U
#define SRT_NX51_xpic_vic_softint0_reset_osac               30
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_osac          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_osac       0x00000000U
#define MSK_NX51_xpic_vic_softint0_reset_reserved31         0x80000000U
#define SRT_NX51_xpic_vic_softint0_reset_reserved31         31
#define DFLT_VAL_NX51_xpic_vic_softint0_reset_reserved31    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint0_reset_reserved31 0x00000000U

/* all used bits of 'NX51_xpic_vic_softint0_reset': */
#define MSK_USED_BITS_NX51_xpic_vic_softint0_reset 0xffffffffU

enum {
	BFW_NX51_xpic_vic_softint0_reset_sw0        = 1, /* [0] */
	BFW_NX51_xpic_vic_softint0_reset_timer0     = 1, /* [1] */
	BFW_NX51_xpic_vic_softint0_reset_timer1     = 1, /* [2] */
	BFW_NX51_xpic_vic_softint0_reset_gpio_timer = 1, /* [3] */
	BFW_NX51_xpic_vic_softint0_reset_timer2     = 1, /* [4] */
	BFW_NX51_xpic_vic_softint0_reset_systime_s  = 1, /* [5] */
	BFW_NX51_xpic_vic_softint0_reset_gpio31     = 1, /* [6] */
	BFW_NX51_xpic_vic_softint0_reset_watchdog   = 1, /* [7] */
	BFW_NX51_xpic_vic_softint0_reset_uart0      = 1, /* [8] */
	BFW_NX51_xpic_vic_softint0_reset_uart1      = 1, /* [9] */
	BFW_NX51_xpic_vic_softint0_reset_uart2      = 1, /* [10] */
	BFW_NX51_xpic_vic_softint0_reset_usb        = 1, /* [11] */
	BFW_NX51_xpic_vic_softint0_reset_spi        = 1, /* [12] */
	BFW_NX51_xpic_vic_softint0_reset_i2c        = 1, /* [13] */
	BFW_NX51_xpic_vic_softint0_reset_reserved14 = 1, /* [14] */
	BFW_NX51_xpic_vic_softint0_reset_hif        = 1, /* [15] */
	BFW_NX51_xpic_vic_softint0_reset_gpio       = 1, /* [16] */
	BFW_NX51_xpic_vic_softint0_reset_com0       = 1, /* [17] */
	BFW_NX51_xpic_vic_softint0_reset_com1       = 1, /* [18] */
	BFW_NX51_xpic_vic_softint0_reset_com2       = 1, /* [19] */
	BFW_NX51_xpic_vic_softint0_reset_com3       = 1, /* [20] */
	BFW_NX51_xpic_vic_softint0_reset_msync0     = 1, /* [21] */
	BFW_NX51_xpic_vic_softint0_reset_msync1     = 1, /* [22] */
	BFW_NX51_xpic_vic_softint0_reset_msync2     = 1, /* [23] */
	BFW_NX51_xpic_vic_softint0_reset_msync3     = 1, /* [24] */
	BFW_NX51_xpic_vic_softint0_reset_int_phy    = 1, /* [25] */
	BFW_NX51_xpic_vic_softint0_reset_sysstate   = 1, /* [26] */
	BFW_NX51_xpic_vic_softint0_reset_dmac       = 1, /* [27] */
	BFW_NX51_xpic_vic_softint0_reset_trigger_lt = 1, /* [28] */
	BFW_NX51_xpic_vic_softint0_reset_can        = 1, /* [29] */
	BFW_NX51_xpic_vic_softint0_reset_osac       = 1, /* [30] */
	BFW_NX51_xpic_vic_softint0_reset_reserved31 = 1  /* [31] */
};

typedef struct NX51_XPIC_VIC_SOFTINT0_RESET_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_xpic_vic_softint0_reset_sw0;        /* Reserved for Software Interrupt                                                          */
	unsigned int timer0     : BFW_NX51_xpic_vic_softint0_reset_timer0;     /* xPIC Timer0 from XPIC_TIMER Module                                                       */
	                                                                       /* Real time operating system timer, Windows CE required                                    */
	unsigned int timer1     : BFW_NX51_xpic_vic_softint0_reset_timer1;     /* xPIC Timer1 from XPIC_TIMER Module                                                       */
	unsigned int gpio_timer : BFW_NX51_xpic_vic_softint0_reset_gpio_timer; /* GPIO Timer0-4                                                                            */
	                                                                       /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion))                    */
	unsigned int timer2     : BFW_NX51_xpic_vic_softint0_reset_timer2;     /* xPIC Timer2 from XPIC_TIMER Module                                                       */
	unsigned int systime_s  : BFW_NX51_xpic_vic_softint0_reset_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                                         */
	unsigned int gpio31     : BFW_NX51_xpic_vic_softint0_reset_gpio31;     /* external interrupt 31, Windows CE required (NMI)                                         */
	unsigned int watchdog   : BFW_NX51_xpic_vic_softint0_reset_watchdog;   /* Watchdog IRQ from XPIC_WDG module                                                        */
	unsigned int uart0      : BFW_NX51_xpic_vic_softint0_reset_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                                        */
	unsigned int uart1      : BFW_NX51_xpic_vic_softint0_reset_uart1;      /* UART 1                                                                                   */
	unsigned int uart2      : BFW_NX51_xpic_vic_softint0_reset_uart2;      /* UART 2                                                                                   */
	unsigned int usb        : BFW_NX51_xpic_vic_softint0_reset_usb;        /* USB interrupt                                                                            */
	unsigned int spi        : BFW_NX51_xpic_vic_softint0_reset_spi;        /* combined SPI0, SPI1 interrupt                                                            */
	unsigned int i2c        : BFW_NX51_xpic_vic_softint0_reset_i2c;        /* combined I2C0, I2C1 interrupt                                                            */
	unsigned int reserved14 : BFW_NX51_xpic_vic_softint0_reset_reserved14; /* reserved for netX compatibility (LCD)                                                    */
	unsigned int hif        : BFW_NX51_xpic_vic_softint0_reset_hif;        /* combined HIF interrupt: DPM, Handshake-Cells (HANDSHAKE_CTRL) and HIF PIOs (HIF_IO_CTRL) */
	unsigned int gpio       : BFW_NX51_xpic_vic_softint0_reset_gpio;       /* Other external Interrupts from GPIO 0-30 / IOLINK                                        */
	unsigned int com0       : BFW_NX51_xpic_vic_softint0_reset_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                                             */
	unsigned int com1       : BFW_NX51_xpic_vic_softint0_reset_com1;       /* Communication channel 1 (= |xpec0_irq[11:0])                                             */
	unsigned int com2       : BFW_NX51_xpic_vic_softint0_reset_com2;       /* reserved for netX compatibility (com2)                                                   */
	unsigned int com3       : BFW_NX51_xpic_vic_softint0_reset_com3;       /* reserved  (com3)                                                                         */
	unsigned int msync0     : BFW_NX51_xpic_vic_softint0_reset_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                                   */
	unsigned int msync1     : BFW_NX51_xpic_vic_softint0_reset_msync1;     /* Motion synchronization channel 1 (= |xpec0_irq[15:12])                                   */
	unsigned int msync2     : BFW_NX51_xpic_vic_softint0_reset_msync2;     /* reserved for netX compatibility (msync2)                                                 */
	unsigned int msync3     : BFW_NX51_xpic_vic_softint0_reset_msync3;     /* reserved for SW IRQ from ARM to xPIC                                                     */
	unsigned int int_phy    : BFW_NX51_xpic_vic_softint0_reset_int_phy;    /* Interrupt from internal Phy                                                              */
	unsigned int sysstate   : BFW_NX51_xpic_vic_softint0_reset_sysstate;   /* License error or extmem_timeout                                                          */
	unsigned int dmac       : BFW_NX51_xpic_vic_softint0_reset_dmac;       /* DMA controller                                                                           */
	unsigned int trigger_lt : BFW_NX51_xpic_vic_softint0_reset_trigger_lt; /* trigger_lt                                                                               */
	unsigned int can        : BFW_NX51_xpic_vic_softint0_reset_can;        /* CAN IRQ                                                                                  */
	unsigned int osac       : BFW_NX51_xpic_vic_softint0_reset_osac;       /* OSAC nfifo or scheduler                                                                  */
	unsigned int reserved31 : BFW_NX51_xpic_vic_softint0_reset_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                                         */
} NX51_XPIC_VIC_SOFTINT0_RESET_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_XPIC_VIC_SOFTINT0_RESET_BIT_T bf;
} NX51_XPIC_VIC_SOFTINT0_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_softint1_reset */
/* => XPIC VIC Software1 interrupt reset register: */
/*    Read status or reset IRQ by writing '1' to the appropriate bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_softint1_reset      0x00000018U
#define Adr_NX51_xpic_vic_xpic_vic_softint1_reset 0x10140918U
#define Adr_NX51_xpic_vic_softint1_reset          0x10140918U
#define DFLT_VAL_NX51_xpic_vic_softint1_reset     0x00000000U

#define MSK_NX51_xpic_vic_softint1_reset_gpio7                  0x00000001U
#define SRT_NX51_xpic_vic_softint1_reset_gpio7                  0
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio7             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio7          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio8                  0x00000002U
#define SRT_NX51_xpic_vic_softint1_reset_gpio8                  1
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio8             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio8          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio9                  0x00000004U
#define SRT_NX51_xpic_vic_softint1_reset_gpio9                  2
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio9             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio9          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio10                 0x00000008U
#define SRT_NX51_xpic_vic_softint1_reset_gpio10                 3
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio10            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio10         0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio11                 0x00000010U
#define SRT_NX51_xpic_vic_softint1_reset_gpio11                 4
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio11            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio11         0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio12                 0x00000020U
#define SRT_NX51_xpic_vic_softint1_reset_gpio12                 5
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio12            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio12         0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio13                 0x00000040U
#define SRT_NX51_xpic_vic_softint1_reset_gpio13                 6
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio13            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio13         0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio14                 0x00000080U
#define SRT_NX51_xpic_vic_softint1_reset_gpio14                 7
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio14            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio14         0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio15                 0x00000100U
#define SRT_NX51_xpic_vic_softint1_reset_gpio15                 8
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio15            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio15         0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio16                 0x00000200U
#define SRT_NX51_xpic_vic_softint1_reset_gpio16                 9
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio16            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio16         0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio_timer2            0x00000400U
#define SRT_NX51_xpic_vic_softint1_reset_gpio_timer2            10
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio_timer2       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio_timer2    0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio_timer3            0x00000800U
#define SRT_NX51_xpic_vic_softint1_reset_gpio_timer3            11
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio_timer3       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio_timer3    0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio_timer4            0x00001000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio_timer4            12
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio_timer4       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio_timer4    0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_spi0                   0x00002000U
#define SRT_NX51_xpic_vic_softint1_reset_spi0                   13
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_spi0              0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_spi0           0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_spi1                   0x00004000U
#define SRT_NX51_xpic_vic_softint1_reset_spi1                   14
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_spi1              0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_spi1           0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio_timer0            0x00008000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio_timer0            15
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio_timer0       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio_timer0    0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio_timer1            0x00010000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio_timer1            16
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio_timer1       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio_timer1    0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio0                  0x00020000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio0                  17
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio0             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio0          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio1                  0x00040000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio1                  18
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio1             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio1          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio2                  0x00080000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio2                  19
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio2             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio2          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio3                  0x00100000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio3                  20
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio3             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio3          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio4                  0x00200000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio4                  21
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio4             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio4          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio5                  0x00400000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio5                  22
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio5             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio5          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_gpio6                  0x00800000U
#define SRT_NX51_xpic_vic_softint1_reset_gpio6                  23
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_gpio6             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_gpio6          0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_reserved24             0x01000000U
#define SRT_NX51_xpic_vic_softint1_reset_reserved24             24
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_reserved24        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_reserved24     0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_reserved25             0x02000000U
#define SRT_NX51_xpic_vic_softint1_reset_reserved25             25
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_reserved25        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_reserved25     0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_reserved26             0x04000000U
#define SRT_NX51_xpic_vic_softint1_reset_reserved26             26
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_reserved26        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_reserved26     0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_reserved27             0x08000000U
#define SRT_NX51_xpic_vic_softint1_reset_reserved27             27
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_reserved27        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_reserved27     0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_eth                    0x10000000U
#define SRT_NX51_xpic_vic_softint1_reset_eth                    28
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_eth               0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_eth            0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_osac_nfifo             0x20000000U
#define SRT_NX51_xpic_vic_softint1_reset_osac_nfifo             29
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_osac_nfifo        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_osac_nfifo     0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_osac_scheduler         0x40000000U
#define SRT_NX51_xpic_vic_softint1_reset_osac_scheduler         30
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_osac_scheduler    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_osac_scheduler 0x00000000U
#define MSK_NX51_xpic_vic_softint1_reset_misalign               0x80000000U
#define SRT_NX51_xpic_vic_softint1_reset_misalign               31
#define DFLT_VAL_NX51_xpic_vic_softint1_reset_misalign          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_softint1_reset_misalign       0x00000000U

/* all used bits of 'NX51_xpic_vic_softint1_reset': */
#define MSK_USED_BITS_NX51_xpic_vic_softint1_reset 0xffffffffU

enum {
	BFW_NX51_xpic_vic_softint1_reset_gpio7          = 1, /* [0] */
	BFW_NX51_xpic_vic_softint1_reset_gpio8          = 1, /* [1] */
	BFW_NX51_xpic_vic_softint1_reset_gpio9          = 1, /* [2] */
	BFW_NX51_xpic_vic_softint1_reset_gpio10         = 1, /* [3] */
	BFW_NX51_xpic_vic_softint1_reset_gpio11         = 1, /* [4] */
	BFW_NX51_xpic_vic_softint1_reset_gpio12         = 1, /* [5] */
	BFW_NX51_xpic_vic_softint1_reset_gpio13         = 1, /* [6] */
	BFW_NX51_xpic_vic_softint1_reset_gpio14         = 1, /* [7] */
	BFW_NX51_xpic_vic_softint1_reset_gpio15         = 1, /* [8] */
	BFW_NX51_xpic_vic_softint1_reset_gpio16         = 1, /* [9] */
	BFW_NX51_xpic_vic_softint1_reset_gpio_timer2    = 1, /* [10] */
	BFW_NX51_xpic_vic_softint1_reset_gpio_timer3    = 1, /* [11] */
	BFW_NX51_xpic_vic_softint1_reset_gpio_timer4    = 1, /* [12] */
	BFW_NX51_xpic_vic_softint1_reset_spi0           = 1, /* [13] */
	BFW_NX51_xpic_vic_softint1_reset_spi1           = 1, /* [14] */
	BFW_NX51_xpic_vic_softint1_reset_gpio_timer0    = 1, /* [15] */
	BFW_NX51_xpic_vic_softint1_reset_gpio_timer1    = 1, /* [16] */
	BFW_NX51_xpic_vic_softint1_reset_gpio0          = 1, /* [17] */
	BFW_NX51_xpic_vic_softint1_reset_gpio1          = 1, /* [18] */
	BFW_NX51_xpic_vic_softint1_reset_gpio2          = 1, /* [19] */
	BFW_NX51_xpic_vic_softint1_reset_gpio3          = 1, /* [20] */
	BFW_NX51_xpic_vic_softint1_reset_gpio4          = 1, /* [21] */
	BFW_NX51_xpic_vic_softint1_reset_gpio5          = 1, /* [22] */
	BFW_NX51_xpic_vic_softint1_reset_gpio6          = 1, /* [23] */
	BFW_NX51_xpic_vic_softint1_reset_reserved24     = 1, /* [24] */
	BFW_NX51_xpic_vic_softint1_reset_reserved25     = 1, /* [25] */
	BFW_NX51_xpic_vic_softint1_reset_reserved26     = 1, /* [26] */
	BFW_NX51_xpic_vic_softint1_reset_reserved27     = 1, /* [27] */
	BFW_NX51_xpic_vic_softint1_reset_eth            = 1, /* [28] */
	BFW_NX51_xpic_vic_softint1_reset_osac_nfifo     = 1, /* [29] */
	BFW_NX51_xpic_vic_softint1_reset_osac_scheduler = 1, /* [30] */
	BFW_NX51_xpic_vic_softint1_reset_misalign       = 1  /* [31] */
};

typedef struct NX51_XPIC_VIC_SOFTINT1_RESET_BIT_Ttag {
	unsigned int gpio7          : BFW_NX51_xpic_vic_softint1_reset_gpio7;          /* gpio7                  */
	unsigned int gpio8          : BFW_NX51_xpic_vic_softint1_reset_gpio8;          /* gpio8                  */
	unsigned int gpio9          : BFW_NX51_xpic_vic_softint1_reset_gpio9;          /* gpio9                  */
	unsigned int gpio10         : BFW_NX51_xpic_vic_softint1_reset_gpio10;         /* gpio10                 */
	unsigned int gpio11         : BFW_NX51_xpic_vic_softint1_reset_gpio11;         /* gpio11                 */
	unsigned int gpio12         : BFW_NX51_xpic_vic_softint1_reset_gpio12;         /* gpio12                 */
	unsigned int gpio13         : BFW_NX51_xpic_vic_softint1_reset_gpio13;         /* gpio13                 */
	unsigned int gpio14         : BFW_NX51_xpic_vic_softint1_reset_gpio14;         /* gpio14                 */
	unsigned int gpio15         : BFW_NX51_xpic_vic_softint1_reset_gpio15;         /* gpio15                 */
	unsigned int gpio16         : BFW_NX51_xpic_vic_softint1_reset_gpio16;         /* gpio16                 */
	unsigned int gpio_timer2    : BFW_NX51_xpic_vic_softint1_reset_gpio_timer2;    /* gpio_timer2            */
	unsigned int gpio_timer3    : BFW_NX51_xpic_vic_softint1_reset_gpio_timer3;    /* gpio_timer3            */
	unsigned int gpio_timer4    : BFW_NX51_xpic_vic_softint1_reset_gpio_timer4;    /* gpio_timer4            */
	unsigned int spi0           : BFW_NX51_xpic_vic_softint1_reset_spi0;           /* spi0                   */
	unsigned int spi1           : BFW_NX51_xpic_vic_softint1_reset_spi1;           /* spi1                   */
	unsigned int gpio_timer0    : BFW_NX51_xpic_vic_softint1_reset_gpio_timer0;    /* gpio_timer0            */
	unsigned int gpio_timer1    : BFW_NX51_xpic_vic_softint1_reset_gpio_timer1;    /* gpio_timer1            */
	unsigned int gpio0          : BFW_NX51_xpic_vic_softint1_reset_gpio0;          /* gpio0                  */
	unsigned int gpio1          : BFW_NX51_xpic_vic_softint1_reset_gpio1;          /* gpio1                  */
	unsigned int gpio2          : BFW_NX51_xpic_vic_softint1_reset_gpio2;          /* gpio2                  */
	unsigned int gpio3          : BFW_NX51_xpic_vic_softint1_reset_gpio3;          /* gpio3                  */
	unsigned int gpio4          : BFW_NX51_xpic_vic_softint1_reset_gpio4;          /* gpio4                  */
	unsigned int gpio5          : BFW_NX51_xpic_vic_softint1_reset_gpio5;          /* gpio5                  */
	unsigned int gpio6          : BFW_NX51_xpic_vic_softint1_reset_gpio6;          /* gpio6                  */
	unsigned int reserved24     : BFW_NX51_xpic_vic_softint1_reset_reserved24;     /* reserved               */
	unsigned int reserved25     : BFW_NX51_xpic_vic_softint1_reset_reserved25;     /* reserved               */
	unsigned int reserved26     : BFW_NX51_xpic_vic_softint1_reset_reserved26;     /* reserved               */
	unsigned int reserved27     : BFW_NX51_xpic_vic_softint1_reset_reserved27;     /* reserved               */
	unsigned int eth            : BFW_NX51_xpic_vic_softint1_reset_eth;            /* ETH module             */
	unsigned int osac_nfifo     : BFW_NX51_xpic_vic_softint1_reset_osac_nfifo;     /* osac_nfifo             */
	unsigned int osac_scheduler : BFW_NX51_xpic_vic_softint1_reset_osac_scheduler; /* osac_scheduler         */
	unsigned int misalign       : BFW_NX51_xpic_vic_softint1_reset_misalign;       /* xPIC data misalignment */
} NX51_XPIC_VIC_SOFTINT1_RESET_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_XPIC_VIC_SOFTINT1_RESET_BIT_T bf;
} NX51_XPIC_VIC_SOFTINT1_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_addr */
/* => XPIC VIC FIQ Vector address 0 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_fiq_addr      0x0000001CU
#define Adr_NX51_xpic_vic_xpic_vic_fiq_addr 0x1014091CU
#define Adr_NX51_xpic_vic_fiq_addr          0x1014091CU
#define DFLT_VAL_NX51_xpic_vic_fiq_addr     0x00000000U

#define MSK_NX51_xpic_vic_fiq_addr_val         0xffffffffU
#define SRT_NX51_xpic_vic_fiq_addr_val         0
#define DFLT_VAL_NX51_xpic_vic_fiq_addr_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_fiq_addr_val 0x00000000U

/* all used bits of 'NX51_xpic_vic_fiq_addr': */
#define MSK_USED_BITS_NX51_xpic_vic_fiq_addr 0xffffffffU

enum {
	BFW_NX51_xpic_vic_fiq_addr_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_FIQ_ADDR_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_fiq_addr_val; /* FIQ handler address */
} NX51_XPIC_VIC_FIQ_ADDR_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_VIC_FIQ_ADDR_BIT_T bf;
} NX51_XPIC_VIC_FIQ_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_irq_addr */
/* => XPIC VIC normal IRQ address register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_irq_addr      0x00000020U
#define Adr_NX51_xpic_vic_xpic_vic_irq_addr 0x10140920U
#define Adr_NX51_xpic_vic_irq_addr          0x10140920U
#define DFLT_VAL_NX51_xpic_vic_irq_addr     0x00000000U

#define MSK_NX51_xpic_vic_irq_addr_val         0xffffffffU
#define SRT_NX51_xpic_vic_irq_addr_val         0
#define DFLT_VAL_NX51_xpic_vic_irq_addr_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_irq_addr_val 0x00000000U

/* all used bits of 'NX51_xpic_vic_irq_addr': */
#define MSK_USED_BITS_NX51_xpic_vic_irq_addr 0xffffffffU

enum {
	BFW_NX51_xpic_vic_irq_addr_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_IRQ_ADDR_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_irq_addr_val; /* IRQ handler address */
} NX51_XPIC_VIC_IRQ_ADDR_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_VIC_IRQ_ADDR_BIT_T bf;
} NX51_XPIC_VIC_IRQ_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vector_addr */
/* => XPIC VIC IRQ Vector address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vector_addr      0x00000024U
#define Adr_NX51_xpic_vic_xpic_vic_vector_addr 0x10140924U
#define Adr_NX51_xpic_vic_vector_addr          0x10140924U

#define MSK_NX51_xpic_vic_vector_addr_val 0xffffffffU
#define SRT_NX51_xpic_vic_vector_addr_val 0

/* all used bits of 'NX51_xpic_vic_vector_addr': */
#define MSK_USED_BITS_NX51_xpic_vic_vector_addr 0xffffffffU

enum {
	BFW_NX51_xpic_vic_vector_addr_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_VECTOR_ADDR_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_vector_addr_val; /* IRQ vector address                                                  */
	                                                      /* read access get actuel highest prior IRQ                            */
	                                                      /* read access get  adr_xpic_vic_table_base_addr + IRQ Number * (4/16) */
} NX51_XPIC_VIC_VECTOR_ADDR_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_XPIC_VIC_VECTOR_ADDR_BIT_T bf;
} NX51_XPIC_VIC_VECTOR_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_table_base_addr */
/* => XPIC VIC IRQ TABLE ADDRESS BASE POINTER */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_table_base_addr      0x00000028U
#define Adr_NX51_xpic_vic_xpic_vic_table_base_addr 0x10140928U
#define Adr_NX51_xpic_vic_table_base_addr          0x10140928U
#define DFLT_VAL_NX51_xpic_vic_table_base_addr     0x00000000U

#define MSK_NX51_xpic_vic_table_base_addr_val         0xffffffffU
#define SRT_NX51_xpic_vic_table_base_addr_val         0
#define DFLT_VAL_NX51_xpic_vic_table_base_addr_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_table_base_addr_val 0x00000000U

/* all used bits of 'NX51_xpic_vic_table_base_addr': */
#define MSK_USED_BITS_NX51_xpic_vic_table_base_addr 0xffffffffU

enum {
	BFW_NX51_xpic_vic_table_base_addr_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_TABLE_BASE_ADDR_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_table_base_addr_val; /* IRQ Table base address                  */
	                                                          /* the Base Pointer Addr for IRQ Jmp Table */
} NX51_XPIC_VIC_TABLE_BASE_ADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_VIC_TABLE_BASE_ADDR_BIT_T bf;
} NX51_XPIC_VIC_TABLE_BASE_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_vect_config */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_fiq_vect_config      0x0000002CU
#define Adr_NX51_xpic_vic_xpic_vic_fiq_vect_config 0x1014092CU
#define Adr_NX51_xpic_vic_fiq_vect_config          0x1014092CU
#define DFLT_VAL_NX51_xpic_vic_fiq_vect_config     0x00000000U

#define MSK_NX51_xpic_vic_fiq_vect_config_int_source                 0x0000003fU
#define SRT_NX51_xpic_vic_fiq_vect_config_int_source                 0
#define DFLT_VAL_NX51_xpic_vic_fiq_vect_config_int_source            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_fiq_vect_config_int_source         0x00000000U
#define MSK_NX51_xpic_vic_fiq_vect_config_enable                     0x00000040U
#define SRT_NX51_xpic_vic_fiq_vect_config_enable                     6
#define DFLT_VAL_NX51_xpic_vic_fiq_vect_config_enable                0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_fiq_vect_config_enable             0x00000000U
#define MSK_NX51_xpic_vic_fiq_vect_config_select_fiq_default         0x00000080U
#define SRT_NX51_xpic_vic_fiq_vect_config_select_fiq_default         7
#define DFLT_VAL_NX51_xpic_vic_fiq_vect_config_select_fiq_default    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_fiq_vect_config_select_fiq_default 0x00000000U

/* all used bits of 'NX51_xpic_vic_fiq_vect_config': */
#define MSK_USED_BITS_NX51_xpic_vic_fiq_vect_config 0x000000ffU

enum {
	BFW_NX51_xpic_vic_fiq_vect_config_int_source         = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_fiq_vect_config_enable             = 1,  /* [6] */
	BFW_NX51_xpic_vic_fiq_vect_config_select_fiq_default = 1,  /* [7] */
	BFW_NX51_xpic_vic_fiq_vect_config_reserved1          = 24  /* [31:8] */
};

typedef struct NX51_XPIC_VIC_FIQ_VECT_CONFIG_BIT_Ttag {
	unsigned int int_source         : BFW_NX51_xpic_vic_fiq_vect_config_int_source;         /* INT_SOURCE 0-64                                                        */
	unsigned int enable             : BFW_NX51_xpic_vic_fiq_vect_config_enable;             /* vector interrupt enable                                                */
	unsigned int select_fiq_default : BFW_NX51_xpic_vic_fiq_vect_config_select_fiq_default; /* 1 = select default vector for fiq (overwrite the int_source selection) */
	unsigned int reserved1          : BFW_NX51_xpic_vic_fiq_vect_config_reserved1;          /* reserved                                                               */
} NX51_XPIC_VIC_FIQ_VECT_CONFIG_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_VIC_FIQ_VECT_CONFIG_BIT_T bf;
} NX51_XPIC_VIC_FIQ_VECT_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config0 */
/* => highest priority */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config0      0x00000030U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config0 0x10140930U
#define Adr_NX51_xpic_vic_vect_config0          0x10140930U
#define DFLT_VAL_NX51_xpic_vic_vect_config0     0x00000000U

#define MSK_NX51_xpic_vic_vect_config0_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config0_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config0_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config0_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config0_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config0_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config0_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config0_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config0': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config0 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config0_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config0_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config0_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG0_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config0_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config0_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config0_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG0_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG0_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config1 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config1      0x00000034U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config1 0x10140934U
#define Adr_NX51_xpic_vic_vect_config1          0x10140934U
#define DFLT_VAL_NX51_xpic_vic_vect_config1     0x00000000U

#define MSK_NX51_xpic_vic_vect_config1_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config1_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config1_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config1_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config1_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config1_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config1_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config1_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config1': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config1 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config1_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config1_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config1_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG1_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config1_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config1_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config1_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG1_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG1_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config2 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config2      0x00000038U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config2 0x10140938U
#define Adr_NX51_xpic_vic_vect_config2          0x10140938U
#define DFLT_VAL_NX51_xpic_vic_vect_config2     0x00000000U

#define MSK_NX51_xpic_vic_vect_config2_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config2_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config2_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config2_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config2_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config2_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config2_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config2_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config2': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config2 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config2_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config2_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config2_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG2_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config2_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config2_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config2_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG2_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG2_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config3 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config3      0x0000003CU
#define Adr_NX51_xpic_vic_xpic_vic_vect_config3 0x1014093CU
#define Adr_NX51_xpic_vic_vect_config3          0x1014093CU
#define DFLT_VAL_NX51_xpic_vic_vect_config3     0x00000000U

#define MSK_NX51_xpic_vic_vect_config3_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config3_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config3_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config3_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config3_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config3_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config3_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config3_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config3': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config3 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config3_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config3_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config3_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG3_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config3_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config3_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config3_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG3_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG3_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG3_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config4 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config4      0x00000040U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config4 0x10140940U
#define Adr_NX51_xpic_vic_vect_config4          0x10140940U
#define DFLT_VAL_NX51_xpic_vic_vect_config4     0x00000000U

#define MSK_NX51_xpic_vic_vect_config4_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config4_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config4_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config4_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config4_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config4_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config4_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config4_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config4': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config4 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config4_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config4_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config4_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG4_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config4_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config4_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config4_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG4_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG4_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG4_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config5 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config5      0x00000044U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config5 0x10140944U
#define Adr_NX51_xpic_vic_vect_config5          0x10140944U
#define DFLT_VAL_NX51_xpic_vic_vect_config5     0x00000000U

#define MSK_NX51_xpic_vic_vect_config5_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config5_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config5_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config5_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config5_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config5_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config5_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config5_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config5': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config5 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config5_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config5_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config5_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG5_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config5_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config5_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config5_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG5_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG5_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG5_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config6 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config6      0x00000048U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config6 0x10140948U
#define Adr_NX51_xpic_vic_vect_config6          0x10140948U
#define DFLT_VAL_NX51_xpic_vic_vect_config6     0x00000000U

#define MSK_NX51_xpic_vic_vect_config6_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config6_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config6_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config6_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config6_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config6_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config6_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config6_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config6': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config6 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config6_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config6_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config6_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG6_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config6_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config6_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config6_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG6_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG6_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG6_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config7 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config7      0x0000004CU
#define Adr_NX51_xpic_vic_xpic_vic_vect_config7 0x1014094CU
#define Adr_NX51_xpic_vic_vect_config7          0x1014094CU
#define DFLT_VAL_NX51_xpic_vic_vect_config7     0x00000000U

#define MSK_NX51_xpic_vic_vect_config7_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config7_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config7_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config7_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config7_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config7_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config7_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config7_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config7': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config7 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config7_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config7_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config7_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG7_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config7_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config7_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config7_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG7_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG7_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG7_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config8 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config8      0x00000050U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config8 0x10140950U
#define Adr_NX51_xpic_vic_vect_config8          0x10140950U
#define DFLT_VAL_NX51_xpic_vic_vect_config8     0x00000000U

#define MSK_NX51_xpic_vic_vect_config8_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config8_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config8_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config8_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config8_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config8_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config8_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config8_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config8': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config8 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config8_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config8_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config8_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG8_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config8_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config8_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config8_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG8_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG8_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG8_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config9 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config9      0x00000054U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config9 0x10140954U
#define Adr_NX51_xpic_vic_vect_config9          0x10140954U
#define DFLT_VAL_NX51_xpic_vic_vect_config9     0x00000000U

#define MSK_NX51_xpic_vic_vect_config9_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config9_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config9_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config9_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config9_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config9_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config9_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config9_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config9': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config9 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config9_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config9_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config9_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG9_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config9_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config9_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config9_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG9_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_VECT_CONFIG9_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG9_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config10 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config10      0x00000058U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config10 0x10140958U
#define Adr_NX51_xpic_vic_vect_config10          0x10140958U
#define DFLT_VAL_NX51_xpic_vic_vect_config10     0x00000000U

#define MSK_NX51_xpic_vic_vect_config10_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config10_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config10_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config10_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config10_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config10_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config10_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config10_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config10': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config10 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config10_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config10_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config10_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG10_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config10_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config10_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config10_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG10_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_VIC_VECT_CONFIG10_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG10_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config11 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config11      0x0000005CU
#define Adr_NX51_xpic_vic_xpic_vic_vect_config11 0x1014095CU
#define Adr_NX51_xpic_vic_vect_config11          0x1014095CU
#define DFLT_VAL_NX51_xpic_vic_vect_config11     0x00000000U

#define MSK_NX51_xpic_vic_vect_config11_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config11_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config11_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config11_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config11_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config11_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config11_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config11_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config11': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config11 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config11_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config11_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config11_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG11_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config11_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config11_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config11_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG11_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_VIC_VECT_CONFIG11_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG11_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config12 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config12      0x00000060U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config12 0x10140960U
#define Adr_NX51_xpic_vic_vect_config12          0x10140960U
#define DFLT_VAL_NX51_xpic_vic_vect_config12     0x00000000U

#define MSK_NX51_xpic_vic_vect_config12_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config12_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config12_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config12_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config12_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config12_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config12_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config12_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config12': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config12 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config12_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config12_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config12_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG12_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config12_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config12_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config12_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG12_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_VIC_VECT_CONFIG12_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG12_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config13 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config13      0x00000064U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config13 0x10140964U
#define Adr_NX51_xpic_vic_vect_config13          0x10140964U
#define DFLT_VAL_NX51_xpic_vic_vect_config13     0x00000000U

#define MSK_NX51_xpic_vic_vect_config13_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config13_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config13_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config13_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config13_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config13_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config13_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config13_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config13': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config13 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config13_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config13_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config13_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG13_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config13_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config13_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config13_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG13_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_VIC_VECT_CONFIG13_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG13_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config14 */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config14      0x00000068U
#define Adr_NX51_xpic_vic_xpic_vic_vect_config14 0x10140968U
#define Adr_NX51_xpic_vic_vect_config14          0x10140968U
#define DFLT_VAL_NX51_xpic_vic_vect_config14     0x00000000U

#define MSK_NX51_xpic_vic_vect_config14_int_source         0x0000003fU
#define SRT_NX51_xpic_vic_vect_config14_int_source         0
#define DFLT_VAL_NX51_xpic_vic_vect_config14_int_source    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config14_int_source 0x00000000U
#define MSK_NX51_xpic_vic_vect_config14_enable             0x00000040U
#define SRT_NX51_xpic_vic_vect_config14_enable             6
#define DFLT_VAL_NX51_xpic_vic_vect_config14_enable        0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config14_enable     0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config14': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config14 0x0000007fU

enum {
	BFW_NX51_xpic_vic_vect_config14_int_source = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config14_enable     = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config14_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG14_BIT_Ttag {
	unsigned int int_source : BFW_NX51_xpic_vic_vect_config14_int_source; /* INT_SOURCE 0-64         */
	unsigned int enable     : BFW_NX51_xpic_vic_vect_config14_enable;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_xpic_vic_vect_config14_reserved1;  /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG14_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_VIC_VECT_CONFIG14_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG14_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_vect_config15 */
/* => XPIC default interrupt vector, all interrupt sources (wired-OR) */
/*    select with default interrupt vector register */
/*    lowest priority */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_vect_config15      0x0000006CU
#define Adr_NX51_xpic_vic_xpic_vic_vect_config15 0x1014096CU
#define Adr_NX51_xpic_vic_vect_config15          0x1014096CU
#define DFLT_VAL_NX51_xpic_vic_vect_config15     0x00000000U

#define MSK_NX51_xpic_vic_vect_config15_enable         0x00000040U
#define SRT_NX51_xpic_vic_vect_config15_enable         6
#define DFLT_VAL_NX51_xpic_vic_vect_config15_enable    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_vect_config15_enable 0x00000000U

/* all used bits of 'NX51_xpic_vic_vect_config15': */
#define MSK_USED_BITS_NX51_xpic_vic_vect_config15 0x00000040U

enum {
	BFW_NX51_xpic_vic_vect_config15_reserved1 = 6,  /* [5:0] */
	BFW_NX51_xpic_vic_vect_config15_enable    = 1,  /* [6] */
	BFW_NX51_xpic_vic_vect_config15_reserved2 = 25  /* [31:7] */
};

typedef struct NX51_XPIC_VIC_VECT_CONFIG15_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_xpic_vic_vect_config15_reserved1; /* reserved                */
	unsigned int enable    : BFW_NX51_xpic_vic_vect_config15_enable;    /* vector interrupt enable */
	unsigned int reserved2 : BFW_NX51_xpic_vic_vect_config15_reserved2; /* reserved                */
} NX51_XPIC_VIC_VECT_CONFIG15_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_VIC_VECT_CONFIG15_BIT_T bf;
} NX51_XPIC_VIC_VECT_CONFIG15_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_default0 */
/* => XPIC default interrupt vector select0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_default0      0x00000070U
#define Adr_NX51_xpic_vic_xpic_vic_default0 0x10140970U
#define Adr_NX51_xpic_vic_default0          0x10140970U
#define DFLT_VAL_NX51_xpic_vic_default0     0x00000000U

#define MSK_NX51_xpic_vic_default0_val         0xffffffffU
#define SRT_NX51_xpic_vic_default0_val         0
#define DFLT_VAL_NX51_xpic_vic_default0_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_default0_val 0x00000000U

/* all used bits of 'NX51_xpic_vic_default0': */
#define MSK_USED_BITS_NX51_xpic_vic_default0 0xffffffffU

enum {
	BFW_NX51_xpic_vic_default0_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_DEFAULT0_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_default0_val; /* select int0 - int31 (wired-OR) 1-selected 0-not selected */
} NX51_XPIC_VIC_DEFAULT0_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_VIC_DEFAULT0_BIT_T bf;
} NX51_XPIC_VIC_DEFAULT0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_default1 */
/* => XPIC default interrupt vector select1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_default1      0x00000074U
#define Adr_NX51_xpic_vic_xpic_vic_default1 0x10140974U
#define Adr_NX51_xpic_vic_default1          0x10140974U
#define DFLT_VAL_NX51_xpic_vic_default1     0x00000000U

#define MSK_NX51_xpic_vic_default1_val         0xffffffffU
#define SRT_NX51_xpic_vic_default1_val         0
#define DFLT_VAL_NX51_xpic_vic_default1_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_default1_val 0x00000000U

/* all used bits of 'NX51_xpic_vic_default1': */
#define MSK_USED_BITS_NX51_xpic_vic_default1 0xffffffffU

enum {
	BFW_NX51_xpic_vic_default1_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_DEFAULT1_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_default1_val; /* select int32 - int63 (wired-OR) 1-selected 0-not selected */
} NX51_XPIC_VIC_DEFAULT1_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_VIC_DEFAULT1_BIT_T bf;
} NX51_XPIC_VIC_DEFAULT1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_default0 */
/* => XPIC default interrupt vector select0 for fiq */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_fiq_default0      0x00000078U
#define Adr_NX51_xpic_vic_xpic_vic_fiq_default0 0x10140978U
#define Adr_NX51_xpic_vic_fiq_default0          0x10140978U
#define DFLT_VAL_NX51_xpic_vic_fiq_default0     0x00000000U

#define MSK_NX51_xpic_vic_fiq_default0_val         0xffffffffU
#define SRT_NX51_xpic_vic_fiq_default0_val         0
#define DFLT_VAL_NX51_xpic_vic_fiq_default0_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_fiq_default0_val 0x00000000U

/* all used bits of 'NX51_xpic_vic_fiq_default0': */
#define MSK_USED_BITS_NX51_xpic_vic_fiq_default0 0xffffffffU

enum {
	BFW_NX51_xpic_vic_fiq_default0_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_FIQ_DEFAULT0_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_fiq_default0_val; /* select int0 - int31 (wired-OR) 1-selected 0-not selected */
} NX51_XPIC_VIC_FIQ_DEFAULT0_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_FIQ_DEFAULT0_BIT_T bf;
} NX51_XPIC_VIC_FIQ_DEFAULT0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_vic_fiq_default1 */
/* => XPIC default interrupt vector select1 for fiq */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_vic_fiq_default1      0x0000007CU
#define Adr_NX51_xpic_vic_xpic_vic_fiq_default1 0x1014097CU
#define Adr_NX51_xpic_vic_fiq_default1          0x1014097CU
#define DFLT_VAL_NX51_xpic_vic_fiq_default1     0x00000000U

#define MSK_NX51_xpic_vic_fiq_default1_val         0xffffffffU
#define SRT_NX51_xpic_vic_fiq_default1_val         0
#define DFLT_VAL_NX51_xpic_vic_fiq_default1_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_vic_fiq_default1_val 0x00000000U

/* all used bits of 'NX51_xpic_vic_fiq_default1': */
#define MSK_USED_BITS_NX51_xpic_vic_fiq_default1 0xffffffffU

enum {
	BFW_NX51_xpic_vic_fiq_default1_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_VIC_FIQ_DEFAULT1_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_vic_fiq_default1_val; /* select int32 - int63 (wired-OR) 1-selected 0-not selected */
} NX51_XPIC_VIC_FIQ_DEFAULT1_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_VIC_FIQ_DEFAULT1_BIT_T bf;
} NX51_XPIC_VIC_FIQ_DEFAULT1_T;


/* ===================================================================== */

/* Area of xpic_wdg */

/* ===================================================================== */

#define Addr_NX51_xpic_wdg 0x10140A00U

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_trig */
/* => netX xPIC Watchdog Trigger Register. */
/*    The watchdog access code is generated by a pseudo random generator. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_trig      0x00000000U
#define Adr_NX51_xpic_wdg_xpic_wdg_trig 0x10140A00U
#define Adr_NX51_xpic_wdg_trig          0x10140A00U
#define DFLT_VAL_NX51_xpic_wdg_trig     0x00000000U

#define MSK_NX51_xpic_wdg_trig_wdg_access_code               0x000fffffU
#define SRT_NX51_xpic_wdg_trig_wdg_access_code               0
#define DFLT_VAL_NX51_xpic_wdg_trig_wdg_access_code          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_trig_wdg_access_code       0x00000000U
#define MSK_NX51_xpic_wdg_trig_irq_req_watchdog              0x01000000U
#define SRT_NX51_xpic_wdg_trig_irq_req_watchdog              24
#define DFLT_VAL_NX51_xpic_wdg_trig_irq_req_watchdog         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_trig_irq_req_watchdog      0x00000000U
#define MSK_NX51_xpic_wdg_trig_wdg_counter_trigger_w         0x10000000U
#define SRT_NX51_xpic_wdg_trig_wdg_counter_trigger_w         28
#define DFLT_VAL_NX51_xpic_wdg_trig_wdg_counter_trigger_w    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_trig_wdg_counter_trigger_w 0x00000000U
#define MSK_NX51_xpic_wdg_trig_write_enable                  0x80000000U
#define SRT_NX51_xpic_wdg_trig_write_enable                  31
#define DFLT_VAL_NX51_xpic_wdg_trig_write_enable             0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_trig_write_enable          0x00000000U

/* all used bits of 'NX51_xpic_wdg_trig': */
#define MSK_USED_BITS_NX51_xpic_wdg_trig 0x910fffffU

enum {
	BFW_NX51_xpic_wdg_trig_wdg_access_code       = 20, /* [19:0] */
	BFW_NX51_xpic_wdg_trig_reserved1             = 4,  /* [23:20] */
	BFW_NX51_xpic_wdg_trig_irq_req_watchdog      = 1,  /* [24] */
	BFW_NX51_xpic_wdg_trig_reserved2             = 3,  /* [27:25] */
	BFW_NX51_xpic_wdg_trig_wdg_counter_trigger_w = 1,  /* [28] */
	BFW_NX51_xpic_wdg_trig_reserved3             = 2,  /* [30:29] */
	BFW_NX51_xpic_wdg_trig_write_enable          = 1   /* [31] */
};

typedef struct NX51_XPIC_WDG_TRIG_BIT_Ttag {
	unsigned int wdg_access_code       : BFW_NX51_xpic_wdg_trig_wdg_access_code;       /* Watchdog access code for triggering. A read access gives the next 16 bit code for trigger. */
	                                                                                   /* A write access with correct access code will trigger the watchdog counter.                 */
	unsigned int reserved1             : BFW_NX51_xpic_wdg_trig_reserved1;             /* reserved                                                                                   */
	unsigned int irq_req_watchdog      : BFW_NX51_xpic_wdg_trig_irq_req_watchdog;      /* xPIC IRQ request of watchdog, writing 1 deletes IRQ to xPIC                                */
	unsigned int reserved2             : BFW_NX51_xpic_wdg_trig_reserved2;             /* reserved                                                                                   */
	unsigned int wdg_counter_trigger_w : BFW_NX51_xpic_wdg_trig_wdg_counter_trigger_w; /* Watchdog trigger bit:                                                                      */
	                                                                                   /* Bit must be set to trigger the watchdog counter.                                           */
	                                                                                   /* When read, this bit is always '0'                                                          */
	unsigned int reserved3             : BFW_NX51_xpic_wdg_trig_reserved3;             /* reserved                                                                                   */
	unsigned int write_enable          : BFW_NX51_xpic_wdg_trig_write_enable;          /* Write enable bit for timeout register:                                                     */
	                                                                                   /* As long as this bit is not set all write accesses to the timeout register are ignored.     */
} NX51_XPIC_WDG_TRIG_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XPIC_WDG_TRIG_BIT_T bf;
} NX51_XPIC_WDG_TRIG_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_counter */
/* => netX xPIC Watchdog Counter Register */
/*    The counter value is decremented each 10000 system clock cycles. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_counter      0x00000004U
#define Adr_NX51_xpic_wdg_xpic_wdg_counter 0x10140A04U
#define Adr_NX51_xpic_wdg_counter          0x10140A04U

#define MSK_NX51_xpic_wdg_counter_val 0x0001ffffU
#define SRT_NX51_xpic_wdg_counter_val 0

/* all used bits of 'NX51_xpic_wdg_counter': */
#define MSK_USED_BITS_NX51_xpic_wdg_counter 0x0001ffffU

enum {
	BFW_NX51_xpic_wdg_counter_val       = 17, /* [16:0] */
	BFW_NX51_xpic_wdg_counter_reserved1 = 15  /* [31:17] */
};

typedef struct NX51_XPIC_WDG_COUNTER_BIT_Ttag {
	unsigned int val       : BFW_NX51_xpic_wdg_counter_val;       /* Actual watchdog counter value:                                       */
	                                                              /* Bit 16 shows:                                                        */
	                                                              /* 1: Watchdog is counting down from xpic_irq_timeout to 0 for xPIC-IRQ */
	                                                              /* 0: Watchdog is counting down from arm_irq_timeout to 0 for ARM-IRQ   */
	unsigned int reserved1 : BFW_NX51_xpic_wdg_counter_reserved1; /* reserved                                                             */
} NX51_XPIC_WDG_COUNTER_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XPIC_WDG_COUNTER_BIT_T bf;
} NX51_XPIC_WDG_COUNTER_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_xpic_irq_timeout */
/* => netX xPIC Watchdog xPIC interrupt timout register: */
/*    xpic_irq_timeout or arm_irq_timeout must be nonzero to enable watchdog */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_xpic_irq_timeout      0x00000008U
#define Adr_NX51_xpic_wdg_xpic_wdg_xpic_irq_timeout 0x10140A08U
#define Adr_NX51_xpic_wdg_xpic_irq_timeout          0x10140A08U
#define DFLT_VAL_NX51_xpic_wdg_xpic_irq_timeout     0x00000000U

#define MSK_NX51_xpic_wdg_xpic_irq_timeout_val         0x0000ffffU
#define SRT_NX51_xpic_wdg_xpic_irq_timeout_val         0
#define DFLT_VAL_NX51_xpic_wdg_xpic_irq_timeout_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_xpic_irq_timeout_val 0x00000000U

/* all used bits of 'NX51_xpic_wdg_xpic_irq_timeout': */
#define MSK_USED_BITS_NX51_xpic_wdg_xpic_irq_timeout 0x0000ffffU

enum {
	BFW_NX51_xpic_wdg_xpic_irq_timeout_val       = 16, /* [15:0] */
	BFW_NX51_xpic_wdg_xpic_irq_timeout_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XPIC_WDG_XPIC_IRQ_TIMEOUT_BIT_Ttag {
	unsigned int val       : BFW_NX51_xpic_wdg_xpic_irq_timeout_val;       /* Watchdog interrupt timeout                                                                  */
	                                                                       /* The total xpic_irq timeout for a netX clock of 100MHz is: xpic_wdg_xpic_irq_timeout * 100s */
	unsigned int reserved1 : BFW_NX51_xpic_wdg_xpic_irq_timeout_reserved1; /* reserved                                                                                    */
} NX51_XPIC_WDG_XPIC_IRQ_TIMEOUT_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_XPIC_WDG_XPIC_IRQ_TIMEOUT_BIT_T bf;
} NX51_XPIC_WDG_XPIC_IRQ_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_arm_irq_timeout */
/* => netX xPIC Watchdog ARM interrupt timout register: */
/*    xpic_irq_timeout or arm_irq_timeout must be nonzero to enable watchdog */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_arm_irq_timeout      0x0000000CU
#define Adr_NX51_xpic_wdg_xpic_wdg_arm_irq_timeout 0x10140A0CU
#define Adr_NX51_xpic_wdg_arm_irq_timeout          0x10140A0CU
#define DFLT_VAL_NX51_xpic_wdg_arm_irq_timeout     0x00000000U

#define MSK_NX51_xpic_wdg_arm_irq_timeout_val         0x0000ffffU
#define SRT_NX51_xpic_wdg_arm_irq_timeout_val         0
#define DFLT_VAL_NX51_xpic_wdg_arm_irq_timeout_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_arm_irq_timeout_val 0x00000000U

/* all used bits of 'NX51_xpic_wdg_arm_irq_timeout': */
#define MSK_USED_BITS_NX51_xpic_wdg_arm_irq_timeout 0x0000ffffU

enum {
	BFW_NX51_xpic_wdg_arm_irq_timeout_val       = 16, /* [15:0] */
	BFW_NX51_xpic_wdg_arm_irq_timeout_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XPIC_WDG_ARM_IRQ_TIMEOUT_BIT_Ttag {
	unsigned int val       : BFW_NX51_xpic_wdg_arm_irq_timeout_val;       /* Watchdog ARM interrupt timeout                                                                                          */
	                                                                      /* The total arm_irq timeout for a netX clock of 100MHz is: (xpic_wdg_xpic_irq_timeout + xpic_wdg_arm_irq_timeout) * 100s */
	unsigned int reserved1 : BFW_NX51_xpic_wdg_arm_irq_timeout_reserved1; /* reserved                                                                                                                */
} NX51_XPIC_WDG_ARM_IRQ_TIMEOUT_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_WDG_ARM_IRQ_TIMEOUT_BIT_T bf;
} NX51_XPIC_WDG_ARM_IRQ_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_raw */
/* => Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_irq_raw      0x00000010U
#define Adr_NX51_xpic_wdg_xpic_wdg_irq_raw 0x10140A10U
#define Adr_NX51_xpic_wdg_irq_raw          0x10140A10U
#define DFLT_VAL_NX51_xpic_wdg_irq_raw     0x00000000U

#define MSK_NX51_xpic_wdg_irq_raw_wdg_arm_irq         0x00000001U
#define SRT_NX51_xpic_wdg_irq_raw_wdg_arm_irq         0
#define DFLT_VAL_NX51_xpic_wdg_irq_raw_wdg_arm_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_irq_raw_wdg_arm_irq 0x00000000U

/* all used bits of 'NX51_xpic_wdg_irq_raw': */
#define MSK_USED_BITS_NX51_xpic_wdg_irq_raw 0x00000001U

enum {
	BFW_NX51_xpic_wdg_irq_raw_wdg_arm_irq = 1,  /* [0] */
	BFW_NX51_xpic_wdg_irq_raw_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_XPIC_WDG_IRQ_RAW_BIT_Ttag {
	unsigned int wdg_arm_irq : BFW_NX51_xpic_wdg_irq_raw_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
	unsigned int reserved1   : BFW_NX51_xpic_wdg_irq_raw_reserved1;   /* reserved                            */
} NX51_XPIC_WDG_IRQ_RAW_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XPIC_WDG_IRQ_RAW_BIT_T bf;
} NX51_XPIC_WDG_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_masked */
/* => xpic_wdg Masked IRQ register: */
/*    Shows status of masked IRQs (as connected to xPIC). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_irq_masked      0x00000014U
#define Adr_NX51_xpic_wdg_xpic_wdg_irq_masked 0x10140A14U
#define Adr_NX51_xpic_wdg_irq_masked          0x10140A14U

#define MSK_NX51_xpic_wdg_irq_masked_wdg_arm_irq 0x00000001U
#define SRT_NX51_xpic_wdg_irq_masked_wdg_arm_irq 0

/* all used bits of 'NX51_xpic_wdg_irq_masked': */
#define MSK_USED_BITS_NX51_xpic_wdg_irq_masked 0x00000001U

enum {
	BFW_NX51_xpic_wdg_irq_masked_wdg_arm_irq = 1,  /* [0] */
	BFW_NX51_xpic_wdg_irq_masked_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_XPIC_WDG_IRQ_MASKED_BIT_Ttag {
	unsigned int wdg_arm_irq : BFW_NX51_xpic_wdg_irq_masked_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
	unsigned int reserved1   : BFW_NX51_xpic_wdg_irq_masked_reserved1;   /* reserved                            */
} NX51_XPIC_WDG_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_XPIC_WDG_IRQ_MASKED_BIT_T bf;
} NX51_XPIC_WDG_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_msk_set */
/* => xpic_wdg interrupt mask enable: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to wdg_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_irq_msk_set      0x00000018U
#define Adr_NX51_xpic_wdg_xpic_wdg_irq_msk_set 0x10140A18U
#define Adr_NX51_xpic_wdg_irq_msk_set          0x10140A18U
#define DFLT_VAL_NX51_xpic_wdg_irq_msk_set     0x00000000U

#define MSK_NX51_xpic_wdg_irq_msk_set_wdg_arm_irq         0x00000001U
#define SRT_NX51_xpic_wdg_irq_msk_set_wdg_arm_irq         0
#define DFLT_VAL_NX51_xpic_wdg_irq_msk_set_wdg_arm_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_irq_msk_set_wdg_arm_irq 0x00000000U

/* all used bits of 'NX51_xpic_wdg_irq_msk_set': */
#define MSK_USED_BITS_NX51_xpic_wdg_irq_msk_set 0x00000001U

enum {
	BFW_NX51_xpic_wdg_irq_msk_set_wdg_arm_irq = 1,  /* [0] */
	BFW_NX51_xpic_wdg_irq_msk_set_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_XPIC_WDG_IRQ_MSK_SET_BIT_Ttag {
	unsigned int wdg_arm_irq : BFW_NX51_xpic_wdg_irq_msk_set_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
	unsigned int reserved1   : BFW_NX51_xpic_wdg_irq_msk_set_reserved1;   /* reserved                            */
} NX51_XPIC_WDG_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_XPIC_WDG_IRQ_MSK_SET_BIT_T bf;
} NX51_XPIC_WDG_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_wdg_irq_msk_reset */
/* => xpic_wdg interrupt mask disable: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_wdg_irq_msk_reset      0x0000001CU
#define Adr_NX51_xpic_wdg_xpic_wdg_irq_msk_reset 0x10140A1CU
#define Adr_NX51_xpic_wdg_irq_msk_reset          0x10140A1CU
#define DFLT_VAL_NX51_xpic_wdg_irq_msk_reset     0x00000000U

#define MSK_NX51_xpic_wdg_irq_msk_reset_wdg_arm_irq         0x00000001U
#define SRT_NX51_xpic_wdg_irq_msk_reset_wdg_arm_irq         0
#define DFLT_VAL_NX51_xpic_wdg_irq_msk_reset_wdg_arm_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_wdg_irq_msk_reset_wdg_arm_irq 0x00000000U

/* all used bits of 'NX51_xpic_wdg_irq_msk_reset': */
#define MSK_USED_BITS_NX51_xpic_wdg_irq_msk_reset 0x00000001U

enum {
	BFW_NX51_xpic_wdg_irq_msk_reset_wdg_arm_irq = 1,  /* [0] */
	BFW_NX51_xpic_wdg_irq_msk_reset_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_XPIC_WDG_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int wdg_arm_irq : BFW_NX51_xpic_wdg_irq_msk_reset_wdg_arm_irq; /* Interrupt from xPIC Watchdog to ARM */
	unsigned int reserved1   : BFW_NX51_xpic_wdg_irq_msk_reset_reserved1;   /* reserved                            */
} NX51_XPIC_WDG_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_WDG_IRQ_MSK_RESET_BIT_T bf;
} NX51_XPIC_WDG_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* AREA intlogic */
/* Area of intlogic_sys, intlogic_sys_mirror_hi, intlogic_sys_mirror_buf */

/* ===================================================================== */

#define Addr_NX51_intlogic_sys            0x10180000U
#define Addr_NX51_intlogic_sys_mirror_hi  0xFFF80000U
#define Addr_NX51_intlogic_sys_mirror_buf 0x08180000U

/* ===================================================================== */

/* AREA xpic_ram */
/* Area of xpic_pram, xpic_dram */

/* ===================================================================== */

#define Addr_NX51_xpic_pram 0x10180000U
#define Addr_NX51_xpic_dram 0x10280000U

/* --------------------------------------------------------------------- */
/* Register xpic_ram_start */
/* => xPIC program or data RAM (xPIC TCM) start address: */
/*    Both xPIC TCMs (program and data) are only accessible by other system masters, \ */
/*    if xPIC is not running (xpic_debug-xpic_hold_pc-hold=0). */
/*    xPIC TCMs are only accessible for configuration and setup of xPIC processor. */
/*    xPIC TCMs should never be used for data exchange between xPIC and other system-masters. */
/*    Attention: Accessing xPIC_dram (data-TCM) while xPIC is running might seem to work but \ */
/*    influences communication tasks and HIF acesses and leads to instable system behaviour! */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_ram_start       0x00000000U
#define Adr_NX51_xpic_pram_xpic_ram_start 0x10180000U
#define Adr_NX51_xpic_dram_xpic_ram_start 0x10280000U

/* --------------------------------------------------------------------- */
/* Register xpic_ram_end */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_ram_end       0x00001FFCU
#define Adr_NX51_xpic_pram_xpic_ram_end 0x10181FFCU
#define Adr_NX51_xpic_dram_xpic_ram_end 0x10281FFCU


/* ===================================================================== */

/* AREA pec_ram */
/* Area of rpec0_pram, tpec0_pram, rpec1_pram, tpec1_pram, rpec0_dram, tpec0_dram, rpec1_dram, tpec1_dram */

/* ===================================================================== */

#define Addr_NX51_rpec0_pram 0x10182000U
#define Addr_NX51_tpec0_pram 0x10184000U
#define Addr_NX51_rpec1_pram 0x10186000U
#define Addr_NX51_tpec1_pram 0x10188000U
#define Addr_NX51_rpec0_dram 0x10282000U
#define Addr_NX51_tpec0_dram 0x10284000U
#define Addr_NX51_rpec1_dram 0x10286000U
#define Addr_NX51_tpec1_dram 0x10288000U

/* --------------------------------------------------------------------- */
/* Register ram_start */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ram_start        0x00000000U
#define Adr_NX51_rpec0_pram_ram_start 0x10182000U
#define Adr_NX51_tpec0_pram_ram_start 0x10184000U
#define Adr_NX51_rpec1_pram_ram_start 0x10186000U
#define Adr_NX51_tpec1_pram_ram_start 0x10188000U
#define Adr_NX51_rpec0_dram_ram_start 0x10282000U
#define Adr_NX51_tpec0_dram_ram_start 0x10284000U
#define Adr_NX51_rpec1_dram_ram_start 0x10286000U
#define Adr_NX51_tpec1_dram_ram_start 0x10288000U

/* --------------------------------------------------------------------- */
/* Register ram_end */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ram_end        0x00001FFCU
#define Adr_NX51_rpec0_pram_ram_end 0x10183FFCU
#define Adr_NX51_tpec0_pram_ram_end 0x10185FFCU
#define Adr_NX51_rpec1_pram_ram_end 0x10187FFCU
#define Adr_NX51_tpec1_pram_ram_end 0x10189FFCU
#define Adr_NX51_rpec0_dram_ram_end 0x10283FFCU
#define Adr_NX51_tpec0_dram_ram_end 0x10285FFCU
#define Adr_NX51_rpec1_dram_ram_end 0x10287FFCU
#define Adr_NX51_tpec1_dram_ram_end 0x10289FFCU


/* ===================================================================== */

/* AREA xmac_ram */
/* Area of rpu0_ram, tpu0_ram, rpu1_ram, tpu1_ram */

/* ===================================================================== */

#define Addr_NX51_rpu0_ram 0x1018A000U
#define Addr_NX51_tpu0_ram 0x1018A400U
#define Addr_NX51_rpu1_ram 0x1018A800U
#define Addr_NX51_tpu1_ram 0x1018AC00U

/* --------------------------------------------------------------------- */
/* Register xmac_ram_start */
/* => xMAC RPU program-RAM start address. */
/*    The Program-RAM is not addressable for xMAC RPU and TPU ! */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_ram_start      0x00000000U
#define Adr_NX51_rpu0_ram_xmac_ram_start 0x1018A000U
#define Adr_NX51_tpu0_ram_xmac_ram_start 0x1018A400U
#define Adr_NX51_rpu1_ram_xmac_ram_start 0x1018A800U
#define Adr_NX51_tpu1_ram_xmac_ram_start 0x1018AC00U

/* --------------------------------------------------------------------- */
/* Register xmac_ram_end */
/* => xMAC RPU program-RAM end address. */
/*    This value is not used by design flow, only for documentation */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_ram_end      0x000003FCU
#define Adr_NX51_rpu0_ram_xmac_ram_end 0x1018A3FCU
#define Adr_NX51_tpu0_ram_xmac_ram_end 0x1018A7FCU
#define Adr_NX51_rpu1_ram_xmac_ram_end 0x1018ABFCU
#define Adr_NX51_tpu1_ram_xmac_ram_end 0x1018AFFCU


/* ===================================================================== */

/* AREA xpec */
/* Area of rpec0_regs, tpec0_regs, rpec1_regs, tpec1_regs */

/* ===================================================================== */

#define Addr_NX51_rpec0_regs 0x1018B000U
#define NX51_NETX_XRP0_BASE  0x1018B000U
#define Addr_NX51_tpec0_regs 0x1018B100U
#define NX51_NETX_XTP0_BASE  0x1018B100U
#define Addr_NX51_rpec1_regs 0x1018B200U
#define NX51_NETX_XRP1_BASE  0x1018B200U
#define Addr_NX51_tpec1_regs 0x1018B300U
#define NX51_NETX_XTP1_BASE  0x1018B300U

/* --------------------------------------------------------------------- */
/* Register xpec_r0 */
/* => xPEC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r0        0x00000000U
#define Adr_NX51_rpec0_regs_xpec_r0 0x1018B000U
#define Adr_NX51_tpec0_regs_xpec_r0 0x1018B100U
#define Adr_NX51_rpec1_regs_xpec_r0 0x1018B200U
#define Adr_NX51_tpec1_regs_xpec_r0 0x1018B300U
#define DFLT_VAL_NX51_xpec_r0       0x00000000U

#define MSK_NX51_xpec_r0_r0         0xffffffffU
#define SRT_NX51_xpec_r0_r0         0
#define DFLT_VAL_NX51_xpec_r0_r0    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r0_r0 0x00000000U

/* all used bits of 'NX51_xpec_r0': */
#define MSK_USED_BITS_NX51_xpec_r0 0xffffffffU

enum {
	BFW_NX51_xpec_r0_r0 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R0_BIT_Ttag {
	unsigned int r0 : BFW_NX51_xpec_r0_r0; /* Work Register 0 */
} NX51_XPEC_R0_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R0_BIT_T bf;
} NX51_XPEC_R0_T;

/* --------------------------------------------------------------------- */
/* Register xpec_r1 */
/* => xPEC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r1        0x00000004U
#define Adr_NX51_rpec0_regs_xpec_r1 0x1018B004U
#define Adr_NX51_tpec0_regs_xpec_r1 0x1018B104U
#define Adr_NX51_rpec1_regs_xpec_r1 0x1018B204U
#define Adr_NX51_tpec1_regs_xpec_r1 0x1018B304U
#define DFLT_VAL_NX51_xpec_r1       0x00000000U

#define MSK_NX51_xpec_r1_r1         0xffffffffU
#define SRT_NX51_xpec_r1_r1         0
#define DFLT_VAL_NX51_xpec_r1_r1    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r1_r1 0x00000000U

/* all used bits of 'NX51_xpec_r1': */
#define MSK_USED_BITS_NX51_xpec_r1 0xffffffffU

enum {
	BFW_NX51_xpec_r1_r1 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R1_BIT_Ttag {
	unsigned int r1 : BFW_NX51_xpec_r1_r1; /* Work Register 1 */
} NX51_XPEC_R1_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R1_BIT_T bf;
} NX51_XPEC_R1_T;

/* --------------------------------------------------------------------- */
/* Register xpec_r2 */
/* => xPEC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r2        0x00000008U
#define Adr_NX51_rpec0_regs_xpec_r2 0x1018B008U
#define Adr_NX51_tpec0_regs_xpec_r2 0x1018B108U
#define Adr_NX51_rpec1_regs_xpec_r2 0x1018B208U
#define Adr_NX51_tpec1_regs_xpec_r2 0x1018B308U
#define DFLT_VAL_NX51_xpec_r2       0x00000000U

#define MSK_NX51_xpec_r2_r2         0xffffffffU
#define SRT_NX51_xpec_r2_r2         0
#define DFLT_VAL_NX51_xpec_r2_r2    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r2_r2 0x00000000U

/* all used bits of 'NX51_xpec_r2': */
#define MSK_USED_BITS_NX51_xpec_r2 0xffffffffU

enum {
	BFW_NX51_xpec_r2_r2 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R2_BIT_Ttag {
	unsigned int r2 : BFW_NX51_xpec_r2_r2; /* Work Register 2 */
} NX51_XPEC_R2_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R2_BIT_T bf;
} NX51_XPEC_R2_T;

/* --------------------------------------------------------------------- */
/* Register xpec_r3 */
/* => xPEC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r3        0x0000000CU
#define Adr_NX51_rpec0_regs_xpec_r3 0x1018B00CU
#define Adr_NX51_tpec0_regs_xpec_r3 0x1018B10CU
#define Adr_NX51_rpec1_regs_xpec_r3 0x1018B20CU
#define Adr_NX51_tpec1_regs_xpec_r3 0x1018B30CU
#define DFLT_VAL_NX51_xpec_r3       0x00000000U

#define MSK_NX51_xpec_r3_r3         0xffffffffU
#define SRT_NX51_xpec_r3_r3         0
#define DFLT_VAL_NX51_xpec_r3_r3    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r3_r3 0x00000000U

/* all used bits of 'NX51_xpec_r3': */
#define MSK_USED_BITS_NX51_xpec_r3 0xffffffffU

enum {
	BFW_NX51_xpec_r3_r3 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R3_BIT_Ttag {
	unsigned int r3 : BFW_NX51_xpec_r3_r3; /* Work Register 3 */
} NX51_XPEC_R3_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R3_BIT_T bf;
} NX51_XPEC_R3_T;

/* --------------------------------------------------------------------- */
/* Register xpec_r4 */
/* => xPEC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r4        0x00000010U
#define Adr_NX51_rpec0_regs_xpec_r4 0x1018B010U
#define Adr_NX51_tpec0_regs_xpec_r4 0x1018B110U
#define Adr_NX51_rpec1_regs_xpec_r4 0x1018B210U
#define Adr_NX51_tpec1_regs_xpec_r4 0x1018B310U
#define DFLT_VAL_NX51_xpec_r4       0x00000000U

#define MSK_NX51_xpec_r4_r4         0xffffffffU
#define SRT_NX51_xpec_r4_r4         0
#define DFLT_VAL_NX51_xpec_r4_r4    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r4_r4 0x00000000U

/* all used bits of 'NX51_xpec_r4': */
#define MSK_USED_BITS_NX51_xpec_r4 0xffffffffU

enum {
	BFW_NX51_xpec_r4_r4 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R4_BIT_Ttag {
	unsigned int r4 : BFW_NX51_xpec_r4_r4; /* Work Register 4 */
} NX51_XPEC_R4_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R4_BIT_T bf;
} NX51_XPEC_R4_T;

/* --------------------------------------------------------------------- */
/* Register xpec_r5 */
/* => xPEC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r5        0x00000014U
#define Adr_NX51_rpec0_regs_xpec_r5 0x1018B014U
#define Adr_NX51_tpec0_regs_xpec_r5 0x1018B114U
#define Adr_NX51_rpec1_regs_xpec_r5 0x1018B214U
#define Adr_NX51_tpec1_regs_xpec_r5 0x1018B314U
#define DFLT_VAL_NX51_xpec_r5       0x00000000U

#define MSK_NX51_xpec_r5_r5         0xffffffffU
#define SRT_NX51_xpec_r5_r5         0
#define DFLT_VAL_NX51_xpec_r5_r5    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r5_r5 0x00000000U

/* all used bits of 'NX51_xpec_r5': */
#define MSK_USED_BITS_NX51_xpec_r5 0xffffffffU

enum {
	BFW_NX51_xpec_r5_r5 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R5_BIT_Ttag {
	unsigned int r5 : BFW_NX51_xpec_r5_r5; /* Work Register 5 */
} NX51_XPEC_R5_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R5_BIT_T bf;
} NX51_XPEC_R5_T;

/* --------------------------------------------------------------------- */
/* Register xpec_r6 */
/* => xPEC work register for indirect addressing */
/*    Shared in xPEC fmmusm mode with fmmusm_read_addr_in (w mode).Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC fmmusm mode with sm_read_addr_out (r mode).Register only accessible via rPEC0 and tPEC0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r6        0x00000018U
#define Adr_NX51_rpec0_regs_xpec_r6 0x1018B018U
#define Adr_NX51_tpec0_regs_xpec_r6 0x1018B118U
#define Adr_NX51_rpec1_regs_xpec_r6 0x1018B218U
#define Adr_NX51_tpec1_regs_xpec_r6 0x1018B318U
#define DFLT_VAL_NX51_xpec_r6       0x00000000U

#define MSK_NX51_xpec_r6_r6         0xffffffffU
#define SRT_NX51_xpec_r6_r6         0
#define DFLT_VAL_NX51_xpec_r6_r6    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r6_r6 0x00000000U

/* all used bits of 'NX51_xpec_r6': */
#define MSK_USED_BITS_NX51_xpec_r6 0xffffffffU

enum {
	BFW_NX51_xpec_r6_r6 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R6_BIT_Ttag {
	unsigned int r6 : BFW_NX51_xpec_r6_r6; /* Work Register 6 */
} NX51_XPEC_R6_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R6_BIT_T bf;
} NX51_XPEC_R6_T;

/* --------------------------------------------------------------------- */
/* Register xpec_r7 */
/* => xPEC work register for indirect addressing */
/*    Shared in xPEC fmmusm mode with fmmusm_write_addr_in (w mode).Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC fmmusm mode with sm_write_addr_out (r mode).Register only accessible via rPEC0 and tPEC0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_r7        0x0000001CU
#define Adr_NX51_rpec0_regs_xpec_r7 0x1018B01CU
#define Adr_NX51_tpec0_regs_xpec_r7 0x1018B11CU
#define Adr_NX51_rpec1_regs_xpec_r7 0x1018B21CU
#define Adr_NX51_tpec1_regs_xpec_r7 0x1018B31CU
#define DFLT_VAL_NX51_xpec_r7       0x00000000U

#define MSK_NX51_xpec_r7_r7         0xffffffffU
#define SRT_NX51_xpec_r7_r7         0
#define DFLT_VAL_NX51_xpec_r7_r7    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_r7_r7 0x00000000U

/* all used bits of 'NX51_xpec_r7': */
#define MSK_USED_BITS_NX51_xpec_r7 0xffffffffU

enum {
	BFW_NX51_xpec_r7_r7 = 32  /* [31:0] */
};

typedef struct NX51_XPEC_R7_BIT_Ttag {
	unsigned int r7 : BFW_NX51_xpec_r7_r7; /* Work Register 7 */
} NX51_XPEC_R7_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_R7_BIT_T bf;
} NX51_XPEC_R7_T;

/* --------------------------------------------------------------------- */
/* Register xpec_stat_bits_shared */
/* => Shared stat register accessed by all xPECs and all xMACs (with 16 events). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_stat_bits_shared        0x00000020U
#define Adr_NX51_rpec0_regs_xpec_stat_bits_shared 0x1018B020U
#define Adr_NX51_tpec0_regs_xpec_stat_bits_shared 0x1018B120U
#define Adr_NX51_rpec1_regs_xpec_stat_bits_shared 0x1018B220U
#define Adr_NX51_tpec1_regs_xpec_stat_bits_shared 0x1018B320U
#define DFLT_VAL_NX51_xpec_stat_bits_shared       0x00000000U

#define MSK_NX51_xpec_stat_bits_shared_flags            0x0000ffffU
#define SRT_NX51_xpec_stat_bits_shared_flags            0
#define DFLT_VAL_NX51_xpec_stat_bits_shared_flags       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_stat_bits_shared_flags    0x00000000U
#define MSK_NX51_xpec_stat_bits_shared_set_mask         0xffff0000U
#define SRT_NX51_xpec_stat_bits_shared_set_mask         16
#define DFLT_VAL_NX51_xpec_stat_bits_shared_set_mask    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_stat_bits_shared_set_mask 0x00000000U

/* all used bits of 'NX51_xpec_stat_bits_shared': */
#define MSK_USED_BITS_NX51_xpec_stat_bits_shared 0xffffffffU

enum {
	BFW_NX51_xpec_stat_bits_shared_flags    = 16, /* [15:0] */
	BFW_NX51_xpec_stat_bits_shared_set_mask = 16  /* [31:16] */
};

typedef struct NX51_XPEC_STAT_BITS_SHARED_BIT_Ttag {
	unsigned int flags    : BFW_NX51_xpec_stat_bits_shared_flags;    /* flags    */
	unsigned int set_mask : BFW_NX51_xpec_stat_bits_shared_set_mask; /* set mask */
} NX51_XPEC_STAT_BITS_SHARED_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPEC_STAT_BITS_SHARED_BIT_T bf;
} NX51_XPEC_STAT_BITS_SHARED_T;

/* --------------------------------------------------------------------- */
/* Register range_urtx_count */
/* => xPEC Overflow Underflow register to limit stack and fifo buffer. */
/*    Generates range events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_range_urtx_count        0x00000024U
#define Adr_NX51_rpec0_regs_range_urtx_count 0x1018B024U
#define Adr_NX51_tpec0_regs_range_urtx_count 0x1018B124U
#define Adr_NX51_rpec1_regs_range_urtx_count 0x1018B224U
#define Adr_NX51_tpec1_regs_range_urtx_count 0x1018B324U
#define DFLT_VAL_NX51_range_urtx_count       0x00000000U

#define MSK_NX51_range_urtx_count_range_urx_count         0x00001fffU
#define SRT_NX51_range_urtx_count_range_urx_count         0
#define DFLT_VAL_NX51_range_urtx_count_range_urx_count    0x00000000U
#define DFLT_BF_VAL_NX51_range_urtx_count_range_urx_count 0x00000000U
#define MSK_NX51_range_urtx_count_range_utx_count         0x1fff0000U
#define SRT_NX51_range_urtx_count_range_utx_count         16
#define DFLT_VAL_NX51_range_urtx_count_range_utx_count    0x00000000U
#define DFLT_BF_VAL_NX51_range_urtx_count_range_utx_count 0x00000000U

/* all used bits of 'NX51_range_urtx_count': */
#define MSK_USED_BITS_NX51_range_urtx_count 0x1fff1fffU

enum {
	BFW_NX51_range_urtx_count_range_urx_count = 13, /* [12:0] */
	BFW_NX51_range_urtx_count_reserved1       = 3,  /* [15:13] */
	BFW_NX51_range_urtx_count_range_utx_count = 13, /* [28:16] */
	BFW_NX51_range_urtx_count_reserved2       = 3   /* [31:29] */
};

typedef struct NX51_RANGE_URTX_COUNT_BIT_Ttag {
	unsigned int range_urx_count : BFW_NX51_range_urtx_count_range_urx_count; /* border for xpec_urx_count */
	unsigned int reserved1       : BFW_NX51_range_urtx_count_reserved1;       /* reserved                  */
	unsigned int range_utx_count : BFW_NX51_range_urtx_count_range_utx_count; /* border for xpec_utx_count */
	unsigned int reserved2       : BFW_NX51_range_urtx_count_reserved2;       /* reserved                  */
} NX51_RANGE_URTX_COUNT_BIT_T;

typedef union {
	unsigned int                val;
	NX51_RANGE_URTX_COUNT_BIT_T bf;
} NX51_RANGE_URTX_COUNT_T;

/* --------------------------------------------------------------------- */
/* Register range45 */
/* => xPEC Overflow Underflow register to limit stack and fifo buffer. */
/*    Generates range events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_range45        0x00000028U
#define Adr_NX51_rpec0_regs_range45 0x1018B028U
#define Adr_NX51_tpec0_regs_range45 0x1018B128U
#define Adr_NX51_rpec1_regs_range45 0x1018B228U
#define Adr_NX51_tpec1_regs_range45 0x1018B328U
#define DFLT_VAL_NX51_range45       0x00000000U

#define MSK_NX51_range45_range4         0x00001fffU
#define SRT_NX51_range45_range4         0
#define DFLT_VAL_NX51_range45_range4    0x00000000U
#define DFLT_BF_VAL_NX51_range45_range4 0x00000000U
#define MSK_NX51_range45_range5         0x1fff0000U
#define SRT_NX51_range45_range5         16
#define DFLT_VAL_NX51_range45_range5    0x00000000U
#define DFLT_BF_VAL_NX51_range45_range5 0x00000000U

/* all used bits of 'NX51_range45': */
#define MSK_USED_BITS_NX51_range45 0x1fff1fffU

enum {
	BFW_NX51_range45_range4    = 13, /* [12:0] */
	BFW_NX51_range45_reserved1 = 3,  /* [15:13] */
	BFW_NX51_range45_range5    = 13, /* [28:16] */
	BFW_NX51_range45_reserved2 = 3   /* [31:29] */
};

typedef struct NX51_RANGE45_BIT_Ttag {
	unsigned int range4    : BFW_NX51_range45_range4;    /* border for xpec_r4 */
	unsigned int reserved1 : BFW_NX51_range45_reserved1; /* reserved           */
	unsigned int range5    : BFW_NX51_range45_range5;    /* border for xpec_r5 */
	unsigned int reserved2 : BFW_NX51_range45_reserved2; /* reserved           */
} NX51_RANGE45_BIT_T;

typedef union {
	unsigned int       val;
	NX51_RANGE45_BIT_T bf;
} NX51_RANGE45_T;

/* --------------------------------------------------------------------- */
/* Register range67 */
/* => xPEC Overflow Underflow register to limit stack and fifo buffer. */
/*    Generates range events */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_range67        0x0000002CU
#define Adr_NX51_rpec0_regs_range67 0x1018B02CU
#define Adr_NX51_tpec0_regs_range67 0x1018B12CU
#define Adr_NX51_rpec1_regs_range67 0x1018B22CU
#define Adr_NX51_tpec1_regs_range67 0x1018B32CU
#define DFLT_VAL_NX51_range67       0x00000000U

#define MSK_NX51_range67_range6         0x00001fffU
#define SRT_NX51_range67_range6         0
#define DFLT_VAL_NX51_range67_range6    0x00000000U
#define DFLT_BF_VAL_NX51_range67_range6 0x00000000U
#define MSK_NX51_range67_range7         0x1fff0000U
#define SRT_NX51_range67_range7         16
#define DFLT_VAL_NX51_range67_range7    0x00000000U
#define DFLT_BF_VAL_NX51_range67_range7 0x00000000U

/* all used bits of 'NX51_range67': */
#define MSK_USED_BITS_NX51_range67 0x1fff1fffU

enum {
	BFW_NX51_range67_range6    = 13, /* [12:0] */
	BFW_NX51_range67_reserved1 = 3,  /* [15:13] */
	BFW_NX51_range67_range7    = 13, /* [28:16] */
	BFW_NX51_range67_reserved2 = 3   /* [31:29] */
};

typedef struct NX51_RANGE67_BIT_Ttag {
	unsigned int range6    : BFW_NX51_range67_range6;    /* border for xpec_r6 */
	unsigned int reserved1 : BFW_NX51_range67_reserved1; /* reserved           */
	unsigned int range7    : BFW_NX51_range67_range7;    /* border for xpec_r7 */
	unsigned int reserved2 : BFW_NX51_range67_reserved2; /* reserved           */
} NX51_RANGE67_BIT_T;

typedef union {
	unsigned int       val;
	NX51_RANGE67_BIT_T bf;
} NX51_RANGE67_T;

/* --------------------------------------------------------------------- */
/* Register timer0 */
/* => xPEC Timer 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_timer0        0x00000030U
#define Adr_NX51_rpec0_regs_timer0 0x1018B030U
#define Adr_NX51_tpec0_regs_timer0 0x1018B130U
#define Adr_NX51_rpec1_regs_timer0 0x1018B230U
#define Adr_NX51_tpec1_regs_timer0 0x1018B330U
#define DFLT_VAL_NX51_timer0       0x00000000U

#define MSK_NX51_timer0_timer_preload0         0xffffffffU
#define SRT_NX51_timer0_timer_preload0         0
#define DFLT_VAL_NX51_timer0_timer_preload0    0x00000000U
#define DFLT_BF_VAL_NX51_timer0_timer_preload0 0x00000000U

/* all used bits of 'NX51_timer0': */
#define MSK_USED_BITS_NX51_timer0 0xffffffffU

enum {
	BFW_NX51_timer0_timer_preload0 = 32  /* [31:0] */
};

typedef struct NX51_TIMER0_BIT_Ttag {
	unsigned int timer_preload0 : BFW_NX51_timer0_timer_preload0; /* read: actual value of timer, write: timer and preload value */
} NX51_TIMER0_BIT_T;

typedef union {
	unsigned int      val;
	NX51_TIMER0_BIT_T bf;
} NX51_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register timer1 */
/* => xPEC Timer 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_timer1        0x00000034U
#define Adr_NX51_rpec0_regs_timer1 0x1018B034U
#define Adr_NX51_tpec0_regs_timer1 0x1018B134U
#define Adr_NX51_rpec1_regs_timer1 0x1018B234U
#define Adr_NX51_tpec1_regs_timer1 0x1018B334U
#define DFLT_VAL_NX51_timer1       0x00000000U

#define MSK_NX51_timer1_timer_preload1         0xffffffffU
#define SRT_NX51_timer1_timer_preload1         0
#define DFLT_VAL_NX51_timer1_timer_preload1    0x00000000U
#define DFLT_BF_VAL_NX51_timer1_timer_preload1 0x00000000U

/* all used bits of 'NX51_timer1': */
#define MSK_USED_BITS_NX51_timer1 0xffffffffU

enum {
	BFW_NX51_timer1_timer_preload1 = 32  /* [31:0] */
};

typedef struct NX51_TIMER1_BIT_Ttag {
	unsigned int timer_preload1 : BFW_NX51_timer1_timer_preload1; /* read: actual value of timer, write: timer and preload value */
} NX51_TIMER1_BIT_T;

typedef union {
	unsigned int      val;
	NX51_TIMER1_BIT_T bf;
} NX51_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register timer2 */
/* => xPEC Timer 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_timer2        0x00000038U
#define Adr_NX51_rpec0_regs_timer2 0x1018B038U
#define Adr_NX51_tpec0_regs_timer2 0x1018B138U
#define Adr_NX51_rpec1_regs_timer2 0x1018B238U
#define Adr_NX51_tpec1_regs_timer2 0x1018B338U
#define DFLT_VAL_NX51_timer2       0x00000000U

#define MSK_NX51_timer2_timer_preload2         0xffffffffU
#define SRT_NX51_timer2_timer_preload2         0
#define DFLT_VAL_NX51_timer2_timer_preload2    0x00000000U
#define DFLT_BF_VAL_NX51_timer2_timer_preload2 0x00000000U

/* all used bits of 'NX51_timer2': */
#define MSK_USED_BITS_NX51_timer2 0xffffffffU

enum {
	BFW_NX51_timer2_timer_preload2 = 32  /* [31:0] */
};

typedef struct NX51_TIMER2_BIT_Ttag {
	unsigned int timer_preload2 : BFW_NX51_timer2_timer_preload2; /* read: actual value of timer, write: timer and preload value */
} NX51_TIMER2_BIT_T;

typedef union {
	unsigned int      val;
	NX51_TIMER2_BIT_T bf;
} NX51_TIMER2_T;

/* --------------------------------------------------------------------- */
/* Register timer3 */
/* => xPEC Timer 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_timer3        0x0000003CU
#define Adr_NX51_rpec0_regs_timer3 0x1018B03CU
#define Adr_NX51_tpec0_regs_timer3 0x1018B13CU
#define Adr_NX51_rpec1_regs_timer3 0x1018B23CU
#define Adr_NX51_tpec1_regs_timer3 0x1018B33CU
#define DFLT_VAL_NX51_timer3       0x00000000U

#define MSK_NX51_timer3_timer_preload3         0xffffffffU
#define SRT_NX51_timer3_timer_preload3         0
#define DFLT_VAL_NX51_timer3_timer_preload3    0x00000000U
#define DFLT_BF_VAL_NX51_timer3_timer_preload3 0x00000000U

/* all used bits of 'NX51_timer3': */
#define MSK_USED_BITS_NX51_timer3 0xffffffffU

enum {
	BFW_NX51_timer3_timer_preload3 = 32  /* [31:0] */
};

typedef struct NX51_TIMER3_BIT_Ttag {
	unsigned int timer_preload3 : BFW_NX51_timer3_timer_preload3; /* read: actual value of timer, write: timer and preload value */
} NX51_TIMER3_BIT_T;

typedef union {
	unsigned int      val;
	NX51_TIMER3_BIT_T bf;
} NX51_TIMER3_T;

/* --------------------------------------------------------------------- */
/* Register urx_count */
/* => xPEC urx counter */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_urx_count        0x00000040U
#define Adr_NX51_rpec0_regs_urx_count 0x1018B040U
#define Adr_NX51_tpec0_regs_urx_count 0x1018B140U
#define Adr_NX51_rpec1_regs_urx_count 0x1018B240U
#define Adr_NX51_tpec1_regs_urx_count 0x1018B340U
#define DFLT_VAL_NX51_urx_count       0x00000000U

#define MSK_NX51_urx_count_urx_count         0xffffffffU
#define SRT_NX51_urx_count_urx_count         0
#define DFLT_VAL_NX51_urx_count_urx_count    0x00000000U
#define DFLT_BF_VAL_NX51_urx_count_urx_count 0x00000000U

/* all used bits of 'NX51_urx_count': */
#define MSK_USED_BITS_NX51_urx_count 0xffffffffU

enum {
	BFW_NX51_urx_count_urx_count = 32  /* [31:0] */
};

typedef struct NX51_URX_COUNT_BIT_Ttag {
	unsigned int urx_count : BFW_NX51_urx_count_urx_count; /* counts up accesses of xPEC to any URX fifo */
} NX51_URX_COUNT_BIT_T;

typedef union {
	unsigned int         val;
	NX51_URX_COUNT_BIT_T bf;
} NX51_URX_COUNT_T;

/* --------------------------------------------------------------------- */
/* Register utx_count */
/* => xPEC utx counter */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_utx_count        0x00000044U
#define Adr_NX51_rpec0_regs_utx_count 0x1018B044U
#define Adr_NX51_tpec0_regs_utx_count 0x1018B144U
#define Adr_NX51_rpec1_regs_utx_count 0x1018B244U
#define Adr_NX51_tpec1_regs_utx_count 0x1018B344U
#define DFLT_VAL_NX51_utx_count       0x00000000U

#define MSK_NX51_utx_count_utx_count         0xffffffffU
#define SRT_NX51_utx_count_utx_count         0
#define DFLT_VAL_NX51_utx_count_utx_count    0x00000000U
#define DFLT_BF_VAL_NX51_utx_count_utx_count 0x00000000U

/* all used bits of 'NX51_utx_count': */
#define MSK_USED_BITS_NX51_utx_count 0xffffffffU

enum {
	BFW_NX51_utx_count_utx_count = 32  /* [31:0] */
};

typedef struct NX51_UTX_COUNT_BIT_Ttag {
	unsigned int utx_count : BFW_NX51_utx_count_utx_count; /* counts up accesses of xPEC to any UTX fifo */
} NX51_UTX_COUNT_BIT_T;

typedef union {
	unsigned int         val;
	NX51_UTX_COUNT_BIT_T bf;
} NX51_UTX_COUNT_T;

/* --------------------------------------------------------------------- */
/* Register xpec_pc */
/* => xPEC Program Counter */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_pc        0x00000048U
#define Adr_NX51_rpec0_regs_xpec_pc 0x1018B048U
#define Adr_NX51_tpec0_regs_xpec_pc 0x1018B148U
#define Adr_NX51_rpec1_regs_xpec_pc 0x1018B248U
#define Adr_NX51_tpec1_regs_xpec_pc 0x1018B348U
#define DFLT_VAL_NX51_xpec_pc       0x000007ffU

#define MSK_NX51_xpec_pc_pc         0x000007ffU
#define SRT_NX51_xpec_pc_pc         0
#define DFLT_VAL_NX51_xpec_pc_pc    0x000007ffU
#define DFLT_BF_VAL_NX51_xpec_pc_pc 0x000007ffU

/* all used bits of 'NX51_xpec_pc': */
#define MSK_USED_BITS_NX51_xpec_pc 0x000007ffU

enum {
	BFW_NX51_xpec_pc_pc        = 11, /* [10:0] */
	BFW_NX51_xpec_pc_reserved1 = 21  /* [31:11] */
};

typedef struct NX51_XPEC_PC_BIT_Ttag {
	unsigned int pc        : BFW_NX51_xpec_pc_pc;        /* Program Counter (dword address inside DPRAM) */
	unsigned int reserved1 : BFW_NX51_xpec_pc_reserved1; /* reserved                                     */
} NX51_XPEC_PC_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPEC_PC_BIT_T bf;
} NX51_XPEC_PC_T;

/* --------------------------------------------------------------------- */
/* Register zero */
/* => Zero Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_zero        0x0000004CU
#define Adr_NX51_rpec0_regs_zero 0x1018B04CU
#define Adr_NX51_tpec0_regs_zero 0x1018B14CU
#define Adr_NX51_rpec1_regs_zero 0x1018B24CU
#define Adr_NX51_tpec1_regs_zero 0x1018B34CU
#define DFLT_VAL_NX51_zero       0x00000000U

#define MSK_NX51_zero_zero         0xffffffffU
#define SRT_NX51_zero_zero         0
#define DFLT_VAL_NX51_zero_zero    0x00000000U
#define DFLT_BF_VAL_NX51_zero_zero 0x00000000U

/* all used bits of 'NX51_zero': */
#define MSK_USED_BITS_NX51_zero 0xffffffffU

enum {
	BFW_NX51_zero_zero = 32  /* [31:0] */
};

typedef struct NX51_ZERO_BIT_Ttag {
	unsigned int zero : BFW_NX51_zero_zero; /* Always Zero */
} NX51_ZERO_BIT_T;

typedef union {
	unsigned int    val;
	NX51_ZERO_BIT_T bf;
} NX51_ZERO_T;

/* --------------------------------------------------------------------- */
/* Register xpec_config */
/* => xPEC Config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_config        0x00000050U
#define Adr_NX51_rpec0_regs_xpec_config 0x1018B050U
#define Adr_NX51_tpec0_regs_xpec_config 0x1018B150U
#define Adr_NX51_rpec1_regs_xpec_config 0x1018B250U
#define Adr_NX51_tpec1_regs_xpec_config 0x1018B350U
#define DFLT_VAL_NX51_xpec_config       0x00000000U

#define MSK_NX51_xpec_config_timer0                  0x00000007U
#define SRT_NX51_xpec_config_timer0                  0
#define DFLT_VAL_NX51_xpec_config_timer0             0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_timer0          0x00000000U
#define MSK_NX51_xpec_config_timer1                  0x00000038U
#define SRT_NX51_xpec_config_timer1                  3
#define DFLT_VAL_NX51_xpec_config_timer1             0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_timer1          0x00000000U
#define MSK_NX51_xpec_config_timer2                  0x000001c0U
#define SRT_NX51_xpec_config_timer2                  6
#define DFLT_VAL_NX51_xpec_config_timer2             0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_timer2          0x00000000U
#define MSK_NX51_xpec_config_timer3                  0x00000e00U
#define SRT_NX51_xpec_config_timer3                  9
#define DFLT_VAL_NX51_xpec_config_timer3             0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_timer3          0x00000000U
#define MSK_NX51_xpec_config_timer4                  0x00007000U
#define SRT_NX51_xpec_config_timer4                  12
#define DFLT_VAL_NX51_xpec_config_timer4             0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_timer4          0x00000000U
#define MSK_NX51_xpec_config_timer5                  0x00038000U
#define SRT_NX51_xpec_config_timer5                  15
#define DFLT_VAL_NX51_xpec_config_timer5             0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_timer5          0x00000000U
#define MSK_NX51_xpec_config_register_mode           0x00300000U
#define SRT_NX51_xpec_config_register_mode           20
#define DFLT_VAL_NX51_xpec_config_register_mode      0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_register_mode   0x00000000U
#define MSK_NX51_xpec_config_reset_urx_fifo0         0x01000000U
#define SRT_NX51_xpec_config_reset_urx_fifo0         24
#define DFLT_VAL_NX51_xpec_config_reset_urx_fifo0    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_reset_urx_fifo0 0x00000000U
#define MSK_NX51_xpec_config_reset_utx_fifo0         0x02000000U
#define SRT_NX51_xpec_config_reset_utx_fifo0         25
#define DFLT_VAL_NX51_xpec_config_reset_utx_fifo0    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_reset_utx_fifo0 0x00000000U
#define MSK_NX51_xpec_config_reset_urx_fifo1         0x04000000U
#define SRT_NX51_xpec_config_reset_urx_fifo1         26
#define DFLT_VAL_NX51_xpec_config_reset_urx_fifo1    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_reset_urx_fifo1 0x00000000U
#define MSK_NX51_xpec_config_reset_utx_fifo1         0x08000000U
#define SRT_NX51_xpec_config_reset_utx_fifo1         27
#define DFLT_VAL_NX51_xpec_config_reset_utx_fifo1    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_reset_utx_fifo1 0x00000000U
#define MSK_NX51_xpec_config_reset_eld0              0x10000000U
#define SRT_NX51_xpec_config_reset_eld0              28
#define DFLT_VAL_NX51_xpec_config_reset_eld0         0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_reset_eld0      0x00000000U
#define MSK_NX51_xpec_config_reset_eld1              0x20000000U
#define SRT_NX51_xpec_config_reset_eld1              29
#define DFLT_VAL_NX51_xpec_config_reset_eld1         0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_reset_eld1      0x00000000U
#define MSK_NX51_xpec_config_debug_mode              0x40000000U
#define SRT_NX51_xpec_config_debug_mode              30
#define DFLT_VAL_NX51_xpec_config_debug_mode         0x00000000U
#define DFLT_BF_VAL_NX51_xpec_config_debug_mode      0x00000000U

/* all used bits of 'NX51_xpec_config': */
#define MSK_USED_BITS_NX51_xpec_config 0x7f33ffffU

enum {
	BFW_NX51_xpec_config_timer0          = 3, /* [2:0] */
	BFW_NX51_xpec_config_timer1          = 3, /* [5:3] */
	BFW_NX51_xpec_config_timer2          = 3, /* [8:6] */
	BFW_NX51_xpec_config_timer3          = 3, /* [11:9] */
	BFW_NX51_xpec_config_timer4          = 3, /* [14:12] */
	BFW_NX51_xpec_config_timer5          = 3, /* [17:15] */
	BFW_NX51_xpec_config_reserved1       = 2, /* [19:18] */
	BFW_NX51_xpec_config_register_mode   = 2, /* [21:20] */
	BFW_NX51_xpec_config_reserved2       = 2, /* [23:22] */
	BFW_NX51_xpec_config_reset_urx_fifo0 = 1, /* [24] */
	BFW_NX51_xpec_config_reset_utx_fifo0 = 1, /* [25] */
	BFW_NX51_xpec_config_reset_urx_fifo1 = 1, /* [26] */
	BFW_NX51_xpec_config_reset_utx_fifo1 = 1, /* [27] */
	BFW_NX51_xpec_config_reset_eld0      = 1, /* [28] */
	BFW_NX51_xpec_config_reset_eld1      = 1, /* [29] */
	BFW_NX51_xpec_config_debug_mode      = 1, /* [30] */
	BFW_NX51_xpec_config_reserved3       = 1  /* [31] */
};

typedef struct NX51_XPEC_CONFIG_BIT_Ttag {
	unsigned int timer0          : BFW_NX51_xpec_config_timer0;          /* Timer0                                                                */
	                                                                     /*       2'b000 : Timer stops at 0                                       */
	                                                                     /*       2'b001 : Timer is preload with value from preload register at 0 */
	                                                                     /*       2'b010 : Timer (value) compare with systime                     */
	                                                                     /*       2'b110 : Timer (value) compare with systime_uc                  */
	                                                                     /*       2'b111 : Timer is workregister                                  */
	unsigned int timer1          : BFW_NX51_xpec_config_timer1;          /* Timer1                                                                */
	unsigned int timer2          : BFW_NX51_xpec_config_timer2;          /* Timer2                                                                */
	unsigned int timer3          : BFW_NX51_xpec_config_timer3;          /* Timer3                                                                */
	unsigned int timer4          : BFW_NX51_xpec_config_timer4;          /* Timer4                                                                */
	unsigned int timer5          : BFW_NX51_xpec_config_timer5;          /* Timer5                                                                */
	unsigned int reserved1       : BFW_NX51_xpec_config_reserved1;       /* reserved                                                              */
	unsigned int register_mode   : BFW_NX51_xpec_config_register_mode;   /* Register Mode                                                         */
	                                                                     /*       2'b00 : normal mode (shared register and statcfg)               */
	                                                                     /*       2'b01 : fmmusm mode / handshake unit                            */
	                                                                     /*       2'b10 : trigger_sample mode                                     */
	                                                                     /*       2'b11 : intlogic mode                                           */
	unsigned int reserved2       : BFW_NX51_xpec_config_reserved2;       /* reserved                                                              */
	unsigned int reset_urx_fifo0 : BFW_NX51_xpec_config_reset_urx_fifo0; /* Reset URX_FIFO of xMAC0, self clearing                                */
	unsigned int reset_utx_fifo0 : BFW_NX51_xpec_config_reset_utx_fifo0; /* Reset UTX_FIFO of xMAC0, self clearing                                */
	unsigned int reset_urx_fifo1 : BFW_NX51_xpec_config_reset_urx_fifo1; /* Reset URX_FIFO of xMAC1, self clearing                                */
	unsigned int reset_utx_fifo1 : BFW_NX51_xpec_config_reset_utx_fifo1; /* Reset UTX_FIFO of xMAC1, self clearing                                */
	unsigned int reset_eld0      : BFW_NX51_xpec_config_reset_eld0;      /* Reset Enhanced Link Detection Unit 0, self clearing                   */
	unsigned int reset_eld1      : BFW_NX51_xpec_config_reset_eld1;      /* Reset Enhanced Link Detection Unit 1, self clearing                   */
	unsigned int debug_mode      : BFW_NX51_xpec_config_debug_mode;      /* in this mode XPEC gets debug data form sr14 and sr15                  */
	unsigned int reserved3       : BFW_NX51_xpec_config_reserved3;       /* reserved                                                              */
} NX51_XPEC_CONFIG_BIT_T;

typedef union {
	unsigned int           val;
	NX51_XPEC_CONFIG_BIT_T bf;
} NX51_XPEC_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register ec_maska */
/* => JMP-Mask a */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_maska        0x00000054U
#define Adr_NX51_rpec0_regs_ec_maska 0x1018B054U
#define Adr_NX51_tpec0_regs_ec_maska 0x1018B154U
#define Adr_NX51_rpec1_regs_ec_maska 0x1018B254U
#define Adr_NX51_tpec1_regs_ec_maska 0x1018B354U
#define DFLT_VAL_NX51_ec_maska       0x0000ffffU

#define MSK_NX51_ec_maska_sel0                      0x000000ffU
#define SRT_NX51_ec_maska_sel0                      0
#define DFLT_VAL_NX51_ec_maska_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_maska_sel0              0x000000ffU
#define MSK_NX51_ec_maska_sel1                      0x0000ff00U
#define SRT_NX51_ec_maska_sel1                      8
#define DFLT_VAL_NX51_ec_maska_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_maska_sel1              0x000000ffU
#define MSK_NX51_ec_maska_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_maska_jmp_adr                   16
#define DFLT_VAL_NX51_ec_maska_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_maska_jmp_adr           0x00000000U
#define MSK_NX51_ec_maska_level_edge_event0         0x18000000U
#define SRT_NX51_ec_maska_level_edge_event0         27
#define DFLT_VAL_NX51_ec_maska_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_maska_level_edge_event0 0x00000000U
#define MSK_NX51_ec_maska_level_edge_event1         0x60000000U
#define SRT_NX51_ec_maska_level_edge_event1         29
#define DFLT_VAL_NX51_ec_maska_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_maska_level_edge_event1 0x00000000U
#define MSK_NX51_ec_maska_and_or                    0x80000000U
#define SRT_NX51_ec_maska_and_or                    31
#define DFLT_VAL_NX51_ec_maska_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_maska_and_or            0x00000000U

/* all used bits of 'NX51_ec_maska': */
#define MSK_USED_BITS_NX51_ec_maska 0xffffffffU

enum {
	BFW_NX51_ec_maska_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_maska_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_maska_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_maska_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_maska_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_maska_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASKA_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_maska_sel0;              /* Select of event 0:                                           */
	                                                                      /*     0-15    : XMAC status reg 0 (statcfg0 16:31)             */
	                                                                      /*     16-31   : XMAC status reg 1 (statcfg1 16:31)             */
	                                                                      /*     32-47   : xpec_stat_bits_shared[0:15]                    */
	                                                                      /*     48-63   : reserved                                       */
	                                                                      /*     64-67   : Timer interrupt 0:3                            */
	                                                                      /*     68-71   : Shared Register sr_0[12:15]                    */
	                                                                      /*     72-75   : Shared Register sr_1[12:15]                    */
	                                                                      /*     76-79   : Shared Register sr_2[12:15]                    */
	                                                                      /*     80-83   : Shared Register sr_3[12:15]                    */
	                                                                      /*     84-87   : Shared Register sr_4[12:15]                    */
	                                                                      /*     88-91   : Shared Register sr_5[12:15]                    */
	                                                                      /*     92-95   : Shared Register sr_6[12:15]                    */
	                                                                      /*     96-99   : Shared Register sr_7[12:15]                    */
	                                                                      /*     100-103 : Shared Register sr_8[12:15]                    */
	                                                                      /*     104-107 : Shared Register sr_9[12:15]                    */
	                                                                      /*     108-111 : Shared Register sr_10[12:15]                   */
	                                                                      /*     112-115 : Shared Register sr_11[12:15]                   */
	                                                                      /*     116-119 : Shared Register sr_12[12:15]                   */
	                                                                      /*     120-123 : Shared Register sr_13[12:15]                   */
	                                                                      /*     124-127 : Shared Register sr_14[12:15]                   */
	                                                                      /*     128-131 : Shared Register sr_15[12:15]                   */
	                                                                      /*         132 : datach_ready                                   */
	                                                                      /*         133 : sysch_ready                                    */
	                                                                      /*         134 : rx_rdy_asyn_xmac0_and_datach_ready             */
	                                                                      /*         135 : rx_rdy_asyn_xmac1_and_datach_ready             */
	                                                                      /*         136 : rx_2_rdy_asyn_xmac0_and_datach_ready           */
	                                                                      /*         137 : rx_2_rdy_asyn_xmac1_and_datach_ready           */
	                                                                      /*         138 : pfifo_rdy_timer2small                          */
	                                                                      /*         139 : datach_rdy_timer2small                         */
	                                                                      /*     140-151 : reserved                                       */
	                                                                      /*     152-163 : FMMU_SM - Events                               */
	                                                                      /*               152 : fmmu_bitwise_rd_or_wr                    */
	                                                                      /*               153 : fmmu_bitwise_rd_and_wr                   */
	                                                                      /*               154 : fmmu_bitwise_wr                          */
	                                                                      /*               155 : fmmu_bitwise_rd                          */
	                                                                      /*               156 : fmmu_rd_or_wr_match                      */
	                                                                      /*               157 : fmmu_rd_and_wr_match                     */
	                                                                      /*               158 : fmmu_wr_match                            */
	                                                                      /*               159 : fmmu_rd_match                            */
	                                                                      /*               160 : lba_match                                */
	                                                                      /*               161 : fba_match                                */
	                                                                      /*               162 : rd_or_wr_match                           */
	                                                                      /*               163 : rd_and_wr_match                          */
	                                                                      /*     164-165   : Timer interrupt 4:5                          */
	                                                                      /*         166 : range_urx_count_smaller                        */
	                                                                      /*         167 : range_urx_count_smaller2                       */
	                                                                      /*         168 : range_utx_count_smaller                        */
	                                                                      /*         169 : range_utx_count_smaller2                       */
	                                                                      /*     170-173 : range_w0 - range_w7 smaller as w4 - w7         */
	                                                                      /*               170 : range_w4 < w4                            */
	                                                                      /*               171 : range_w5 < w5                            */
	                                                                      /*               172 : range_w6 < w6                            */
	                                                                      /*               173 : range_w7 < w7                            */
	                                                                      /*     174-181 : range_w0 - range_w7 4 and 2 smaller as w4 - w7 */
	                                                                      /*               174 : range_w4 4< w4                           */
	                                                                      /*               175 : range_w5 4< w5                           */
	                                                                      /*               176 : range_w6 4< w6                           */
	                                                                      /*               177 : range_w7 4< w7                           */
	                                                                      /*               178 : range_w4 2< w4                           */
	                                                                      /*               179 : range_w5 2< w5                           */
	                                                                      /*               180 : range_w6 2< w6                           */
	                                                                      /*               181 : range_w7 2< w7                           */
	                                                                      /*         182 : rx_rdy_asyn_xmac0                              */
	                                                                      /*         183 : rx_rdy_asyn_xmac1                              */
	                                                                      /*         184 : rx_2_rdy_async_xmac0                           */
	                                                                      /*         185 : rx_2_rdy_async_xmac1                           */
	                                                                      /*         186 : tx_nxt2_asyn_xmac0                             */
	                                                                      /*         187 : tx_nxt2_asyn_xmac1                             */
	                                                                      /*         188 : tx_nxt_2_asyn_xmac0_and_datach_ready           */
	                                                                      /*         189 : tx_nxt_2_asyn_xmac1_and_datach_ready           */
	                                                                      /*     190-221 : fifo_empty [0:31]                              */
	                                                                      /*         222 : reserved                                       */
	                                                                      /*         223 : reserved                                       */
	                                                                      /*     224-239 : arm_irq [0:15] (from irq_reg[16:31])           */
	                                                                      /*         240 : debug_event                                    */
	                                                                      /*     241-242 : FMMU_SM - Events                               */
	                                                                      /*               241 : wr_match                                 */
	                                                                      /*               242 : rd_match                                 */
	                                                                      /*     243-246 : SYNC_UNIT Events                               */
	                                                                      /*               243 : xc_sample_in[1]                          */
	                                                                      /*               244 : xc_sample_in[0]                          */
	                                                                      /*               245 : xc_sync1_status                          */
	                                                                      /*               246 : xc_sync0_status                          */
	                                                                      /*         247 : reserved                                       */
	                                                                      /*         248 : fmmusm_status_ecat_fin                         */
	                                                                      /*         249 : phy0_irq_in                                    */
	                                                                      /*         250 : phy1_irq_in                                    */
	                                                                      /*         251 : miimu0_snrdy                                   */
	                                                                      /*         252 : miimu1_snrdy                                   */
	                                                                      /*         253 : reserved                                       */
	                                                                      /*         254 : always zero                                    */
	                                                                      /*         255 : disable # default value                        */
	unsigned int sel1              : BFW_NX51_ec_maska_sel1;              /* Select of event 1                                            */
	unsigned int jmp_adr           : BFW_NX51_ec_maska_jmp_adr;           /* jmp address (0-2047)                                         */
	unsigned int level_edge_event0 : BFW_NX51_ec_maska_level_edge_event0; /* for event 0 : level / edge sensitive:                        */
	                                                                      /*               2'b00 sensitve to 1 level                      */
	                                                                      /*               2'b01 sensitve to 0 level                      */
	                                                                      /*               2'b10 sensitve to positive edge (low to high)  */
	                                                                      /*               2'b11 sensitve to negative edge (high to low)  */
	unsigned int level_edge_event1 : BFW_NX51_ec_maska_level_edge_event1; /* for event 1 : level / edge sensitive:                        */
	                                                                      /*               2'b00 sensitve to 1 level                      */
	                                                                      /*               2'b01 sensitve to 0 level                      */
	                                                                      /*               2'b10 sensitve to positive edge (low to high)  */
	                                                                      /*               2'b11 sensitve to negative edge (high to low)  */
	unsigned int and_or            : BFW_NX51_ec_maska_and_or;            /* and/or bit:                                                  */
	                                                                      /* 0 - All bits of mask must fit with events,                   */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0    */
} NX51_EC_MASKA_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASKA_BIT_T bf;
} NX51_EC_MASKA_T;

/* --------------------------------------------------------------------- */
/* Register ec_maskb */
/* => JMP-Mask b */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_maskb        0x00000058U
#define Adr_NX51_rpec0_regs_ec_maskb 0x1018B058U
#define Adr_NX51_tpec0_regs_ec_maskb 0x1018B158U
#define Adr_NX51_rpec1_regs_ec_maskb 0x1018B258U
#define Adr_NX51_tpec1_regs_ec_maskb 0x1018B358U
#define DFLT_VAL_NX51_ec_maskb       0x0000ffffU

#define MSK_NX51_ec_maskb_sel0                      0x000000ffU
#define SRT_NX51_ec_maskb_sel0                      0
#define DFLT_VAL_NX51_ec_maskb_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_maskb_sel0              0x000000ffU
#define MSK_NX51_ec_maskb_sel1                      0x0000ff00U
#define SRT_NX51_ec_maskb_sel1                      8
#define DFLT_VAL_NX51_ec_maskb_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_maskb_sel1              0x000000ffU
#define MSK_NX51_ec_maskb_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_maskb_jmp_adr                   16
#define DFLT_VAL_NX51_ec_maskb_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_maskb_jmp_adr           0x00000000U
#define MSK_NX51_ec_maskb_level_edge_event0         0x18000000U
#define SRT_NX51_ec_maskb_level_edge_event0         27
#define DFLT_VAL_NX51_ec_maskb_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_maskb_level_edge_event0 0x00000000U
#define MSK_NX51_ec_maskb_level_edge_event1         0x60000000U
#define SRT_NX51_ec_maskb_level_edge_event1         29
#define DFLT_VAL_NX51_ec_maskb_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_maskb_level_edge_event1 0x00000000U
#define MSK_NX51_ec_maskb_and_or                    0x80000000U
#define SRT_NX51_ec_maskb_and_or                    31
#define DFLT_VAL_NX51_ec_maskb_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_maskb_and_or            0x00000000U

/* all used bits of 'NX51_ec_maskb': */
#define MSK_USED_BITS_NX51_ec_maskb 0xffffffffU

enum {
	BFW_NX51_ec_maskb_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_maskb_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_maskb_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_maskb_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_maskb_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_maskb_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASKB_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_maskb_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_maskb_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_maskb_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_maskb_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_maskb_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_maskb_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASKB_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASKB_BIT_T bf;
} NX51_EC_MASKB_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask0 */
/* => JMP-Mask 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask0        0x0000005CU
#define Adr_NX51_rpec0_regs_ec_mask0 0x1018B05CU
#define Adr_NX51_tpec0_regs_ec_mask0 0x1018B15CU
#define Adr_NX51_rpec1_regs_ec_mask0 0x1018B25CU
#define Adr_NX51_tpec1_regs_ec_mask0 0x1018B35CU
#define DFLT_VAL_NX51_ec_mask0       0x0000ffffU

#define MSK_NX51_ec_mask0_sel0                      0x000000ffU
#define SRT_NX51_ec_mask0_sel0                      0
#define DFLT_VAL_NX51_ec_mask0_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask0_sel0              0x000000ffU
#define MSK_NX51_ec_mask0_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask0_sel1                      8
#define DFLT_VAL_NX51_ec_mask0_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask0_sel1              0x000000ffU
#define MSK_NX51_ec_mask0_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask0_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask0_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask0_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask0_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask0_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask0_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask0_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask0_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask0_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask0_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask0_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask0_and_or                    0x80000000U
#define SRT_NX51_ec_mask0_and_or                    31
#define DFLT_VAL_NX51_ec_mask0_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask0_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask0': */
#define MSK_USED_BITS_NX51_ec_mask0 0xffffffffU

enum {
	BFW_NX51_ec_mask0_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask0_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask0_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask0_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask0_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask0_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK0_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask0_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask0_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask0_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask0_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask0_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask0_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK0_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK0_BIT_T bf;
} NX51_EC_MASK0_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask1 */
/* => JMP-Mask 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask1        0x00000060U
#define Adr_NX51_rpec0_regs_ec_mask1 0x1018B060U
#define Adr_NX51_tpec0_regs_ec_mask1 0x1018B160U
#define Adr_NX51_rpec1_regs_ec_mask1 0x1018B260U
#define Adr_NX51_tpec1_regs_ec_mask1 0x1018B360U
#define DFLT_VAL_NX51_ec_mask1       0x0000ffffU

#define MSK_NX51_ec_mask1_sel0                      0x000000ffU
#define SRT_NX51_ec_mask1_sel0                      0
#define DFLT_VAL_NX51_ec_mask1_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask1_sel0              0x000000ffU
#define MSK_NX51_ec_mask1_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask1_sel1                      8
#define DFLT_VAL_NX51_ec_mask1_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask1_sel1              0x000000ffU
#define MSK_NX51_ec_mask1_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask1_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask1_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask1_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask1_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask1_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask1_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask1_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask1_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask1_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask1_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask1_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask1_and_or                    0x80000000U
#define SRT_NX51_ec_mask1_and_or                    31
#define DFLT_VAL_NX51_ec_mask1_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask1_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask1': */
#define MSK_USED_BITS_NX51_ec_mask1 0xffffffffU

enum {
	BFW_NX51_ec_mask1_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask1_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask1_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask1_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask1_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask1_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK1_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask1_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask1_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask1_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask1_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask1_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask1_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK1_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK1_BIT_T bf;
} NX51_EC_MASK1_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask2 */
/* => JMP-Mask 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask2        0x00000064U
#define Adr_NX51_rpec0_regs_ec_mask2 0x1018B064U
#define Adr_NX51_tpec0_regs_ec_mask2 0x1018B164U
#define Adr_NX51_rpec1_regs_ec_mask2 0x1018B264U
#define Adr_NX51_tpec1_regs_ec_mask2 0x1018B364U
#define DFLT_VAL_NX51_ec_mask2       0x0000ffffU

#define MSK_NX51_ec_mask2_sel0                      0x000000ffU
#define SRT_NX51_ec_mask2_sel0                      0
#define DFLT_VAL_NX51_ec_mask2_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask2_sel0              0x000000ffU
#define MSK_NX51_ec_mask2_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask2_sel1                      8
#define DFLT_VAL_NX51_ec_mask2_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask2_sel1              0x000000ffU
#define MSK_NX51_ec_mask2_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask2_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask2_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask2_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask2_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask2_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask2_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask2_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask2_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask2_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask2_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask2_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask2_and_or                    0x80000000U
#define SRT_NX51_ec_mask2_and_or                    31
#define DFLT_VAL_NX51_ec_mask2_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask2_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask2': */
#define MSK_USED_BITS_NX51_ec_mask2 0xffffffffU

enum {
	BFW_NX51_ec_mask2_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask2_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask2_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask2_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask2_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask2_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK2_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask2_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask2_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask2_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask2_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask2_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask2_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK2_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK2_BIT_T bf;
} NX51_EC_MASK2_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask3 */
/* => JMP-Mask 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask3        0x00000068U
#define Adr_NX51_rpec0_regs_ec_mask3 0x1018B068U
#define Adr_NX51_tpec0_regs_ec_mask3 0x1018B168U
#define Adr_NX51_rpec1_regs_ec_mask3 0x1018B268U
#define Adr_NX51_tpec1_regs_ec_mask3 0x1018B368U
#define DFLT_VAL_NX51_ec_mask3       0x0000ffffU

#define MSK_NX51_ec_mask3_sel0                      0x000000ffU
#define SRT_NX51_ec_mask3_sel0                      0
#define DFLT_VAL_NX51_ec_mask3_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask3_sel0              0x000000ffU
#define MSK_NX51_ec_mask3_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask3_sel1                      8
#define DFLT_VAL_NX51_ec_mask3_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask3_sel1              0x000000ffU
#define MSK_NX51_ec_mask3_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask3_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask3_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask3_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask3_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask3_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask3_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask3_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask3_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask3_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask3_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask3_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask3_and_or                    0x80000000U
#define SRT_NX51_ec_mask3_and_or                    31
#define DFLT_VAL_NX51_ec_mask3_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask3_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask3': */
#define MSK_USED_BITS_NX51_ec_mask3 0xffffffffU

enum {
	BFW_NX51_ec_mask3_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask3_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask3_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask3_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask3_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask3_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK3_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask3_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask3_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask3_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask3_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask3_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask3_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK3_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK3_BIT_T bf;
} NX51_EC_MASK3_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask4 */
/* => JMP-Mask 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask4        0x0000006CU
#define Adr_NX51_rpec0_regs_ec_mask4 0x1018B06CU
#define Adr_NX51_tpec0_regs_ec_mask4 0x1018B16CU
#define Adr_NX51_rpec1_regs_ec_mask4 0x1018B26CU
#define Adr_NX51_tpec1_regs_ec_mask4 0x1018B36CU
#define DFLT_VAL_NX51_ec_mask4       0x0000ffffU

#define MSK_NX51_ec_mask4_sel0                      0x000000ffU
#define SRT_NX51_ec_mask4_sel0                      0
#define DFLT_VAL_NX51_ec_mask4_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask4_sel0              0x000000ffU
#define MSK_NX51_ec_mask4_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask4_sel1                      8
#define DFLT_VAL_NX51_ec_mask4_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask4_sel1              0x000000ffU
#define MSK_NX51_ec_mask4_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask4_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask4_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask4_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask4_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask4_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask4_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask4_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask4_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask4_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask4_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask4_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask4_and_or                    0x80000000U
#define SRT_NX51_ec_mask4_and_or                    31
#define DFLT_VAL_NX51_ec_mask4_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask4_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask4': */
#define MSK_USED_BITS_NX51_ec_mask4 0xffffffffU

enum {
	BFW_NX51_ec_mask4_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask4_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask4_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask4_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask4_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask4_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK4_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask4_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask4_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask4_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask4_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask4_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask4_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK4_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK4_BIT_T bf;
} NX51_EC_MASK4_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask5 */
/* => JMP-Mask 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask5        0x00000070U
#define Adr_NX51_rpec0_regs_ec_mask5 0x1018B070U
#define Adr_NX51_tpec0_regs_ec_mask5 0x1018B170U
#define Adr_NX51_rpec1_regs_ec_mask5 0x1018B270U
#define Adr_NX51_tpec1_regs_ec_mask5 0x1018B370U
#define DFLT_VAL_NX51_ec_mask5       0x0000ffffU

#define MSK_NX51_ec_mask5_sel0                      0x000000ffU
#define SRT_NX51_ec_mask5_sel0                      0
#define DFLT_VAL_NX51_ec_mask5_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask5_sel0              0x000000ffU
#define MSK_NX51_ec_mask5_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask5_sel1                      8
#define DFLT_VAL_NX51_ec_mask5_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask5_sel1              0x000000ffU
#define MSK_NX51_ec_mask5_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask5_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask5_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask5_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask5_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask5_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask5_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask5_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask5_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask5_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask5_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask5_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask5_and_or                    0x80000000U
#define SRT_NX51_ec_mask5_and_or                    31
#define DFLT_VAL_NX51_ec_mask5_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask5_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask5': */
#define MSK_USED_BITS_NX51_ec_mask5 0xffffffffU

enum {
	BFW_NX51_ec_mask5_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask5_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask5_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask5_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask5_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask5_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK5_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask5_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask5_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask5_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask5_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask5_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask5_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK5_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK5_BIT_T bf;
} NX51_EC_MASK5_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask6 */
/* => JMP-Mask 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask6        0x00000074U
#define Adr_NX51_rpec0_regs_ec_mask6 0x1018B074U
#define Adr_NX51_tpec0_regs_ec_mask6 0x1018B174U
#define Adr_NX51_rpec1_regs_ec_mask6 0x1018B274U
#define Adr_NX51_tpec1_regs_ec_mask6 0x1018B374U
#define DFLT_VAL_NX51_ec_mask6       0x0000ffffU

#define MSK_NX51_ec_mask6_sel0                      0x000000ffU
#define SRT_NX51_ec_mask6_sel0                      0
#define DFLT_VAL_NX51_ec_mask6_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask6_sel0              0x000000ffU
#define MSK_NX51_ec_mask6_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask6_sel1                      8
#define DFLT_VAL_NX51_ec_mask6_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask6_sel1              0x000000ffU
#define MSK_NX51_ec_mask6_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask6_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask6_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask6_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask6_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask6_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask6_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask6_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask6_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask6_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask6_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask6_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask6_and_or                    0x80000000U
#define SRT_NX51_ec_mask6_and_or                    31
#define DFLT_VAL_NX51_ec_mask6_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask6_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask6': */
#define MSK_USED_BITS_NX51_ec_mask6 0xffffffffU

enum {
	BFW_NX51_ec_mask6_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask6_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask6_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask6_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask6_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask6_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK6_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask6_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask6_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask6_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask6_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask6_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask6_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK6_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK6_BIT_T bf;
} NX51_EC_MASK6_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask7 */
/* => JMP-Mask 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask7        0x00000078U
#define Adr_NX51_rpec0_regs_ec_mask7 0x1018B078U
#define Adr_NX51_tpec0_regs_ec_mask7 0x1018B178U
#define Adr_NX51_rpec1_regs_ec_mask7 0x1018B278U
#define Adr_NX51_tpec1_regs_ec_mask7 0x1018B378U
#define DFLT_VAL_NX51_ec_mask7       0x0000ffffU

#define MSK_NX51_ec_mask7_sel0                      0x000000ffU
#define SRT_NX51_ec_mask7_sel0                      0
#define DFLT_VAL_NX51_ec_mask7_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask7_sel0              0x000000ffU
#define MSK_NX51_ec_mask7_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask7_sel1                      8
#define DFLT_VAL_NX51_ec_mask7_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask7_sel1              0x000000ffU
#define MSK_NX51_ec_mask7_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask7_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask7_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask7_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask7_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask7_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask7_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask7_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask7_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask7_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask7_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask7_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask7_and_or                    0x80000000U
#define SRT_NX51_ec_mask7_and_or                    31
#define DFLT_VAL_NX51_ec_mask7_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask7_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask7': */
#define MSK_USED_BITS_NX51_ec_mask7 0xffffffffU

enum {
	BFW_NX51_ec_mask7_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask7_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask7_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask7_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask7_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask7_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK7_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask7_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask7_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask7_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask7_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask7_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask7_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK7_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK7_BIT_T bf;
} NX51_EC_MASK7_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask8 */
/* => JMP-Mask 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask8        0x0000007CU
#define Adr_NX51_rpec0_regs_ec_mask8 0x1018B07CU
#define Adr_NX51_tpec0_regs_ec_mask8 0x1018B17CU
#define Adr_NX51_rpec1_regs_ec_mask8 0x1018B27CU
#define Adr_NX51_tpec1_regs_ec_mask8 0x1018B37CU
#define DFLT_VAL_NX51_ec_mask8       0x0000ffffU

#define MSK_NX51_ec_mask8_sel0                      0x000000ffU
#define SRT_NX51_ec_mask8_sel0                      0
#define DFLT_VAL_NX51_ec_mask8_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask8_sel0              0x000000ffU
#define MSK_NX51_ec_mask8_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask8_sel1                      8
#define DFLT_VAL_NX51_ec_mask8_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask8_sel1              0x000000ffU
#define MSK_NX51_ec_mask8_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask8_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask8_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask8_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask8_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask8_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask8_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask8_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask8_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask8_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask8_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask8_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask8_and_or                    0x80000000U
#define SRT_NX51_ec_mask8_and_or                    31
#define DFLT_VAL_NX51_ec_mask8_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask8_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask8': */
#define MSK_USED_BITS_NX51_ec_mask8 0xffffffffU

enum {
	BFW_NX51_ec_mask8_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask8_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask8_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask8_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask8_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask8_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK8_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask8_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask8_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask8_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask8_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask8_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask8_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK8_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK8_BIT_T bf;
} NX51_EC_MASK8_T;

/* --------------------------------------------------------------------- */
/* Register ec_mask9 */
/* => JMP-Mask 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ec_mask9        0x00000080U
#define Adr_NX51_rpec0_regs_ec_mask9 0x1018B080U
#define Adr_NX51_tpec0_regs_ec_mask9 0x1018B180U
#define Adr_NX51_rpec1_regs_ec_mask9 0x1018B280U
#define Adr_NX51_tpec1_regs_ec_mask9 0x1018B380U
#define DFLT_VAL_NX51_ec_mask9       0x0000ffffU

#define MSK_NX51_ec_mask9_sel0                      0x000000ffU
#define SRT_NX51_ec_mask9_sel0                      0
#define DFLT_VAL_NX51_ec_mask9_sel0                 0x000000ffU
#define DFLT_BF_VAL_NX51_ec_mask9_sel0              0x000000ffU
#define MSK_NX51_ec_mask9_sel1                      0x0000ff00U
#define SRT_NX51_ec_mask9_sel1                      8
#define DFLT_VAL_NX51_ec_mask9_sel1                 0x0000ff00U
#define DFLT_BF_VAL_NX51_ec_mask9_sel1              0x000000ffU
#define MSK_NX51_ec_mask9_jmp_adr                   0x07ff0000U
#define SRT_NX51_ec_mask9_jmp_adr                   16
#define DFLT_VAL_NX51_ec_mask9_jmp_adr              0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask9_jmp_adr           0x00000000U
#define MSK_NX51_ec_mask9_level_edge_event0         0x18000000U
#define SRT_NX51_ec_mask9_level_edge_event0         27
#define DFLT_VAL_NX51_ec_mask9_level_edge_event0    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask9_level_edge_event0 0x00000000U
#define MSK_NX51_ec_mask9_level_edge_event1         0x60000000U
#define SRT_NX51_ec_mask9_level_edge_event1         29
#define DFLT_VAL_NX51_ec_mask9_level_edge_event1    0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask9_level_edge_event1 0x00000000U
#define MSK_NX51_ec_mask9_and_or                    0x80000000U
#define SRT_NX51_ec_mask9_and_or                    31
#define DFLT_VAL_NX51_ec_mask9_and_or               0x00000000U
#define DFLT_BF_VAL_NX51_ec_mask9_and_or            0x00000000U

/* all used bits of 'NX51_ec_mask9': */
#define MSK_USED_BITS_NX51_ec_mask9 0xffffffffU

enum {
	BFW_NX51_ec_mask9_sel0              = 8,  /* [7:0] */
	BFW_NX51_ec_mask9_sel1              = 8,  /* [15:8] */
	BFW_NX51_ec_mask9_jmp_adr           = 11, /* [26:16] */
	BFW_NX51_ec_mask9_level_edge_event0 = 2,  /* [28:27] */
	BFW_NX51_ec_mask9_level_edge_event1 = 2,  /* [30:29] */
	BFW_NX51_ec_mask9_and_or            = 1   /* [31] */
};

typedef struct NX51_EC_MASK9_BIT_Ttag {
	unsigned int sel0              : BFW_NX51_ec_mask9_sel0;              /* Select of event 0                                           */
	unsigned int sel1              : BFW_NX51_ec_mask9_sel1;              /* Select of event 1                                           */
	unsigned int jmp_adr           : BFW_NX51_ec_mask9_jmp_adr;           /* jmp address (0-2047)                                        */
	unsigned int level_edge_event0 : BFW_NX51_ec_mask9_level_edge_event0; /* for event 0 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int level_edge_event1 : BFW_NX51_ec_mask9_level_edge_event1; /* for event 1 : level / edge sensitive:                       */
	                                                                      /*               2'b00 sensitve to 1 level                     */
	                                                                      /*               2'b01 sensitve to 0 level                     */
	                                                                      /*               2'b10 sensitve to positive edge (low to high) */
	                                                                      /*               2'b11 sensitve to negative edge (high to low) */
	unsigned int and_or            : BFW_NX51_ec_mask9_and_or;            /* and/or bit:                                                 */
	                                                                      /* 0 - All bits of mask must fit with events,                  */
	                                                                      /* 1 - Only one bit of mask must fit with events # default 0   */
} NX51_EC_MASK9_BIT_T;

typedef union {
	unsigned int        val;
	NX51_EC_MASK9_BIT_T bf;
} NX51_EC_MASK9_T;

/* --------------------------------------------------------------------- */
/* Register timer4 */
/* => xPEC Timer 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_timer4        0x00000084U
#define Adr_NX51_rpec0_regs_timer4 0x1018B084U
#define Adr_NX51_tpec0_regs_timer4 0x1018B184U
#define Adr_NX51_rpec1_regs_timer4 0x1018B284U
#define Adr_NX51_tpec1_regs_timer4 0x1018B384U
#define DFLT_VAL_NX51_timer4       0x00000000U

#define MSK_NX51_timer4_timer_preload4         0xffffffffU
#define SRT_NX51_timer4_timer_preload4         0
#define DFLT_VAL_NX51_timer4_timer_preload4    0x00000000U
#define DFLT_BF_VAL_NX51_timer4_timer_preload4 0x00000000U

/* all used bits of 'NX51_timer4': */
#define MSK_USED_BITS_NX51_timer4 0xffffffffU

enum {
	BFW_NX51_timer4_timer_preload4 = 32  /* [31:0] */
};

typedef struct NX51_TIMER4_BIT_Ttag {
	unsigned int timer_preload4 : BFW_NX51_timer4_timer_preload4; /* read: actual value of timer, write: timer and preload value */
} NX51_TIMER4_BIT_T;

typedef union {
	unsigned int      val;
	NX51_TIMER4_BIT_T bf;
} NX51_TIMER4_T;

/* --------------------------------------------------------------------- */
/* Register timer5 */
/* => xPEC Timer 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_timer5        0x00000088U
#define Adr_NX51_rpec0_regs_timer5 0x1018B088U
#define Adr_NX51_tpec0_regs_timer5 0x1018B188U
#define Adr_NX51_rpec1_regs_timer5 0x1018B288U
#define Adr_NX51_tpec1_regs_timer5 0x1018B388U
#define DFLT_VAL_NX51_timer5       0x00000000U

#define MSK_NX51_timer5_timer_preload5         0xffffffffU
#define SRT_NX51_timer5_timer_preload5         0
#define DFLT_VAL_NX51_timer5_timer_preload5    0x00000000U
#define DFLT_BF_VAL_NX51_timer5_timer_preload5 0x00000000U

/* all used bits of 'NX51_timer5': */
#define MSK_USED_BITS_NX51_timer5 0xffffffffU

enum {
	BFW_NX51_timer5_timer_preload5 = 32  /* [31:0] */
};

typedef struct NX51_TIMER5_BIT_Ttag {
	unsigned int timer_preload5 : BFW_NX51_timer5_timer_preload5; /* read: actual value of timer, write: timer and preload value */
} NX51_TIMER5_BIT_T;

typedef union {
	unsigned int      val;
	NX51_TIMER5_BIT_T bf;
} NX51_TIMER5_T;

/* --------------------------------------------------------------------- */
/* Register irq */
/* => xPEC IRQ Register */
/*    Shared Register accessed by rPEC and tPEC of 1 port */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_irq        0x0000008CU
#define Adr_NX51_rpec0_regs_irq 0x1018B08CU
#define Adr_NX51_tpec0_regs_irq 0x1018B18CU
#define Adr_NX51_rpec1_regs_irq 0x1018B28CU
#define Adr_NX51_tpec1_regs_irq 0x1018B38CU
#define DFLT_VAL_NX51_irq       0x00000000U

#define MSK_NX51_irq_xpec_irq         0x0000ffffU
#define SRT_NX51_irq_xpec_irq         0
#define DFLT_VAL_NX51_irq_xpec_irq    0x00000000U
#define DFLT_BF_VAL_NX51_irq_xpec_irq 0x00000000U
#define MSK_NX51_irq_arm_irq          0xffff0000U
#define SRT_NX51_irq_arm_irq          16
#define DFLT_VAL_NX51_irq_arm_irq     0x00000000U
#define DFLT_BF_VAL_NX51_irq_arm_irq  0x00000000U

/* all used bits of 'NX51_irq': */
#define MSK_USED_BITS_NX51_irq 0xffffffffU

enum {
	BFW_NX51_irq_xpec_irq = 16, /* [15:0] */
	BFW_NX51_irq_arm_irq  = 16  /* [31:16] */
};

typedef struct NX51_IRQ_BIT_Ttag {
	unsigned int xpec_irq : BFW_NX51_irq_xpec_irq; /* set by xpec ; reset by arm  */
	unsigned int arm_irq  : BFW_NX51_irq_arm_irq;  /* set by arm  ; reset by xpec */
} NX51_IRQ_BIT_T;

typedef union {
	unsigned int   val;
	NX51_IRQ_BIT_T bf;
} NX51_IRQ_T;

/* --------------------------------------------------------------------- */
/* Register xpec_systime_ns */
/* => Shared in xPEC intlogic mode with systime_uc_ns (r mode). */
/*    xPEC System time (for read) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_systime_ns        0x00000090U
#define Adr_NX51_rpec0_regs_xpec_systime_ns 0x1018B090U
#define Adr_NX51_tpec0_regs_xpec_systime_ns 0x1018B190U
#define Adr_NX51_rpec1_regs_xpec_systime_ns 0x1018B290U
#define Adr_NX51_tpec1_regs_xpec_systime_ns 0x1018B390U

#define MSK_NX51_xpec_systime_ns_systime_ns 0xffffffffU
#define SRT_NX51_xpec_systime_ns_systime_ns 0

/* all used bits of 'NX51_xpec_systime_ns': */
#define MSK_USED_BITS_NX51_xpec_systime_ns 0xffffffffU

enum {
	BFW_NX51_xpec_systime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_XPEC_SYSTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_xpec_systime_ns_systime_ns; /* read: 32 - Bit System Time (ns) */
} NX51_XPEC_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XPEC_SYSTIME_NS_BIT_T bf;
} NX51_XPEC_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register fifo_data */
/* => xPEC fifo_data */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fifo_data        0x00000094U
#define Adr_NX51_rpec0_regs_fifo_data 0x1018B094U
#define Adr_NX51_tpec0_regs_fifo_data 0x1018B194U
#define Adr_NX51_rpec1_regs_fifo_data 0x1018B294U
#define Adr_NX51_tpec1_regs_fifo_data 0x1018B394U
#define DFLT_VAL_NX51_fifo_data       0x00000000U

#define MSK_NX51_fifo_data_fifo_data         0xffffffffU
#define SRT_NX51_fifo_data_fifo_data         0
#define DFLT_VAL_NX51_fifo_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_fifo_data_fifo_data 0x00000000U

/* all used bits of 'NX51_fifo_data': */
#define MSK_USED_BITS_NX51_fifo_data 0xffffffffU

enum {
	BFW_NX51_fifo_data_fifo_data = 32  /* [31:0] */
};

typedef struct NX51_FIFO_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_fifo_data_fifo_data; /* default 0 */
} NX51_FIFO_DATA_BIT_T;

typedef union {
	unsigned int         val;
	NX51_FIFO_DATA_BIT_T bf;
} NX51_FIFO_DATA_T;

/* --------------------------------------------------------------------- */
/* Register xpec_systime_s */
/* => Shared in xPEC intlogic mode with systime_uc_s (r mode). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_systime_s        0x00000098U
#define Adr_NX51_rpec0_regs_xpec_systime_s 0x1018B098U
#define Adr_NX51_tpec0_regs_xpec_systime_s 0x1018B198U
#define Adr_NX51_rpec1_regs_xpec_systime_s 0x1018B298U
#define Adr_NX51_tpec1_regs_xpec_systime_s 0x1018B398U

#define MSK_NX51_xpec_systime_s_systime_s 0xffffffffU
#define SRT_NX51_xpec_systime_s_systime_s 0

/* all used bits of 'NX51_xpec_systime_s': */
#define MSK_USED_BITS_NX51_xpec_systime_s 0xffffffffU

enum {
	BFW_NX51_xpec_systime_s_systime_s = 32  /* [31:0] */
};

typedef struct NX51_XPEC_SYSTIME_S_BIT_Ttag {
	unsigned int systime_s : BFW_NX51_xpec_systime_s_systime_s; /* read: 32 - Bit System Time (s) */
} NX51_XPEC_SYSTIME_S_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XPEC_SYSTIME_S_BIT_T bf;
} NX51_XPEC_SYSTIME_S_T;

/* --------------------------------------------------------------------- */
/* Register datach_data */
/* => Shared in xPEC fmmusm mode with buf_man (r/w mode).Register only accessible via rPEC0 and tPEC0 */
/*    xPEC data channel - data */
/*    becomes adr_buf_man of BUF_MAN */
/*    Buffer manager address for master xPEC: */
/*    16 buffer manager modules can be accessed, where each one handles buffer numbers between up to 4 procesors. */
/*    Each read request of a master will be answered by the most actual buffer number, */
/*    each write request of a master will be answered by the lowest free buffer number. */
/*    The buffer managers can be accessed in 2 different modes: 'normal mode' and 'parallel mode' (also known as EtherCAT mode): */
/*    In normal mode getting a new buffer happens with 2 command accesses: */
/*    1st: Write access: Tell the buf_manager channel (0..15) and wether you want read or write buffer. */
/*         Wait for 2 clockcycles, until new buffer number is calculated after any write access. */
/*    2nd: Read access: Read the buffer number (0..4). */
/*    In parallel mode all buffers are accessed in parallel but some functionality is limited. */
/*     3 -  0 : buf_nr         # write access: number of buf_manager channel (0..15) # default 7 */
/*            :                # read access: number of buffer (0..m+1), where m ist the number of masters using this buf_manager */
/*     6 -  5 : req_type       # Request type bits are write-only */
/*            :                # 00: request read buffer (or semaphore) */
/*            :                # 01: request write buffer (or release semaphore) */
/*            :                # 10: release write buffer (or release semaphore) */
/*            :                # 11: do not request new buffer or semaphore (used to only change channel) */
/*        7   : semaphore_mode # Activate 'semaphore mode' for this buf_nr by writing 1 to this bit. */
/*            :                # To return from semaphore-mode reset this channel */
/*            :                # In semaphore mode only buf_nr=0 (this master gets the semaphore) */
/*            :                # or buf_nr=7 (master does not get semphore) are returned. */
/*            :                # Requesting or releasing a semaphore (by req_type) is allowed while switching to semaphore mode */
/*        8   : parallel_mode  # activate parallel mode by writing 1 to this bit (other bits are ignored): */
/*            :                # In parallel mode, the behavior of all bits of this register changes completely. */
/*            :                # To return to normal mode, write 0xffff0000 to this register. */
/*            :                # parallel mode write access: */
/*            :                #   15.. 0: Request bits of all 16 channels (1: request new buffer, 0: dont request buffer) */
/*            :                #   31..16: wr bits of all 16 channels: */
/*            :                #           0: request read buffer or request semaphore */
/*            :                #           1: request write buffer or release semaphore */
/*            :                # parallel mode read access: */
/*            :                #   1,0: Actual buffer number of channel 0. */
/*            :                #   ... */
/*            :                #   31,30: Actual buffer number of channel 15. */
/*            :                # In parallel mode the number of masters is limited to 2, resulting in 3 buffers per channel. */
/*            :                # In parallel mode buffers cannot be released without requesting new buffer numbers. */
/*        9   : reset          # reset channel */
/*       10   : sm_update_en   # activate SM_auto_update mode by writing 1 to this bit: */
/*            :                # In SM_auto_update mode the requested buffer numbers of buffer managers 0..7 will automatically */
/*            :                # be programmed to the FMMU_SM unit. */
/*       11   : sm_update_dis  # de-activate SM_auto_update mode by writing 1 to this bit: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_datach_data        0x0000009CU
#define Adr_NX51_rpec0_regs_datach_data 0x1018B09CU
#define Adr_NX51_tpec0_regs_datach_data 0x1018B19CU
#define Adr_NX51_rpec1_regs_datach_data 0x1018B29CU
#define Adr_NX51_tpec1_regs_datach_data 0x1018B39CU

/* --------------------------------------------------------------------- */
/* Register xpec_sr0 */
/* => Shared Work Register 0 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr0        0x000000A0U
#define Adr_NX51_rpec0_regs_xpec_sr0 0x1018B0A0U
#define Adr_NX51_tpec0_regs_xpec_sr0 0x1018B1A0U
#define Adr_NX51_rpec1_regs_xpec_sr0 0x1018B2A0U
#define Adr_NX51_tpec1_regs_xpec_sr0 0x1018B3A0U
#define DFLT_VAL_NX51_xpec_sr0       0x00000000U

#define MSK_NX51_xpec_sr0_SR0            0x0000ffffU
#define SRT_NX51_xpec_sr0_SR0            0
#define DFLT_VAL_NX51_xpec_sr0_SR0       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr0_SR0    0x00000000U
#define MSK_NX51_xpec_sr0_SR0_15         0xffff0000U
#define SRT_NX51_xpec_sr0_SR0_15         16
#define DFLT_VAL_NX51_xpec_sr0_SR0_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr0_SR0_15 0x00000000U

/* all used bits of 'NX51_xpec_sr0': */
#define MSK_USED_BITS_NX51_xpec_sr0 0xffffffffU

enum {
	BFW_NX51_xpec_sr0_SR0    = 16, /* [15:0] */
	BFW_NX51_xpec_sr0_SR0_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR0_BIT_Ttag {
	unsigned int SR0    : BFW_NX51_xpec_sr0_SR0;    /* Shared Register */
	unsigned int SR0_15 : BFW_NX51_xpec_sr0_SR0_15; /* Sign extension  */
} NX51_XPEC_SR0_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR0_BIT_T bf;
} NX51_XPEC_SR0_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr1 */
/* => Shared Work Register 1 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr1        0x000000A4U
#define Adr_NX51_rpec0_regs_xpec_sr1 0x1018B0A4U
#define Adr_NX51_tpec0_regs_xpec_sr1 0x1018B1A4U
#define Adr_NX51_rpec1_regs_xpec_sr1 0x1018B2A4U
#define Adr_NX51_tpec1_regs_xpec_sr1 0x1018B3A4U
#define DFLT_VAL_NX51_xpec_sr1       0x00000000U

#define MSK_NX51_xpec_sr1_SR1            0x0000ffffU
#define SRT_NX51_xpec_sr1_SR1            0
#define DFLT_VAL_NX51_xpec_sr1_SR1       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr1_SR1    0x00000000U
#define MSK_NX51_xpec_sr1_SR1_15         0xffff0000U
#define SRT_NX51_xpec_sr1_SR1_15         16
#define DFLT_VAL_NX51_xpec_sr1_SR1_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr1_SR1_15 0x00000000U

/* all used bits of 'NX51_xpec_sr1': */
#define MSK_USED_BITS_NX51_xpec_sr1 0xffffffffU

enum {
	BFW_NX51_xpec_sr1_SR1    = 16, /* [15:0] */
	BFW_NX51_xpec_sr1_SR1_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR1_BIT_Ttag {
	unsigned int SR1    : BFW_NX51_xpec_sr1_SR1;    /* Shared Register */
	unsigned int SR1_15 : BFW_NX51_xpec_sr1_SR1_15; /* Sign extension  */
} NX51_XPEC_SR1_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR1_BIT_T bf;
} NX51_XPEC_SR1_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr2 */
/* => Shared Work Register 2 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr2        0x000000A8U
#define Adr_NX51_rpec0_regs_xpec_sr2 0x1018B0A8U
#define Adr_NX51_tpec0_regs_xpec_sr2 0x1018B1A8U
#define Adr_NX51_rpec1_regs_xpec_sr2 0x1018B2A8U
#define Adr_NX51_tpec1_regs_xpec_sr2 0x1018B3A8U
#define DFLT_VAL_NX51_xpec_sr2       0x00000000U

#define MSK_NX51_xpec_sr2_SR2            0x0000ffffU
#define SRT_NX51_xpec_sr2_SR2            0
#define DFLT_VAL_NX51_xpec_sr2_SR2       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr2_SR2    0x00000000U
#define MSK_NX51_xpec_sr2_SR2_15         0xffff0000U
#define SRT_NX51_xpec_sr2_SR2_15         16
#define DFLT_VAL_NX51_xpec_sr2_SR2_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr2_SR2_15 0x00000000U

/* all used bits of 'NX51_xpec_sr2': */
#define MSK_USED_BITS_NX51_xpec_sr2 0xffffffffU

enum {
	BFW_NX51_xpec_sr2_SR2    = 16, /* [15:0] */
	BFW_NX51_xpec_sr2_SR2_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR2_BIT_Ttag {
	unsigned int SR2    : BFW_NX51_xpec_sr2_SR2;    /* Shared Register */
	unsigned int SR2_15 : BFW_NX51_xpec_sr2_SR2_15; /* Sign extension  */
} NX51_XPEC_SR2_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR2_BIT_T bf;
} NX51_XPEC_SR2_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr3 */
/* => Shared Work Register 3 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr3        0x000000ACU
#define Adr_NX51_rpec0_regs_xpec_sr3 0x1018B0ACU
#define Adr_NX51_tpec0_regs_xpec_sr3 0x1018B1ACU
#define Adr_NX51_rpec1_regs_xpec_sr3 0x1018B2ACU
#define Adr_NX51_tpec1_regs_xpec_sr3 0x1018B3ACU
#define DFLT_VAL_NX51_xpec_sr3       0x00000000U

#define MSK_NX51_xpec_sr3_SR3            0x0000ffffU
#define SRT_NX51_xpec_sr3_SR3            0
#define DFLT_VAL_NX51_xpec_sr3_SR3       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr3_SR3    0x00000000U
#define MSK_NX51_xpec_sr3_SR3_15         0xffff0000U
#define SRT_NX51_xpec_sr3_SR3_15         16
#define DFLT_VAL_NX51_xpec_sr3_SR3_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr3_SR3_15 0x00000000U

/* all used bits of 'NX51_xpec_sr3': */
#define MSK_USED_BITS_NX51_xpec_sr3 0xffffffffU

enum {
	BFW_NX51_xpec_sr3_SR3    = 16, /* [15:0] */
	BFW_NX51_xpec_sr3_SR3_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR3_BIT_Ttag {
	unsigned int SR3    : BFW_NX51_xpec_sr3_SR3;    /* Shared Register */
	unsigned int SR3_15 : BFW_NX51_xpec_sr3_SR3_15; /* Sign extension  */
} NX51_XPEC_SR3_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR3_BIT_T bf;
} NX51_XPEC_SR3_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr4 */
/* => Shared Work Register 4 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr4        0x000000B0U
#define Adr_NX51_rpec0_regs_xpec_sr4 0x1018B0B0U
#define Adr_NX51_tpec0_regs_xpec_sr4 0x1018B1B0U
#define Adr_NX51_rpec1_regs_xpec_sr4 0x1018B2B0U
#define Adr_NX51_tpec1_regs_xpec_sr4 0x1018B3B0U
#define DFLT_VAL_NX51_xpec_sr4       0x00000000U

#define MSK_NX51_xpec_sr4_SR4            0x0000ffffU
#define SRT_NX51_xpec_sr4_SR4            0
#define DFLT_VAL_NX51_xpec_sr4_SR4       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr4_SR4    0x00000000U
#define MSK_NX51_xpec_sr4_SR4_15         0xffff0000U
#define SRT_NX51_xpec_sr4_SR4_15         16
#define DFLT_VAL_NX51_xpec_sr4_SR4_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr4_SR4_15 0x00000000U

/* all used bits of 'NX51_xpec_sr4': */
#define MSK_USED_BITS_NX51_xpec_sr4 0xffffffffU

enum {
	BFW_NX51_xpec_sr4_SR4    = 16, /* [15:0] */
	BFW_NX51_xpec_sr4_SR4_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR4_BIT_Ttag {
	unsigned int SR4    : BFW_NX51_xpec_sr4_SR4;    /* Shared Register */
	unsigned int SR4_15 : BFW_NX51_xpec_sr4_SR4_15; /* Sign extension  */
} NX51_XPEC_SR4_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR4_BIT_T bf;
} NX51_XPEC_SR4_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr5 */
/* => Shared Work Register 5 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr5        0x000000B4U
#define Adr_NX51_rpec0_regs_xpec_sr5 0x1018B0B4U
#define Adr_NX51_tpec0_regs_xpec_sr5 0x1018B1B4U
#define Adr_NX51_rpec1_regs_xpec_sr5 0x1018B2B4U
#define Adr_NX51_tpec1_regs_xpec_sr5 0x1018B3B4U
#define DFLT_VAL_NX51_xpec_sr5       0x00000000U

#define MSK_NX51_xpec_sr5_SR5            0x0000ffffU
#define SRT_NX51_xpec_sr5_SR5            0
#define DFLT_VAL_NX51_xpec_sr5_SR5       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr5_SR5    0x00000000U
#define MSK_NX51_xpec_sr5_SR5_15         0xffff0000U
#define SRT_NX51_xpec_sr5_SR5_15         16
#define DFLT_VAL_NX51_xpec_sr5_SR5_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr5_SR5_15 0x00000000U

/* all used bits of 'NX51_xpec_sr5': */
#define MSK_USED_BITS_NX51_xpec_sr5 0xffffffffU

enum {
	BFW_NX51_xpec_sr5_SR5    = 16, /* [15:0] */
	BFW_NX51_xpec_sr5_SR5_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR5_BIT_Ttag {
	unsigned int SR5    : BFW_NX51_xpec_sr5_SR5;    /* Shared Register */
	unsigned int SR5_15 : BFW_NX51_xpec_sr5_SR5_15; /* Sign extension  */
} NX51_XPEC_SR5_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR5_BIT_T bf;
} NX51_XPEC_SR5_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr6 */
/* => Shared Work Register 6 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr6        0x000000B8U
#define Adr_NX51_rpec0_regs_xpec_sr6 0x1018B0B8U
#define Adr_NX51_tpec0_regs_xpec_sr6 0x1018B1B8U
#define Adr_NX51_rpec1_regs_xpec_sr6 0x1018B2B8U
#define Adr_NX51_tpec1_regs_xpec_sr6 0x1018B3B8U
#define DFLT_VAL_NX51_xpec_sr6       0x00000000U

#define MSK_NX51_xpec_sr6_SR6            0x0000ffffU
#define SRT_NX51_xpec_sr6_SR6            0
#define DFLT_VAL_NX51_xpec_sr6_SR6       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr6_SR6    0x00000000U
#define MSK_NX51_xpec_sr6_SR6_15         0xffff0000U
#define SRT_NX51_xpec_sr6_SR6_15         16
#define DFLT_VAL_NX51_xpec_sr6_SR6_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr6_SR6_15 0x00000000U

/* all used bits of 'NX51_xpec_sr6': */
#define MSK_USED_BITS_NX51_xpec_sr6 0xffffffffU

enum {
	BFW_NX51_xpec_sr6_SR6    = 16, /* [15:0] */
	BFW_NX51_xpec_sr6_SR6_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR6_BIT_Ttag {
	unsigned int SR6    : BFW_NX51_xpec_sr6_SR6;    /* Shared Register */
	unsigned int SR6_15 : BFW_NX51_xpec_sr6_SR6_15; /* Sign extension  */
} NX51_XPEC_SR6_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR6_BIT_T bf;
} NX51_XPEC_SR6_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr7 */
/* => Shared Work Register 7 accessed by all xPECs and all xMACs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr7        0x000000BCU
#define Adr_NX51_rpec0_regs_xpec_sr7 0x1018B0BCU
#define Adr_NX51_tpec0_regs_xpec_sr7 0x1018B1BCU
#define Adr_NX51_rpec1_regs_xpec_sr7 0x1018B2BCU
#define Adr_NX51_tpec1_regs_xpec_sr7 0x1018B3BCU
#define DFLT_VAL_NX51_xpec_sr7       0x00000000U

#define MSK_NX51_xpec_sr7_SR7            0x0000ffffU
#define SRT_NX51_xpec_sr7_SR7            0
#define DFLT_VAL_NX51_xpec_sr7_SR7       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr7_SR7    0x00000000U
#define MSK_NX51_xpec_sr7_SR7_15         0xffff0000U
#define SRT_NX51_xpec_sr7_SR7_15         16
#define DFLT_VAL_NX51_xpec_sr7_SR7_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr7_SR7_15 0x00000000U

/* all used bits of 'NX51_xpec_sr7': */
#define MSK_USED_BITS_NX51_xpec_sr7 0xffffffffU

enum {
	BFW_NX51_xpec_sr7_SR7    = 16, /* [15:0] */
	BFW_NX51_xpec_sr7_SR7_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR7_BIT_Ttag {
	unsigned int SR7    : BFW_NX51_xpec_sr7_SR7;    /* Shared Register */
	unsigned int SR7_15 : BFW_NX51_xpec_sr7_SR7_15; /* Sign extension  */
} NX51_XPEC_SR7_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR7_BIT_T bf;
} NX51_XPEC_SR7_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr8 */
/* => Shared Work Register 8 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with fmmusm_len_en (r/w mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_trigger_sample_irq (r mode). */
/*    Shared in xPEC intlogic mode with xmac0_rpu_systime_uc (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr8        0x000000C0U
#define Adr_NX51_rpec0_regs_xpec_sr8 0x1018B0C0U
#define Adr_NX51_tpec0_regs_xpec_sr8 0x1018B1C0U
#define Adr_NX51_rpec1_regs_xpec_sr8 0x1018B2C0U
#define Adr_NX51_tpec1_regs_xpec_sr8 0x1018B3C0U
#define DFLT_VAL_NX51_xpec_sr8       0x00000000U

#define MSK_NX51_xpec_sr8_SR8            0x0000ffffU
#define SRT_NX51_xpec_sr8_SR8            0
#define DFLT_VAL_NX51_xpec_sr8_SR8       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr8_SR8    0x00000000U
#define MSK_NX51_xpec_sr8_SR8_15         0xffff0000U
#define SRT_NX51_xpec_sr8_SR8_15         16
#define DFLT_VAL_NX51_xpec_sr8_SR8_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr8_SR8_15 0x00000000U

/* all used bits of 'NX51_xpec_sr8': */
#define MSK_USED_BITS_NX51_xpec_sr8 0xffffffffU

enum {
	BFW_NX51_xpec_sr8_SR8    = 16, /* [15:0] */
	BFW_NX51_xpec_sr8_SR8_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR8_BIT_Ttag {
	unsigned int SR8    : BFW_NX51_xpec_sr8_SR8;    /* Shared Register */
	unsigned int SR8_15 : BFW_NX51_xpec_sr8_SR8_15; /* Sign extension  */
} NX51_XPEC_SR8_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR8_BIT_T bf;
} NX51_XPEC_SR8_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr9 */
/* => Shared Work Register 9 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with fmmusm_status_out (r mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_trigger_activate (r mode). */
/*    Shared in xPEC intlogic mode with xmac1_rpu_systime_uc (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr9        0x000000C4U
#define Adr_NX51_rpec0_regs_xpec_sr9 0x1018B0C4U
#define Adr_NX51_tpec0_regs_xpec_sr9 0x1018B1C4U
#define Adr_NX51_rpec1_regs_xpec_sr9 0x1018B2C4U
#define Adr_NX51_tpec1_regs_xpec_sr9 0x1018B3C4U
#define DFLT_VAL_NX51_xpec_sr9       0x00000000U

#define MSK_NX51_xpec_sr9_SR9            0x0000ffffU
#define SRT_NX51_xpec_sr9_SR9            0
#define DFLT_VAL_NX51_xpec_sr9_SR9       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr9_SR9    0x00000000U
#define MSK_NX51_xpec_sr9_SR9_15         0xffff0000U
#define SRT_NX51_xpec_sr9_SR9_15         16
#define DFLT_VAL_NX51_xpec_sr9_SR9_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr9_SR9_15 0x00000000U

/* all used bits of 'NX51_xpec_sr9': */
#define MSK_USED_BITS_NX51_xpec_sr9 0xffffffffU

enum {
	BFW_NX51_xpec_sr9_SR9    = 16, /* [15:0] */
	BFW_NX51_xpec_sr9_SR9_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR9_BIT_Ttag {
	unsigned int SR9    : BFW_NX51_xpec_sr9_SR9;    /* Shared Register */
	unsigned int SR9_15 : BFW_NX51_xpec_sr9_SR9_15; /* Sign extension  */
} NX51_XPEC_SR9_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XPEC_SR9_BIT_T bf;
} NX51_XPEC_SR9_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr10 */
/* => Shared Work Register 10 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with sm_buf_statcfg (r/w mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_trigger_impulse_length (r mode). */
/*    Shared in xPEC intlogic mode with xmac0_tpu_systime_uc (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr10        0x000000C8U
#define Adr_NX51_rpec0_regs_xpec_sr10 0x1018B0C8U
#define Adr_NX51_tpec0_regs_xpec_sr10 0x1018B1C8U
#define Adr_NX51_rpec1_regs_xpec_sr10 0x1018B2C8U
#define Adr_NX51_tpec1_regs_xpec_sr10 0x1018B3C8U
#define DFLT_VAL_NX51_xpec_sr10       0x00000000U

#define MSK_NX51_xpec_sr10_SR10            0x0000ffffU
#define SRT_NX51_xpec_sr10_SR10            0
#define DFLT_VAL_NX51_xpec_sr10_SR10       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr10_SR10    0x00000000U
#define MSK_NX51_xpec_sr10_SR10_15         0xffff0000U
#define SRT_NX51_xpec_sr10_SR10_15         16
#define DFLT_VAL_NX51_xpec_sr10_SR10_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr10_SR10_15 0x00000000U

/* all used bits of 'NX51_xpec_sr10': */
#define MSK_USED_BITS_NX51_xpec_sr10 0xffffffffU

enum {
	BFW_NX51_xpec_sr10_SR10    = 16, /* [15:0] */
	BFW_NX51_xpec_sr10_SR10_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR10_BIT_Ttag {
	unsigned int SR10    : BFW_NX51_xpec_sr10_SR10;    /* Shared Register */
	unsigned int SR10_15 : BFW_NX51_xpec_sr10_SR10_15; /* Sign extension  */
} NX51_XPEC_SR10_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPEC_SR10_BIT_T bf;
} NX51_XPEC_SR10_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr11 */
/* => Shared Work Register 11 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with sm_read_event (r/w mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_trigger_0_starttime_ns (r mode). */
/*    Shared in xPEC intlogic mode with xmac1_tpu_systime_uc (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr11        0x000000CCU
#define Adr_NX51_rpec0_regs_xpec_sr11 0x1018B0CCU
#define Adr_NX51_tpec0_regs_xpec_sr11 0x1018B1CCU
#define Adr_NX51_rpec1_regs_xpec_sr11 0x1018B2CCU
#define Adr_NX51_tpec1_regs_xpec_sr11 0x1018B3CCU
#define DFLT_VAL_NX51_xpec_sr11       0x00000000U

#define MSK_NX51_xpec_sr11_SR11            0x0000ffffU
#define SRT_NX51_xpec_sr11_SR11            0
#define DFLT_VAL_NX51_xpec_sr11_SR11       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr11_SR11    0x00000000U
#define MSK_NX51_xpec_sr11_SR11_15         0xffff0000U
#define SRT_NX51_xpec_sr11_SR11_15         16
#define DFLT_VAL_NX51_xpec_sr11_SR11_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr11_SR11_15 0x00000000U

/* all used bits of 'NX51_xpec_sr11': */
#define MSK_USED_BITS_NX51_xpec_sr11 0xffffffffU

enum {
	BFW_NX51_xpec_sr11_SR11    = 16, /* [15:0] */
	BFW_NX51_xpec_sr11_SR11_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR11_BIT_Ttag {
	unsigned int SR11    : BFW_NX51_xpec_sr11_SR11;    /* Shared Register */
	unsigned int SR11_15 : BFW_NX51_xpec_sr11_SR11_15; /* Sign extension  */
} NX51_XPEC_SR11_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPEC_SR11_BIT_T bf;
} NX51_XPEC_SR11_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr12 */
/* => Shared Work Register 12 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with sm_write_event (r/w mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_trigger_1_starttime_ns (r mode). */
/*    Shared in xPEC intlogic mode with xmac0_rpu_systime (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr12        0x000000D0U
#define Adr_NX51_rpec0_regs_xpec_sr12 0x1018B0D0U
#define Adr_NX51_tpec0_regs_xpec_sr12 0x1018B1D0U
#define Adr_NX51_rpec1_regs_xpec_sr12 0x1018B2D0U
#define Adr_NX51_tpec1_regs_xpec_sr12 0x1018B3D0U
#define DFLT_VAL_NX51_xpec_sr12       0x00000000U

#define MSK_NX51_xpec_sr12_SR12            0x0000ffffU
#define SRT_NX51_xpec_sr12_SR12            0
#define DFLT_VAL_NX51_xpec_sr12_SR12       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr12_SR12    0x00000000U
#define MSK_NX51_xpec_sr12_SR12_15         0xffff0000U
#define SRT_NX51_xpec_sr12_SR12_15         16
#define DFLT_VAL_NX51_xpec_sr12_SR12_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr12_SR12_15 0x00000000U

/* all used bits of 'NX51_xpec_sr12': */
#define MSK_USED_BITS_NX51_xpec_sr12 0xffffffffU

enum {
	BFW_NX51_xpec_sr12_SR12    = 16, /* [15:0] */
	BFW_NX51_xpec_sr12_SR12_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR12_BIT_Ttag {
	unsigned int SR12    : BFW_NX51_xpec_sr12_SR12;    /* Shared Register */
	unsigned int SR12_15 : BFW_NX51_xpec_sr12_SR12_15; /* Sign extension  */
} NX51_XPEC_SR12_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPEC_SR12_BIT_T bf;
} NX51_XPEC_SR12_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr13 */
/* => Shared Work Register 13 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with sm_first_byte_addressed (r/w mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_trigger_0_cyc_time (r mode). */
/*    Shared in xPEC intlogic mode with xmac1_rpu_systime (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr13        0x000000D4U
#define Adr_NX51_rpec0_regs_xpec_sr13 0x1018B0D4U
#define Adr_NX51_tpec0_regs_xpec_sr13 0x1018B1D4U
#define Adr_NX51_rpec1_regs_xpec_sr13 0x1018B2D4U
#define Adr_NX51_tpec1_regs_xpec_sr13 0x1018B3D4U
#define DFLT_VAL_NX51_xpec_sr13       0x00000000U

#define MSK_NX51_xpec_sr13_SR13            0x0000ffffU
#define SRT_NX51_xpec_sr13_SR13            0
#define DFLT_VAL_NX51_xpec_sr13_SR13       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr13_SR13    0x00000000U
#define MSK_NX51_xpec_sr13_SR13_15         0xffff0000U
#define SRT_NX51_xpec_sr13_SR13_15         16
#define DFLT_VAL_NX51_xpec_sr13_SR13_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr13_SR13_15 0x00000000U

/* all used bits of 'NX51_xpec_sr13': */
#define MSK_USED_BITS_NX51_xpec_sr13 0xffffffffU

enum {
	BFW_NX51_xpec_sr13_SR13    = 16, /* [15:0] */
	BFW_NX51_xpec_sr13_SR13_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR13_BIT_Ttag {
	unsigned int SR13    : BFW_NX51_xpec_sr13_SR13;    /* Shared Register */
	unsigned int SR13_15 : BFW_NX51_xpec_sr13_SR13_15; /* Sign extension  */
} NX51_XPEC_SR13_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPEC_SR13_BIT_T bf;
} NX51_XPEC_SR13_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr14 */
/* => Shared Work Register 14 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with sm_last_byte_addressed (r/w mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_trigger_1_cyc_time (r mode). */
/*    Shared in xPEC intlogic mode with xmac0_tpu_systime (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr14        0x000000D8U
#define Adr_NX51_rpec0_regs_xpec_sr14 0x1018B0D8U
#define Adr_NX51_tpec0_regs_xpec_sr14 0x1018B1D8U
#define Adr_NX51_rpec1_regs_xpec_sr14 0x1018B2D8U
#define Adr_NX51_tpec1_regs_xpec_sr14 0x1018B3D8U
#define DFLT_VAL_NX51_xpec_sr14       0x00000000U

#define MSK_NX51_xpec_sr14_SR14            0x0000ffffU
#define SRT_NX51_xpec_sr14_SR14            0
#define DFLT_VAL_NX51_xpec_sr14_SR14       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr14_SR14    0x00000000U
#define MSK_NX51_xpec_sr14_SR14_15         0xffff0000U
#define SRT_NX51_xpec_sr14_SR14_15         16
#define DFLT_VAL_NX51_xpec_sr14_SR14_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr14_SR14_15 0x00000000U

/* all used bits of 'NX51_xpec_sr14': */
#define MSK_USED_BITS_NX51_xpec_sr14 0xffffffffU

enum {
	BFW_NX51_xpec_sr14_SR14    = 16, /* [15:0] */
	BFW_NX51_xpec_sr14_SR14_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR14_BIT_Ttag {
	unsigned int SR14    : BFW_NX51_xpec_sr14_SR14;    /* Shared Register -- in debug mode (statcfg[14]) read 32 Bit xpec_debug_code */
	unsigned int SR14_15 : BFW_NX51_xpec_sr14_SR14_15; /* Sign extension                                                             */
} NX51_XPEC_SR14_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPEC_SR14_BIT_T bf;
} NX51_XPEC_SR14_T;

/* --------------------------------------------------------------------- */
/* Register xpec_sr15 */
/* => Shared Work Register 15 accessed by all xPECs and all xMACs. */
/*    Shared in xPEC fmmusm mode with sm_served (r/w mode). Register only accessible via rPEC0 and tPEC0 */
/*    Shared in xPEC trigger_sample mode with adr_sample_mode (r mode). */
/*    Shared in xPEC intlogic mode with xmac1_tpu_systime (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpec_sr15        0x000000DCU
#define Adr_NX51_rpec0_regs_xpec_sr15 0x1018B0DCU
#define Adr_NX51_tpec0_regs_xpec_sr15 0x1018B1DCU
#define Adr_NX51_rpec1_regs_xpec_sr15 0x1018B2DCU
#define Adr_NX51_tpec1_regs_xpec_sr15 0x1018B3DCU
#define DFLT_VAL_NX51_xpec_sr15       0x00000000U

#define MSK_NX51_xpec_sr15_SR15            0x0000ffffU
#define SRT_NX51_xpec_sr15_SR15            0
#define DFLT_VAL_NX51_xpec_sr15_SR15       0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr15_SR15    0x00000000U
#define MSK_NX51_xpec_sr15_SR15_15         0xffff0000U
#define SRT_NX51_xpec_sr15_SR15_15         16
#define DFLT_VAL_NX51_xpec_sr15_SR15_15    0x00000000U
#define DFLT_BF_VAL_NX51_xpec_sr15_SR15_15 0x00000000U

/* all used bits of 'NX51_xpec_sr15': */
#define MSK_USED_BITS_NX51_xpec_sr15 0xffffffffU

enum {
	BFW_NX51_xpec_sr15_SR15    = 16, /* [15:0] */
	BFW_NX51_xpec_sr15_SR15_15 = 16  /* [31:16] */
};

typedef struct NX51_XPEC_SR15_BIT_Ttag {
	unsigned int SR15    : BFW_NX51_xpec_sr15_SR15;    /* Shared Register -- in debug mode (statcfg[14]) read 11 Bit xpec_debug_pc */
	unsigned int SR15_15 : BFW_NX51_xpec_sr15_SR15_15; /* Sign extension                                                           */
} NX51_XPEC_SR15_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPEC_SR15_BIT_T bf;
} NX51_XPEC_SR15_T;

/* --------------------------------------------------------------------- */
/* Register statcfg0 */
/* => xMAC0 Shared Config/Status Register */
/*    for write mode the upper Bits [31:16] are mask bits for Bits [15:0] of shared_config (xMAC) register */
/*    Shared in xPEC trigger_sample mode with adr_sample_0_pos_systime_ns (r mode). */
/*    Shared in xPEC intlogic mode with crc_polynom (r/w mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_statcfg0        0x000000E0U
#define Adr_NX51_rpec0_regs_statcfg0 0x1018B0E0U
#define Adr_NX51_tpec0_regs_statcfg0 0x1018B1E0U
#define Adr_NX51_rpec1_regs_statcfg0 0x1018B2E0U
#define Adr_NX51_tpec1_regs_statcfg0 0x1018B3E0U
#define DFLT_VAL_NX51_statcfg0       0x00000000U

#define MSK_NX51_statcfg0_xmac0_config_shared0         0x000000ffU
#define SRT_NX51_statcfg0_xmac0_config_shared0         0
#define DFLT_VAL_NX51_statcfg0_xmac0_config_shared0    0x00000000U
#define DFLT_BF_VAL_NX51_statcfg0_xmac0_config_shared0 0x00000000U
#define MSK_NX51_statcfg0_xmac0_io_oe_shared0          0x0000ff00U
#define SRT_NX51_statcfg0_xmac0_io_oe_shared0          8
#define DFLT_VAL_NX51_statcfg0_xmac0_io_oe_shared0     0x00000000U
#define DFLT_BF_VAL_NX51_statcfg0_xmac0_io_oe_shared0  0x00000000U
#define MSK_NX51_statcfg0_xmac0_status_shared0         0xffff0000U
#define SRT_NX51_statcfg0_xmac0_status_shared0         16
#define DFLT_VAL_NX51_statcfg0_xmac0_status_shared0    0x00000000U
#define DFLT_BF_VAL_NX51_statcfg0_xmac0_status_shared0 0x00000000U

/* all used bits of 'NX51_statcfg0': */
#define MSK_USED_BITS_NX51_statcfg0 0xffffffffU

enum {
	BFW_NX51_statcfg0_xmac0_config_shared0 = 8,  /* [7:0] */
	BFW_NX51_statcfg0_xmac0_io_oe_shared0  = 8,  /* [15:8] */
	BFW_NX51_statcfg0_xmac0_status_shared0 = 16  /* [31:16] */
};

typedef struct NX51_STATCFG0_BIT_Ttag {
	unsigned int xmac0_config_shared0 : BFW_NX51_statcfg0_xmac0_config_shared0; /* same as xmac0_config_shared0[7:0]           */
	unsigned int xmac0_io_oe_shared0  : BFW_NX51_statcfg0_xmac0_io_oe_shared0;  /* same as xmac0_io_oe_shared0[7:0]            */
	unsigned int xmac0_status_shared0 : BFW_NX51_statcfg0_xmac0_status_shared0; /* read access: same as xmac0_status_shared0   */
	                                                                            /* write access: write bit mask for bits 15..0 */
} NX51_STATCFG0_BIT_T;

typedef union {
	unsigned int        val;
	NX51_STATCFG0_BIT_T bf;
} NX51_STATCFG0_T;

/* --------------------------------------------------------------------- */
/* Register statcfg1 */
/* => xMAC1 Shared Config/Status Register */
/*    for write mode the upper Bits [31:16] are mask bits for Bits [15:0] of shared_config (xMAC) register */
/*    Shared in xPEC trigger_sample mode with adr_sample_0_neg_systime_ns (r mode). */
/*    Shared in xPEC intlogic mode with crc_cfg (r/w mode). */
/*    crc_cfg[10]    = crc_invert */
/*    crc_cfg[9]     = crc_zero */
/*    crc_cfg[8]     = reserved */
/*    crc_cfg[7]     = crc_shift_right */
/*    crc_cfg[6]     = crc_swap_output */
/*    crc_cfg[5]     = crc_direct_div */
/*    crc_cfg[4:0]   = crc_length */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_statcfg1        0x000000E4U
#define Adr_NX51_rpec0_regs_statcfg1 0x1018B0E4U
#define Adr_NX51_tpec0_regs_statcfg1 0x1018B1E4U
#define Adr_NX51_rpec1_regs_statcfg1 0x1018B2E4U
#define Adr_NX51_tpec1_regs_statcfg1 0x1018B3E4U
#define DFLT_VAL_NX51_statcfg1       0x00000000U

#define MSK_NX51_statcfg1_xmac1_config_shared1         0x000000ffU
#define SRT_NX51_statcfg1_xmac1_config_shared1         0
#define DFLT_VAL_NX51_statcfg1_xmac1_config_shared1    0x00000000U
#define DFLT_BF_VAL_NX51_statcfg1_xmac1_config_shared1 0x00000000U
#define MSK_NX51_statcfg1_xmac1_io_oe_shared1          0x0000ff00U
#define SRT_NX51_statcfg1_xmac1_io_oe_shared1          8
#define DFLT_VAL_NX51_statcfg1_xmac1_io_oe_shared1     0x00000000U
#define DFLT_BF_VAL_NX51_statcfg1_xmac1_io_oe_shared1  0x00000000U
#define MSK_NX51_statcfg1_xmac1_status_shared1         0xffff0000U
#define SRT_NX51_statcfg1_xmac1_status_shared1         16
#define DFLT_VAL_NX51_statcfg1_xmac1_status_shared1    0x00000000U
#define DFLT_BF_VAL_NX51_statcfg1_xmac1_status_shared1 0x00000000U

/* all used bits of 'NX51_statcfg1': */
#define MSK_USED_BITS_NX51_statcfg1 0xffffffffU

enum {
	BFW_NX51_statcfg1_xmac1_config_shared1 = 8,  /* [7:0] */
	BFW_NX51_statcfg1_xmac1_io_oe_shared1  = 8,  /* [15:8] */
	BFW_NX51_statcfg1_xmac1_status_shared1 = 16  /* [31:16] */
};

typedef struct NX51_STATCFG1_BIT_Ttag {
	unsigned int xmac1_config_shared1 : BFW_NX51_statcfg1_xmac1_config_shared1; /* same as xmac1_config_shared1[7:0]           */
	unsigned int xmac1_io_oe_shared1  : BFW_NX51_statcfg1_xmac1_io_oe_shared1;  /* same as xmac1_io_oe_shared1[7:0]            */
	unsigned int xmac1_status_shared1 : BFW_NX51_statcfg1_xmac1_status_shared1; /* read access: same as xmac1_status_shared1   */
	                                                                            /* write access: write bit mask for bits 15..0 */
} NX51_STATCFG1_BIT_T;

typedef union {
	unsigned int        val;
	NX51_STATCFG1_BIT_T bf;
} NX51_STATCFG1_T;

/* --------------------------------------------------------------------- */
/* Register datach_wr_cfg */
/* => Shared in xPEC trigger_sample mode with adr_sample_1_pos_systime_ns (r mode). */
/*    Shared in xPEC fmmusm mode with fmmu_read_bit_rol_pos (r mode). */
/*    Shared in xPEC intlogic mode with xpec_config2 (r/w mode) */
/*      9 - 8    : wr4_range_sel        # Select range mode for wr4 # default 0 */
/*               :                      #       2'b00 : normal mode (range4 for wr4) */
/*               :                      #       2'b01 : select wr6 as range  for wr4 */
/*               :                      #       2'b10 : select wr7 as range  for wr4 */
/*               :                      #       2'b11 : reserved */
/*    11 - 10    : wr5_range_sel        # Select range mode for wr5 # default 0 */
/*               :                      #       2'b00 : normal mode (range5 for wr5) */
/*               :                      #       2'b01 : select wr6 as range  for wr5 */
/*               :                      #       2'b10 : select wr7 as range  for wr5 */
/*               :                      #       2'b11 : reserved */
/*    13 - 12    : wr6_range_sel        # Select range mode for wr6 # default 0 */
/*               :                      #       2'b00 : normal mode (range6 for wr6) */
/*               :                      #       2'b01 : select wr4 as range  for wr6 */
/*               :                      #       2'b10 : select wr5 as range  for wr6 */
/*               :                      #       2'b11 : reserved */
/*    15 - 14    : wr7_range_sel        # Select range mode for wr7 # default 0 */
/*               :                      #       2'b00 : normal mode (range7 for wr7) */
/*               :                      #       2'b01 : select wr4 as range  for wr7 */
/*               :                      #       2'b10 : select wr5 as range  for wr7 */
/*               :                      #       2'b11 : reserved */
/*    19 - 16    : datach_segment_addr_31_28 # bits 31..28 of data channel address # default 0 */
/*    21 - 20    : sysch_size                # access width of system channel access # default 0x2 */
/*               :                      #       2'b00 : byte access (8 bit) */
/*               :                      #       2'b01 : word access (16 bit) */
/*               :                      #       2'b10 : dword access (32 bit) # default */
/*               :                      #       2'b11 : reserved */
/*         22    : datach_rdy_timer2small # debug status, set to one if datach_rdy event goes up after datach_rdy timer expired; write one to reset flag. Recommended value: number of PICs using data_ch plus 2, netx51 worst case-value=6 */
/*         23    : pfifo_rdy_timer2small  # debug status, set to one if pfifo_rdy event goes up after pfifo_rdy timer expired; write one to reset flag */
/*    27 - 24    : datach_rdy_timer     #  0: datach_rdy signal generated after access finished: */
/*               :                      #  1..15: datach_rdy generated x cc after access started (set to worst case value; used to get determistic PEC program flow) */
/*    31 - 28    : pfifo_rdy_timer      #  0: pfifo_rdy signal generated after access finished */
/*               :                      #  1..15: pfifo_rdy generated x cc after access started (set to worst case value; used to get determistic PEC program flow, worst case value is number of pfifo accessing parties minus one) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_datach_wr_cfg        0x000000E8U
#define Adr_NX51_rpec0_regs_datach_wr_cfg 0x1018B0E8U
#define Adr_NX51_tpec0_regs_datach_wr_cfg 0x1018B1E8U
#define Adr_NX51_rpec1_regs_datach_wr_cfg 0x1018B2E8U
#define Adr_NX51_tpec1_regs_datach_wr_cfg 0x1018B3E8U
#define DFLT_VAL_NX51_datach_wr_cfg       0x00000000U

#define MSK_NX51_datach_wr_cfg_datach_wr_offset_addr         0x0fffffffU
#define SRT_NX51_datach_wr_cfg_datach_wr_offset_addr         0
#define DFLT_VAL_NX51_datach_wr_cfg_datach_wr_offset_addr    0x00000000U
#define DFLT_BF_VAL_NX51_datach_wr_cfg_datach_wr_offset_addr 0x00000000U
#define MSK_NX51_datach_wr_cfg_datach_wr_size                0x30000000U
#define SRT_NX51_datach_wr_cfg_datach_wr_size                28
#define DFLT_VAL_NX51_datach_wr_cfg_datach_wr_size           0x00000000U
#define DFLT_BF_VAL_NX51_datach_wr_cfg_datach_wr_size        0x00000000U
#define MSK_NX51_datach_wr_cfg_datach_wr_mode                0xc0000000U
#define SRT_NX51_datach_wr_cfg_datach_wr_mode                30
#define DFLT_VAL_NX51_datach_wr_cfg_datach_wr_mode           0x00000000U
#define DFLT_BF_VAL_NX51_datach_wr_cfg_datach_wr_mode        0x00000000U

/* all used bits of 'NX51_datach_wr_cfg': */
#define MSK_USED_BITS_NX51_datach_wr_cfg 0xffffffffU

enum {
	BFW_NX51_datach_wr_cfg_datach_wr_offset_addr = 28, /* [27:0] */
	BFW_NX51_datach_wr_cfg_datach_wr_size        = 2,  /* [29:28] */
	BFW_NX51_datach_wr_cfg_datach_wr_mode        = 2   /* [31:30] */
};

typedef struct NX51_DATACH_WR_CFG_BIT_Ttag {
	unsigned int datach_wr_offset_addr : BFW_NX51_datach_wr_cfg_datach_wr_offset_addr; /* read address offset, address that is accessed = xpec_config2.datach_segment_addr_31_28 << 28 + datach_rd_offset_addr */
	unsigned int datach_wr_size        : BFW_NX51_datach_wr_cfg_datach_wr_size;        /* default 0                                                                                                            */
	                                                                                   /*       2'b00 : byte access (8 bit)                                                                                    */
	                                                                                   /*       2'b01 : word access (16 bit)                                                                                   */
	                                                                                   /*       2'b10 : dword access (32 bit)                                                                                  */
	                                                                                   /*       2'b11 : reserved                                                                                               */
	unsigned int datach_wr_mode        : BFW_NX51_datach_wr_cfg_datach_wr_mode;        /* default 0                                                                                                            */
	                                                                                   /*       2'b00 : normal access                                                                                          */
	                                                                                   /*       2'b01 : auto post-inc (for offset_addr)                                                                        */
	                                                                                   /*       2'b10 : reserved                                                                                               */
	                                                                                   /*       2'b11 : reserved                                                                                               */
} NX51_DATACH_WR_CFG_BIT_T;

typedef union {
	unsigned int             val;
	NX51_DATACH_WR_CFG_BIT_T bf;
} NX51_DATACH_WR_CFG_T;

/* --------------------------------------------------------------------- */
/* Register datach_rd_cfg */
/* => Shared in xPEC trigger_sample mode with adr_sample_1_neg_systime_ns (r mode). */
/*    Shared in xPEC fmmusm mode with fmmu_write_bit_rol_pos (r mode). */
/*    Shared in xPEC intlogic mode with crc_data (r/w mode) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_datach_rd_cfg        0x000000ECU
#define Adr_NX51_rpec0_regs_datach_rd_cfg 0x1018B0ECU
#define Adr_NX51_tpec0_regs_datach_rd_cfg 0x1018B1ECU
#define Adr_NX51_rpec1_regs_datach_rd_cfg 0x1018B2ECU
#define Adr_NX51_tpec1_regs_datach_rd_cfg 0x1018B3ECU
#define DFLT_VAL_NX51_datach_rd_cfg       0x00000000U

#define MSK_NX51_datach_rd_cfg_datach_rd_offset_addr         0x0fffffffU
#define SRT_NX51_datach_rd_cfg_datach_rd_offset_addr         0
#define DFLT_VAL_NX51_datach_rd_cfg_datach_rd_offset_addr    0x00000000U
#define DFLT_BF_VAL_NX51_datach_rd_cfg_datach_rd_offset_addr 0x00000000U
#define MSK_NX51_datach_rd_cfg_datach_rd_size                0x30000000U
#define SRT_NX51_datach_rd_cfg_datach_rd_size                28
#define DFLT_VAL_NX51_datach_rd_cfg_datach_rd_size           0x00000000U
#define DFLT_BF_VAL_NX51_datach_rd_cfg_datach_rd_size        0x00000000U
#define MSK_NX51_datach_rd_cfg_datach_rd_mode                0xc0000000U
#define SRT_NX51_datach_rd_cfg_datach_rd_mode                30
#define DFLT_VAL_NX51_datach_rd_cfg_datach_rd_mode           0x00000000U
#define DFLT_BF_VAL_NX51_datach_rd_cfg_datach_rd_mode        0x00000000U

/* all used bits of 'NX51_datach_rd_cfg': */
#define MSK_USED_BITS_NX51_datach_rd_cfg 0xffffffffU

enum {
	BFW_NX51_datach_rd_cfg_datach_rd_offset_addr = 28, /* [27:0] */
	BFW_NX51_datach_rd_cfg_datach_rd_size        = 2,  /* [29:28] */
	BFW_NX51_datach_rd_cfg_datach_rd_mode        = 2   /* [31:30] */
};

typedef struct NX51_DATACH_RD_CFG_BIT_Ttag {
	unsigned int datach_rd_offset_addr : BFW_NX51_datach_rd_cfg_datach_rd_offset_addr; /* write address offset, address that is accessed = xpec_net.datach_segment_addr_31_28 << 28 + datach_wr_offset_addr */
	unsigned int datach_rd_size        : BFW_NX51_datach_rd_cfg_datach_rd_size;        /* default 0                                                                                                         */
	                                                                                   /*       2'b00 : byte access (8 bit)                                                                                 */
	                                                                                   /*       2'b01 : word access (16 bit)                                                                                */
	                                                                                   /*       2'b10 : dword access (32 bit)                                                                               */
	                                                                                   /*       2'b11 : reserved                                                                                            */
	unsigned int datach_rd_mode        : BFW_NX51_datach_rd_cfg_datach_rd_mode;        /* default 0                                                                                                         */
	                                                                                   /*       2'b00 : normal access                                                                                       */
	                                                                                   /*       2'b01 : auto post-inc (for offset_addr)                                                                     */
	                                                                                   /*       2'b10 : reserved                                                                                            */
	                                                                                   /*       2'b11 : reserved                                                                                            */
} NX51_DATACH_RD_CFG_BIT_T;

typedef union {
	unsigned int             val;
	NX51_DATACH_RD_CFG_BIT_T bf;
} NX51_DATACH_RD_CFG_T;

/* --------------------------------------------------------------------- */
/* Register urtx0 */
/* => xMAC0 URX Shared Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_urtx0        0x000000F0U
#define Adr_NX51_rpec0_regs_urtx0 0x1018B0F0U
#define Adr_NX51_tpec0_regs_urtx0 0x1018B1F0U
#define Adr_NX51_rpec1_regs_urtx0 0x1018B2F0U
#define Adr_NX51_tpec1_regs_urtx0 0x1018B3F0U
#define DFLT_VAL_NX51_urtx0       0x00000000U

#define MSK_NX51_urtx0_urtx_xmac0         0x0000ffffU
#define SRT_NX51_urtx0_urtx_xmac0         0
#define DFLT_VAL_NX51_urtx0_urtx_xmac0    0x00000000U
#define DFLT_BF_VAL_NX51_urtx0_urtx_xmac0 0x00000000U

/* all used bits of 'NX51_urtx0': */
#define MSK_USED_BITS_NX51_urtx0 0x0000ffffU

enum {
	BFW_NX51_urtx0_urtx_xmac0 = 16, /* [15:0] */
	BFW_NX51_urtx0_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_URTX0_BIT_Ttag {
	unsigned int urtx_xmac0 : BFW_NX51_urtx0_urtx_xmac0; /* read access:  Lastly received bits (output of URX_FIFO)       */
	                                                     /* write access: Bits to be transmitted next (input of UTX_FIFO) */
	unsigned int reserved1  : BFW_NX51_urtx0_reserved1;  /* reserved                                                      */
} NX51_URTX0_BIT_T;

typedef union {
	unsigned int     val;
	NX51_URTX0_BIT_T bf;
} NX51_URTX0_T;

/* --------------------------------------------------------------------- */
/* Register urtx1 */
/* => xMAC1 URX Shared Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_urtx1        0x000000F4U
#define Adr_NX51_rpec0_regs_urtx1 0x1018B0F4U
#define Adr_NX51_tpec0_regs_urtx1 0x1018B1F4U
#define Adr_NX51_rpec1_regs_urtx1 0x1018B2F4U
#define Adr_NX51_tpec1_regs_urtx1 0x1018B3F4U
#define DFLT_VAL_NX51_urtx1       0x00000000U

#define MSK_NX51_urtx1_urtx_xmac1         0x0000ffffU
#define SRT_NX51_urtx1_urtx_xmac1         0
#define DFLT_VAL_NX51_urtx1_urtx_xmac1    0x00000000U
#define DFLT_BF_VAL_NX51_urtx1_urtx_xmac1 0x00000000U

/* all used bits of 'NX51_urtx1': */
#define MSK_USED_BITS_NX51_urtx1 0x0000ffffU

enum {
	BFW_NX51_urtx1_urtx_xmac1 = 16, /* [15:0] */
	BFW_NX51_urtx1_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_URTX1_BIT_Ttag {
	unsigned int urtx_xmac1 : BFW_NX51_urtx1_urtx_xmac1; /* read access:  Lastly received bits (output of URX_FIFO)       */
	                                                     /* write access: Bits to be transmitted next (input of UTX_FIFO) */
	unsigned int reserved1  : BFW_NX51_urtx1_reserved1;  /* reserved                                                      */
} NX51_URTX1_BIT_T;

typedef union {
	unsigned int     val;
	NX51_URTX1_BIT_T bf;
} NX51_URTX1_T;

/* --------------------------------------------------------------------- */
/* Register sysch_data */
/* => Shared in xPEC trigger_sample mode with adr_trigger_sample_config (r mode). */
/*    Shared in xPEC fmmusm mode with fmmu_read_bit_mask (r mode). */
/*    Shared in xPEC intlogic mode with mii_clk_phase (r mode). */
/*    11 -  9 : xmac1_tpu_clk_phase # clock phase of xmac1 TPU */
/*     8 -  6 : xmac1_rpu_clk_phase # clock phase of xmac1 RPU */
/*     5 -  3 : xmac0_tpu_clk_phase # clock phase of xmac0 TPU */
/*     2 -  0 : xmac0_rpu_clk_phase # clock phase of xmac0 RPU */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sysch_data        0x000000F8U
#define Adr_NX51_rpec0_regs_sysch_data 0x1018B0F8U
#define Adr_NX51_tpec0_regs_sysch_data 0x1018B1F8U
#define Adr_NX51_rpec1_regs_sysch_data 0x1018B2F8U
#define Adr_NX51_tpec1_regs_sysch_data 0x1018B3F8U

/* --------------------------------------------------------------------- */
/* Register sysch_addr */
/* => Shared in xPEC trigger_sample mode with adr_trigger_sample_status (r mode). */
/*    Shared in xPEC fmmusm mode with fmmu_write_bit_mask (r mode). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sysch_addr        0x000000FCU
#define Adr_NX51_rpec0_regs_sysch_addr 0x1018B0FCU
#define Adr_NX51_tpec0_regs_sysch_addr 0x1018B1FCU
#define Adr_NX51_rpec1_regs_sysch_addr 0x1018B2FCU
#define Adr_NX51_tpec1_regs_sysch_addr 0x1018B3FCU


/* ===================================================================== */

/* AREA xmac */
/* Area of xmac0_regs, xmac1_regs */

/* ===================================================================== */

#define Addr_NX51_xmac0_regs 0x1018B400U
#define NX51_NETX_XM0_BASE   0x1018B400U
#define Addr_NX51_xmac1_regs 0x1018B600U
#define NX51_NETX_XM1_BASE   0x1018B600U

/* --------------------------------------------------------------------- */
/* Register xmac_sr0 */
/* => Shared Work Register 0 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr0        0x00000000U
#define Adr_NX51_xmac0_regs_xmac_sr0 0x1018B400U
#define Adr_NX51_xmac1_regs_xmac_sr0 0x1018B600U
#define DFLT_VAL_NX51_xmac_sr0       0x00000000U

#define MSK_NX51_xmac_sr0_sr0         0x0000ffffU
#define SRT_NX51_xmac_sr0_sr0         0
#define DFLT_VAL_NX51_xmac_sr0_sr0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr0_sr0 0x00000000U

/* all used bits of 'NX51_xmac_sr0': */
#define MSK_USED_BITS_NX51_xmac_sr0 0x0000ffffU

enum {
	BFW_NX51_xmac_sr0_sr0       = 16, /* [15:0] */
	BFW_NX51_xmac_sr0_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR0_BIT_Ttag {
	unsigned int sr0       : BFW_NX51_xmac_sr0_sr0;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr0_reserved1; /* reserved        */
} NX51_XMAC_SR0_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR0_BIT_T bf;
} NX51_XMAC_SR0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr1 */
/* => Shared Work Register 1 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr1        0x00000004U
#define Adr_NX51_xmac0_regs_xmac_sr1 0x1018B404U
#define Adr_NX51_xmac1_regs_xmac_sr1 0x1018B604U
#define DFLT_VAL_NX51_xmac_sr1       0x00000000U

#define MSK_NX51_xmac_sr1_sr1         0x0000ffffU
#define SRT_NX51_xmac_sr1_sr1         0
#define DFLT_VAL_NX51_xmac_sr1_sr1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr1_sr1 0x00000000U

/* all used bits of 'NX51_xmac_sr1': */
#define MSK_USED_BITS_NX51_xmac_sr1 0x0000ffffU

enum {
	BFW_NX51_xmac_sr1_sr1       = 16, /* [15:0] */
	BFW_NX51_xmac_sr1_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR1_BIT_Ttag {
	unsigned int sr1       : BFW_NX51_xmac_sr1_sr1;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr1_reserved1; /* reserved        */
} NX51_XMAC_SR1_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR1_BIT_T bf;
} NX51_XMAC_SR1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr2 */
/* => Shared Work Register 2 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr2        0x00000008U
#define Adr_NX51_xmac0_regs_xmac_sr2 0x1018B408U
#define Adr_NX51_xmac1_regs_xmac_sr2 0x1018B608U
#define DFLT_VAL_NX51_xmac_sr2       0x00000000U

#define MSK_NX51_xmac_sr2_sr2         0x0000ffffU
#define SRT_NX51_xmac_sr2_sr2         0
#define DFLT_VAL_NX51_xmac_sr2_sr2    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr2_sr2 0x00000000U

/* all used bits of 'NX51_xmac_sr2': */
#define MSK_USED_BITS_NX51_xmac_sr2 0x0000ffffU

enum {
	BFW_NX51_xmac_sr2_sr2       = 16, /* [15:0] */
	BFW_NX51_xmac_sr2_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR2_BIT_Ttag {
	unsigned int sr2       : BFW_NX51_xmac_sr2_sr2;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr2_reserved1; /* reserved        */
} NX51_XMAC_SR2_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR2_BIT_T bf;
} NX51_XMAC_SR2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr3 */
/* => Shared Work Register 3 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr3        0x0000000CU
#define Adr_NX51_xmac0_regs_xmac_sr3 0x1018B40CU
#define Adr_NX51_xmac1_regs_xmac_sr3 0x1018B60CU
#define DFLT_VAL_NX51_xmac_sr3       0x00000000U

#define MSK_NX51_xmac_sr3_sr3         0x0000ffffU
#define SRT_NX51_xmac_sr3_sr3         0
#define DFLT_VAL_NX51_xmac_sr3_sr3    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr3_sr3 0x00000000U

/* all used bits of 'NX51_xmac_sr3': */
#define MSK_USED_BITS_NX51_xmac_sr3 0x0000ffffU

enum {
	BFW_NX51_xmac_sr3_sr3       = 16, /* [15:0] */
	BFW_NX51_xmac_sr3_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR3_BIT_Ttag {
	unsigned int sr3       : BFW_NX51_xmac_sr3_sr3;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr3_reserved1; /* reserved        */
} NX51_XMAC_SR3_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR3_BIT_T bf;
} NX51_XMAC_SR3_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr4 */
/* => Shared Work Register 4 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr4        0x00000010U
#define Adr_NX51_xmac0_regs_xmac_sr4 0x1018B410U
#define Adr_NX51_xmac1_regs_xmac_sr4 0x1018B610U
#define DFLT_VAL_NX51_xmac_sr4       0x00000000U

#define MSK_NX51_xmac_sr4_sr4         0x0000ffffU
#define SRT_NX51_xmac_sr4_sr4         0
#define DFLT_VAL_NX51_xmac_sr4_sr4    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr4_sr4 0x00000000U

/* all used bits of 'NX51_xmac_sr4': */
#define MSK_USED_BITS_NX51_xmac_sr4 0x0000ffffU

enum {
	BFW_NX51_xmac_sr4_sr4       = 16, /* [15:0] */
	BFW_NX51_xmac_sr4_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR4_BIT_Ttag {
	unsigned int sr4       : BFW_NX51_xmac_sr4_sr4;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr4_reserved1; /* reserved        */
} NX51_XMAC_SR4_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR4_BIT_T bf;
} NX51_XMAC_SR4_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr5 */
/* => Shared Work Register 5 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr5        0x00000014U
#define Adr_NX51_xmac0_regs_xmac_sr5 0x1018B414U
#define Adr_NX51_xmac1_regs_xmac_sr5 0x1018B614U
#define DFLT_VAL_NX51_xmac_sr5       0x00000000U

#define MSK_NX51_xmac_sr5_sr5         0x0000ffffU
#define SRT_NX51_xmac_sr5_sr5         0
#define DFLT_VAL_NX51_xmac_sr5_sr5    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr5_sr5 0x00000000U

/* all used bits of 'NX51_xmac_sr5': */
#define MSK_USED_BITS_NX51_xmac_sr5 0x0000ffffU

enum {
	BFW_NX51_xmac_sr5_sr5       = 16, /* [15:0] */
	BFW_NX51_xmac_sr5_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR5_BIT_Ttag {
	unsigned int sr5       : BFW_NX51_xmac_sr5_sr5;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr5_reserved1; /* reserved        */
} NX51_XMAC_SR5_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR5_BIT_T bf;
} NX51_XMAC_SR5_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr6 */
/* => Shared Work Register 6 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr6        0x00000018U
#define Adr_NX51_xmac0_regs_xmac_sr6 0x1018B418U
#define Adr_NX51_xmac1_regs_xmac_sr6 0x1018B618U
#define DFLT_VAL_NX51_xmac_sr6       0x00000000U

#define MSK_NX51_xmac_sr6_sr6         0x0000ffffU
#define SRT_NX51_xmac_sr6_sr6         0
#define DFLT_VAL_NX51_xmac_sr6_sr6    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr6_sr6 0x00000000U

/* all used bits of 'NX51_xmac_sr6': */
#define MSK_USED_BITS_NX51_xmac_sr6 0x0000ffffU

enum {
	BFW_NX51_xmac_sr6_sr6       = 16, /* [15:0] */
	BFW_NX51_xmac_sr6_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR6_BIT_Ttag {
	unsigned int sr6       : BFW_NX51_xmac_sr6_sr6;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr6_reserved1; /* reserved        */
} NX51_XMAC_SR6_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR6_BIT_T bf;
} NX51_XMAC_SR6_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr7 */
/* => Shared Work Register 7 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr7        0x0000001CU
#define Adr_NX51_xmac0_regs_xmac_sr7 0x1018B41CU
#define Adr_NX51_xmac1_regs_xmac_sr7 0x1018B61CU
#define DFLT_VAL_NX51_xmac_sr7       0x00000000U

#define MSK_NX51_xmac_sr7_sr7         0x0000ffffU
#define SRT_NX51_xmac_sr7_sr7         0
#define DFLT_VAL_NX51_xmac_sr7_sr7    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr7_sr7 0x00000000U

/* all used bits of 'NX51_xmac_sr7': */
#define MSK_USED_BITS_NX51_xmac_sr7 0x0000ffffU

enum {
	BFW_NX51_xmac_sr7_sr7       = 16, /* [15:0] */
	BFW_NX51_xmac_sr7_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR7_BIT_Ttag {
	unsigned int sr7       : BFW_NX51_xmac_sr7_sr7;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr7_reserved1; /* reserved        */
} NX51_XMAC_SR7_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR7_BIT_T bf;
} NX51_XMAC_SR7_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr8 */
/* => Shared Work Register 8 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr8        0x00000020U
#define Adr_NX51_xmac0_regs_xmac_sr8 0x1018B420U
#define Adr_NX51_xmac1_regs_xmac_sr8 0x1018B620U
#define DFLT_VAL_NX51_xmac_sr8       0x00000000U

#define MSK_NX51_xmac_sr8_sr8         0x0000ffffU
#define SRT_NX51_xmac_sr8_sr8         0
#define DFLT_VAL_NX51_xmac_sr8_sr8    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr8_sr8 0x00000000U

/* all used bits of 'NX51_xmac_sr8': */
#define MSK_USED_BITS_NX51_xmac_sr8 0x0000ffffU

enum {
	BFW_NX51_xmac_sr8_sr8       = 16, /* [15:0] */
	BFW_NX51_xmac_sr8_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR8_BIT_Ttag {
	unsigned int sr8       : BFW_NX51_xmac_sr8_sr8;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr8_reserved1; /* reserved        */
} NX51_XMAC_SR8_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR8_BIT_T bf;
} NX51_XMAC_SR8_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr9 */
/* => Shared Work Register 9 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr9        0x00000024U
#define Adr_NX51_xmac0_regs_xmac_sr9 0x1018B424U
#define Adr_NX51_xmac1_regs_xmac_sr9 0x1018B624U
#define DFLT_VAL_NX51_xmac_sr9       0x00000000U

#define MSK_NX51_xmac_sr9_sr9         0x0000ffffU
#define SRT_NX51_xmac_sr9_sr9         0
#define DFLT_VAL_NX51_xmac_sr9_sr9    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr9_sr9 0x00000000U

/* all used bits of 'NX51_xmac_sr9': */
#define MSK_USED_BITS_NX51_xmac_sr9 0x0000ffffU

enum {
	BFW_NX51_xmac_sr9_sr9       = 16, /* [15:0] */
	BFW_NX51_xmac_sr9_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR9_BIT_Ttag {
	unsigned int sr9       : BFW_NX51_xmac_sr9_sr9;       /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr9_reserved1; /* reserved        */
} NX51_XMAC_SR9_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_SR9_BIT_T bf;
} NX51_XMAC_SR9_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr10 */
/* => Shared Work Register 10 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr10        0x00000028U
#define Adr_NX51_xmac0_regs_xmac_sr10 0x1018B428U
#define Adr_NX51_xmac1_regs_xmac_sr10 0x1018B628U
#define DFLT_VAL_NX51_xmac_sr10       0x00000000U

#define MSK_NX51_xmac_sr10_sr10         0x0000ffffU
#define SRT_NX51_xmac_sr10_sr10         0
#define DFLT_VAL_NX51_xmac_sr10_sr10    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr10_sr10 0x00000000U

/* all used bits of 'NX51_xmac_sr10': */
#define MSK_USED_BITS_NX51_xmac_sr10 0x0000ffffU

enum {
	BFW_NX51_xmac_sr10_sr10      = 16, /* [15:0] */
	BFW_NX51_xmac_sr10_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR10_BIT_Ttag {
	unsigned int sr10      : BFW_NX51_xmac_sr10_sr10;      /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr10_reserved1; /* reserved        */
} NX51_XMAC_SR10_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XMAC_SR10_BIT_T bf;
} NX51_XMAC_SR10_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr11 */
/* => Shared Work Register 11 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr11        0x0000002CU
#define Adr_NX51_xmac0_regs_xmac_sr11 0x1018B42CU
#define Adr_NX51_xmac1_regs_xmac_sr11 0x1018B62CU
#define DFLT_VAL_NX51_xmac_sr11       0x00000000U

#define MSK_NX51_xmac_sr11_sr11         0x0000ffffU
#define SRT_NX51_xmac_sr11_sr11         0
#define DFLT_VAL_NX51_xmac_sr11_sr11    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr11_sr11 0x00000000U

/* all used bits of 'NX51_xmac_sr11': */
#define MSK_USED_BITS_NX51_xmac_sr11 0x0000ffffU

enum {
	BFW_NX51_xmac_sr11_sr11      = 16, /* [15:0] */
	BFW_NX51_xmac_sr11_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR11_BIT_Ttag {
	unsigned int sr11      : BFW_NX51_xmac_sr11_sr11;      /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr11_reserved1; /* reserved        */
} NX51_XMAC_SR11_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XMAC_SR11_BIT_T bf;
} NX51_XMAC_SR11_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr12 */
/* => Shared Work Register 12 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr12        0x00000030U
#define Adr_NX51_xmac0_regs_xmac_sr12 0x1018B430U
#define Adr_NX51_xmac1_regs_xmac_sr12 0x1018B630U
#define DFLT_VAL_NX51_xmac_sr12       0x00000000U

#define MSK_NX51_xmac_sr12_sr12         0x0000ffffU
#define SRT_NX51_xmac_sr12_sr12         0
#define DFLT_VAL_NX51_xmac_sr12_sr12    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr12_sr12 0x00000000U

/* all used bits of 'NX51_xmac_sr12': */
#define MSK_USED_BITS_NX51_xmac_sr12 0x0000ffffU

enum {
	BFW_NX51_xmac_sr12_sr12      = 16, /* [15:0] */
	BFW_NX51_xmac_sr12_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR12_BIT_Ttag {
	unsigned int sr12      : BFW_NX51_xmac_sr12_sr12;      /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr12_reserved1; /* reserved        */
} NX51_XMAC_SR12_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XMAC_SR12_BIT_T bf;
} NX51_XMAC_SR12_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr13 */
/* => Shared Work Register 13 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr13        0x00000034U
#define Adr_NX51_xmac0_regs_xmac_sr13 0x1018B434U
#define Adr_NX51_xmac1_regs_xmac_sr13 0x1018B634U
#define DFLT_VAL_NX51_xmac_sr13       0x00000000U

#define MSK_NX51_xmac_sr13_sr13         0x0000ffffU
#define SRT_NX51_xmac_sr13_sr13         0
#define DFLT_VAL_NX51_xmac_sr13_sr13    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr13_sr13 0x00000000U

/* all used bits of 'NX51_xmac_sr13': */
#define MSK_USED_BITS_NX51_xmac_sr13 0x0000ffffU

enum {
	BFW_NX51_xmac_sr13_sr13      = 16, /* [15:0] */
	BFW_NX51_xmac_sr13_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR13_BIT_Ttag {
	unsigned int sr13      : BFW_NX51_xmac_sr13_sr13;      /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr13_reserved1; /* reserved        */
} NX51_XMAC_SR13_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XMAC_SR13_BIT_T bf;
} NX51_XMAC_SR13_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr14 */
/* => Shared Work Register 14 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr14        0x00000038U
#define Adr_NX51_xmac0_regs_xmac_sr14 0x1018B438U
#define Adr_NX51_xmac1_regs_xmac_sr14 0x1018B638U
#define DFLT_VAL_NX51_xmac_sr14       0x00000000U

#define MSK_NX51_xmac_sr14_sr14         0x0000ffffU
#define SRT_NX51_xmac_sr14_sr14         0
#define DFLT_VAL_NX51_xmac_sr14_sr14    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr14_sr14 0x00000000U

/* all used bits of 'NX51_xmac_sr14': */
#define MSK_USED_BITS_NX51_xmac_sr14 0x0000ffffU

enum {
	BFW_NX51_xmac_sr14_sr14      = 16, /* [15:0] */
	BFW_NX51_xmac_sr14_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR14_BIT_Ttag {
	unsigned int sr14      : BFW_NX51_xmac_sr14_sr14;      /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr14_reserved1; /* reserved        */
} NX51_XMAC_SR14_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XMAC_SR14_BIT_T bf;
} NX51_XMAC_SR14_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sr15 */
/* => Shared Work Register 15 accessible by all xMACs and xPECs */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sr15        0x0000003CU
#define Adr_NX51_xmac0_regs_xmac_sr15 0x1018B43CU
#define Adr_NX51_xmac1_regs_xmac_sr15 0x1018B63CU
#define DFLT_VAL_NX51_xmac_sr15       0x00000000U

#define MSK_NX51_xmac_sr15_sr15         0x0000ffffU
#define SRT_NX51_xmac_sr15_sr15         0
#define DFLT_VAL_NX51_xmac_sr15_sr15    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sr15_sr15 0x00000000U

/* all used bits of 'NX51_xmac_sr15': */
#define MSK_USED_BITS_NX51_xmac_sr15 0x0000ffffU

enum {
	BFW_NX51_xmac_sr15_sr15      = 16, /* [15:0] */
	BFW_NX51_xmac_sr15_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SR15_BIT_Ttag {
	unsigned int sr15      : BFW_NX51_xmac_sr15_sr15;      /* Shared Register */
	unsigned int reserved1 : BFW_NX51_xmac_sr15_reserved1; /* reserved        */
} NX51_XMAC_SR15_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XMAC_SR15_BIT_T bf;
} NX51_XMAC_SR15_T;

/* --------------------------------------------------------------------- */
/* Register xmac_status_shared0 */
/* => xMAC0 Shared Status Register: */
/*    This register is read-only except bits rx_ovf, tx_ufl and eld_bad_link which can be written with 1 to reset the appropriate FIFO/function. */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_status_shared0        0x00000040U
#define Adr_NX51_xmac0_regs_xmac_status_shared0 0x1018B440U
#define Adr_NX51_xmac1_regs_xmac_status_shared0 0x1018B640U
#define DFLT_VAL_NX51_xmac_status_shared0       0x00000000U

#define MSK_NX51_xmac_status_shared0_gpio0_in                  0x00000001U
#define SRT_NX51_xmac_status_shared0_gpio0_in                  0
#define DFLT_VAL_NX51_xmac_status_shared0_gpio0_in             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_gpio0_in          0x00000000U
#define MSK_NX51_xmac_status_shared0_gpio1_in                  0x00000002U
#define SRT_NX51_xmac_status_shared0_gpio1_in                  1
#define DFLT_VAL_NX51_xmac_status_shared0_gpio1_in             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_gpio1_in          0x00000000U
#define MSK_NX51_xmac_status_shared0_gpio2_in_phy_led0         0x00000004U
#define SRT_NX51_xmac_status_shared0_gpio2_in_phy_led0         2
#define DFLT_VAL_NX51_xmac_status_shared0_gpio2_in_phy_led0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_gpio2_in_phy_led0 0x00000000U
#define MSK_NX51_xmac_status_shared0_gpio3_in_phy_led1         0x00000008U
#define SRT_NX51_xmac_status_shared0_gpio3_in_phy_led1         3
#define DFLT_VAL_NX51_xmac_status_shared0_gpio3_in_phy_led1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_gpio3_in_phy_led1 0x00000000U
#define MSK_NX51_xmac_status_shared0_gpio4_in_phy_led2         0x00000010U
#define SRT_NX51_xmac_status_shared0_gpio4_in_phy_led2         4
#define DFLT_VAL_NX51_xmac_status_shared0_gpio4_in_phy_led2    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_gpio4_in_phy_led2 0x00000000U
#define MSK_NX51_xmac_status_shared0_gpio5_in_phy_led3         0x00000020U
#define SRT_NX51_xmac_status_shared0_gpio5_in_phy_led3         5
#define DFLT_VAL_NX51_xmac_status_shared0_gpio5_in_phy_led3    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_gpio5_in_phy_led3 0x00000000U
#define MSK_NX51_xmac_status_shared0_brec                      0x00000040U
#define SRT_NX51_xmac_status_shared0_brec                      6
#define DFLT_VAL_NX51_xmac_status_shared0_brec                 0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_brec              0x00000000U
#define MSK_NX51_xmac_status_shared0_btran                     0x00000080U
#define SRT_NX51_xmac_status_shared0_btran                     7
#define DFLT_VAL_NX51_xmac_status_shared0_btran                0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_btran             0x00000000U
#define MSK_NX51_xmac_status_shared0_stat_rpu                  0x00000100U
#define SRT_NX51_xmac_status_shared0_stat_rpu                  8
#define DFLT_VAL_NX51_xmac_status_shared0_stat_rpu             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_stat_rpu          0x00000000U
#define MSK_NX51_xmac_status_shared0_stat_tpu                  0x00000200U
#define SRT_NX51_xmac_status_shared0_stat_tpu                  9
#define DFLT_VAL_NX51_xmac_status_shared0_stat_tpu             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_stat_tpu          0x00000000U
#define MSK_NX51_xmac_status_shared0_rx_rdy                    0x00000400U
#define SRT_NX51_xmac_status_shared0_rx_rdy                    10
#define DFLT_VAL_NX51_xmac_status_shared0_rx_rdy               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_rx_rdy            0x00000000U
#define MSK_NX51_xmac_status_shared0_rx_ovf                    0x00000800U
#define SRT_NX51_xmac_status_shared0_rx_ovf                    11
#define DFLT_VAL_NX51_xmac_status_shared0_rx_ovf               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_rx_ovf            0x00000000U
#define MSK_NX51_xmac_status_shared0_tx_nxt                    0x00001000U
#define SRT_NX51_xmac_status_shared0_tx_nxt                    12
#define DFLT_VAL_NX51_xmac_status_shared0_tx_nxt               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_tx_nxt            0x00000000U
#define MSK_NX51_xmac_status_shared0_tx_ufl                    0x00002000U
#define SRT_NX51_xmac_status_shared0_tx_ufl                    13
#define DFLT_VAL_NX51_xmac_status_shared0_tx_ufl               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_tx_ufl            0x00000000U
#define MSK_NX51_xmac_status_shared0_utx_empty                 0x00004000U
#define SRT_NX51_xmac_status_shared0_utx_empty                 14
#define DFLT_VAL_NX51_xmac_status_shared0_utx_empty            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_utx_empty         0x00000000U
#define MSK_NX51_xmac_status_shared0_eld_bad_link              0x00008000U
#define SRT_NX51_xmac_status_shared0_eld_bad_link              15
#define DFLT_VAL_NX51_xmac_status_shared0_eld_bad_link         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared0_eld_bad_link      0x00000000U

/* all used bits of 'NX51_xmac_status_shared0': */
#define MSK_USED_BITS_NX51_xmac_status_shared0 0x0000ffffU

enum {
	BFW_NX51_xmac_status_shared0_gpio0_in          = 1,  /* [0] */
	BFW_NX51_xmac_status_shared0_gpio1_in          = 1,  /* [1] */
	BFW_NX51_xmac_status_shared0_gpio2_in_phy_led0 = 1,  /* [2] */
	BFW_NX51_xmac_status_shared0_gpio3_in_phy_led1 = 1,  /* [3] */
	BFW_NX51_xmac_status_shared0_gpio4_in_phy_led2 = 1,  /* [4] */
	BFW_NX51_xmac_status_shared0_gpio5_in_phy_led3 = 1,  /* [5] */
	BFW_NX51_xmac_status_shared0_brec              = 1,  /* [6] */
	BFW_NX51_xmac_status_shared0_btran             = 1,  /* [7] */
	BFW_NX51_xmac_status_shared0_stat_rpu          = 1,  /* [8] */
	BFW_NX51_xmac_status_shared0_stat_tpu          = 1,  /* [9] */
	BFW_NX51_xmac_status_shared0_rx_rdy            = 1,  /* [10] */
	BFW_NX51_xmac_status_shared0_rx_ovf            = 1,  /* [11] */
	BFW_NX51_xmac_status_shared0_tx_nxt            = 1,  /* [12] */
	BFW_NX51_xmac_status_shared0_tx_ufl            = 1,  /* [13] */
	BFW_NX51_xmac_status_shared0_utx_empty         = 1,  /* [14] */
	BFW_NX51_xmac_status_shared0_eld_bad_link      = 1,  /* [15] */
	BFW_NX51_xmac_status_shared0_reserved1         = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STATUS_SHARED0_BIT_Ttag {
	unsigned int gpio0_in          : BFW_NX51_xmac_status_shared0_gpio0_in;          /* value at external gpio pin                                                                                        */
	unsigned int gpio1_in          : BFW_NX51_xmac_status_shared0_gpio1_in;          /* value at external gpio pin                                                                                        */
	unsigned int gpio2_in_phy_led0 : BFW_NX51_xmac_status_shared0_gpio2_in_phy_led0; /* IF phy_led_en:                                                                                                    */
	                                                                                 /* 1: Internal Phy0 LED0, usually link_status                                                                        */
	                                                                                 /* 0: gpio2_in # value at external gpio pin                                                                          */
	unsigned int gpio3_in_phy_led1 : BFW_NX51_xmac_status_shared0_gpio3_in_phy_led1; /* IF phy_led_en:                                                                                                    */
	                                                                                 /* 1: Internal Phy0 LED1, usually activity                                                                           */
	                                                                                 /* 0: gpio3_in # value at external gpio pin                                                                          */
	unsigned int gpio4_in_phy_led2 : BFW_NX51_xmac_status_shared0_gpio4_in_phy_led2; /* IF phy_led_en:                                                                                                    */
	                                                                                 /* 1: Internal Phy0 LED2, usually speed100                                                                           */
	                                                                                 /* 0: gpio4_in # value at external gpio pin                                                                          */
	unsigned int gpio5_in_phy_led3 : BFW_NX51_xmac_status_shared0_gpio5_in_phy_led3; /* IF phy_led_en:                                                                                                    */
	                                                                                 /* 1: Internal Phy0 LED3, usually full_duplex                                                                        */
	                                                                                 /* 0: gpio5_in # value at external gpio pin                                                                          */
	unsigned int brec              : BFW_NX51_xmac_status_shared0_brec;              /* bit_received (active for 1 cc)                                                                                    */
	unsigned int btran             : BFW_NX51_xmac_status_shared0_btran;             /* bit_transmitted (active for 1 cc)                                                                                 */
	unsigned int stat_rpu          : BFW_NX51_xmac_status_shared0_stat_rpu;          /* General RPU status bits, set and reset by RPU command bits.                                                       */
	unsigned int stat_tpu          : BFW_NX51_xmac_status_shared0_stat_tpu;          /* General TPU status bits, set and reset by TPU command bits.                                                       */
	unsigned int rx_rdy            : BFW_NX51_xmac_status_shared0_rx_rdy;            /* Received bytes are valid at output of URX_FIFO.                                                                   */
	unsigned int rx_ovf            : BFW_NX51_xmac_status_shared0_rx_ovf;            /* Receive overflow (too much data in URX_FIFO).                                                                     */
	                                                                                 /* To reset this bit, reset xMAC0-URX_FIFO by writing 1 to this bit (xMAC only, not via xpec_statcfg).               */
	unsigned int tx_nxt            : BFW_NX51_xmac_status_shared0_tx_nxt;            /* Put next tx_word to UTX_FIFO: at least one entry of UTX_FIFO is empty.                                            */
	unsigned int tx_ufl            : BFW_NX51_xmac_status_shared0_tx_ufl;            /* Transmit underflow (not enough data in UTX_FIFO).                                                                 */
	                                                                                 /* To reset this bit, reset xMAC0-UTX_FIFO by writing 1 to this bit (xMAC only, not via xpec_statcfg).               */
	unsigned int utx_empty         : BFW_NX51_xmac_status_shared0_utx_empty;         /* UTX_FIFO is empty                                                                                                 */
	unsigned int eld_bad_link      : BFW_NX51_xmac_status_shared0_eld_bad_link;      /* link_status from enhanced link detection unit.                                                                    */
	                                                                                 /* To reset this bit, reset Enhanced Link Detection Unit by writing 1 to this bit (xMAC only, not via xpec_statcfg). */
	unsigned int reserved1         : BFW_NX51_xmac_status_shared0_reserved1;         /* reserved                                                                                                          */
} NX51_XMAC_STATUS_SHARED0_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_XMAC_STATUS_SHARED0_BIT_T bf;
} NX51_XMAC_STATUS_SHARED0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_shared0 */
/* => xMAC0 Shared Config Register: */
/*    Upper bits 15..8 are write mask and thus not readable. */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_shared0        0x00000044U
#define Adr_NX51_xmac0_regs_xmac_config_shared0 0x1018B444U
#define Adr_NX51_xmac1_regs_xmac_config_shared0 0x1018B644U
#define DFLT_VAL_NX51_xmac_config_shared0       0x00000000U

#define MSK_NX51_xmac_config_shared0_gpio0_out                0x00000001U
#define SRT_NX51_xmac_config_shared0_gpio0_out                0
#define DFLT_VAL_NX51_xmac_config_shared0_gpio0_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio0_out        0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio1_out                0x00000002U
#define SRT_NX51_xmac_config_shared0_gpio1_out                1
#define DFLT_VAL_NX51_xmac_config_shared0_gpio1_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio1_out        0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio2_out                0x00000004U
#define SRT_NX51_xmac_config_shared0_gpio2_out                2
#define DFLT_VAL_NX51_xmac_config_shared0_gpio2_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio2_out        0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio3_out                0x00000008U
#define SRT_NX51_xmac_config_shared0_gpio3_out                3
#define DFLT_VAL_NX51_xmac_config_shared0_gpio3_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio3_out        0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio4_out                0x00000010U
#define SRT_NX51_xmac_config_shared0_gpio4_out                4
#define DFLT_VAL_NX51_xmac_config_shared0_gpio4_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio4_out        0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio5_out                0x00000020U
#define SRT_NX51_xmac_config_shared0_gpio5_out                5
#define DFLT_VAL_NX51_xmac_config_shared0_gpio5_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio5_out        0x00000000U
#define MSK_NX51_xmac_config_shared0_reserved_stat            0x000000c0U
#define SRT_NX51_xmac_config_shared0_reserved_stat            6
#define DFLT_VAL_NX51_xmac_config_shared0_reserved_stat       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_reserved_stat    0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio0_out_wm             0x00000100U
#define SRT_NX51_xmac_config_shared0_gpio0_out_wm             8
#define DFLT_VAL_NX51_xmac_config_shared0_gpio0_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio0_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio1_out_wm             0x00000200U
#define SRT_NX51_xmac_config_shared0_gpio1_out_wm             9
#define DFLT_VAL_NX51_xmac_config_shared0_gpio1_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio1_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio2_out_wm             0x00000400U
#define SRT_NX51_xmac_config_shared0_gpio2_out_wm             10
#define DFLT_VAL_NX51_xmac_config_shared0_gpio2_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio2_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio3_out_wm             0x00000800U
#define SRT_NX51_xmac_config_shared0_gpio3_out_wm             11
#define DFLT_VAL_NX51_xmac_config_shared0_gpio3_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio3_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio4_out_wm             0x00001000U
#define SRT_NX51_xmac_config_shared0_gpio4_out_wm             12
#define DFLT_VAL_NX51_xmac_config_shared0_gpio4_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio4_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared0_gpio5_out_wm             0x00002000U
#define SRT_NX51_xmac_config_shared0_gpio5_out_wm             13
#define DFLT_VAL_NX51_xmac_config_shared0_gpio5_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_gpio5_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared0_reserved_stat_wm         0x0000c000U
#define SRT_NX51_xmac_config_shared0_reserved_stat_wm         14
#define DFLT_VAL_NX51_xmac_config_shared0_reserved_stat_wm    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared0_reserved_stat_wm 0x00000000U

/* all used bits of 'NX51_xmac_config_shared0': */
#define MSK_USED_BITS_NX51_xmac_config_shared0 0x0000ffffU

enum {
	BFW_NX51_xmac_config_shared0_gpio0_out        = 1,  /* [0] */
	BFW_NX51_xmac_config_shared0_gpio1_out        = 1,  /* [1] */
	BFW_NX51_xmac_config_shared0_gpio2_out        = 1,  /* [2] */
	BFW_NX51_xmac_config_shared0_gpio3_out        = 1,  /* [3] */
	BFW_NX51_xmac_config_shared0_gpio4_out        = 1,  /* [4] */
	BFW_NX51_xmac_config_shared0_gpio5_out        = 1,  /* [5] */
	BFW_NX51_xmac_config_shared0_reserved_stat    = 2,  /* [7:6] */
	BFW_NX51_xmac_config_shared0_gpio0_out_wm     = 1,  /* [8] */
	BFW_NX51_xmac_config_shared0_gpio1_out_wm     = 1,  /* [9] */
	BFW_NX51_xmac_config_shared0_gpio2_out_wm     = 1,  /* [10] */
	BFW_NX51_xmac_config_shared0_gpio3_out_wm     = 1,  /* [11] */
	BFW_NX51_xmac_config_shared0_gpio4_out_wm     = 1,  /* [12] */
	BFW_NX51_xmac_config_shared0_gpio5_out_wm     = 1,  /* [13] */
	BFW_NX51_xmac_config_shared0_reserved_stat_wm = 2,  /* [15:14] */
	BFW_NX51_xmac_config_shared0_reserved1        = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CONFIG_SHARED0_BIT_Ttag {
	unsigned int gpio0_out        : BFW_NX51_xmac_config_shared0_gpio0_out;        /* General Purpose IO 0 output                */
	unsigned int gpio1_out        : BFW_NX51_xmac_config_shared0_gpio1_out;        /* General Purpose IO 1 output                */
	unsigned int gpio2_out        : BFW_NX51_xmac_config_shared0_gpio2_out;        /* General Purpose IO 2 output                */
	unsigned int gpio3_out        : BFW_NX51_xmac_config_shared0_gpio3_out;        /* General Purpose IO 3 output                */
	unsigned int gpio4_out        : BFW_NX51_xmac_config_shared0_gpio4_out;        /* General Purpose IO 4 output                */
	unsigned int gpio5_out        : BFW_NX51_xmac_config_shared0_gpio5_out;        /* General Purpose IO 5 output                */
	unsigned int reserved_stat    : BFW_NX51_xmac_config_shared0_reserved_stat;    /* Reserved Status Bits                       */
	unsigned int gpio0_out_wm     : BFW_NX51_xmac_config_shared0_gpio0_out_wm;     /* Write mask for General Purpose IO 0 output */
	unsigned int gpio1_out_wm     : BFW_NX51_xmac_config_shared0_gpio1_out_wm;     /* Write mask for General Purpose IO 1 output */
	unsigned int gpio2_out_wm     : BFW_NX51_xmac_config_shared0_gpio2_out_wm;     /* Write mask for General Purpose IO 2 output */
	unsigned int gpio3_out_wm     : BFW_NX51_xmac_config_shared0_gpio3_out_wm;     /* Write mask for General Purpose IO 3 output */
	unsigned int gpio4_out_wm     : BFW_NX51_xmac_config_shared0_gpio4_out_wm;     /* Write mask for General Purpose IO 4 output */
	unsigned int gpio5_out_wm     : BFW_NX51_xmac_config_shared0_gpio5_out_wm;     /* Write mask for General Purpose IO 5 output */
	unsigned int reserved_stat_wm : BFW_NX51_xmac_config_shared0_reserved_stat_wm; /* Write mask for Reserved Status Bits        */
	unsigned int reserved1        : BFW_NX51_xmac_config_shared0_reserved1;        /* reserved                                   */
} NX51_XMAC_CONFIG_SHARED0_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_XMAC_CONFIG_SHARED0_BIT_T bf;
} NX51_XMAC_CONFIG_SHARED0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_io_oe_shared0 */
/* => xMAC0 Shared GPIO Output Enable Register: */
/*    Upper bits 15..8 are write mask and thus not readable. */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_io_oe_shared0        0x00000048U
#define Adr_NX51_xmac0_regs_xmac_io_oe_shared0 0x1018B448U
#define Adr_NX51_xmac1_regs_xmac_io_oe_shared0 0x1018B648U
#define DFLT_VAL_NX51_xmac_io_oe_shared0       0x00000000U

#define MSK_NX51_xmac_io_oe_shared0_gpio0_oe                 0x00000001U
#define SRT_NX51_xmac_io_oe_shared0_gpio0_oe                 0
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio0_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio0_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio1_oe                 0x00000002U
#define SRT_NX51_xmac_io_oe_shared0_gpio1_oe                 1
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio1_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio1_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio2_oe                 0x00000004U
#define SRT_NX51_xmac_io_oe_shared0_gpio2_oe                 2
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio2_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio2_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio3_oe                 0x00000008U
#define SRT_NX51_xmac_io_oe_shared0_gpio3_oe                 3
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio3_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio3_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio4_oe                 0x00000010U
#define SRT_NX51_xmac_io_oe_shared0_gpio4_oe                 4
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio4_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio4_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio5_oe                 0x00000020U
#define SRT_NX51_xmac_io_oe_shared0_gpio5_oe                 5
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio5_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio5_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_reserved_stat            0x000000c0U
#define SRT_NX51_xmac_io_oe_shared0_reserved_stat            6
#define DFLT_VAL_NX51_xmac_io_oe_shared0_reserved_stat       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_reserved_stat    0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio0_oe_wm              0x00000100U
#define SRT_NX51_xmac_io_oe_shared0_gpio0_oe_wm              8
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio0_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio0_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio1_oe_wm              0x00000200U
#define SRT_NX51_xmac_io_oe_shared0_gpio1_oe_wm              9
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio1_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio1_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio2_oe_wm              0x00000400U
#define SRT_NX51_xmac_io_oe_shared0_gpio2_oe_wm              10
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio2_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio2_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio3_oe_wm              0x00000800U
#define SRT_NX51_xmac_io_oe_shared0_gpio3_oe_wm              11
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio3_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio3_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio4_oe_wm              0x00001000U
#define SRT_NX51_xmac_io_oe_shared0_gpio4_oe_wm              12
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio4_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio4_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_gpio5_oe_wm              0x00002000U
#define SRT_NX51_xmac_io_oe_shared0_gpio5_oe_wm              13
#define DFLT_VAL_NX51_xmac_io_oe_shared0_gpio5_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_gpio5_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared0_reserved_stat_wm         0x0000c000U
#define SRT_NX51_xmac_io_oe_shared0_reserved_stat_wm         14
#define DFLT_VAL_NX51_xmac_io_oe_shared0_reserved_stat_wm    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared0_reserved_stat_wm 0x00000000U

/* all used bits of 'NX51_xmac_io_oe_shared0': */
#define MSK_USED_BITS_NX51_xmac_io_oe_shared0 0x0000ffffU

enum {
	BFW_NX51_xmac_io_oe_shared0_gpio0_oe         = 1,  /* [0] */
	BFW_NX51_xmac_io_oe_shared0_gpio1_oe         = 1,  /* [1] */
	BFW_NX51_xmac_io_oe_shared0_gpio2_oe         = 1,  /* [2] */
	BFW_NX51_xmac_io_oe_shared0_gpio3_oe         = 1,  /* [3] */
	BFW_NX51_xmac_io_oe_shared0_gpio4_oe         = 1,  /* [4] */
	BFW_NX51_xmac_io_oe_shared0_gpio5_oe         = 1,  /* [5] */
	BFW_NX51_xmac_io_oe_shared0_reserved_stat    = 2,  /* [7:6] */
	BFW_NX51_xmac_io_oe_shared0_gpio0_oe_wm      = 1,  /* [8] */
	BFW_NX51_xmac_io_oe_shared0_gpio1_oe_wm      = 1,  /* [9] */
	BFW_NX51_xmac_io_oe_shared0_gpio2_oe_wm      = 1,  /* [10] */
	BFW_NX51_xmac_io_oe_shared0_gpio3_oe_wm      = 1,  /* [11] */
	BFW_NX51_xmac_io_oe_shared0_gpio4_oe_wm      = 1,  /* [12] */
	BFW_NX51_xmac_io_oe_shared0_gpio5_oe_wm      = 1,  /* [13] */
	BFW_NX51_xmac_io_oe_shared0_reserved_stat_wm = 2,  /* [15:14] */
	BFW_NX51_xmac_io_oe_shared0_reserved1        = 16  /* [31:16] */
};

typedef struct NX51_XMAC_IO_OE_SHARED0_BIT_Ttag {
	unsigned int gpio0_oe         : BFW_NX51_xmac_io_oe_shared0_gpio0_oe;         /* General Purpose IO 0 output enable                */
	unsigned int gpio1_oe         : BFW_NX51_xmac_io_oe_shared0_gpio1_oe;         /* General Purpose IO 1 output enable                */
	unsigned int gpio2_oe         : BFW_NX51_xmac_io_oe_shared0_gpio2_oe;         /* General Purpose IO 2 output enable                */
	unsigned int gpio3_oe         : BFW_NX51_xmac_io_oe_shared0_gpio3_oe;         /* General Purpose IO 3 output enable                */
	unsigned int gpio4_oe         : BFW_NX51_xmac_io_oe_shared0_gpio4_oe;         /* General Purpose IO 4 output enable                */
	unsigned int gpio5_oe         : BFW_NX51_xmac_io_oe_shared0_gpio5_oe;         /* General Purpose IO 5 output enable                */
	unsigned int reserved_stat    : BFW_NX51_xmac_io_oe_shared0_reserved_stat;    /* Reserved Status Bits                              */
	unsigned int gpio0_oe_wm      : BFW_NX51_xmac_io_oe_shared0_gpio0_oe_wm;      /* Write mask for General Purpose IO 0 output enable */
	unsigned int gpio1_oe_wm      : BFW_NX51_xmac_io_oe_shared0_gpio1_oe_wm;      /* Write mask for General Purpose IO 1 output enable */
	unsigned int gpio2_oe_wm      : BFW_NX51_xmac_io_oe_shared0_gpio2_oe_wm;      /* Write mask for General Purpose IO 2 output enable */
	unsigned int gpio3_oe_wm      : BFW_NX51_xmac_io_oe_shared0_gpio3_oe_wm;      /* Write mask for General Purpose IO 3 output enable */
	unsigned int gpio4_oe_wm      : BFW_NX51_xmac_io_oe_shared0_gpio4_oe_wm;      /* Write mask for General Purpose IO 4 output enable */
	unsigned int gpio5_oe_wm      : BFW_NX51_xmac_io_oe_shared0_gpio5_oe_wm;      /* Write mask for General Purpose IO 5 output enable */
	unsigned int reserved_stat_wm : BFW_NX51_xmac_io_oe_shared0_reserved_stat_wm; /* Write mask for Reserved Status Bits               */
	unsigned int reserved1        : BFW_NX51_xmac_io_oe_shared0_reserved1;        /* reserved                                          */
} NX51_XMAC_IO_OE_SHARED0_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XMAC_IO_OE_SHARED0_BIT_T bf;
} NX51_XMAC_IO_OE_SHARED0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_status_shared1 */
/* => xMAC1 Shared Status Register: */
/*    This register is read-only except bits rx_ovf, tx_ufl and eld_bad_link which can be written with 1 to reset the appropriate FIFO/function. */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_status_shared1        0x0000004CU
#define Adr_NX51_xmac0_regs_xmac_status_shared1 0x1018B44CU
#define Adr_NX51_xmac1_regs_xmac_status_shared1 0x1018B64CU
#define DFLT_VAL_NX51_xmac_status_shared1       0x00000000U

#define MSK_NX51_xmac_status_shared1_gpio0_in                  0x00000001U
#define SRT_NX51_xmac_status_shared1_gpio0_in                  0
#define DFLT_VAL_NX51_xmac_status_shared1_gpio0_in             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_gpio0_in          0x00000000U
#define MSK_NX51_xmac_status_shared1_gpio1_in                  0x00000002U
#define SRT_NX51_xmac_status_shared1_gpio1_in                  1
#define DFLT_VAL_NX51_xmac_status_shared1_gpio1_in             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_gpio1_in          0x00000000U
#define MSK_NX51_xmac_status_shared1_gpio2_in_phy_led0         0x00000004U
#define SRT_NX51_xmac_status_shared1_gpio2_in_phy_led0         2
#define DFLT_VAL_NX51_xmac_status_shared1_gpio2_in_phy_led0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_gpio2_in_phy_led0 0x00000000U
#define MSK_NX51_xmac_status_shared1_gpio3_in_phy_led1         0x00000008U
#define SRT_NX51_xmac_status_shared1_gpio3_in_phy_led1         3
#define DFLT_VAL_NX51_xmac_status_shared1_gpio3_in_phy_led1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_gpio3_in_phy_led1 0x00000000U
#define MSK_NX51_xmac_status_shared1_gpio4_in_phy_led2         0x00000010U
#define SRT_NX51_xmac_status_shared1_gpio4_in_phy_led2         4
#define DFLT_VAL_NX51_xmac_status_shared1_gpio4_in_phy_led2    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_gpio4_in_phy_led2 0x00000000U
#define MSK_NX51_xmac_status_shared1_gpio5_in_phy_led3         0x00000020U
#define SRT_NX51_xmac_status_shared1_gpio5_in_phy_led3         5
#define DFLT_VAL_NX51_xmac_status_shared1_gpio5_in_phy_led3    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_gpio5_in_phy_led3 0x00000000U
#define MSK_NX51_xmac_status_shared1_brec                      0x00000040U
#define SRT_NX51_xmac_status_shared1_brec                      6
#define DFLT_VAL_NX51_xmac_status_shared1_brec                 0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_brec              0x00000000U
#define MSK_NX51_xmac_status_shared1_btran                     0x00000080U
#define SRT_NX51_xmac_status_shared1_btran                     7
#define DFLT_VAL_NX51_xmac_status_shared1_btran                0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_btran             0x00000000U
#define MSK_NX51_xmac_status_shared1_stat_rpu                  0x00000100U
#define SRT_NX51_xmac_status_shared1_stat_rpu                  8
#define DFLT_VAL_NX51_xmac_status_shared1_stat_rpu             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_stat_rpu          0x00000000U
#define MSK_NX51_xmac_status_shared1_stat_tpu                  0x00000200U
#define SRT_NX51_xmac_status_shared1_stat_tpu                  9
#define DFLT_VAL_NX51_xmac_status_shared1_stat_tpu             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_stat_tpu          0x00000000U
#define MSK_NX51_xmac_status_shared1_rx_rdy                    0x00000400U
#define SRT_NX51_xmac_status_shared1_rx_rdy                    10
#define DFLT_VAL_NX51_xmac_status_shared1_rx_rdy               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_rx_rdy            0x00000000U
#define MSK_NX51_xmac_status_shared1_rx_ovf                    0x00000800U
#define SRT_NX51_xmac_status_shared1_rx_ovf                    11
#define DFLT_VAL_NX51_xmac_status_shared1_rx_ovf               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_rx_ovf            0x00000000U
#define MSK_NX51_xmac_status_shared1_tx_nxt                    0x00001000U
#define SRT_NX51_xmac_status_shared1_tx_nxt                    12
#define DFLT_VAL_NX51_xmac_status_shared1_tx_nxt               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_tx_nxt            0x00000000U
#define MSK_NX51_xmac_status_shared1_tx_ufl                    0x00002000U
#define SRT_NX51_xmac_status_shared1_tx_ufl                    13
#define DFLT_VAL_NX51_xmac_status_shared1_tx_ufl               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_tx_ufl            0x00000000U
#define MSK_NX51_xmac_status_shared1_utx_empty                 0x00004000U
#define SRT_NX51_xmac_status_shared1_utx_empty                 14
#define DFLT_VAL_NX51_xmac_status_shared1_utx_empty            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_utx_empty         0x00000000U
#define MSK_NX51_xmac_status_shared1_eld_bad_link              0x00008000U
#define SRT_NX51_xmac_status_shared1_eld_bad_link              15
#define DFLT_VAL_NX51_xmac_status_shared1_eld_bad_link         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_shared1_eld_bad_link      0x00000000U

/* all used bits of 'NX51_xmac_status_shared1': */
#define MSK_USED_BITS_NX51_xmac_status_shared1 0x0000ffffU

enum {
	BFW_NX51_xmac_status_shared1_gpio0_in          = 1,  /* [0] */
	BFW_NX51_xmac_status_shared1_gpio1_in          = 1,  /* [1] */
	BFW_NX51_xmac_status_shared1_gpio2_in_phy_led0 = 1,  /* [2] */
	BFW_NX51_xmac_status_shared1_gpio3_in_phy_led1 = 1,  /* [3] */
	BFW_NX51_xmac_status_shared1_gpio4_in_phy_led2 = 1,  /* [4] */
	BFW_NX51_xmac_status_shared1_gpio5_in_phy_led3 = 1,  /* [5] */
	BFW_NX51_xmac_status_shared1_brec              = 1,  /* [6] */
	BFW_NX51_xmac_status_shared1_btran             = 1,  /* [7] */
	BFW_NX51_xmac_status_shared1_stat_rpu          = 1,  /* [8] */
	BFW_NX51_xmac_status_shared1_stat_tpu          = 1,  /* [9] */
	BFW_NX51_xmac_status_shared1_rx_rdy            = 1,  /* [10] */
	BFW_NX51_xmac_status_shared1_rx_ovf            = 1,  /* [11] */
	BFW_NX51_xmac_status_shared1_tx_nxt            = 1,  /* [12] */
	BFW_NX51_xmac_status_shared1_tx_ufl            = 1,  /* [13] */
	BFW_NX51_xmac_status_shared1_utx_empty         = 1,  /* [14] */
	BFW_NX51_xmac_status_shared1_eld_bad_link      = 1,  /* [15] */
	BFW_NX51_xmac_status_shared1_reserved1         = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STATUS_SHARED1_BIT_Ttag {
	unsigned int gpio0_in          : BFW_NX51_xmac_status_shared1_gpio0_in;          /* value at external gpio pin                                                                          */
	unsigned int gpio1_in          : BFW_NX51_xmac_status_shared1_gpio1_in;          /* value at external gpio pin                                                                          */
	unsigned int gpio2_in_phy_led0 : BFW_NX51_xmac_status_shared1_gpio2_in_phy_led0; /* IF phy_led_en:                                                                                      */
	                                                                                 /* 1: Internal Phy0 LED0, usually link_status                                                          */
	                                                                                 /* 0: gpio2_in # value at external gpio pin                                                            */
	unsigned int gpio3_in_phy_led1 : BFW_NX51_xmac_status_shared1_gpio3_in_phy_led1; /* IF phy_led_en:                                                                                      */
	                                                                                 /* 1: Internal Phy0 LED1, usually activity                                                             */
	                                                                                 /* 0: gpio3_in # value at external gpio pin                                                            */
	unsigned int gpio4_in_phy_led2 : BFW_NX51_xmac_status_shared1_gpio4_in_phy_led2; /* IF phy_led_en:                                                                                      */
	                                                                                 /* 1: Internal Phy0 LED2, usually speed100                                                             */
	                                                                                 /* 0: gpio4_in # value at external gpio pin                                                            */
	unsigned int gpio5_in_phy_led3 : BFW_NX51_xmac_status_shared1_gpio5_in_phy_led3; /* IF phy_led_en:                                                                                      */
	                                                                                 /* 1: Internal Phy0 LED3, usually full_duplex                                                          */
	                                                                                 /* 0: gpio5_in # value at external gpio pin                                                            */
	unsigned int brec              : BFW_NX51_xmac_status_shared1_brec;              /* bit_received (active for 1 cc)                                                                      */
	unsigned int btran             : BFW_NX51_xmac_status_shared1_btran;             /* bit_transmitted (active for 1 cc)                                                                   */
	unsigned int stat_rpu          : BFW_NX51_xmac_status_shared1_stat_rpu;          /* General RPU status bits, set and reset by RPU command bits.                                         */
	unsigned int stat_tpu          : BFW_NX51_xmac_status_shared1_stat_tpu;          /* General TPU status bits, set and reset by TPU command bits.                                         */
	unsigned int rx_rdy            : BFW_NX51_xmac_status_shared1_rx_rdy;            /* Received bytes are valid at output of URX_FIFO.                                                     */
	unsigned int rx_ovf            : BFW_NX51_xmac_status_shared1_rx_ovf;            /* Receive overflow (too much data in URX_FIFO).                                                       */
	                                                                                 /* To reset this bit, reset xMAC1-URX_FIFO by writing 1 to this bit (xMAC only, not via xpec_statcfg). */
	unsigned int tx_nxt            : BFW_NX51_xmac_status_shared1_tx_nxt;            /* Put next tx_word to UTX_FIFO: at least one entry of UTX_FIFO is empty.                              */
	unsigned int tx_ufl            : BFW_NX51_xmac_status_shared1_tx_ufl;            /* Transmit underflow (not enough data in UTX_FIFO).                                                   */
	                                                                                 /* To reset this bit, reset xMAC1-UTX_FIFO by writing 1 to this bit (xMAC only, not via xpec_statcfg). */
	unsigned int utx_empty         : BFW_NX51_xmac_status_shared1_utx_empty;         /* UTX_FIFO is empty                                                                                   */
	unsigned int eld_bad_link      : BFW_NX51_xmac_status_shared1_eld_bad_link;      /* link_status from enhanced link detection unit                                                       */
	                                                                                 /* To reset this bit, write 1 to this bit (xMAC only, not via xpec_statcfg).                           */
	unsigned int reserved1         : BFW_NX51_xmac_status_shared1_reserved1;         /* reserved                                                                                            */
} NX51_XMAC_STATUS_SHARED1_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_XMAC_STATUS_SHARED1_BIT_T bf;
} NX51_XMAC_STATUS_SHARED1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_shared1 */
/* => xMAC1 Shared Config Register: */
/*    Upper bits 15..8 are write mask and thus not readable. */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_shared1        0x00000050U
#define Adr_NX51_xmac0_regs_xmac_config_shared1 0x1018B450U
#define Adr_NX51_xmac1_regs_xmac_config_shared1 0x1018B650U
#define DFLT_VAL_NX51_xmac_config_shared1       0x00000000U

#define MSK_NX51_xmac_config_shared1_gpio0_out                0x00000001U
#define SRT_NX51_xmac_config_shared1_gpio0_out                0
#define DFLT_VAL_NX51_xmac_config_shared1_gpio0_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio0_out        0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio1_out                0x00000002U
#define SRT_NX51_xmac_config_shared1_gpio1_out                1
#define DFLT_VAL_NX51_xmac_config_shared1_gpio1_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio1_out        0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio2_out                0x00000004U
#define SRT_NX51_xmac_config_shared1_gpio2_out                2
#define DFLT_VAL_NX51_xmac_config_shared1_gpio2_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio2_out        0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio3_out                0x00000008U
#define SRT_NX51_xmac_config_shared1_gpio3_out                3
#define DFLT_VAL_NX51_xmac_config_shared1_gpio3_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio3_out        0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio4_out                0x00000010U
#define SRT_NX51_xmac_config_shared1_gpio4_out                4
#define DFLT_VAL_NX51_xmac_config_shared1_gpio4_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio4_out        0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio5_out                0x00000020U
#define SRT_NX51_xmac_config_shared1_gpio5_out                5
#define DFLT_VAL_NX51_xmac_config_shared1_gpio5_out           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio5_out        0x00000000U
#define MSK_NX51_xmac_config_shared1_reserved_stat            0x000000c0U
#define SRT_NX51_xmac_config_shared1_reserved_stat            6
#define DFLT_VAL_NX51_xmac_config_shared1_reserved_stat       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_reserved_stat    0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio0_out_wm             0x00000100U
#define SRT_NX51_xmac_config_shared1_gpio0_out_wm             8
#define DFLT_VAL_NX51_xmac_config_shared1_gpio0_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio0_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio1_out_wm             0x00000200U
#define SRT_NX51_xmac_config_shared1_gpio1_out_wm             9
#define DFLT_VAL_NX51_xmac_config_shared1_gpio1_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio1_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio2_out_wm             0x00000400U
#define SRT_NX51_xmac_config_shared1_gpio2_out_wm             10
#define DFLT_VAL_NX51_xmac_config_shared1_gpio2_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio2_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio3_out_wm             0x00000800U
#define SRT_NX51_xmac_config_shared1_gpio3_out_wm             11
#define DFLT_VAL_NX51_xmac_config_shared1_gpio3_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio3_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio4_out_wm             0x00001000U
#define SRT_NX51_xmac_config_shared1_gpio4_out_wm             12
#define DFLT_VAL_NX51_xmac_config_shared1_gpio4_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio4_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared1_gpio5_out_wm             0x00002000U
#define SRT_NX51_xmac_config_shared1_gpio5_out_wm             13
#define DFLT_VAL_NX51_xmac_config_shared1_gpio5_out_wm        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_gpio5_out_wm     0x00000000U
#define MSK_NX51_xmac_config_shared1_reserved_stat_wm         0x0000c000U
#define SRT_NX51_xmac_config_shared1_reserved_stat_wm         14
#define DFLT_VAL_NX51_xmac_config_shared1_reserved_stat_wm    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_shared1_reserved_stat_wm 0x00000000U

/* all used bits of 'NX51_xmac_config_shared1': */
#define MSK_USED_BITS_NX51_xmac_config_shared1 0x0000ffffU

enum {
	BFW_NX51_xmac_config_shared1_gpio0_out        = 1,  /* [0] */
	BFW_NX51_xmac_config_shared1_gpio1_out        = 1,  /* [1] */
	BFW_NX51_xmac_config_shared1_gpio2_out        = 1,  /* [2] */
	BFW_NX51_xmac_config_shared1_gpio3_out        = 1,  /* [3] */
	BFW_NX51_xmac_config_shared1_gpio4_out        = 1,  /* [4] */
	BFW_NX51_xmac_config_shared1_gpio5_out        = 1,  /* [5] */
	BFW_NX51_xmac_config_shared1_reserved_stat    = 2,  /* [7:6] */
	BFW_NX51_xmac_config_shared1_gpio0_out_wm     = 1,  /* [8] */
	BFW_NX51_xmac_config_shared1_gpio1_out_wm     = 1,  /* [9] */
	BFW_NX51_xmac_config_shared1_gpio2_out_wm     = 1,  /* [10] */
	BFW_NX51_xmac_config_shared1_gpio3_out_wm     = 1,  /* [11] */
	BFW_NX51_xmac_config_shared1_gpio4_out_wm     = 1,  /* [12] */
	BFW_NX51_xmac_config_shared1_gpio5_out_wm     = 1,  /* [13] */
	BFW_NX51_xmac_config_shared1_reserved_stat_wm = 2,  /* [15:14] */
	BFW_NX51_xmac_config_shared1_reserved1        = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CONFIG_SHARED1_BIT_Ttag {
	unsigned int gpio0_out        : BFW_NX51_xmac_config_shared1_gpio0_out;        /* General Purpose IO 0 output                */
	unsigned int gpio1_out        : BFW_NX51_xmac_config_shared1_gpio1_out;        /* General Purpose IO 1 output                */
	unsigned int gpio2_out        : BFW_NX51_xmac_config_shared1_gpio2_out;        /* General Purpose IO 2 output                */
	unsigned int gpio3_out        : BFW_NX51_xmac_config_shared1_gpio3_out;        /* General Purpose IO 3 output                */
	unsigned int gpio4_out        : BFW_NX51_xmac_config_shared1_gpio4_out;        /* General Purpose IO 4 output                */
	unsigned int gpio5_out        : BFW_NX51_xmac_config_shared1_gpio5_out;        /* General Purpose IO 5 output                */
	unsigned int reserved_stat    : BFW_NX51_xmac_config_shared1_reserved_stat;    /* Reserved Status Bits                       */
	unsigned int gpio0_out_wm     : BFW_NX51_xmac_config_shared1_gpio0_out_wm;     /* Write mask for General Purpose IO 0 output */
	unsigned int gpio1_out_wm     : BFW_NX51_xmac_config_shared1_gpio1_out_wm;     /* Write mask for General Purpose IO 1 output */
	unsigned int gpio2_out_wm     : BFW_NX51_xmac_config_shared1_gpio2_out_wm;     /* Write mask for General Purpose IO 2 output */
	unsigned int gpio3_out_wm     : BFW_NX51_xmac_config_shared1_gpio3_out_wm;     /* Write mask for General Purpose IO 3 output */
	unsigned int gpio4_out_wm     : BFW_NX51_xmac_config_shared1_gpio4_out_wm;     /* Write mask for General Purpose IO 4 output */
	unsigned int gpio5_out_wm     : BFW_NX51_xmac_config_shared1_gpio5_out_wm;     /* Write mask for General Purpose IO 5 output */
	unsigned int reserved_stat_wm : BFW_NX51_xmac_config_shared1_reserved_stat_wm; /* Write mask for Reserved Status Bits        */
	unsigned int reserved1        : BFW_NX51_xmac_config_shared1_reserved1;        /* reserved                                   */
} NX51_XMAC_CONFIG_SHARED1_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_XMAC_CONFIG_SHARED1_BIT_T bf;
} NX51_XMAC_CONFIG_SHARED1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_io_oe_shared1 */
/* => xMAC1 Shared GPIO Output Enable Register: */
/*    Upper bits 15..8 are write mask and thus not readable. */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_io_oe_shared1        0x00000054U
#define Adr_NX51_xmac0_regs_xmac_io_oe_shared1 0x1018B454U
#define Adr_NX51_xmac1_regs_xmac_io_oe_shared1 0x1018B654U
#define DFLT_VAL_NX51_xmac_io_oe_shared1       0x00000000U

#define MSK_NX51_xmac_io_oe_shared1_gpio0_oe                 0x00000001U
#define SRT_NX51_xmac_io_oe_shared1_gpio0_oe                 0
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio0_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio0_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio1_oe                 0x00000002U
#define SRT_NX51_xmac_io_oe_shared1_gpio1_oe                 1
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio1_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio1_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio2_oe                 0x00000004U
#define SRT_NX51_xmac_io_oe_shared1_gpio2_oe                 2
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio2_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio2_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio3_oe                 0x00000008U
#define SRT_NX51_xmac_io_oe_shared1_gpio3_oe                 3
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio3_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio3_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio4_oe                 0x00000010U
#define SRT_NX51_xmac_io_oe_shared1_gpio4_oe                 4
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio4_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio4_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio5_oe                 0x00000020U
#define SRT_NX51_xmac_io_oe_shared1_gpio5_oe                 5
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio5_oe            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio5_oe         0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_reserved_stat            0x000000c0U
#define SRT_NX51_xmac_io_oe_shared1_reserved_stat            6
#define DFLT_VAL_NX51_xmac_io_oe_shared1_reserved_stat       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_reserved_stat    0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio0_oe_wm              0x00000100U
#define SRT_NX51_xmac_io_oe_shared1_gpio0_oe_wm              8
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio0_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio0_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio1_oe_wm              0x00000200U
#define SRT_NX51_xmac_io_oe_shared1_gpio1_oe_wm              9
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio1_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio1_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio2_oe_wm              0x00000400U
#define SRT_NX51_xmac_io_oe_shared1_gpio2_oe_wm              10
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio2_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio2_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio3_oe_wm              0x00000800U
#define SRT_NX51_xmac_io_oe_shared1_gpio3_oe_wm              11
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio3_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio3_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio4_oe_wm              0x00001000U
#define SRT_NX51_xmac_io_oe_shared1_gpio4_oe_wm              12
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio4_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio4_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_gpio5_oe_wm              0x00002000U
#define SRT_NX51_xmac_io_oe_shared1_gpio5_oe_wm              13
#define DFLT_VAL_NX51_xmac_io_oe_shared1_gpio5_oe_wm         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_gpio5_oe_wm      0x00000000U
#define MSK_NX51_xmac_io_oe_shared1_reserved_stat_wm         0x0000c000U
#define SRT_NX51_xmac_io_oe_shared1_reserved_stat_wm         14
#define DFLT_VAL_NX51_xmac_io_oe_shared1_reserved_stat_wm    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_io_oe_shared1_reserved_stat_wm 0x00000000U

/* all used bits of 'NX51_xmac_io_oe_shared1': */
#define MSK_USED_BITS_NX51_xmac_io_oe_shared1 0x0000ffffU

enum {
	BFW_NX51_xmac_io_oe_shared1_gpio0_oe         = 1,  /* [0] */
	BFW_NX51_xmac_io_oe_shared1_gpio1_oe         = 1,  /* [1] */
	BFW_NX51_xmac_io_oe_shared1_gpio2_oe         = 1,  /* [2] */
	BFW_NX51_xmac_io_oe_shared1_gpio3_oe         = 1,  /* [3] */
	BFW_NX51_xmac_io_oe_shared1_gpio4_oe         = 1,  /* [4] */
	BFW_NX51_xmac_io_oe_shared1_gpio5_oe         = 1,  /* [5] */
	BFW_NX51_xmac_io_oe_shared1_reserved_stat    = 2,  /* [7:6] */
	BFW_NX51_xmac_io_oe_shared1_gpio0_oe_wm      = 1,  /* [8] */
	BFW_NX51_xmac_io_oe_shared1_gpio1_oe_wm      = 1,  /* [9] */
	BFW_NX51_xmac_io_oe_shared1_gpio2_oe_wm      = 1,  /* [10] */
	BFW_NX51_xmac_io_oe_shared1_gpio3_oe_wm      = 1,  /* [11] */
	BFW_NX51_xmac_io_oe_shared1_gpio4_oe_wm      = 1,  /* [12] */
	BFW_NX51_xmac_io_oe_shared1_gpio5_oe_wm      = 1,  /* [13] */
	BFW_NX51_xmac_io_oe_shared1_reserved_stat_wm = 2,  /* [15:14] */
	BFW_NX51_xmac_io_oe_shared1_reserved1        = 16  /* [31:16] */
};

typedef struct NX51_XMAC_IO_OE_SHARED1_BIT_Ttag {
	unsigned int gpio0_oe         : BFW_NX51_xmac_io_oe_shared1_gpio0_oe;         /* General Purpose IO 0 output enable                */
	unsigned int gpio1_oe         : BFW_NX51_xmac_io_oe_shared1_gpio1_oe;         /* General Purpose IO 1 output enable                */
	unsigned int gpio2_oe         : BFW_NX51_xmac_io_oe_shared1_gpio2_oe;         /* General Purpose IO 2 output enable                */
	unsigned int gpio3_oe         : BFW_NX51_xmac_io_oe_shared1_gpio3_oe;         /* General Purpose IO 3 output enable                */
	unsigned int gpio4_oe         : BFW_NX51_xmac_io_oe_shared1_gpio4_oe;         /* General Purpose IO 4 output enable                */
	unsigned int gpio5_oe         : BFW_NX51_xmac_io_oe_shared1_gpio5_oe;         /* General Purpose IO 5 output enable                */
	unsigned int reserved_stat    : BFW_NX51_xmac_io_oe_shared1_reserved_stat;    /* Reserved Status Bits                              */
	unsigned int gpio0_oe_wm      : BFW_NX51_xmac_io_oe_shared1_gpio0_oe_wm;      /* Write mask for General Purpose IO 0 output enable */
	unsigned int gpio1_oe_wm      : BFW_NX51_xmac_io_oe_shared1_gpio1_oe_wm;      /* Write mask for General Purpose IO 1 output enable */
	unsigned int gpio2_oe_wm      : BFW_NX51_xmac_io_oe_shared1_gpio2_oe_wm;      /* Write mask for General Purpose IO 2 output enable */
	unsigned int gpio3_oe_wm      : BFW_NX51_xmac_io_oe_shared1_gpio3_oe_wm;      /* Write mask for General Purpose IO 3 output enable */
	unsigned int gpio4_oe_wm      : BFW_NX51_xmac_io_oe_shared1_gpio4_oe_wm;      /* Write mask for General Purpose IO 4 output enable */
	unsigned int gpio5_oe_wm      : BFW_NX51_xmac_io_oe_shared1_gpio5_oe_wm;      /* Write mask for General Purpose IO 5 output enable */
	unsigned int reserved_stat_wm : BFW_NX51_xmac_io_oe_shared1_reserved_stat_wm; /* Write mask for Reserved Status Bits               */
	unsigned int reserved1        : BFW_NX51_xmac_io_oe_shared1_reserved1;        /* reserved                                          */
} NX51_XMAC_IO_OE_SHARED1_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XMAC_IO_OE_SHARED1_BIT_T bf;
} NX51_XMAC_IO_OE_SHARED1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_urx_utx0 */
/* => xMAC0 URX/UTX Shared Register FIFO */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_urx_utx0        0x00000070U
#define Adr_NX51_xmac0_regs_xmac_urx_utx0 0x1018B470U
#define Adr_NX51_xmac1_regs_xmac_urx_utx0 0x1018B670U
#define DFLT_VAL_NX51_xmac_urx_utx0       0x00000000U

#define MSK_NX51_xmac_urx_utx0_utrx_xmac0         0x0000ffffU
#define SRT_NX51_xmac_urx_utx0_utrx_xmac0         0
#define DFLT_VAL_NX51_xmac_urx_utx0_utrx_xmac0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_urx_utx0_utrx_xmac0 0x00000000U

/* all used bits of 'NX51_xmac_urx_utx0': */
#define MSK_USED_BITS_NX51_xmac_urx_utx0 0x0000ffffU

enum {
	BFW_NX51_xmac_urx_utx0_utrx_xmac0 = 16, /* [15:0] */
	BFW_NX51_xmac_urx_utx0_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_URX_UTX0_BIT_Ttag {
	unsigned int utrx_xmac0 : BFW_NX51_xmac_urx_utx0_utrx_xmac0; /* read access:  Lastly received bits (output of URX_FIFO)       */
	                                                             /* write access: Bits to be transmitted next (input of UTX_FIFO) */
	unsigned int reserved1  : BFW_NX51_xmac_urx_utx0_reserved1;  /* reserved                                                      */
} NX51_XMAC_URX_UTX0_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_URX_UTX0_BIT_T bf;
} NX51_XMAC_URX_UTX0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_urx_utx1 */
/* => xMAC1 URX/UTX Shared Register FIFO */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_urx_utx1        0x00000074U
#define Adr_NX51_xmac0_regs_xmac_urx_utx1 0x1018B474U
#define Adr_NX51_xmac1_regs_xmac_urx_utx1 0x1018B674U
#define DFLT_VAL_NX51_xmac_urx_utx1       0x00000000U

#define MSK_NX51_xmac_urx_utx1_utrx_xmac1         0x0000ffffU
#define SRT_NX51_xmac_urx_utx1_utrx_xmac1         0
#define DFLT_VAL_NX51_xmac_urx_utx1_utrx_xmac1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_urx_utx1_utrx_xmac1 0x00000000U

/* all used bits of 'NX51_xmac_urx_utx1': */
#define MSK_USED_BITS_NX51_xmac_urx_utx1 0x0000ffffU

enum {
	BFW_NX51_xmac_urx_utx1_utrx_xmac1 = 16, /* [15:0] */
	BFW_NX51_xmac_urx_utx1_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_URX_UTX1_BIT_Ttag {
	unsigned int utrx_xmac1 : BFW_NX51_xmac_urx_utx1_utrx_xmac1; /* read access:  Lastly received bits (output of URX_FIFO)       */
	                                                             /* write access: Bits to be transmitted next (input of UTX_FIFO) */
	unsigned int reserved1  : BFW_NX51_xmac_urx_utx1_reserved1;  /* reserved                                                      */
} NX51_XMAC_URX_UTX1_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_URX_UTX1_BIT_T bf;
} NX51_XMAC_URX_UTX1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_urx */
/* => xMAC URX FIFO input */
/*    URX FIFO is part of xMAC. It can be read (output) by all xMACs and xPECs, but only written (input) by the xMAC it belongs to. */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_urx        0x00000080U
#define Adr_NX51_xmac0_regs_xmac_urx 0x1018B480U
#define Adr_NX51_xmac1_regs_xmac_urx 0x1018B680U
#define DFLT_VAL_NX51_xmac_urx       0x00000000U

#define MSK_NX51_xmac_urx_urx         0x0000ffffU
#define SRT_NX51_xmac_urx_urx         0
#define DFLT_VAL_NX51_xmac_urx_urx    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_urx_urx 0x00000000U

/* all used bits of 'NX51_xmac_urx': */
#define MSK_USED_BITS_NX51_xmac_urx 0x0000ffffU

enum {
	BFW_NX51_xmac_urx_urx       = 16, /* [15:0] */
	BFW_NX51_xmac_urx_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_URX_BIT_Ttag {
	unsigned int urx       : BFW_NX51_xmac_urx_urx;       /* Lastly received bits to be transmitted to xPEC (input of URX_FIFO) */
	unsigned int reserved1 : BFW_NX51_xmac_urx_reserved1; /* reserved                                                           */
} NX51_XMAC_URX_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_URX_BIT_T bf;
} NX51_XMAC_URX_T;

/* --------------------------------------------------------------------- */
/* Register xmac_utx */
/* => xMAC UTX FIFO output */
/*    UTX FIFO is part of xMAC. It can be written (input) by all xMACs and xPECs, but only read (output) by the xMAC it belongs to. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_utx        0x00000084U
#define Adr_NX51_xmac0_regs_xmac_utx 0x1018B484U
#define Adr_NX51_xmac1_regs_xmac_utx 0x1018B684U

#define MSK_NX51_xmac_utx_utx 0x0000ffffU
#define SRT_NX51_xmac_utx_utx 0

/* all used bits of 'NX51_xmac_utx': */
#define MSK_USED_BITS_NX51_xmac_utx 0x0000ffffU

enum {
	BFW_NX51_xmac_utx_utx       = 16, /* [15:0] */
	BFW_NX51_xmac_utx_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_UTX_BIT_Ttag {
	unsigned int utx       : BFW_NX51_xmac_utx_utx;       /* Bits to be transmitted next (output of UTX_FIFO)                             */
	                                                      /* read as src2 allows multiple reads, only read as src1 will change FIFO state */
	unsigned int reserved1 : BFW_NX51_xmac_utx_reserved1; /* reserved                                                                     */
} NX51_XMAC_UTX_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_UTX_BIT_T bf;
} NX51_XMAC_UTX_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx */
/* => xMAC RX Register */
/*    Sampled bits from SBU are collected in this register, \ */
/*    i.e. if a new bit arrives from SBU (sync), other bits are shifted (direction programmable). */
/*    Same behavior in MII-Modes (4 bits arrive in parallel and the other bits are shifted by 4). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx        0x00000088U
#define Adr_NX51_xmac0_regs_xmac_rx 0x1018B488U
#define Adr_NX51_xmac1_regs_xmac_rx 0x1018B688U

#define MSK_NX51_xmac_rx_rx 0x0000ffffU
#define SRT_NX51_xmac_rx_rx 0

/* all used bits of 'NX51_xmac_rx': */
#define MSK_USED_BITS_NX51_xmac_rx 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_rx        = 16, /* [15:0] */
	BFW_NX51_xmac_rx_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_BIT_Ttag {
	unsigned int rx        : BFW_NX51_xmac_rx_rx;        /* 16 previously received bits */
	unsigned int reserved1 : BFW_NX51_xmac_rx_reserved1; /* reserved                    */
} NX51_XMAC_RX_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XMAC_RX_BIT_T bf;
} NX51_XMAC_RX_T;

/* --------------------------------------------------------------------- */
/* Register xmac_other_rx */
/* => RX Register of other xMAC. */
/*    Used for fast forward of data between 2 xMACs (specially in MII-HUB-mode) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_other_rx        0x0000008CU
#define Adr_NX51_xmac0_regs_xmac_other_rx 0x1018B48CU
#define Adr_NX51_xmac1_regs_xmac_other_rx 0x1018B68CU

#define MSK_NX51_xmac_other_rx_rx 0x0000ffffU
#define SRT_NX51_xmac_other_rx_rx 0

/* all used bits of 'NX51_xmac_other_rx': */
#define MSK_USED_BITS_NX51_xmac_other_rx 0x0000ffffU

enum {
	BFW_NX51_xmac_other_rx_rx        = 16, /* [15:0] */
	BFW_NX51_xmac_other_rx_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_OTHER_RX_BIT_Ttag {
	unsigned int rx        : BFW_NX51_xmac_other_rx_rx;        /* 16 previously received bits of other xMAC */
	unsigned int reserved1 : BFW_NX51_xmac_other_rx_reserved1; /* reserved                                  */
} NX51_XMAC_OTHER_RX_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_OTHER_RX_BIT_T bf;
} NX51_XMAC_OTHER_RX_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_hw */
/* => xMAC RX_HW Register */
/*    rx_hw bit in RPU-code writes actually received bit from rx to this register. */
/*    Useful in case of bitwise format, to collect source bits from raw input bitstream (e.g. in HDLC-coding). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_hw        0x00000090U
#define Adr_NX51_xmac0_regs_xmac_rx_hw 0x1018B490U
#define Adr_NX51_xmac1_regs_xmac_rx_hw 0x1018B690U
#define DFLT_VAL_NX51_xmac_rx_hw       0x00000000U

#define MSK_NX51_xmac_rx_hw_rx_hw         0x0000ffffU
#define SRT_NX51_xmac_rx_hw_rx_hw         0
#define DFLT_VAL_NX51_xmac_rx_hw_rx_hw    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_hw_rx_hw 0x00000000U

/* all used bits of 'NX51_xmac_rx_hw': */
#define MSK_USED_BITS_NX51_xmac_rx_hw 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_hw_rx_hw     = 16, /* [15:0] */
	BFW_NX51_xmac_rx_hw_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_HW_BIT_Ttag {
	unsigned int rx_hw     : BFW_NX51_xmac_rx_hw_rx_hw;     /* collected source bits from raw input bitstream                        */
	                                                        /* same orientation of bits as in rx register (depending on rx_shift_lr) */
	unsigned int reserved1 : BFW_NX51_xmac_rx_hw_reserved1; /* reserved                                                              */
} NX51_XMAC_RX_HW_BIT_T;

typedef union {
	unsigned int          val;
	NX51_XMAC_RX_HW_BIT_T bf;
} NX51_XMAC_RX_HW_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_hw_count */
/* => xMAC RX_HW_COUNT Register */
/*    Counts bits collected by rx_hw bit RPU-code. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_hw_count        0x00000094U
#define Adr_NX51_xmac0_regs_xmac_rx_hw_count 0x1018B494U
#define Adr_NX51_xmac1_regs_xmac_rx_hw_count 0x1018B694U
#define DFLT_VAL_NX51_xmac_rx_hw_count       0x00000000U

#define MSK_NX51_xmac_rx_hw_count_rx_hw_count         0x0000ffffU
#define SRT_NX51_xmac_rx_hw_count_rx_hw_count         0
#define DFLT_VAL_NX51_xmac_rx_hw_count_rx_hw_count    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_hw_count_rx_hw_count 0x00000000U

/* all used bits of 'NX51_xmac_rx_hw_count': */
#define MSK_USED_BITS_NX51_xmac_rx_hw_count 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_hw_count_rx_hw_count = 16, /* [15:0] */
	BFW_NX51_xmac_rx_hw_count_reserved1   = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_HW_COUNT_BIT_Ttag {
	unsigned int rx_hw_count : BFW_NX51_xmac_rx_hw_count_rx_hw_count; /* counts down with rx_hw in RPU-code:                                         */
	                                                                  /* rx_nof_bits != 1: from rx_nof_bits-1 to 0 with precharge to (rx_nof_bits-1) */
	                                                                  /* rx_nof_bits =  1: 16-bit downcounter without precharge                      */
	unsigned int reserved1   : BFW_NX51_xmac_rx_hw_count_reserved1;   /* reserved                                                                    */
} NX51_XMAC_RX_HW_COUNT_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_RX_HW_COUNT_BIT_T bf;
} NX51_XMAC_RX_HW_COUNT_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx */
/* => xMAC TX Register */
/*    Transmitted bits read automatically by OBU from this register, \ */
/*    i.e. if a bit is send (sync), other bits are rotated accordingly (direction programmable). */
/*    Same behavior in MII-Modes (4 bits arrive in parallel and the other bits are rotated by 4). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx        0x00000098U
#define Adr_NX51_xmac0_regs_xmac_tx 0x1018B498U
#define Adr_NX51_xmac1_regs_xmac_tx 0x1018B698U
#define DFLT_VAL_NX51_xmac_tx       0x00000000U

#define MSK_NX51_xmac_tx_tx         0x0000ffffU
#define SRT_NX51_xmac_tx_tx         0
#define DFLT_VAL_NX51_xmac_tx_tx    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_tx 0x00000000U

/* all used bits of 'NX51_xmac_tx': */
#define MSK_USED_BITS_NX51_xmac_tx 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_tx        = 16, /* [15:0] */
	BFW_NX51_xmac_tx_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_BIT_Ttag {
	unsigned int tx        : BFW_NX51_xmac_tx_tx;        /* to be transmitted bits                                */
	                                                     /* bit 0  is transmitted next in case of tx_shift_lr = 0 */
	                                                     /* bit 15 is transmitted next in case of tx_shift_lr = 1 */
	unsigned int reserved1 : BFW_NX51_xmac_tx_reserved1; /* reserved                                              */
} NX51_XMAC_TX_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XMAC_TX_BIT_T bf;
} NX51_XMAC_TX_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_hw */
/* => xMAC TX_HW Register */
/*    tx_hw bit in TPU-code writes to be transmitted bit in tx register from this register */
/*    Useful in case of bitwise format, to insert source bits into output bitstream. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_hw        0x0000009CU
#define Adr_NX51_xmac0_regs_xmac_tx_hw 0x1018B49CU
#define Adr_NX51_xmac1_regs_xmac_tx_hw 0x1018B69CU
#define DFLT_VAL_NX51_xmac_tx_hw       0x00000000U

#define MSK_NX51_xmac_tx_hw_tx_hw         0x0000ffffU
#define SRT_NX51_xmac_tx_hw_tx_hw         0
#define DFLT_VAL_NX51_xmac_tx_hw_tx_hw    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_hw_tx_hw 0x00000000U

/* all used bits of 'NX51_xmac_tx_hw': */
#define MSK_USED_BITS_NX51_xmac_tx_hw 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_hw_tx_hw     = 16, /* [15:0] */
	BFW_NX51_xmac_tx_hw_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_HW_BIT_Ttag {
	unsigned int tx_hw     : BFW_NX51_xmac_tx_hw_tx_hw;     /* bits to be inserted into output bitstream                             */
	                                                        /* same orientation of bits as in tx register (depending on tx_shift_lr) */
	unsigned int reserved1 : BFW_NX51_xmac_tx_hw_reserved1; /* reserved                                                              */
} NX51_XMAC_TX_HW_BIT_T;

typedef union {
	unsigned int          val;
	NX51_XMAC_TX_HW_BIT_T bf;
} NX51_XMAC_TX_HW_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_hw_count */
/* => xMAC TX_HW_COUNT Register */
/*    Counts bits transmitted by tx_hw bit in TPU-code. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_hw_count        0x000000A0U
#define Adr_NX51_xmac0_regs_xmac_tx_hw_count 0x1018B4A0U
#define Adr_NX51_xmac1_regs_xmac_tx_hw_count 0x1018B6A0U
#define DFLT_VAL_NX51_xmac_tx_hw_count       0x00000000U

#define MSK_NX51_xmac_tx_hw_count_tx_hw_count         0x0000ffffU
#define SRT_NX51_xmac_tx_hw_count_tx_hw_count         0
#define DFLT_VAL_NX51_xmac_tx_hw_count_tx_hw_count    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_hw_count_tx_hw_count 0x00000000U

/* all used bits of 'NX51_xmac_tx_hw_count': */
#define MSK_USED_BITS_NX51_xmac_tx_hw_count 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_hw_count_tx_hw_count = 16, /* [15:0] */
	BFW_NX51_xmac_tx_hw_count_reserved1   = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_HW_COUNT_BIT_Ttag {
	unsigned int tx_hw_count : BFW_NX51_xmac_tx_hw_count_tx_hw_count; /* counts down with tx_hw in TPU-code                                        */
	                                                                  /* tx_nof_bits != 1: from tx_nof_bits-1 to 0 with precharge to tx_nof_bits-1 */
	                                                                  /* tx_nof_bits =  1: 16-bit downcounter without precharge                    */
	unsigned int reserved1   : BFW_NX51_xmac_tx_hw_count_reserved1;   /* reserved                                                                  */
} NX51_XMAC_TX_HW_COUNT_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_TX_HW_COUNT_BIT_T bf;
} NX51_XMAC_TX_HW_COUNT_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_sent */
/* => xMAC TX Sent Register */
/*    Collects already transmitted bits. */
/*    Useful for pattern match. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_sent        0x000000A4U
#define Adr_NX51_xmac0_regs_xmac_tx_sent 0x1018B4A4U
#define Adr_NX51_xmac1_regs_xmac_tx_sent 0x1018B6A4U
#define DFLT_VAL_NX51_xmac_tx_sent       0x00000000U

#define MSK_NX51_xmac_tx_sent_tx_sent         0x0000ffffU
#define SRT_NX51_xmac_tx_sent_tx_sent         0
#define DFLT_VAL_NX51_xmac_tx_sent_tx_sent    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_sent_tx_sent 0x00000000U

/* all used bits of 'NX51_xmac_tx_sent': */
#define MSK_USED_BITS_NX51_xmac_tx_sent 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_sent_tx_sent   = 16, /* [15:0] */
	BFW_NX51_xmac_tx_sent_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_SENT_BIT_Ttag {
	unsigned int tx_sent   : BFW_NX51_xmac_tx_sent_tx_sent;   /* already transmitted bits,                                          */
	                                                          /* bit 15 is always the oldest bit (shift direction not programmable) */
	unsigned int reserved1 : BFW_NX51_xmac_tx_sent_reserved1; /* reserved                                                           */
} NX51_XMAC_TX_SENT_BIT_T;

typedef union {
	unsigned int            val;
	NX51_XMAC_TX_SENT_BIT_T bf;
} NX51_XMAC_TX_SENT_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpu_pc */
/* => RPU Progamm counter */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpu_pc        0x000000A8U
#define Adr_NX51_xmac0_regs_xmac_rpu_pc 0x1018B4A8U
#define Adr_NX51_xmac1_regs_xmac_rpu_pc 0x1018B6A8U
#define DFLT_VAL_NX51_xmac_rpu_pc       0x00000000U

#define MSK_NX51_xmac_rpu_pc_rpu_pc         0x0000007fU
#define SRT_NX51_xmac_rpu_pc_rpu_pc         0
#define DFLT_VAL_NX51_xmac_rpu_pc_rpu_pc    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rpu_pc_rpu_pc 0x00000000U

/* all used bits of 'NX51_xmac_rpu_pc': */
#define MSK_USED_BITS_NX51_xmac_rpu_pc 0x0000007fU

enum {
	BFW_NX51_xmac_rpu_pc_rpu_pc    = 7,  /* [6:0] */
	BFW_NX51_xmac_rpu_pc_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_XMAC_RPU_PC_BIT_Ttag {
	unsigned int rpu_pc    : BFW_NX51_xmac_rpu_pc_rpu_pc;    /* Program Counter of RPU */
	unsigned int reserved1 : BFW_NX51_xmac_rpu_pc_reserved1; /* reserved               */
} NX51_XMAC_RPU_PC_BIT_T;

typedef union {
	unsigned int           val;
	NX51_XMAC_RPU_PC_BIT_T bf;
} NX51_XMAC_RPU_PC_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpu_jmp_latch */
/* => RPU Jump Latch: */
/*    Stores old PC at jump (via write to pc or via jump to address different from pc+1). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpu_jmp_latch        0x000000ACU
#define Adr_NX51_xmac0_regs_xmac_rpu_jmp_latch 0x1018B4ACU
#define Adr_NX51_xmac1_regs_xmac_rpu_jmp_latch 0x1018B6ACU

#define MSK_NX51_xmac_rpu_jmp_latch_old_pc 0x0000007fU
#define SRT_NX51_xmac_rpu_jmp_latch_old_pc 0

/* all used bits of 'NX51_xmac_rpu_jmp_latch': */
#define MSK_USED_BITS_NX51_xmac_rpu_jmp_latch 0x0000007fU

enum {
	BFW_NX51_xmac_rpu_jmp_latch_old_pc    = 7,  /* [6:0] */
	BFW_NX51_xmac_rpu_jmp_latch_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_XMAC_RPU_JMP_LATCH_BIT_Ttag {
	unsigned int old_pc    : BFW_NX51_xmac_rpu_jmp_latch_old_pc;    /* Program Counter of RPU before last jump */
	unsigned int reserved1 : BFW_NX51_xmac_rpu_jmp_latch_reserved1; /* reserved                                */
} NX51_XMAC_RPU_JMP_LATCH_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XMAC_RPU_JMP_LATCH_BIT_T bf;
} NX51_XMAC_RPU_JMP_LATCH_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpu_pc */
/* => TPU Progamm counter */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpu_pc        0x000000B0U
#define Adr_NX51_xmac0_regs_xmac_tpu_pc 0x1018B4B0U
#define Adr_NX51_xmac1_regs_xmac_tpu_pc 0x1018B6B0U
#define DFLT_VAL_NX51_xmac_tpu_pc       0x00000000U

#define MSK_NX51_xmac_tpu_pc_tpu_pc         0x0000007fU
#define SRT_NX51_xmac_tpu_pc_tpu_pc         0
#define DFLT_VAL_NX51_xmac_tpu_pc_tpu_pc    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tpu_pc_tpu_pc 0x00000000U

/* all used bits of 'NX51_xmac_tpu_pc': */
#define MSK_USED_BITS_NX51_xmac_tpu_pc 0x0000007fU

enum {
	BFW_NX51_xmac_tpu_pc_tpu_pc    = 7,  /* [6:0] */
	BFW_NX51_xmac_tpu_pc_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_XMAC_TPU_PC_BIT_Ttag {
	unsigned int tpu_pc    : BFW_NX51_xmac_tpu_pc_tpu_pc;    /* Program Counter of TPU */
	unsigned int reserved1 : BFW_NX51_xmac_tpu_pc_reserved1; /* reserved               */
} NX51_XMAC_TPU_PC_BIT_T;

typedef union {
	unsigned int           val;
	NX51_XMAC_TPU_PC_BIT_T bf;
} NX51_XMAC_TPU_PC_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpu_jmp_latch */
/* => TPU Jump Latch: */
/*    Stores old PC at jump (via write to pc or via jump to address different from pc+1). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpu_jmp_latch        0x000000B4U
#define Adr_NX51_xmac0_regs_xmac_tpu_jmp_latch 0x1018B4B4U
#define Adr_NX51_xmac1_regs_xmac_tpu_jmp_latch 0x1018B6B4U

#define MSK_NX51_xmac_tpu_jmp_latch_old_pc 0x0000007fU
#define SRT_NX51_xmac_tpu_jmp_latch_old_pc 0

/* all used bits of 'NX51_xmac_tpu_jmp_latch': */
#define MSK_USED_BITS_NX51_xmac_tpu_jmp_latch 0x0000007fU

enum {
	BFW_NX51_xmac_tpu_jmp_latch_old_pc    = 7,  /* [6:0] */
	BFW_NX51_xmac_tpu_jmp_latch_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_XMAC_TPU_JMP_LATCH_BIT_Ttag {
	unsigned int old_pc    : BFW_NX51_xmac_tpu_jmp_latch_old_pc;    /* Program Counter of TPU before last jump */
	unsigned int reserved1 : BFW_NX51_xmac_tpu_jmp_latch_reserved1; /* reserved                                */
} NX51_XMAC_TPU_JMP_LATCH_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XMAC_TPU_JMP_LATCH_BIT_T bf;
} NX51_XMAC_TPU_JMP_LATCH_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr0 */
/* => xMAC internal Work Register 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr0        0x000000B8U
#define Adr_NX51_xmac0_regs_xmac_wr0 0x1018B4B8U
#define Adr_NX51_xmac1_regs_xmac_wr0 0x1018B6B8U
#define DFLT_VAL_NX51_xmac_wr0       0x00000000U

#define MSK_NX51_xmac_wr0_wr0         0x0000ffffU
#define SRT_NX51_xmac_wr0_wr0         0
#define DFLT_VAL_NX51_xmac_wr0_wr0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr0_wr0 0x00000000U

/* all used bits of 'NX51_xmac_wr0': */
#define MSK_USED_BITS_NX51_xmac_wr0 0x0000ffffU

enum {
	BFW_NX51_xmac_wr0_wr0       = 16, /* [15:0] */
	BFW_NX51_xmac_wr0_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR0_BIT_Ttag {
	unsigned int wr0       : BFW_NX51_xmac_wr0_wr0;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr0_reserved1; /* reserved      */
} NX51_XMAC_WR0_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR0_BIT_T bf;
} NX51_XMAC_WR0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr1 */
/* => xMAC internal Work Register 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr1        0x000000BCU
#define Adr_NX51_xmac0_regs_xmac_wr1 0x1018B4BCU
#define Adr_NX51_xmac1_regs_xmac_wr1 0x1018B6BCU
#define DFLT_VAL_NX51_xmac_wr1       0x00000000U

#define MSK_NX51_xmac_wr1_wr1         0x0000ffffU
#define SRT_NX51_xmac_wr1_wr1         0
#define DFLT_VAL_NX51_xmac_wr1_wr1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr1_wr1 0x00000000U

/* all used bits of 'NX51_xmac_wr1': */
#define MSK_USED_BITS_NX51_xmac_wr1 0x0000ffffU

enum {
	BFW_NX51_xmac_wr1_wr1       = 16, /* [15:0] */
	BFW_NX51_xmac_wr1_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR1_BIT_Ttag {
	unsigned int wr1       : BFW_NX51_xmac_wr1_wr1;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr1_reserved1; /* reserved      */
} NX51_XMAC_WR1_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR1_BIT_T bf;
} NX51_XMAC_WR1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr2 */
/* => xMAC internal Work Register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr2        0x000000C0U
#define Adr_NX51_xmac0_regs_xmac_wr2 0x1018B4C0U
#define Adr_NX51_xmac1_regs_xmac_wr2 0x1018B6C0U
#define DFLT_VAL_NX51_xmac_wr2       0x00000000U

#define MSK_NX51_xmac_wr2_wr2         0x0000ffffU
#define SRT_NX51_xmac_wr2_wr2         0
#define DFLT_VAL_NX51_xmac_wr2_wr2    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr2_wr2 0x00000000U

/* all used bits of 'NX51_xmac_wr2': */
#define MSK_USED_BITS_NX51_xmac_wr2 0x0000ffffU

enum {
	BFW_NX51_xmac_wr2_wr2       = 16, /* [15:0] */
	BFW_NX51_xmac_wr2_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR2_BIT_Ttag {
	unsigned int wr2       : BFW_NX51_xmac_wr2_wr2;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr2_reserved1; /* reserved      */
} NX51_XMAC_WR2_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR2_BIT_T bf;
} NX51_XMAC_WR2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr3 */
/* => xMAC internal Work Register 3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr3        0x000000C4U
#define Adr_NX51_xmac0_regs_xmac_wr3 0x1018B4C4U
#define Adr_NX51_xmac1_regs_xmac_wr3 0x1018B6C4U
#define DFLT_VAL_NX51_xmac_wr3       0x00000000U

#define MSK_NX51_xmac_wr3_wr3         0x0000ffffU
#define SRT_NX51_xmac_wr3_wr3         0
#define DFLT_VAL_NX51_xmac_wr3_wr3    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr3_wr3 0x00000000U

/* all used bits of 'NX51_xmac_wr3': */
#define MSK_USED_BITS_NX51_xmac_wr3 0x0000ffffU

enum {
	BFW_NX51_xmac_wr3_wr3       = 16, /* [15:0] */
	BFW_NX51_xmac_wr3_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR3_BIT_Ttag {
	unsigned int wr3       : BFW_NX51_xmac_wr3_wr3;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr3_reserved1; /* reserved      */
} NX51_XMAC_WR3_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR3_BIT_T bf;
} NX51_XMAC_WR3_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr4 */
/* => xMAC internal Work Register 4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr4        0x000000C8U
#define Adr_NX51_xmac0_regs_xmac_wr4 0x1018B4C8U
#define Adr_NX51_xmac1_regs_xmac_wr4 0x1018B6C8U
#define DFLT_VAL_NX51_xmac_wr4       0x00000000U

#define MSK_NX51_xmac_wr4_wr4         0x0000ffffU
#define SRT_NX51_xmac_wr4_wr4         0
#define DFLT_VAL_NX51_xmac_wr4_wr4    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr4_wr4 0x00000000U

/* all used bits of 'NX51_xmac_wr4': */
#define MSK_USED_BITS_NX51_xmac_wr4 0x0000ffffU

enum {
	BFW_NX51_xmac_wr4_wr4       = 16, /* [15:0] */
	BFW_NX51_xmac_wr4_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR4_BIT_Ttag {
	unsigned int wr4       : BFW_NX51_xmac_wr4_wr4;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr4_reserved1; /* reserved      */
} NX51_XMAC_WR4_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR4_BIT_T bf;
} NX51_XMAC_WR4_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr5 */
/* => xMAC internal Work Register 5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr5        0x000000CCU
#define Adr_NX51_xmac0_regs_xmac_wr5 0x1018B4CCU
#define Adr_NX51_xmac1_regs_xmac_wr5 0x1018B6CCU
#define DFLT_VAL_NX51_xmac_wr5       0x00000000U

#define MSK_NX51_xmac_wr5_wr5         0x0000ffffU
#define SRT_NX51_xmac_wr5_wr5         0
#define DFLT_VAL_NX51_xmac_wr5_wr5    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr5_wr5 0x00000000U

/* all used bits of 'NX51_xmac_wr5': */
#define MSK_USED_BITS_NX51_xmac_wr5 0x0000ffffU

enum {
	BFW_NX51_xmac_wr5_wr5       = 16, /* [15:0] */
	BFW_NX51_xmac_wr5_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR5_BIT_Ttag {
	unsigned int wr5       : BFW_NX51_xmac_wr5_wr5;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr5_reserved1; /* reserved      */
} NX51_XMAC_WR5_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR5_BIT_T bf;
} NX51_XMAC_WR5_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr6 */
/* => xMAC internal Work Register 6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr6        0x000000D0U
#define Adr_NX51_xmac0_regs_xmac_wr6 0x1018B4D0U
#define Adr_NX51_xmac1_regs_xmac_wr6 0x1018B6D0U
#define DFLT_VAL_NX51_xmac_wr6       0x00000000U

#define MSK_NX51_xmac_wr6_wr6         0x0000ffffU
#define SRT_NX51_xmac_wr6_wr6         0
#define DFLT_VAL_NX51_xmac_wr6_wr6    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr6_wr6 0x00000000U

/* all used bits of 'NX51_xmac_wr6': */
#define MSK_USED_BITS_NX51_xmac_wr6 0x0000ffffU

enum {
	BFW_NX51_xmac_wr6_wr6       = 16, /* [15:0] */
	BFW_NX51_xmac_wr6_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR6_BIT_Ttag {
	unsigned int wr6       : BFW_NX51_xmac_wr6_wr6;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr6_reserved1; /* reserved      */
} NX51_XMAC_WR6_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR6_BIT_T bf;
} NX51_XMAC_WR6_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr7 */
/* => xMAC internal Work Register 7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr7        0x000000D4U
#define Adr_NX51_xmac0_regs_xmac_wr7 0x1018B4D4U
#define Adr_NX51_xmac1_regs_xmac_wr7 0x1018B6D4U
#define DFLT_VAL_NX51_xmac_wr7       0x00000000U

#define MSK_NX51_xmac_wr7_wr7         0x0000ffffU
#define SRT_NX51_xmac_wr7_wr7         0
#define DFLT_VAL_NX51_xmac_wr7_wr7    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr7_wr7 0x00000000U

/* all used bits of 'NX51_xmac_wr7': */
#define MSK_USED_BITS_NX51_xmac_wr7 0x0000ffffU

enum {
	BFW_NX51_xmac_wr7_wr7       = 16, /* [15:0] */
	BFW_NX51_xmac_wr7_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR7_BIT_Ttag {
	unsigned int wr7       : BFW_NX51_xmac_wr7_wr7;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr7_reserved1; /* reserved      */
} NX51_XMAC_WR7_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR7_BIT_T bf;
} NX51_XMAC_WR7_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr8 */
/* => xMAC internal Work Register 8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr8        0x000000D8U
#define Adr_NX51_xmac0_regs_xmac_wr8 0x1018B4D8U
#define Adr_NX51_xmac1_regs_xmac_wr8 0x1018B6D8U
#define DFLT_VAL_NX51_xmac_wr8       0x00000000U

#define MSK_NX51_xmac_wr8_wr8         0x0000ffffU
#define SRT_NX51_xmac_wr8_wr8         0
#define DFLT_VAL_NX51_xmac_wr8_wr8    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr8_wr8 0x00000000U

/* all used bits of 'NX51_xmac_wr8': */
#define MSK_USED_BITS_NX51_xmac_wr8 0x0000ffffU

enum {
	BFW_NX51_xmac_wr8_wr8       = 16, /* [15:0] */
	BFW_NX51_xmac_wr8_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR8_BIT_Ttag {
	unsigned int wr8       : BFW_NX51_xmac_wr8_wr8;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr8_reserved1; /* reserved      */
} NX51_XMAC_WR8_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR8_BIT_T bf;
} NX51_XMAC_WR8_T;

/* --------------------------------------------------------------------- */
/* Register xmac_wr9 */
/* => xMAC internal Work Register 9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_wr9        0x000000DCU
#define Adr_NX51_xmac0_regs_xmac_wr9 0x1018B4DCU
#define Adr_NX51_xmac1_regs_xmac_wr9 0x1018B6DCU
#define DFLT_VAL_NX51_xmac_wr9       0x00000000U

#define MSK_NX51_xmac_wr9_wr9         0x0000ffffU
#define SRT_NX51_xmac_wr9_wr9         0
#define DFLT_VAL_NX51_xmac_wr9_wr9    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_wr9_wr9 0x00000000U

/* all used bits of 'NX51_xmac_wr9': */
#define MSK_USED_BITS_NX51_xmac_wr9 0x0000ffffU

enum {
	BFW_NX51_xmac_wr9_wr9       = 16, /* [15:0] */
	BFW_NX51_xmac_wr9_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_WR9_BIT_Ttag {
	unsigned int wr9       : BFW_NX51_xmac_wr9_wr9;       /* Work Register */
	unsigned int reserved1 : BFW_NX51_xmac_wr9_reserved1; /* reserved      */
} NX51_XMAC_WR9_BIT_T;

typedef union {
	unsigned int        val;
	NX51_XMAC_WR9_BIT_T bf;
} NX51_XMAC_WR9_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sys_time */
/* => xMAC System Time */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sys_time        0x000000E0U
#define Adr_NX51_xmac0_regs_xmac_sys_time 0x1018B4E0U
#define Adr_NX51_xmac1_regs_xmac_sys_time 0x1018B6E0U

#define MSK_NX51_xmac_sys_time_sys_time 0x0000ffffU
#define SRT_NX51_xmac_sys_time_sys_time 0

/* all used bits of 'NX51_xmac_sys_time': */
#define MSK_USED_BITS_NX51_xmac_sys_time 0x0000ffffU

enum {
	BFW_NX51_xmac_sys_time_sys_time  = 16, /* [15:0] */
	BFW_NX51_xmac_sys_time_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SYS_TIME_BIT_Ttag {
	unsigned int sys_time  : BFW_NX51_xmac_sys_time_sys_time;  /* 16 lower bits of 32 bit systime_ns.                                                             */
	                                                           /* Read access to this register will latch sys_time_upper, sys_time_uc and sys_time_uc_upper.      */
	                                                           /* Read access to this register will also latch sys_time, sys_time_uc and clk_phase shown in xPEC. */
	unsigned int reserved1 : BFW_NX51_xmac_sys_time_reserved1; /* reserved                                                                                        */
} NX51_XMAC_SYS_TIME_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_SYS_TIME_BIT_T bf;
} NX51_XMAC_SYS_TIME_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sys_time_upper */
/* => xMAC System Time uppler bits, */
/*    latched at read access of xmac_sys_time. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sys_time_upper        0x000000E4U
#define Adr_NX51_xmac0_regs_xmac_sys_time_upper 0x1018B4E4U
#define Adr_NX51_xmac1_regs_xmac_sys_time_upper 0x1018B6E4U

#define MSK_NX51_xmac_sys_time_upper_val 0x0000ffffU
#define SRT_NX51_xmac_sys_time_upper_val 0

/* all used bits of 'NX51_xmac_sys_time_upper': */
#define MSK_USED_BITS_NX51_xmac_sys_time_upper 0x0000ffffU

enum {
	BFW_NX51_xmac_sys_time_upper_val       = 16, /* [15:0] */
	BFW_NX51_xmac_sys_time_upper_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SYS_TIME_UPPER_BIT_Ttag {
	unsigned int val       : BFW_NX51_xmac_sys_time_upper_val;       /* 16 upper bits of 32 bit systime_ns,               */
	                                                                 /* latched at read access of xmac_sys_time (lower),  */
	                                                                 /* different latch registers for RPU and TPU access. */
	unsigned int reserved1 : BFW_NX51_xmac_sys_time_upper_reserved1; /* reserved                                          */
} NX51_XMAC_SYS_TIME_UPPER_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_XMAC_SYS_TIME_UPPER_BIT_T bf;
} NX51_XMAC_SYS_TIME_UPPER_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sys_time_uc */
/* => xMAC System Time Uncontrolled */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sys_time_uc        0x000000E8U
#define Adr_NX51_xmac0_regs_xmac_sys_time_uc 0x1018B4E8U
#define Adr_NX51_xmac1_regs_xmac_sys_time_uc 0x1018B6E8U

#define MSK_NX51_xmac_sys_time_uc_val 0x0000ffffU
#define SRT_NX51_xmac_sys_time_uc_val 0

/* all used bits of 'NX51_xmac_sys_time_uc': */
#define MSK_USED_BITS_NX51_xmac_sys_time_uc 0x0000ffffU

enum {
	BFW_NX51_xmac_sys_time_uc_val       = 16, /* [15:0] */
	BFW_NX51_xmac_sys_time_uc_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SYS_TIME_UC_BIT_Ttag {
	unsigned int val       : BFW_NX51_xmac_sys_time_uc_val;       /* 16 lower bits of 32 bit systime_uc_ns             */
	                                                              /* latched at read access of xmac_sys_time (lower),  */
	                                                              /* different latch registers for RPU and TPU access. */
	unsigned int reserved1 : BFW_NX51_xmac_sys_time_uc_reserved1; /* reserved                                          */
} NX51_XMAC_SYS_TIME_UC_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_SYS_TIME_UC_BIT_T bf;
} NX51_XMAC_SYS_TIME_UC_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sys_time_uc_upper */
/* => xMAC System Time uppler bits, */
/*    latched at read access of xmac_sys_time. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sys_time_uc_upper        0x000000ECU
#define Adr_NX51_xmac0_regs_xmac_sys_time_uc_upper 0x1018B4ECU
#define Adr_NX51_xmac1_regs_xmac_sys_time_uc_upper 0x1018B6ECU

#define MSK_NX51_xmac_sys_time_uc_upper_val 0x0000ffffU
#define SRT_NX51_xmac_sys_time_uc_upper_val 0

/* all used bits of 'NX51_xmac_sys_time_uc_upper': */
#define MSK_USED_BITS_NX51_xmac_sys_time_uc_upper 0x0000ffffU

enum {
	BFW_NX51_xmac_sys_time_uc_upper_val       = 16, /* [15:0] */
	BFW_NX51_xmac_sys_time_uc_upper_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SYS_TIME_UC_UPPER_BIT_Ttag {
	unsigned int val       : BFW_NX51_xmac_sys_time_uc_upper_val;       /* 16 upper bits of 32 bit systime_uc_ns             */
	                                                                    /* latched at read access of xmac_sys_time (lower),  */
	                                                                    /* different latch registers for RPU and TPU access. */
	unsigned int reserved1 : BFW_NX51_xmac_sys_time_uc_upper_reserved1; /* reserved                                          */
} NX51_XMAC_SYS_TIME_UC_UPPER_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XMAC_SYS_TIME_UC_UPPER_BIT_T bf;
} NX51_XMAC_SYS_TIME_UC_UPPER_T;

/* --------------------------------------------------------------------- */
/* Register xmac_cmp0_status */
/* => xMAC Compare0 Status Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_cmp0_status        0x000000F0U
#define Adr_NX51_xmac0_regs_xmac_cmp0_status 0x1018B4F0U
#define Adr_NX51_xmac1_regs_xmac_cmp0_status 0x1018B6F0U

#define MSK_NX51_xmac_cmp0_status_sr0_z       0x00000001U
#define SRT_NX51_xmac_cmp0_status_sr0_z       0
#define MSK_NX51_xmac_cmp0_status_sr1_z       0x00000002U
#define SRT_NX51_xmac_cmp0_status_sr1_z       1
#define MSK_NX51_xmac_cmp0_status_sr2_z       0x00000004U
#define SRT_NX51_xmac_cmp0_status_sr2_z       2
#define MSK_NX51_xmac_cmp0_status_sr3_z       0x00000008U
#define SRT_NX51_xmac_cmp0_status_sr3_z       3
#define MSK_NX51_xmac_cmp0_status_sr4_z       0x00000010U
#define SRT_NX51_xmac_cmp0_status_sr4_z       4
#define MSK_NX51_xmac_cmp0_status_sr5_z       0x00000020U
#define SRT_NX51_xmac_cmp0_status_sr5_z       5
#define MSK_NX51_xmac_cmp0_status_sr6_z       0x00000040U
#define SRT_NX51_xmac_cmp0_status_sr6_z       6
#define MSK_NX51_xmac_cmp0_status_sr7_z       0x00000080U
#define SRT_NX51_xmac_cmp0_status_sr7_z       7
#define MSK_NX51_xmac_cmp0_status_cnt_rx_z    0x00000100U
#define SRT_NX51_xmac_cmp0_status_cnt_rx_z    8
#define MSK_NX51_xmac_cmp0_status_cnt_tx_z    0x00000200U
#define SRT_NX51_xmac_cmp0_status_cnt_tx_z    9
#define MSK_NX51_xmac_cmp0_status_cnt_rx_hw_z 0x00000400U
#define SRT_NX51_xmac_cmp0_status_cnt_rx_hw_z 10
#define MSK_NX51_xmac_cmp0_status_cnt_tx_hw_z 0x00000800U
#define SRT_NX51_xmac_cmp0_status_cnt_tx_hw_z 11
#define MSK_NX51_xmac_cmp0_status_cnt1_rpu_z  0x00001000U
#define SRT_NX51_xmac_cmp0_status_cnt1_rpu_z  12
#define MSK_NX51_xmac_cmp0_status_cnt2_rpu_z  0x00002000U
#define SRT_NX51_xmac_cmp0_status_cnt2_rpu_z  13
#define MSK_NX51_xmac_cmp0_status_cnt1_tpu_z  0x00004000U
#define SRT_NX51_xmac_cmp0_status_cnt1_tpu_z  14
#define MSK_NX51_xmac_cmp0_status_cnt2_tpu_z  0x00008000U
#define SRT_NX51_xmac_cmp0_status_cnt2_tpu_z  15

/* all used bits of 'NX51_xmac_cmp0_status': */
#define MSK_USED_BITS_NX51_xmac_cmp0_status 0x0000ffffU

enum {
	BFW_NX51_xmac_cmp0_status_sr0_z       = 1,  /* [0] */
	BFW_NX51_xmac_cmp0_status_sr1_z       = 1,  /* [1] */
	BFW_NX51_xmac_cmp0_status_sr2_z       = 1,  /* [2] */
	BFW_NX51_xmac_cmp0_status_sr3_z       = 1,  /* [3] */
	BFW_NX51_xmac_cmp0_status_sr4_z       = 1,  /* [4] */
	BFW_NX51_xmac_cmp0_status_sr5_z       = 1,  /* [5] */
	BFW_NX51_xmac_cmp0_status_sr6_z       = 1,  /* [6] */
	BFW_NX51_xmac_cmp0_status_sr7_z       = 1,  /* [7] */
	BFW_NX51_xmac_cmp0_status_cnt_rx_z    = 1,  /* [8] */
	BFW_NX51_xmac_cmp0_status_cnt_tx_z    = 1,  /* [9] */
	BFW_NX51_xmac_cmp0_status_cnt_rx_hw_z = 1,  /* [10] */
	BFW_NX51_xmac_cmp0_status_cnt_tx_hw_z = 1,  /* [11] */
	BFW_NX51_xmac_cmp0_status_cnt1_rpu_z  = 1,  /* [12] */
	BFW_NX51_xmac_cmp0_status_cnt2_rpu_z  = 1,  /* [13] */
	BFW_NX51_xmac_cmp0_status_cnt1_tpu_z  = 1,  /* [14] */
	BFW_NX51_xmac_cmp0_status_cnt2_tpu_z  = 1,  /* [15] */
	BFW_NX51_xmac_cmp0_status_reserved1   = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CMP0_STATUS_BIT_Ttag {
	unsigned int sr0_z       : BFW_NX51_xmac_cmp0_status_sr0_z;       /* sr0 = 0         */
	unsigned int sr1_z       : BFW_NX51_xmac_cmp0_status_sr1_z;       /* sr1 = 0         */
	unsigned int sr2_z       : BFW_NX51_xmac_cmp0_status_sr2_z;       /* sr2 = 0         */
	unsigned int sr3_z       : BFW_NX51_xmac_cmp0_status_sr3_z;       /* sr3 = 0         */
	unsigned int sr4_z       : BFW_NX51_xmac_cmp0_status_sr4_z;       /* sr4 = 0         */
	unsigned int sr5_z       : BFW_NX51_xmac_cmp0_status_sr5_z;       /* sr5 = 0         */
	unsigned int sr6_z       : BFW_NX51_xmac_cmp0_status_sr6_z;       /* sr6 = 0         */
	unsigned int sr7_z       : BFW_NX51_xmac_cmp0_status_sr7_z;       /* sr7 = 0         */
	unsigned int cnt_rx_z    : BFW_NX51_xmac_cmp0_status_cnt_rx_z;    /* count_rx = 0    */
	unsigned int cnt_tx_z    : BFW_NX51_xmac_cmp0_status_cnt_tx_z;    /* count_tx = 0    */
	unsigned int cnt_rx_hw_z : BFW_NX51_xmac_cmp0_status_cnt_rx_hw_z; /* rx_hw_count = 0 */
	unsigned int cnt_tx_hw_z : BFW_NX51_xmac_cmp0_status_cnt_tx_hw_z; /* tx_hw_count = 0 */
	unsigned int cnt1_rpu_z  : BFW_NX51_xmac_cmp0_status_cnt1_rpu_z;  /* rpu_count1 = 0  */
	unsigned int cnt2_rpu_z  : BFW_NX51_xmac_cmp0_status_cnt2_rpu_z;  /* rpu_count2 = 0  */
	unsigned int cnt1_tpu_z  : BFW_NX51_xmac_cmp0_status_cnt1_tpu_z;  /* tpu_count1 = 0  */
	unsigned int cnt2_tpu_z  : BFW_NX51_xmac_cmp0_status_cnt2_tpu_z;  /* tpu_count2 = 0  */
	unsigned int reserved1   : BFW_NX51_xmac_cmp0_status_reserved1;   /* reserved        */
} NX51_XMAC_CMP0_STATUS_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_CMP0_STATUS_BIT_T bf;
} NX51_XMAC_CMP0_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_cmp1_status */
/* => xMAC Compare1 Status Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_cmp1_status        0x000000F4U
#define Adr_NX51_xmac0_regs_xmac_cmp1_status 0x1018B4F4U
#define Adr_NX51_xmac1_regs_xmac_cmp1_status 0x1018B6F4U

#define MSK_NX51_xmac_cmp1_status_wr0_z   0x00000001U
#define SRT_NX51_xmac_cmp1_status_wr0_z   0
#define MSK_NX51_xmac_cmp1_status_wr1_z   0x00000002U
#define SRT_NX51_xmac_cmp1_status_wr1_z   1
#define MSK_NX51_xmac_cmp1_status_wr2_z   0x00000004U
#define SRT_NX51_xmac_cmp1_status_wr2_z   2
#define MSK_NX51_xmac_cmp1_status_wr3_z   0x00000008U
#define SRT_NX51_xmac_cmp1_status_wr3_z   3
#define MSK_NX51_xmac_cmp1_status_wr4_z   0x00000010U
#define SRT_NX51_xmac_cmp1_status_wr4_z   4
#define MSK_NX51_xmac_cmp1_status_wr5_z   0x00000020U
#define SRT_NX51_xmac_cmp1_status_wr5_z   5
#define MSK_NX51_xmac_cmp1_status_wr6_z   0x00000040U
#define SRT_NX51_xmac_cmp1_status_wr6_z   6
#define MSK_NX51_xmac_cmp1_status_wr7_z   0x00000080U
#define SRT_NX51_xmac_cmp1_status_wr7_z   7
#define MSK_NX51_xmac_cmp1_status_wr8_z   0x00000100U
#define SRT_NX51_xmac_cmp1_status_wr8_z   8
#define MSK_NX51_xmac_cmp1_status_wr9_z   0x00000200U
#define SRT_NX51_xmac_cmp1_status_wr9_z   9
#define MSK_NX51_xmac_cmp1_status_wr0_wr1 0x00000400U
#define SRT_NX51_xmac_cmp1_status_wr0_wr1 10
#define MSK_NX51_xmac_cmp1_status_wr2_wr3 0x00000800U
#define SRT_NX51_xmac_cmp1_status_wr2_wr3 11
#define MSK_NX51_xmac_cmp1_status_wr4_wr5 0x00001000U
#define SRT_NX51_xmac_cmp1_status_wr4_wr5 12
#define MSK_NX51_xmac_cmp1_status_wr6_wr7 0x00002000U
#define SRT_NX51_xmac_cmp1_status_wr6_wr7 13
#define MSK_NX51_xmac_cmp1_status_wr8_wr9 0x00004000U
#define SRT_NX51_xmac_cmp1_status_wr8_wr9 14
#define MSK_NX51_xmac_cmp1_status_zero    0x00008000U
#define SRT_NX51_xmac_cmp1_status_zero    15

/* all used bits of 'NX51_xmac_cmp1_status': */
#define MSK_USED_BITS_NX51_xmac_cmp1_status 0x0000ffffU

enum {
	BFW_NX51_xmac_cmp1_status_wr0_z     = 1,  /* [0] */
	BFW_NX51_xmac_cmp1_status_wr1_z     = 1,  /* [1] */
	BFW_NX51_xmac_cmp1_status_wr2_z     = 1,  /* [2] */
	BFW_NX51_xmac_cmp1_status_wr3_z     = 1,  /* [3] */
	BFW_NX51_xmac_cmp1_status_wr4_z     = 1,  /* [4] */
	BFW_NX51_xmac_cmp1_status_wr5_z     = 1,  /* [5] */
	BFW_NX51_xmac_cmp1_status_wr6_z     = 1,  /* [6] */
	BFW_NX51_xmac_cmp1_status_wr7_z     = 1,  /* [7] */
	BFW_NX51_xmac_cmp1_status_wr8_z     = 1,  /* [8] */
	BFW_NX51_xmac_cmp1_status_wr9_z     = 1,  /* [9] */
	BFW_NX51_xmac_cmp1_status_wr0_wr1   = 1,  /* [10] */
	BFW_NX51_xmac_cmp1_status_wr2_wr3   = 1,  /* [11] */
	BFW_NX51_xmac_cmp1_status_wr4_wr5   = 1,  /* [12] */
	BFW_NX51_xmac_cmp1_status_wr6_wr7   = 1,  /* [13] */
	BFW_NX51_xmac_cmp1_status_wr8_wr9   = 1,  /* [14] */
	BFW_NX51_xmac_cmp1_status_zero      = 1,  /* [15] */
	BFW_NX51_xmac_cmp1_status_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CMP1_STATUS_BIT_Ttag {
	unsigned int wr0_z     : BFW_NX51_xmac_cmp1_status_wr0_z;     /* 1: work register 0 equals 0 */
	unsigned int wr1_z     : BFW_NX51_xmac_cmp1_status_wr1_z;     /* 1: work register 1 equals 0 */
	unsigned int wr2_z     : BFW_NX51_xmac_cmp1_status_wr2_z;     /* 1: work register 2 equals 0 */
	unsigned int wr3_z     : BFW_NX51_xmac_cmp1_status_wr3_z;     /* 1: work register 3 equals 0 */
	unsigned int wr4_z     : BFW_NX51_xmac_cmp1_status_wr4_z;     /* 1: work register 4 equals 0 */
	unsigned int wr5_z     : BFW_NX51_xmac_cmp1_status_wr5_z;     /* 1: work register 5 equals 0 */
	unsigned int wr6_z     : BFW_NX51_xmac_cmp1_status_wr6_z;     /* 1: work register 6 equals 0 */
	unsigned int wr7_z     : BFW_NX51_xmac_cmp1_status_wr7_z;     /* 1: work register 7 equals 0 */
	unsigned int wr8_z     : BFW_NX51_xmac_cmp1_status_wr8_z;     /* 1: work register 8 equals 0 */
	unsigned int wr9_z     : BFW_NX51_xmac_cmp1_status_wr9_z;     /* 1: work register 9 equals 0 */
	unsigned int wr0_wr1   : BFW_NX51_xmac_cmp1_status_wr0_wr1;   /* 1: wr0 equals wr1           */
	unsigned int wr2_wr3   : BFW_NX51_xmac_cmp1_status_wr2_wr3;   /* 1: wr2 equals wr3           */
	unsigned int wr4_wr5   : BFW_NX51_xmac_cmp1_status_wr4_wr5;   /* 1: wr4 equals wr5           */
	unsigned int wr6_wr7   : BFW_NX51_xmac_cmp1_status_wr6_wr7;   /* 1: wr6 equals wr7           */
	unsigned int wr8_wr9   : BFW_NX51_xmac_cmp1_status_wr8_wr9;   /* 1: wr8 equals wr9           */
	unsigned int zero      : BFW_NX51_xmac_cmp1_status_zero;      /* always 0, used by xmacass   */
	unsigned int reserved1 : BFW_NX51_xmac_cmp1_status_reserved1; /* reserved                    */
} NX51_XMAC_CMP1_STATUS_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_CMP1_STATUS_BIT_T bf;
} NX51_XMAC_CMP1_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_cmp2_status */
/* => xMAC Compare2 Status Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_cmp2_status        0x000000F8U
#define Adr_NX51_xmac0_regs_xmac_cmp2_status 0x1018B4F8U
#define Adr_NX51_xmac1_regs_xmac_cmp2_status 0x1018B6F8U

#define MSK_NX51_xmac_cmp2_status_wr0_sr0  0x00000001U
#define SRT_NX51_xmac_cmp2_status_wr0_sr0  0
#define MSK_NX51_xmac_cmp2_status_wr1_sr1  0x00000002U
#define SRT_NX51_xmac_cmp2_status_wr1_sr1  1
#define MSK_NX51_xmac_cmp2_status_wr2_sr2  0x00000004U
#define SRT_NX51_xmac_cmp2_status_wr2_sr2  2
#define MSK_NX51_xmac_cmp2_status_wr3_sr3  0x00000008U
#define SRT_NX51_xmac_cmp2_status_wr3_sr3  3
#define MSK_NX51_xmac_cmp2_status_wr4_sr4  0x00000010U
#define SRT_NX51_xmac_cmp2_status_wr4_sr4  4
#define MSK_NX51_xmac_cmp2_status_wr5_sr5  0x00000020U
#define SRT_NX51_xmac_cmp2_status_wr5_sr5  5
#define MSK_NX51_xmac_cmp2_status_wr6_sr6  0x00000040U
#define SRT_NX51_xmac_cmp2_status_wr6_sr6  6
#define MSK_NX51_xmac_cmp2_status_wr7_sr7  0x00000080U
#define SRT_NX51_xmac_cmp2_status_wr7_sr7  7
#define MSK_NX51_xmac_cmp2_status_wr8_sr8  0x00000100U
#define SRT_NX51_xmac_cmp2_status_wr8_sr8  8
#define MSK_NX51_xmac_cmp2_status_wr9_sr9  0x00000200U
#define SRT_NX51_xmac_cmp2_status_wr9_sr9  9
#define MSK_NX51_xmac_cmp2_status_wr5_sr10 0x00000400U
#define SRT_NX51_xmac_cmp2_status_wr5_sr10 10
#define MSK_NX51_xmac_cmp2_status_wr6_sr11 0x00000800U
#define SRT_NX51_xmac_cmp2_status_wr6_sr11 11
#define MSK_NX51_xmac_cmp2_status_wr5_sr12 0x00001000U
#define SRT_NX51_xmac_cmp2_status_wr5_sr12 12
#define MSK_NX51_xmac_cmp2_status_wr6_sr13 0x00002000U
#define SRT_NX51_xmac_cmp2_status_wr6_sr13 13
#define MSK_NX51_xmac_cmp2_status_wr5_sr14 0x00004000U
#define SRT_NX51_xmac_cmp2_status_wr5_sr14 14
#define MSK_NX51_xmac_cmp2_status_wr6_sr15 0x00008000U
#define SRT_NX51_xmac_cmp2_status_wr6_sr15 15

/* all used bits of 'NX51_xmac_cmp2_status': */
#define MSK_USED_BITS_NX51_xmac_cmp2_status 0x0000ffffU

enum {
	BFW_NX51_xmac_cmp2_status_wr0_sr0   = 1,  /* [0] */
	BFW_NX51_xmac_cmp2_status_wr1_sr1   = 1,  /* [1] */
	BFW_NX51_xmac_cmp2_status_wr2_sr2   = 1,  /* [2] */
	BFW_NX51_xmac_cmp2_status_wr3_sr3   = 1,  /* [3] */
	BFW_NX51_xmac_cmp2_status_wr4_sr4   = 1,  /* [4] */
	BFW_NX51_xmac_cmp2_status_wr5_sr5   = 1,  /* [5] */
	BFW_NX51_xmac_cmp2_status_wr6_sr6   = 1,  /* [6] */
	BFW_NX51_xmac_cmp2_status_wr7_sr7   = 1,  /* [7] */
	BFW_NX51_xmac_cmp2_status_wr8_sr8   = 1,  /* [8] */
	BFW_NX51_xmac_cmp2_status_wr9_sr9   = 1,  /* [9] */
	BFW_NX51_xmac_cmp2_status_wr5_sr10  = 1,  /* [10] */
	BFW_NX51_xmac_cmp2_status_wr6_sr11  = 1,  /* [11] */
	BFW_NX51_xmac_cmp2_status_wr5_sr12  = 1,  /* [12] */
	BFW_NX51_xmac_cmp2_status_wr6_sr13  = 1,  /* [13] */
	BFW_NX51_xmac_cmp2_status_wr5_sr14  = 1,  /* [14] */
	BFW_NX51_xmac_cmp2_status_wr6_sr15  = 1,  /* [15] */
	BFW_NX51_xmac_cmp2_status_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CMP2_STATUS_BIT_Ttag {
	unsigned int wr0_sr0   : BFW_NX51_xmac_cmp2_status_wr0_sr0;   /* 1: wr0 equals sr0  */
	unsigned int wr1_sr1   : BFW_NX51_xmac_cmp2_status_wr1_sr1;   /* 1: wr1 equals sr1  */
	unsigned int wr2_sr2   : BFW_NX51_xmac_cmp2_status_wr2_sr2;   /* 1: wr2 equals sr2  */
	unsigned int wr3_sr3   : BFW_NX51_xmac_cmp2_status_wr3_sr3;   /* 1: wr3 equals sr3  */
	unsigned int wr4_sr4   : BFW_NX51_xmac_cmp2_status_wr4_sr4;   /* 1: wr4 equals sr4  */
	unsigned int wr5_sr5   : BFW_NX51_xmac_cmp2_status_wr5_sr5;   /* 1: wr5 equals sr5  */
	unsigned int wr6_sr6   : BFW_NX51_xmac_cmp2_status_wr6_sr6;   /* 1: wr6 equals sr6  */
	unsigned int wr7_sr7   : BFW_NX51_xmac_cmp2_status_wr7_sr7;   /* 1: wr7 equals sr7  */
	unsigned int wr8_sr8   : BFW_NX51_xmac_cmp2_status_wr8_sr8;   /* 1: wr8 equals sr8  */
	unsigned int wr9_sr9   : BFW_NX51_xmac_cmp2_status_wr9_sr9;   /* 1: wr9 equals sr9  */
	unsigned int wr5_sr10  : BFW_NX51_xmac_cmp2_status_wr5_sr10;  /* 1: wr5 equals sr10 */
	unsigned int wr6_sr11  : BFW_NX51_xmac_cmp2_status_wr6_sr11;  /* 1: wr6 equals sr11 */
	unsigned int wr5_sr12  : BFW_NX51_xmac_cmp2_status_wr5_sr12;  /* 1: wr5 equals sr12 */
	unsigned int wr6_sr13  : BFW_NX51_xmac_cmp2_status_wr6_sr13;  /* 1: wr6 equals sr13 */
	unsigned int wr5_sr14  : BFW_NX51_xmac_cmp2_status_wr5_sr14;  /* 1: wr5 equals sr14 */
	unsigned int wr6_sr15  : BFW_NX51_xmac_cmp2_status_wr6_sr15;  /* 1: wr6 equals sr15 */
	unsigned int reserved1 : BFW_NX51_xmac_cmp2_status_reserved1; /* reserved           */
} NX51_XMAC_CMP2_STATUS_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_CMP2_STATUS_BIT_T bf;
} NX51_XMAC_CMP2_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_cmp3_status */
/* => xMAC Compare3 Status Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_cmp3_status        0x000000FCU
#define Adr_NX51_xmac0_regs_xmac_cmp3_status 0x1018B4FCU
#define Adr_NX51_xmac1_regs_xmac_cmp3_status 0x1018B6FCU

#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr0 0x00000001U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr0 0
#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr1 0x00000002U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr1 1
#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr2 0x00000004U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr2 2
#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr3 0x00000008U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr3 3
#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr4 0x00000010U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr4 4
#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr5 0x00000020U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr5 5
#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr6 0x00000040U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr6 6
#define MSK_NX51_xmac_cmp3_status_rpucnt1_wr7 0x00000080U
#define SRT_NX51_xmac_cmp3_status_rpucnt1_wr7 7
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr0 0x00000100U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr0 8
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr1 0x00000200U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr1 9
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr2 0x00000400U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr2 10
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr3 0x00000800U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr3 11
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr4 0x00001000U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr4 12
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr5 0x00002000U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr5 13
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr6 0x00004000U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr6 14
#define MSK_NX51_xmac_cmp3_status_tpucnt1_wr7 0x00008000U
#define SRT_NX51_xmac_cmp3_status_tpucnt1_wr7 15

/* all used bits of 'NX51_xmac_cmp3_status': */
#define MSK_USED_BITS_NX51_xmac_cmp3_status 0x0000ffffU

enum {
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr0 = 1,  /* [0] */
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr1 = 1,  /* [1] */
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr2 = 1,  /* [2] */
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr3 = 1,  /* [3] */
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr4 = 1,  /* [4] */
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr5 = 1,  /* [5] */
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr6 = 1,  /* [6] */
	BFW_NX51_xmac_cmp3_status_rpucnt1_wr7 = 1,  /* [7] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr0 = 1,  /* [8] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr1 = 1,  /* [9] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr2 = 1,  /* [10] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr3 = 1,  /* [11] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr4 = 1,  /* [12] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr5 = 1,  /* [13] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr6 = 1,  /* [14] */
	BFW_NX51_xmac_cmp3_status_tpucnt1_wr7 = 1,  /* [15] */
	BFW_NX51_xmac_cmp3_status_reserved1   = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CMP3_STATUS_BIT_Ttag {
	unsigned int rpucnt1_wr0 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr0; /* 1: rpu_count1 equals wr0 */
	unsigned int rpucnt1_wr1 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr1; /* 1: rpu_count1 equals wr1 */
	unsigned int rpucnt1_wr2 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr2; /* 1: rpu_count1 equals wr2 */
	unsigned int rpucnt1_wr3 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr3; /* 1: rpu_count1 equals wr3 */
	unsigned int rpucnt1_wr4 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr4; /* 1: rpu_count1 equals wr4 */
	unsigned int rpucnt1_wr5 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr5; /* 1: rpu_count1 equals wr5 */
	unsigned int rpucnt1_wr6 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr6; /* 1: rpu_count1 equals wr6 */
	unsigned int rpucnt1_wr7 : BFW_NX51_xmac_cmp3_status_rpucnt1_wr7; /* 1: rpu_count1 equals wr7 */
	unsigned int tpucnt1_wr0 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr0; /* 1: tpu_count1 equals wr0 */
	unsigned int tpucnt1_wr1 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr1; /* 1: tpu_count1 equals wr1 */
	unsigned int tpucnt1_wr2 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr2; /* 1: tpu_count1 equals wr2 */
	unsigned int tpucnt1_wr3 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr3; /* 1: tpu_count1 equals wr3 */
	unsigned int tpucnt1_wr4 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr4; /* 1: tpu_count1 equals wr4 */
	unsigned int tpucnt1_wr5 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr5; /* 1: tpu_count1 equals wr5 */
	unsigned int tpucnt1_wr6 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr6; /* 1: tpu_count1 equals wr6 */
	unsigned int tpucnt1_wr7 : BFW_NX51_xmac_cmp3_status_tpucnt1_wr7; /* 1: tpu_count1 equals wr7 */
	unsigned int reserved1   : BFW_NX51_xmac_cmp3_status_reserved1;   /* reserved                 */
} NX51_XMAC_CMP3_STATUS_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_CMP3_STATUS_BIT_T bf;
} NX51_XMAC_CMP3_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_cmp4_status */
/* => xMAC Compare4 Status Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_cmp4_status        0x00000100U
#define Adr_NX51_xmac0_regs_xmac_cmp4_status 0x1018B500U
#define Adr_NX51_xmac1_regs_xmac_cmp4_status 0x1018B700U

#define MSK_NX51_xmac_cmp4_status_rpm_hit0           0x00000001U
#define SRT_NX51_xmac_cmp4_status_rpm_hit0           0
#define MSK_NX51_xmac_cmp4_status_rpm_hit1           0x00000002U
#define SRT_NX51_xmac_cmp4_status_rpm_hit1           1
#define MSK_NX51_xmac_cmp4_status_rpm_hit0or1        0x00000004U
#define SRT_NX51_xmac_cmp4_status_rpm_hit0or1        2
#define MSK_NX51_xmac_cmp4_status_tpm_hit0           0x00000008U
#define SRT_NX51_xmac_cmp4_status_tpm_hit0           3
#define MSK_NX51_xmac_cmp4_status_tpm_hit1           0x00000010U
#define SRT_NX51_xmac_cmp4_status_tpm_hit1           4
#define MSK_NX51_xmac_cmp4_status_tpm_hit0or1        0x00000020U
#define SRT_NX51_xmac_cmp4_status_tpm_hit0or1        5
#define MSK_NX51_xmac_cmp4_status_rpm_hit0_tx        0x00000040U
#define SRT_NX51_xmac_cmp4_status_rpm_hit0_tx        6
#define MSK_NX51_xmac_cmp4_status_rpm_hit1_tx        0x00000080U
#define SRT_NX51_xmac_cmp4_status_rpm_hit1_tx        7
#define MSK_NX51_xmac_cmp4_status_rpm_hit0or1_tx     0x00000100U
#define SRT_NX51_xmac_cmp4_status_rpm_hit0or1_tx     8
#define MSK_NX51_xmac_cmp4_status_tpm_hit0_rx        0x00000200U
#define SRT_NX51_xmac_cmp4_status_tpm_hit0_rx        9
#define MSK_NX51_xmac_cmp4_status_tpm_hit1_rx        0x00000400U
#define SRT_NX51_xmac_cmp4_status_tpm_hit1_rx        10
#define MSK_NX51_xmac_cmp4_status_tpm_hit0or1_rx     0x00000800U
#define SRT_NX51_xmac_cmp4_status_tpm_hit0or1_rx     11
#define MSK_NX51_xmac_cmp4_status_tx_eq_wr45         0x00001000U
#define SRT_NX51_xmac_cmp4_status_tx_eq_wr45         12
#define MSK_NX51_xmac_cmp4_status_sys_time           0x00002000U
#define SRT_NX51_xmac_cmp4_status_sys_time           13
#define MSK_NX51_xmac_cmp4_status_sys_time_uc        0x00004000U
#define SRT_NX51_xmac_cmp4_status_sys_time_uc        14
#define MSK_NX51_xmac_cmp4_status_sys_time_uc_eq_wr2 0x00008000U
#define SRT_NX51_xmac_cmp4_status_sys_time_uc_eq_wr2 15

/* all used bits of 'NX51_xmac_cmp4_status': */
#define MSK_USED_BITS_NX51_xmac_cmp4_status 0x0000ffffU

enum {
	BFW_NX51_xmac_cmp4_status_rpm_hit0           = 1,  /* [0] */
	BFW_NX51_xmac_cmp4_status_rpm_hit1           = 1,  /* [1] */
	BFW_NX51_xmac_cmp4_status_rpm_hit0or1        = 1,  /* [2] */
	BFW_NX51_xmac_cmp4_status_tpm_hit0           = 1,  /* [3] */
	BFW_NX51_xmac_cmp4_status_tpm_hit1           = 1,  /* [4] */
	BFW_NX51_xmac_cmp4_status_tpm_hit0or1        = 1,  /* [5] */
	BFW_NX51_xmac_cmp4_status_rpm_hit0_tx        = 1,  /* [6] */
	BFW_NX51_xmac_cmp4_status_rpm_hit1_tx        = 1,  /* [7] */
	BFW_NX51_xmac_cmp4_status_rpm_hit0or1_tx     = 1,  /* [8] */
	BFW_NX51_xmac_cmp4_status_tpm_hit0_rx        = 1,  /* [9] */
	BFW_NX51_xmac_cmp4_status_tpm_hit1_rx        = 1,  /* [10] */
	BFW_NX51_xmac_cmp4_status_tpm_hit0or1_rx     = 1,  /* [11] */
	BFW_NX51_xmac_cmp4_status_tx_eq_wr45         = 1,  /* [12] */
	BFW_NX51_xmac_cmp4_status_sys_time           = 1,  /* [13] */
	BFW_NX51_xmac_cmp4_status_sys_time_uc        = 1,  /* [14] */
	BFW_NX51_xmac_cmp4_status_sys_time_uc_eq_wr2 = 1,  /* [15] */
	BFW_NX51_xmac_cmp4_status_reserved1          = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CMP4_STATUS_BIT_Ttag {
	unsigned int rpm_hit0           : BFW_NX51_xmac_cmp4_status_rpm_hit0;           /* receive pattern 0 matches                                                 */
	unsigned int rpm_hit1           : BFW_NX51_xmac_cmp4_status_rpm_hit1;           /* receive pattern 1 matches                                                 */
	unsigned int rpm_hit0or1        : BFW_NX51_xmac_cmp4_status_rpm_hit0or1;        /* receive pattern 0 or pattern 1 matches                                    */
	unsigned int tpm_hit0           : BFW_NX51_xmac_cmp4_status_tpm_hit0;           /* transmit pattern 0 matches                                                */
	unsigned int tpm_hit1           : BFW_NX51_xmac_cmp4_status_tpm_hit1;           /* transmit pattern 1 matches                                                */
	unsigned int tpm_hit0or1        : BFW_NX51_xmac_cmp4_status_tpm_hit0or1;        /* transmit pattern 0 or pattern 1 matches                                   */
	unsigned int rpm_hit0_tx        : BFW_NX51_xmac_cmp4_status_rpm_hit0_tx;        /* receive pattern 0 matches with tx_sent register                           */
	unsigned int rpm_hit1_tx        : BFW_NX51_xmac_cmp4_status_rpm_hit1_tx;        /* receive pattern 1 matches with tx_sent register                           */
	unsigned int rpm_hit0or1_tx     : BFW_NX51_xmac_cmp4_status_rpm_hit0or1_tx;     /* receive pattern 0 or pattern 1 matches with tx_sent register              */
	unsigned int tpm_hit0_rx        : BFW_NX51_xmac_cmp4_status_tpm_hit0_rx;        /* transmit pattern 0 matches with rx register                               */
	unsigned int tpm_hit1_rx        : BFW_NX51_xmac_cmp4_status_tpm_hit1_rx;        /* transmit pattern 1 matches with rx register                               */
	unsigned int tpm_hit0or1_rx     : BFW_NX51_xmac_cmp4_status_tpm_hit0or1_rx;     /* transmit pattern 0 or pattern 1 matches with rx register                  */
	unsigned int tx_eq_wr45         : BFW_NX51_xmac_cmp4_status_tx_eq_wr45;         /* compare of tx with wr4(value) and wr5(mask):                              */
	                                                                                /* wr5 defines, which bits of tx and wr4 are to be compared                  */
	                                                                                /* (1: compare this bit position, 0: ignore this bit position)               */
	unsigned int sys_time           : BFW_NX51_xmac_cmp4_status_sys_time;           /* compare of sys_time with wr6,wr2(value) and wr7,wr3(mask):                */
	                                                                                /* {wr7,wr3} define, which bits of sys_time and {wr6,wr2} are to be compared */
	                                                                                /* (1: compare this bit position, 0: ignore this bit position)               */
	unsigned int sys_time_uc        : BFW_NX51_xmac_cmp4_status_sys_time_uc;        /* compare of sys_time_uc with wr6,wr2(value) and wr7,wr3(mask):             */
	                                                                                /* {wr7,wr3} define, which bits of sys_time and {wr6,wr2} are to be compared */
	                                                                                /* (1: compare this bit position, 0: ignore this bit position)               */
	unsigned int sys_time_uc_eq_wr2 : BFW_NX51_xmac_cmp4_status_sys_time_uc_eq_wr2; /* systime_uc[15:0] equals wr2 (without any mask function).                  */
	unsigned int reserved1          : BFW_NX51_xmac_cmp4_status_reserved1;          /* reserved                                                                  */
} NX51_XMAC_CMP4_STATUS_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_CMP4_STATUS_BIT_T bf;
} NX51_XMAC_CMP4_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_alu_flags */
/* => xMAC RPU and TPU ALU Flags: */
/*    ALU Flags are only influenced by combinatonal commands like add, sub, rotate, shift. */
/*    Bitwise commands (e.g. and, or, ...) do not influence ALU-Flags. */
/*    In case of bitwise commands, ALU-Flags keep their old value. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_alu_flags        0x00000104U
#define Adr_NX51_xmac0_regs_xmac_alu_flags 0x1018B504U
#define Adr_NX51_xmac1_regs_xmac_alu_flags 0x1018B704U

#define MSK_NX51_xmac_alu_flags_rpu_carry 0x00000001U
#define SRT_NX51_xmac_alu_flags_rpu_carry 0
#define MSK_NX51_xmac_alu_flags_rpu_zero  0x00000002U
#define SRT_NX51_xmac_alu_flags_rpu_zero  1
#define MSK_NX51_xmac_alu_flags_rpu_neg   0x00000004U
#define SRT_NX51_xmac_alu_flags_rpu_neg   2
#define MSK_NX51_xmac_alu_flags_rpu_ovf   0x00000008U
#define SRT_NX51_xmac_alu_flags_rpu_ovf   3
#define MSK_NX51_xmac_alu_flags_tpu_carry 0x00000010U
#define SRT_NX51_xmac_alu_flags_tpu_carry 4
#define MSK_NX51_xmac_alu_flags_tpu_zero  0x00000020U
#define SRT_NX51_xmac_alu_flags_tpu_zero  5
#define MSK_NX51_xmac_alu_flags_tpu_neg   0x00000040U
#define SRT_NX51_xmac_alu_flags_tpu_neg   6
#define MSK_NX51_xmac_alu_flags_tpu_ovf   0x00000080U
#define SRT_NX51_xmac_alu_flags_tpu_ovf   7
#define MSK_NX51_xmac_alu_flags_rxcnt_wr0 0x00000100U
#define SRT_NX51_xmac_alu_flags_rxcnt_wr0 8
#define MSK_NX51_xmac_alu_flags_rxcnt_wr1 0x00000200U
#define SRT_NX51_xmac_alu_flags_rxcnt_wr1 9
#define MSK_NX51_xmac_alu_flags_rxcnt_wr2 0x00000400U
#define SRT_NX51_xmac_alu_flags_rxcnt_wr2 10
#define MSK_NX51_xmac_alu_flags_rxcnt_wr3 0x00000800U
#define SRT_NX51_xmac_alu_flags_rxcnt_wr3 11
#define MSK_NX51_xmac_alu_flags_txcnt_wr4 0x00001000U
#define SRT_NX51_xmac_alu_flags_txcnt_wr4 12
#define MSK_NX51_xmac_alu_flags_txcnt_wr5 0x00002000U
#define SRT_NX51_xmac_alu_flags_txcnt_wr5 13
#define MSK_NX51_xmac_alu_flags_txcnt_wr6 0x00004000U
#define SRT_NX51_xmac_alu_flags_txcnt_wr6 14
#define MSK_NX51_xmac_alu_flags_txcnt_wr7 0x00008000U
#define SRT_NX51_xmac_alu_flags_txcnt_wr7 15

/* all used bits of 'NX51_xmac_alu_flags': */
#define MSK_USED_BITS_NX51_xmac_alu_flags 0x0000ffffU

enum {
	BFW_NX51_xmac_alu_flags_rpu_carry = 1,  /* [0] */
	BFW_NX51_xmac_alu_flags_rpu_zero  = 1,  /* [1] */
	BFW_NX51_xmac_alu_flags_rpu_neg   = 1,  /* [2] */
	BFW_NX51_xmac_alu_flags_rpu_ovf   = 1,  /* [3] */
	BFW_NX51_xmac_alu_flags_tpu_carry = 1,  /* [4] */
	BFW_NX51_xmac_alu_flags_tpu_zero  = 1,  /* [5] */
	BFW_NX51_xmac_alu_flags_tpu_neg   = 1,  /* [6] */
	BFW_NX51_xmac_alu_flags_tpu_ovf   = 1,  /* [7] */
	BFW_NX51_xmac_alu_flags_rxcnt_wr0 = 1,  /* [8] */
	BFW_NX51_xmac_alu_flags_rxcnt_wr1 = 1,  /* [9] */
	BFW_NX51_xmac_alu_flags_rxcnt_wr2 = 1,  /* [10] */
	BFW_NX51_xmac_alu_flags_rxcnt_wr3 = 1,  /* [11] */
	BFW_NX51_xmac_alu_flags_txcnt_wr4 = 1,  /* [12] */
	BFW_NX51_xmac_alu_flags_txcnt_wr5 = 1,  /* [13] */
	BFW_NX51_xmac_alu_flags_txcnt_wr6 = 1,  /* [14] */
	BFW_NX51_xmac_alu_flags_txcnt_wr7 = 1,  /* [15] */
	BFW_NX51_xmac_alu_flags_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_ALU_FLAGS_BIT_Ttag {
	unsigned int rpu_carry : BFW_NX51_xmac_alu_flags_rpu_carry; /* RPU carry flag                                              */
	unsigned int rpu_zero  : BFW_NX51_xmac_alu_flags_rpu_zero;  /* RPU zero flag                                               */
	unsigned int rpu_neg   : BFW_NX51_xmac_alu_flags_rpu_neg;   /* RPU neg flag                                                */
	unsigned int rpu_ovf   : BFW_NX51_xmac_alu_flags_rpu_ovf;   /* RPU ovf flag                                                */
	unsigned int tpu_carry : BFW_NX51_xmac_alu_flags_tpu_carry; /* TPU carry flag                                              */
	unsigned int tpu_zero  : BFW_NX51_xmac_alu_flags_tpu_zero;  /* TPU zero flag                                               */
	unsigned int tpu_neg   : BFW_NX51_xmac_alu_flags_tpu_neg;   /* TPU neg flag                                                */
	unsigned int tpu_ovf   : BFW_NX51_xmac_alu_flags_tpu_ovf;   /* TPU ovf flag                                                */
	unsigned int rxcnt_wr0 : BFW_NX51_xmac_alu_flags_rxcnt_wr0; /* 1: rx_count equals wr0, no ALU-Flag, calculated every cycle */
	unsigned int rxcnt_wr1 : BFW_NX51_xmac_alu_flags_rxcnt_wr1; /* 1: rx_count equals wr1, no ALU-Flag, calculated every cycle */
	unsigned int rxcnt_wr2 : BFW_NX51_xmac_alu_flags_rxcnt_wr2; /* 1: rx_count equals wr2, no ALU-Flag, calculated every cycle */
	unsigned int rxcnt_wr3 : BFW_NX51_xmac_alu_flags_rxcnt_wr3; /* 1: rx_count equals wr3, no ALU-Flag, calculated every cycle */
	unsigned int txcnt_wr4 : BFW_NX51_xmac_alu_flags_txcnt_wr4; /* 1: tx_count equals wr4, no ALU-Flag, calculated every cycle */
	unsigned int txcnt_wr5 : BFW_NX51_xmac_alu_flags_txcnt_wr5; /* 1: tx_count equals wr5, no ALU-Flag, calculated every cycle */
	unsigned int txcnt_wr6 : BFW_NX51_xmac_alu_flags_txcnt_wr6; /* 1: tx_count equals wr6, no ALU-Flag, calculated every cycle */
	unsigned int txcnt_wr7 : BFW_NX51_xmac_alu_flags_txcnt_wr7; /* 1: tx_count equals wr7, no ALU-Flag, calculated every cycle */
	unsigned int reserved1 : BFW_NX51_xmac_alu_flags_reserved1; /* reserved                                                    */
} NX51_XMAC_ALU_FLAGS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XMAC_ALU_FLAGS_BIT_T bf;
} NX51_XMAC_ALU_FLAGS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_status_int */
/* => xMAC Status Internal Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_status_int        0x00000108U
#define Adr_NX51_xmac0_regs_xmac_status_int 0x1018B508U
#define Adr_NX51_xmac1_regs_xmac_status_int 0x1018B708U

#define MSK_NX51_xmac_status_int_rx_crc_ok             0x00000001U
#define SRT_NX51_xmac_status_int_rx_crc_ok             0
#define MSK_NX51_xmac_status_int_tx_crc_ok             0x00000002U
#define SRT_NX51_xmac_status_int_tx_crc_ok             1
#define MSK_NX51_xmac_status_int_rx_crc32_ok           0x00000004U
#define SRT_NX51_xmac_status_int_rx_crc32_ok           2
#define MSK_NX51_xmac_status_int_bitstream_in_filtered 0x00000008U
#define SRT_NX51_xmac_status_int_bitstream_in_filtered 3
#define MSK_NX51_xmac_status_int_lbit_eq_bit           0x00000010U
#define SRT_NX51_xmac_status_int_lbit_eq_bit           4
#define MSK_NX51_xmac_status_int_recbit                0x00000020U
#define SRT_NX51_xmac_status_int_recbit                5
#define MSK_NX51_xmac_status_int_brec                  0x00000040U
#define SRT_NX51_xmac_status_int_brec                  6
#define MSK_NX51_xmac_status_int_btran                 0x00000080U
#define SRT_NX51_xmac_status_int_btran                 7
#define MSK_NX51_xmac_status_int_rpucnt2_wr0           0x00000100U
#define SRT_NX51_xmac_status_int_rpucnt2_wr0           8
#define MSK_NX51_xmac_status_int_rpucnt2_wr1           0x00000200U
#define SRT_NX51_xmac_status_int_rpucnt2_wr1           9
#define MSK_NX51_xmac_status_int_rpucnt2_wr2           0x00000400U
#define SRT_NX51_xmac_status_int_rpucnt2_wr2           10
#define MSK_NX51_xmac_status_int_rpucnt2_wr3           0x00000800U
#define SRT_NX51_xmac_status_int_rpucnt2_wr3           11
#define MSK_NX51_xmac_status_int_tpucnt2_wr4           0x00001000U
#define SRT_NX51_xmac_status_int_tpucnt2_wr4           12
#define MSK_NX51_xmac_status_int_tpucnt2_wr5           0x00002000U
#define SRT_NX51_xmac_status_int_tpucnt2_wr5           13
#define MSK_NX51_xmac_status_int_tpucnt2_wr6           0x00004000U
#define SRT_NX51_xmac_status_int_tpucnt2_wr6           14
#define MSK_NX51_xmac_status_int_tpucnt2_wr7           0x00008000U
#define SRT_NX51_xmac_status_int_tpucnt2_wr7           15

/* all used bits of 'NX51_xmac_status_int': */
#define MSK_USED_BITS_NX51_xmac_status_int 0x0000ffffU

enum {
	BFW_NX51_xmac_status_int_rx_crc_ok             = 1,  /* [0] */
	BFW_NX51_xmac_status_int_tx_crc_ok             = 1,  /* [1] */
	BFW_NX51_xmac_status_int_rx_crc32_ok           = 1,  /* [2] */
	BFW_NX51_xmac_status_int_bitstream_in_filtered = 1,  /* [3] */
	BFW_NX51_xmac_status_int_lbit_eq_bit           = 1,  /* [4] */
	BFW_NX51_xmac_status_int_recbit                = 1,  /* [5] */
	BFW_NX51_xmac_status_int_brec                  = 1,  /* [6] */
	BFW_NX51_xmac_status_int_btran                 = 1,  /* [7] */
	BFW_NX51_xmac_status_int_rpucnt2_wr0           = 1,  /* [8] */
	BFW_NX51_xmac_status_int_rpucnt2_wr1           = 1,  /* [9] */
	BFW_NX51_xmac_status_int_rpucnt2_wr2           = 1,  /* [10] */
	BFW_NX51_xmac_status_int_rpucnt2_wr3           = 1,  /* [11] */
	BFW_NX51_xmac_status_int_tpucnt2_wr4           = 1,  /* [12] */
	BFW_NX51_xmac_status_int_tpucnt2_wr5           = 1,  /* [13] */
	BFW_NX51_xmac_status_int_tpucnt2_wr6           = 1,  /* [14] */
	BFW_NX51_xmac_status_int_tpucnt2_wr7           = 1,  /* [15] */
	BFW_NX51_xmac_status_int_reserved1             = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STATUS_INT_BIT_Ttag {
	unsigned int rx_crc_ok             : BFW_NX51_xmac_status_int_rx_crc_ok;             /* compare of rx_crc_l/_h with wr0/1:                                                  */
	unsigned int tx_crc_ok             : BFW_NX51_xmac_status_int_tx_crc_ok;             /* compare of tx_crc_l/_h with wr8/9:                                                  */
	unsigned int rx_crc32_ok           : BFW_NX51_xmac_status_int_rx_crc32_ok;           /* compare of rx_crc32 with 0xc704dd7b                                                 */
	unsigned int bitstream_in_filtered : BFW_NX51_xmac_status_int_bitstream_in_filtered; /* input after signal_filter but before sample_unit, might be used to control rate_mul */
	unsigned int lbit_eq_bit           : BFW_NX51_xmac_status_int_lbit_eq_bit;           /* last received bit = actually received bit                                           */
	unsigned int recbit                : BFW_NX51_xmac_status_int_recbit;                /* acutally received bit                                                               */
	unsigned int brec                  : BFW_NX51_xmac_status_int_brec;                  /* bit received (active for 1 cc)                                                      */
	unsigned int btran                 : BFW_NX51_xmac_status_int_btran;                 /* bit transmitted (active for 1 cc)                                                   */
	unsigned int rpucnt2_wr0           : BFW_NX51_xmac_status_int_rpucnt2_wr0;           /* 1: rpu_count2 equals wr0                                                            */
	unsigned int rpucnt2_wr1           : BFW_NX51_xmac_status_int_rpucnt2_wr1;           /* 1: rpu_count2 equals wr1                                                            */
	unsigned int rpucnt2_wr2           : BFW_NX51_xmac_status_int_rpucnt2_wr2;           /* 1: rpu_count2 equals wr2                                                            */
	unsigned int rpucnt2_wr3           : BFW_NX51_xmac_status_int_rpucnt2_wr3;           /* 1: rpu_count2 equals wr3                                                            */
	unsigned int tpucnt2_wr4           : BFW_NX51_xmac_status_int_tpucnt2_wr4;           /* 1: tpu_count2 equals wr4                                                            */
	unsigned int tpucnt2_wr5           : BFW_NX51_xmac_status_int_tpucnt2_wr5;           /* 1: tpu_count2 equals wr5                                                            */
	unsigned int tpucnt2_wr6           : BFW_NX51_xmac_status_int_tpucnt2_wr6;           /* 1: tpu_count2 equals wr6                                                            */
	unsigned int tpucnt2_wr7           : BFW_NX51_xmac_status_int_tpucnt2_wr7;           /* 1: tpu_count2 equals wr7                                                            */
	unsigned int reserved1             : BFW_NX51_xmac_status_int_reserved1;             /* reserved                                                                            */
} NX51_XMAC_STATUS_INT_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_STATUS_INT_BIT_T bf;
} NX51_XMAC_STATUS_INT_T;

/* --------------------------------------------------------------------- */
/* Register xmac_stat_bits */
/* => xMAC stat_bits: */
/*    set and reset by hw_support bits (set_stat and reset_stat) and selected by src1_adr, */
/*    accessible by all RPUs and TPUs with higher set than reset priority */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_stat_bits        0x0000010CU
#define Adr_NX51_xmac0_regs_xmac_stat_bits 0x1018B50CU
#define Adr_NX51_xmac1_regs_xmac_stat_bits 0x1018B70CU

#define MSK_NX51_xmac_stat_bits_stat_bits 0x0000ffffU
#define SRT_NX51_xmac_stat_bits_stat_bits 0

/* all used bits of 'NX51_xmac_stat_bits': */
#define MSK_USED_BITS_NX51_xmac_stat_bits 0x0000ffffU

enum {
	BFW_NX51_xmac_stat_bits_stat_bits = 16, /* [15:0] */
	BFW_NX51_xmac_stat_bits_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STAT_BITS_BIT_Ttag {
	unsigned int stat_bits : BFW_NX51_xmac_stat_bits_stat_bits; /* seperate bits selected by lower bits of src1_adr, if set_stat/reset_stat are active */
	unsigned int reserved1 : BFW_NX51_xmac_stat_bits_reserved1; /* reserved                                                                            */
} NX51_XMAC_STAT_BITS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XMAC_STAT_BITS_BIT_T bf;
} NX51_XMAC_STAT_BITS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_stat_bits_shared_lower */
/* => stat_bits_shared (lower): */
/*    These bits can be accessed by all xMACs and xPECs in parallel, all accesses with write bit mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_stat_bits_shared_lower        0x00000110U
#define Adr_NX51_xmac0_regs_xmac_stat_bits_shared_lower 0x1018B510U
#define Adr_NX51_xmac1_regs_xmac_stat_bits_shared_lower 0x1018B710U
#define DFLT_VAL_NX51_xmac_stat_bits_shared_lower       0x00000000U

#define MSK_NX51_xmac_stat_bits_shared_lower_val                0x000000ffU
#define SRT_NX51_xmac_stat_bits_shared_lower_val                0
#define DFLT_VAL_NX51_xmac_stat_bits_shared_lower_val           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_stat_bits_shared_lower_val        0x00000000U
#define MSK_NX51_xmac_stat_bits_shared_lower_write_mask         0x0000ff00U
#define SRT_NX51_xmac_stat_bits_shared_lower_write_mask         8
#define DFLT_VAL_NX51_xmac_stat_bits_shared_lower_write_mask    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_stat_bits_shared_lower_write_mask 0x00000000U

/* all used bits of 'NX51_xmac_stat_bits_shared_lower': */
#define MSK_USED_BITS_NX51_xmac_stat_bits_shared_lower 0x0000ffffU

enum {
	BFW_NX51_xmac_stat_bits_shared_lower_val        = 8,  /* [7:0] */
	BFW_NX51_xmac_stat_bits_shared_lower_write_mask = 8,  /* [15:8] */
	BFW_NX51_xmac_stat_bits_shared_lower_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STAT_BITS_SHARED_LOWER_BIT_Ttag {
	unsigned int val        : BFW_NX51_xmac_stat_bits_shared_lower_val;        /* Global stat_bits_shared[7:0] */
	unsigned int write_mask : BFW_NX51_xmac_stat_bits_shared_lower_write_mask; /* write mask of bits 7..0      */
	unsigned int reserved1  : BFW_NX51_xmac_stat_bits_shared_lower_reserved1;  /* reserved                     */
} NX51_XMAC_STAT_BITS_SHARED_LOWER_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_XMAC_STAT_BITS_SHARED_LOWER_BIT_T bf;
} NX51_XMAC_STAT_BITS_SHARED_LOWER_T;

/* --------------------------------------------------------------------- */
/* Register xmac_stat_bits_shared_upper */
/* => stat_bits_shared (upper): */
/*    These bits can be accessed by all xMACs and xPECs in parallel, all accesses with write bit mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_stat_bits_shared_upper        0x00000114U
#define Adr_NX51_xmac0_regs_xmac_stat_bits_shared_upper 0x1018B514U
#define Adr_NX51_xmac1_regs_xmac_stat_bits_shared_upper 0x1018B714U
#define DFLT_VAL_NX51_xmac_stat_bits_shared_upper       0x00000000U

#define MSK_NX51_xmac_stat_bits_shared_upper_val                0x000000ffU
#define SRT_NX51_xmac_stat_bits_shared_upper_val                0
#define DFLT_VAL_NX51_xmac_stat_bits_shared_upper_val           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_stat_bits_shared_upper_val        0x00000000U
#define MSK_NX51_xmac_stat_bits_shared_upper_write_mask         0x0000ff00U
#define SRT_NX51_xmac_stat_bits_shared_upper_write_mask         8
#define DFLT_VAL_NX51_xmac_stat_bits_shared_upper_write_mask    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_stat_bits_shared_upper_write_mask 0x00000000U

/* all used bits of 'NX51_xmac_stat_bits_shared_upper': */
#define MSK_USED_BITS_NX51_xmac_stat_bits_shared_upper 0x0000ffffU

enum {
	BFW_NX51_xmac_stat_bits_shared_upper_val        = 8,  /* [7:0] */
	BFW_NX51_xmac_stat_bits_shared_upper_write_mask = 8,  /* [15:8] */
	BFW_NX51_xmac_stat_bits_shared_upper_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STAT_BITS_SHARED_UPPER_BIT_Ttag {
	unsigned int val        : BFW_NX51_xmac_stat_bits_shared_upper_val;        /* Global stat_bits_shared[15:8] */
	unsigned int write_mask : BFW_NX51_xmac_stat_bits_shared_upper_write_mask; /* write mask of bits 7..0       */
	unsigned int reserved1  : BFW_NX51_xmac_stat_bits_shared_upper_reserved1;  /* reserved                      */
} NX51_XMAC_STAT_BITS_SHARED_UPPER_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_XMAC_STAT_BITS_SHARED_UPPER_BIT_T bf;
} NX51_XMAC_STAT_BITS_SHARED_UPPER_T;

/* --------------------------------------------------------------------- */
/* Register xmac_status_mii */
/* => xMAC MII receive status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_status_mii        0x00000118U
#define Adr_NX51_xmac0_regs_xmac_status_mii 0x1018B518U
#define Adr_NX51_xmac1_regs_xmac_status_mii 0x1018B718U

#define MSK_NX51_xmac_status_mii_rx_dv       0x00000001U
#define SRT_NX51_xmac_status_mii_rx_dv       0
#define MSK_NX51_xmac_status_mii_rx_err      0x00000002U
#define SRT_NX51_xmac_status_mii_rx_err      1
#define MSK_NX51_xmac_status_mii_crs         0x00000004U
#define SRT_NX51_xmac_status_mii_crs         2
#define MSK_NX51_xmac_status_mii_col         0x00000008U
#define SRT_NX51_xmac_status_mii_col         3
#define MSK_NX51_xmac_status_mii_s_nc        0x00000010U
#define SRT_NX51_xmac_status_mii_s_nc        4
#define MSK_NX51_xmac_status_mii_v_ne_ns_nc  0x00000020U
#define SRT_NX51_xmac_status_mii_v_ne_ns_nc  5
#define MSK_NX51_xmac_status_mii_v_ne_nc     0x00000040U
#define SRT_NX51_xmac_status_mii_v_ne_nc     6
#define MSK_NX51_xmac_status_mii_v_ne_ns     0x00000080U
#define SRT_NX51_xmac_status_mii_v_ne_ns     7
#define MSK_NX51_xmac_status_mii_v_ne        0x00000100U
#define SRT_NX51_xmac_status_mii_v_ne        8
#define MSK_NX51_xmac_status_mii_v_ne_s_nc   0x00000200U
#define SRT_NX51_xmac_status_mii_v_ne_s_nc   9
#define MSK_NX51_xmac_status_mii_v_ne_s      0x00000400U
#define SRT_NX51_xmac_status_mii_v_ne_s      10
#define MSK_NX51_xmac_status_mii_v_ne_nc_p0  0x00000800U
#define SRT_NX51_xmac_status_mii_v_ne_nc_p0  11
#define MSK_NX51_xmac_status_mii_v_ne_nc_p1  0x00001000U
#define SRT_NX51_xmac_status_mii_v_ne_nc_p1  12
#define MSK_NX51_xmac_status_mii_v_ne_nc_p01 0x00002000U
#define SRT_NX51_xmac_status_mii_v_ne_nc_p01 13
#define MSK_NX51_xmac_status_mii_anycol      0x00004000U
#define SRT_NX51_xmac_status_mii_anycol      14

/* all used bits of 'NX51_xmac_status_mii': */
#define MSK_USED_BITS_NX51_xmac_status_mii 0x00007fffU

enum {
	BFW_NX51_xmac_status_mii_rx_dv       = 1,  /* [0] */
	BFW_NX51_xmac_status_mii_rx_err      = 1,  /* [1] */
	BFW_NX51_xmac_status_mii_crs         = 1,  /* [2] */
	BFW_NX51_xmac_status_mii_col         = 1,  /* [3] */
	BFW_NX51_xmac_status_mii_s_nc        = 1,  /* [4] */
	BFW_NX51_xmac_status_mii_v_ne_ns_nc  = 1,  /* [5] */
	BFW_NX51_xmac_status_mii_v_ne_nc     = 1,  /* [6] */
	BFW_NX51_xmac_status_mii_v_ne_ns     = 1,  /* [7] */
	BFW_NX51_xmac_status_mii_v_ne        = 1,  /* [8] */
	BFW_NX51_xmac_status_mii_v_ne_s_nc   = 1,  /* [9] */
	BFW_NX51_xmac_status_mii_v_ne_s      = 1,  /* [10] */
	BFW_NX51_xmac_status_mii_v_ne_nc_p0  = 1,  /* [11] */
	BFW_NX51_xmac_status_mii_v_ne_nc_p1  = 1,  /* [12] */
	BFW_NX51_xmac_status_mii_v_ne_nc_p01 = 1,  /* [13] */
	BFW_NX51_xmac_status_mii_anycol      = 1,  /* [14] */
	BFW_NX51_xmac_status_mii_reserved1   = 17  /* [31:15] */
};

typedef struct NX51_XMAC_STATUS_MII_BIT_Ttag {
	unsigned int rx_dv       : BFW_NX51_xmac_status_mii_rx_dv;       /* mii data valid                                         */
	unsigned int rx_err      : BFW_NX51_xmac_status_mii_rx_err;      /* mii rx_err                                             */
	unsigned int crs         : BFW_NX51_xmac_status_mii_crs;         /* mii crs                                                */
	unsigned int col         : BFW_NX51_xmac_status_mii_col;         /* mii col                                                */
	unsigned int s_nc        : BFW_NX51_xmac_status_mii_s_nc;        /* crs & !col                                             */
	unsigned int v_ne_ns_nc  : BFW_NX51_xmac_status_mii_v_ne_ns_nc;  /* rx_dv & !rx_err & !crs & !col                          */
	unsigned int v_ne_nc     : BFW_NX51_xmac_status_mii_v_ne_nc;     /* rx_dv & !rx_err &        !col                          */
	unsigned int v_ne_ns     : BFW_NX51_xmac_status_mii_v_ne_ns;     /* rx_dv & !rx_err & !crs                                 */
	unsigned int v_ne        : BFW_NX51_xmac_status_mii_v_ne;        /* rx_dv & !rx_err                                        */
	unsigned int v_ne_s_nc   : BFW_NX51_xmac_status_mii_v_ne_s_nc;   /* rx_dv & !rx_err &  crs & !col                          */
	unsigned int v_ne_s      : BFW_NX51_xmac_status_mii_v_ne_s;      /* rx_dv & !rx_err &  crs                                 */
	unsigned int v_ne_nc_p0  : BFW_NX51_xmac_status_mii_v_ne_nc_p0;  /* rx_dv & !rx_err &        !col &  rpm_hit0              */
	unsigned int v_ne_nc_p1  : BFW_NX51_xmac_status_mii_v_ne_nc_p1;  /* rx_dv & !rx_err &        !col &              rpm_hit1  */
	unsigned int v_ne_nc_p01 : BFW_NX51_xmac_status_mii_v_ne_nc_p01; /* rx_dv & !rx_err &        !col & (rpm_hit0 |  rpm_hit1) */
	unsigned int anycol      : BFW_NX51_xmac_status_mii_anycol;      /* mii col is active at this xMAC or other xMAC           */
	unsigned int reserved1   : BFW_NX51_xmac_status_mii_reserved1;   /* reserved                                               */
} NX51_XMAC_STATUS_MII_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_STATUS_MII_BIT_T bf;
} NX51_XMAC_STATUS_MII_T;

/* --------------------------------------------------------------------- */
/* Register xmac_status_mii2 */
/* => xMAC 2nd MII receive status register: */
/*    All bits are read only, writing 1 to rx_err_was_here, col_was_here or crs_was_here resets these bits. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_status_mii2        0x0000011CU
#define Adr_NX51_xmac0_regs_xmac_status_mii2 0x1018B51CU
#define Adr_NX51_xmac1_regs_xmac_status_mii2 0x1018B71CU
#define DFLT_VAL_NX51_xmac_status_mii2       0x00000000U

#define MSK_NX51_xmac_status_mii2_dv                            0x00000001U
#define SRT_NX51_xmac_status_mii2_dv                            0
#define DFLT_VAL_NX51_xmac_status_mii2_dv                       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_dv                    0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_dv                         0x00000002U
#define SRT_NX51_xmac_status_mii2_rx_dv                         1
#define DFLT_VAL_NX51_xmac_status_mii2_rx_dv                    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_dv                 0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_err                        0x00000004U
#define SRT_NX51_xmac_status_mii2_rx_err                        2
#define DFLT_VAL_NX51_xmac_status_mii2_rx_err                   0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_err                0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_crs                        0x00000008U
#define SRT_NX51_xmac_status_mii2_rx_crs                        3
#define DFLT_VAL_NX51_xmac_status_mii2_rx_crs                   0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_crs                0x00000000U
#define MSK_NX51_xmac_status_mii2_v_ne                          0x00000010U
#define SRT_NX51_xmac_status_mii2_v_ne                          4
#define DFLT_VAL_NX51_xmac_status_mii2_v_ne                     0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_v_ne                  0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_miif_error_ro              0x00000020U
#define SRT_NX51_xmac_status_mii2_rx_miif_error_ro              5
#define DFLT_VAL_NX51_xmac_status_mii2_rx_miif_error_ro         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_miif_error_ro      0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_miif_ovfl_ro               0x00000040U
#define SRT_NX51_xmac_status_mii2_rx_miif_ovfl_ro               6
#define DFLT_VAL_NX51_xmac_status_mii2_rx_miif_ovfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_miif_ovfl_ro       0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_miif_unfl_ro               0x00000080U
#define SRT_NX51_xmac_status_mii2_rx_miif_unfl_ro               7
#define DFLT_VAL_NX51_xmac_status_mii2_rx_miif_unfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_miif_unfl_ro       0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_miif_short_dv_ro           0x00000100U
#define SRT_NX51_xmac_status_mii2_rx_miif_short_dv_ro           8
#define DFLT_VAL_NX51_xmac_status_mii2_rx_miif_short_dv_ro      0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_miif_short_dv_ro   0x00000000U
#define MSK_NX51_xmac_status_mii2_tx_miif_error_ro              0x00000200U
#define SRT_NX51_xmac_status_mii2_tx_miif_error_ro              9
#define DFLT_VAL_NX51_xmac_status_mii2_tx_miif_error_ro         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_tx_miif_error_ro      0x00000000U
#define MSK_NX51_xmac_status_mii2_tx_miif_ovfl_ro               0x00000400U
#define SRT_NX51_xmac_status_mii2_tx_miif_ovfl_ro               10
#define DFLT_VAL_NX51_xmac_status_mii2_tx_miif_ovfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_tx_miif_ovfl_ro       0x00000000U
#define MSK_NX51_xmac_status_mii2_tx_miif_unfl_ro               0x00000800U
#define SRT_NX51_xmac_status_mii2_tx_miif_unfl_ro               11
#define DFLT_VAL_NX51_xmac_status_mii2_tx_miif_unfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_tx_miif_unfl_ro       0x00000000U
#define MSK_NX51_xmac_status_mii2_tx_miif_short_txen_ro         0x00001000U
#define SRT_NX51_xmac_status_mii2_tx_miif_short_txen_ro         12
#define DFLT_VAL_NX51_xmac_status_mii2_tx_miif_short_txen_ro    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_tx_miif_short_txen_ro 0x00000000U
#define MSK_NX51_xmac_status_mii2_rx_err_was_here               0x00002000U
#define SRT_NX51_xmac_status_mii2_rx_err_was_here               13
#define DFLT_VAL_NX51_xmac_status_mii2_rx_err_was_here          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_rx_err_was_here       0x00000000U
#define MSK_NX51_xmac_status_mii2_col_was_here                  0x00004000U
#define SRT_NX51_xmac_status_mii2_col_was_here                  14
#define DFLT_VAL_NX51_xmac_status_mii2_col_was_here             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_col_was_here          0x00000000U
#define MSK_NX51_xmac_status_mii2_crs_was_here                  0x00008000U
#define SRT_NX51_xmac_status_mii2_crs_was_here                  15
#define DFLT_VAL_NX51_xmac_status_mii2_crs_was_here             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_status_mii2_crs_was_here          0x00000000U

/* all used bits of 'NX51_xmac_status_mii2': */
#define MSK_USED_BITS_NX51_xmac_status_mii2 0x0000ffffU

enum {
	BFW_NX51_xmac_status_mii2_dv                    = 1,  /* [0] */
	BFW_NX51_xmac_status_mii2_rx_dv                 = 1,  /* [1] */
	BFW_NX51_xmac_status_mii2_rx_err                = 1,  /* [2] */
	BFW_NX51_xmac_status_mii2_rx_crs                = 1,  /* [3] */
	BFW_NX51_xmac_status_mii2_v_ne                  = 1,  /* [4] */
	BFW_NX51_xmac_status_mii2_rx_miif_error_ro      = 1,  /* [5] */
	BFW_NX51_xmac_status_mii2_rx_miif_ovfl_ro       = 1,  /* [6] */
	BFW_NX51_xmac_status_mii2_rx_miif_unfl_ro       = 1,  /* [7] */
	BFW_NX51_xmac_status_mii2_rx_miif_short_dv_ro   = 1,  /* [8] */
	BFW_NX51_xmac_status_mii2_tx_miif_error_ro      = 1,  /* [9] */
	BFW_NX51_xmac_status_mii2_tx_miif_ovfl_ro       = 1,  /* [10] */
	BFW_NX51_xmac_status_mii2_tx_miif_unfl_ro       = 1,  /* [11] */
	BFW_NX51_xmac_status_mii2_tx_miif_short_txen_ro = 1,  /* [12] */
	BFW_NX51_xmac_status_mii2_rx_err_was_here       = 1,  /* [13] */
	BFW_NX51_xmac_status_mii2_col_was_here          = 1,  /* [14] */
	BFW_NX51_xmac_status_mii2_crs_was_here          = 1,  /* [15] */
	BFW_NX51_xmac_status_mii2_reserved1             = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STATUS_MII2_BIT_Ttag {
	unsigned int dv                    : BFW_NX51_xmac_status_mii2_dv;                    /* RX-Nibble-FIFO data valid:                                                                     */
	                                                                                      /* Fifo is automatically filled, if rx_dv=1. This bit gets active, if fifo contains enough data.  */
	unsigned int rx_dv                 : BFW_NX51_xmac_status_mii2_rx_dv;                 /* MII rx_dv before RX_Nibble-FIFO.                                                               */
	                                                                                      /* This bit is a copy of xmac_status_mii-rx_dv.                                                   */
	unsigned int rx_err                : BFW_NX51_xmac_status_mii2_rx_err;                /* MII rx_err before RX_Nibble-FIFO.                                                              */
	                                                                                      /* This bit is a copy of xmac_status_mii-rx_err.                                                  */
	unsigned int rx_crs                : BFW_NX51_xmac_status_mii2_rx_crs;                /* MII crs before RX_Nibble-FIFO.                                                                 */
	                                                                                      /* This bit is a copy of xmac_status_mii-crs.                                                     */
	unsigned int v_ne                  : BFW_NX51_xmac_status_mii2_v_ne;                  /* dv & !rx_err                                                                                   */
	                                                                                      /* Useful, if rx_err has to be checked every cycle by software                                    */
	                                                                                      /* dv:     after fifo,  i.e. status_mii2(0)                                                       */
	                                                                                      /* rx_err: before fifo, i.e. status_mii(1)                                                        */
	unsigned int rx_miif_error_ro      : BFW_NX51_xmac_status_mii2_rx_miif_error_ro;      /* Any error at RX-Nibble-FIFO occured.                                                           */
	                                                                                      /* Any error can be tx_miif_short_txen_ro, tx_miif_ovfl_ro or tx_miif_unfl_ro.                    */
	                                                                                      /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_miif_ovfl_ro       : BFW_NX51_xmac_status_mii2_rx_miif_ovfl_ro;       /* RX-Nibble-FIFO overflow.                                                                       */
	                                                                                      /* This bit is read only.                                                                         */
	                                                                                      /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_miif_unfl_ro       : BFW_NX51_xmac_status_mii2_rx_miif_unfl_ro;       /* RX-Nibble-FIFO underflow.                                                                      */
	                                                                                      /* This bit is read only.                                                                         */
	                                                                                      /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_miif_short_dv_ro   : BFW_NX51_xmac_status_mii2_rx_miif_short_dv_ro;   /* RX-Nibble-FIFO error: rx_dv was active or inactive for very short time.                        */
	                                                                                      /* Rx_dv went inactive before FIFO reached fill_level or went active before FIFO was flushed.     */
	                                                                                      /* This bit is read only.                                                                         */
	                                                                                      /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_error_ro      : BFW_NX51_xmac_status_mii2_tx_miif_error_ro;      /* Any error at TX-Nibble-FIFO occured.                                                           */
	                                                                                      /* Any error can be tx_miif_short_txen_ro, tx_miif_ovfl_ro or tx_miif_unfl_ro.                    */
	                                                                                      /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_ovfl_ro       : BFW_NX51_xmac_status_mii2_tx_miif_ovfl_ro;       /* TX-Nibble-FIFO overflow.                                                                       */
	                                                                                      /* This bit is read only.                                                                         */
	                                                                                      /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_unfl_ro       : BFW_NX51_xmac_status_mii2_tx_miif_unfl_ro;       /* TX-Nibble-FIFO underflow.                                                                      */
	                                                                                      /* This bit is read only.                                                                         */
	                                                                                      /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_short_txen_ro : BFW_NX51_xmac_status_mii2_tx_miif_short_txen_ro; /* tx_en was changed too fast:                                                                    */
	                                                                                      /* When setting tx_en=1, it must stay active at least until fifo reaches fill_level (fifo_depth). */
	                                                                                      /* When setting tx_en=0, it must stay inactive at least until fifo is empty.                      */
	                                                                                      /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_err_was_here       : BFW_NX51_xmac_status_mii2_rx_err_was_here;       /* rx_err was here:                                                                               */
	                                                                                      /* Useful, if rx_err needs only to be checked at end of frame.                                    */
	                                                                                      /* Set with rx_err xor config_rx_nibble_fifo-rx_err_low_active.                                   */
	                                                                                      /* Reset by writing 1 to this bit.                                                                */
	unsigned int col_was_here          : BFW_NX51_xmac_status_mii2_col_was_here;          /* col was here:                                                                                  */
	                                                                                      /* Useful, if col needs only to be checked at end of frame.                                       */
	                                                                                      /* Set with col xor config_tx_nibble_fifo-col_low_active of xmac_config_mii.                      */
	                                                                                      /* Reset by writing 1 to this bit.                                                                */
	unsigned int crs_was_here          : BFW_NX51_xmac_status_mii2_crs_was_here;          /* crs was here:                                                                                  */
	                                                                                      /* Useful, if crs needs only to be checked at end of frame.                                       */
	                                                                                      /* Set with crs xor config_rx_nibble_fifo-crs_low_active of xmac_config_mii.                      */
	                                                                                      /* Reset by writing 1 to this bit.                                                                */
	unsigned int reserved1             : BFW_NX51_xmac_status_mii2_reserved1;             /* reserved                                                                                       */
} NX51_XMAC_STATUS_MII2_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_STATUS_MII2_BIT_T bf;
} NX51_XMAC_STATUS_MII2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_other_status_mii2 */
/* => xMAC 2nd MII receive status register of other xMAC: */
/*    Used for fast forward of data between 2 xMACs (specially in MII-HUB-mode) */
/*    All bits are read only, writing 1 to rx_err_was_here, col_was_here or crs_was_here resets these bits. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_other_status_mii2        0x00000120U
#define Adr_NX51_xmac0_regs_xmac_other_status_mii2 0x1018B520U
#define Adr_NX51_xmac1_regs_xmac_other_status_mii2 0x1018B720U
#define DFLT_VAL_NX51_xmac_other_status_mii2       0x00000000U

#define MSK_NX51_xmac_other_status_mii2_dv                            0x00000001U
#define SRT_NX51_xmac_other_status_mii2_dv                            0
#define DFLT_VAL_NX51_xmac_other_status_mii2_dv                       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_dv                    0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_dv                         0x00000002U
#define SRT_NX51_xmac_other_status_mii2_rx_dv                         1
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_dv                    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_dv                 0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_err                        0x00000004U
#define SRT_NX51_xmac_other_status_mii2_rx_err                        2
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_err                   0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_err                0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_crs                        0x00000008U
#define SRT_NX51_xmac_other_status_mii2_rx_crs                        3
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_crs                   0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_crs                0x00000000U
#define MSK_NX51_xmac_other_status_mii2_v_ne                          0x00000010U
#define SRT_NX51_xmac_other_status_mii2_v_ne                          4
#define DFLT_VAL_NX51_xmac_other_status_mii2_v_ne                     0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_v_ne                  0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_miif_error_ro              0x00000020U
#define SRT_NX51_xmac_other_status_mii2_rx_miif_error_ro              5
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_miif_error_ro         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_miif_error_ro      0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_miif_ovfl_ro               0x00000040U
#define SRT_NX51_xmac_other_status_mii2_rx_miif_ovfl_ro               6
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_miif_ovfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_miif_ovfl_ro       0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_miif_unfl_ro               0x00000080U
#define SRT_NX51_xmac_other_status_mii2_rx_miif_unfl_ro               7
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_miif_unfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_miif_unfl_ro       0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_miif_short_dv_ro           0x00000100U
#define SRT_NX51_xmac_other_status_mii2_rx_miif_short_dv_ro           8
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_miif_short_dv_ro      0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_miif_short_dv_ro   0x00000000U
#define MSK_NX51_xmac_other_status_mii2_tx_miif_error_ro              0x00000200U
#define SRT_NX51_xmac_other_status_mii2_tx_miif_error_ro              9
#define DFLT_VAL_NX51_xmac_other_status_mii2_tx_miif_error_ro         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_tx_miif_error_ro      0x00000000U
#define MSK_NX51_xmac_other_status_mii2_tx_miif_ovfl_ro               0x00000400U
#define SRT_NX51_xmac_other_status_mii2_tx_miif_ovfl_ro               10
#define DFLT_VAL_NX51_xmac_other_status_mii2_tx_miif_ovfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_tx_miif_ovfl_ro       0x00000000U
#define MSK_NX51_xmac_other_status_mii2_tx_miif_unfl_ro               0x00000800U
#define SRT_NX51_xmac_other_status_mii2_tx_miif_unfl_ro               11
#define DFLT_VAL_NX51_xmac_other_status_mii2_tx_miif_unfl_ro          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_tx_miif_unfl_ro       0x00000000U
#define MSK_NX51_xmac_other_status_mii2_tx_miif_short_txen_ro         0x00001000U
#define SRT_NX51_xmac_other_status_mii2_tx_miif_short_txen_ro         12
#define DFLT_VAL_NX51_xmac_other_status_mii2_tx_miif_short_txen_ro    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_tx_miif_short_txen_ro 0x00000000U
#define MSK_NX51_xmac_other_status_mii2_rx_err_was_here               0x00002000U
#define SRT_NX51_xmac_other_status_mii2_rx_err_was_here               13
#define DFLT_VAL_NX51_xmac_other_status_mii2_rx_err_was_here          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_rx_err_was_here       0x00000000U
#define MSK_NX51_xmac_other_status_mii2_col_was_here                  0x00004000U
#define SRT_NX51_xmac_other_status_mii2_col_was_here                  14
#define DFLT_VAL_NX51_xmac_other_status_mii2_col_was_here             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_col_was_here          0x00000000U
#define MSK_NX51_xmac_other_status_mii2_crs_was_here                  0x00008000U
#define SRT_NX51_xmac_other_status_mii2_crs_was_here                  15
#define DFLT_VAL_NX51_xmac_other_status_mii2_crs_was_here             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_other_status_mii2_crs_was_here          0x00000000U

/* all used bits of 'NX51_xmac_other_status_mii2': */
#define MSK_USED_BITS_NX51_xmac_other_status_mii2 0x0000ffffU

enum {
	BFW_NX51_xmac_other_status_mii2_dv                    = 1,  /* [0] */
	BFW_NX51_xmac_other_status_mii2_rx_dv                 = 1,  /* [1] */
	BFW_NX51_xmac_other_status_mii2_rx_err                = 1,  /* [2] */
	BFW_NX51_xmac_other_status_mii2_rx_crs                = 1,  /* [3] */
	BFW_NX51_xmac_other_status_mii2_v_ne                  = 1,  /* [4] */
	BFW_NX51_xmac_other_status_mii2_rx_miif_error_ro      = 1,  /* [5] */
	BFW_NX51_xmac_other_status_mii2_rx_miif_ovfl_ro       = 1,  /* [6] */
	BFW_NX51_xmac_other_status_mii2_rx_miif_unfl_ro       = 1,  /* [7] */
	BFW_NX51_xmac_other_status_mii2_rx_miif_short_dv_ro   = 1,  /* [8] */
	BFW_NX51_xmac_other_status_mii2_tx_miif_error_ro      = 1,  /* [9] */
	BFW_NX51_xmac_other_status_mii2_tx_miif_ovfl_ro       = 1,  /* [10] */
	BFW_NX51_xmac_other_status_mii2_tx_miif_unfl_ro       = 1,  /* [11] */
	BFW_NX51_xmac_other_status_mii2_tx_miif_short_txen_ro = 1,  /* [12] */
	BFW_NX51_xmac_other_status_mii2_rx_err_was_here       = 1,  /* [13] */
	BFW_NX51_xmac_other_status_mii2_col_was_here          = 1,  /* [14] */
	BFW_NX51_xmac_other_status_mii2_crs_was_here          = 1,  /* [15] */
	BFW_NX51_xmac_other_status_mii2_reserved1             = 16  /* [31:16] */
};

typedef struct NX51_XMAC_OTHER_STATUS_MII2_BIT_Ttag {
	unsigned int dv                    : BFW_NX51_xmac_other_status_mii2_dv;                    /* RX-Nibble-FIFO data valid:                                                                     */
	                                                                                            /* Fifo is automatically filled, if rx_dv=1. This bit gets active, if fifo contains enough data.  */
	unsigned int rx_dv                 : BFW_NX51_xmac_other_status_mii2_rx_dv;                 /* MII rx_dv before RX_Nibble-FIFO.                                                               */
	                                                                                            /* This bit is a copy of xmac_status_mii-rx_dv.                                                   */
	unsigned int rx_err                : BFW_NX51_xmac_other_status_mii2_rx_err;                /* MII rx_err before RX_Nibble-FIFO.                                                              */
	                                                                                            /* This bit is a copy of xmac_status_mii-rx_err.                                                  */
	unsigned int rx_crs                : BFW_NX51_xmac_other_status_mii2_rx_crs;                /* MII crs before RX_Nibble-FIFO.                                                                 */
	                                                                                            /* This bit is a copy of xmac_status_mii-crs.                                                     */
	unsigned int v_ne                  : BFW_NX51_xmac_other_status_mii2_v_ne;                  /* dv & !rx_err                                                                                   */
	                                                                                            /* Useful, if rx_err has to be checked every cycle by software                                    */
	                                                                                            /* dv:     after fifo,  i.e. status_mii2(0)                                                       */
	                                                                                            /* rx_err: before fifo, i.e. status_mii(1)                                                        */
	unsigned int rx_miif_error_ro      : BFW_NX51_xmac_other_status_mii2_rx_miif_error_ro;      /* Any error at RX-Nibble-FIFO occured.                                                           */
	                                                                                            /* Any error can be tx_miif_short_txen_ro, tx_miif_ovfl_ro or tx_miif_unfl_ro.                    */
	                                                                                            /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_miif_ovfl_ro       : BFW_NX51_xmac_other_status_mii2_rx_miif_ovfl_ro;       /* RX-Nibble-FIFO overflow.                                                                       */
	                                                                                            /* This bit is read only.                                                                         */
	                                                                                            /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_miif_unfl_ro       : BFW_NX51_xmac_other_status_mii2_rx_miif_unfl_ro;       /* RX-Nibble-FIFO underflow.                                                                      */
	                                                                                            /* This bit is read only.                                                                         */
	                                                                                            /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_miif_short_dv_ro   : BFW_NX51_xmac_other_status_mii2_rx_miif_short_dv_ro;   /* RX-Nibble-FIFO error: rx_dv was active or inactive for very short time.                        */
	                                                                                            /* Rx_dv went inactive before FIFO reached fill_level or went active before FIFO was flushed.     */
	                                                                                            /* This bit is read only.                                                                         */
	                                                                                            /* Reset by setting xmac_config_rx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_error_ro      : BFW_NX51_xmac_other_status_mii2_tx_miif_error_ro;      /* Any error at TX-Nibble-FIFO occured.                                                           */
	                                                                                            /* Any error can be tx_miif_short_txen_ro, tx_miif_ovfl_ro or tx_miif_unfl_ro.                    */
	                                                                                            /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_ovfl_ro       : BFW_NX51_xmac_other_status_mii2_tx_miif_ovfl_ro;       /* TX-Nibble-FIFO overflow.                                                                       */
	                                                                                            /* This bit is read only.                                                                         */
	                                                                                            /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_unfl_ro       : BFW_NX51_xmac_other_status_mii2_tx_miif_unfl_ro;       /* TX-Nibble-FIFO underflow.                                                                      */
	                                                                                            /* This bit is read only.                                                                         */
	                                                                                            /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int tx_miif_short_txen_ro : BFW_NX51_xmac_other_status_mii2_tx_miif_short_txen_ro; /* tx_en was changed too fast:                                                                    */
	                                                                                            /* When setting tx_en=1, it must stay active at least until fifo reaches fill_level (fifo_depth). */
	                                                                                            /* When setting tx_en=0, it must stay inactive at least until fifo is empty.                      */
	                                                                                            /* Reset by setting xmac_config_tx_nibble_fifo-fifo_depth=0.                                      */
	unsigned int rx_err_was_here       : BFW_NX51_xmac_other_status_mii2_rx_err_was_here;       /* rx_err was here:                                                                               */
	                                                                                            /* Useful, if rx_err needs only to be checked at end of frame.                                    */
	                                                                                            /* Set with rx_err xor config_rx_nibble_fifo-rx_err_low_active.                                   */
	                                                                                            /* Reset by writing 1 to this bit. Attention: Reset of other xMAC has a pipeline-delay of 1cc.    */
	unsigned int col_was_here          : BFW_NX51_xmac_other_status_mii2_col_was_here;          /* col was here:                                                                                  */
	                                                                                            /* Useful, if col needs only to be checked at end of frame.                                       */
	                                                                                            /* Set with col xor config_tx_nibble_fifo-col_low_active of xmac_config_mii.                      */
	                                                                                            /* Reset by writing 1 to this bit. Attention: Reset of other xMAC has a pipeline-delay of 1cc.    */
	unsigned int crs_was_here          : BFW_NX51_xmac_other_status_mii2_crs_was_here;          /* crs was here:                                                                                  */
	                                                                                            /* Useful, if crs needs only to be checked at end of frame.                                       */
	                                                                                            /* Set with crs xor config_rx_nibble_fifo-crs_low_active of xmac_config_mii.                      */
	                                                                                            /* Reset by writing 1 to this bit. Attention: Reset of other xMAC has a pipeline-delay of 1cc.    */
	unsigned int reserved1             : BFW_NX51_xmac_other_status_mii2_reserved1;             /* reserved                                                                                       */
} NX51_XMAC_OTHER_STATUS_MII2_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XMAC_OTHER_STATUS_MII2_BIT_T bf;
} NX51_XMAC_OTHER_STATUS_MII2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_mii */
/* => xMAC MII transmit config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_mii        0x00000124U
#define Adr_NX51_xmac0_regs_xmac_config_mii 0x1018B524U
#define Adr_NX51_xmac1_regs_xmac_config_mii 0x1018B724U
#define DFLT_VAL_NX51_xmac_config_mii       0x00000000U

#define MSK_NX51_xmac_config_mii_tx_en          0x00000001U
#define SRT_NX51_xmac_config_mii_tx_en          0
#define DFLT_VAL_NX51_xmac_config_mii_tx_en     0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_mii_tx_en  0x00000000U
#define MSK_NX51_xmac_config_mii_tx_err         0x00000002U
#define SRT_NX51_xmac_config_mii_tx_err         1
#define DFLT_VAL_NX51_xmac_config_mii_tx_err    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_mii_tx_err 0x00000000U

/* all used bits of 'NX51_xmac_config_mii': */
#define MSK_USED_BITS_NX51_xmac_config_mii 0x00000003U

enum {
	BFW_NX51_xmac_config_mii_tx_en     = 1,  /* [0] */
	BFW_NX51_xmac_config_mii_tx_err    = 1,  /* [1] */
	BFW_NX51_xmac_config_mii_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_XMAC_CONFIG_MII_BIT_Ttag {
	unsigned int tx_en     : BFW_NX51_xmac_config_mii_tx_en;     /* mii tx_en                  */
	                                                             /* Synchronized to mii tx_clk */
	unsigned int tx_err    : BFW_NX51_xmac_config_mii_tx_err;    /* mii tx_err                 */
	                                                             /* Synchronized to mii tx_clk */
	unsigned int reserved1 : BFW_NX51_xmac_config_mii_reserved1; /* reserved                   */
} NX51_XMAC_CONFIG_MII_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_CONFIG_MII_BIT_T bf;
} NX51_XMAC_CONFIG_MII_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_rx_nibble_fifo */
/* => xMAC RX MII Nibble FIFO config register */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_rx_nibble_fifo        0x00000128U
#define Adr_NX51_xmac0_regs_xmac_config_rx_nibble_fifo 0x1018B528U
#define Adr_NX51_xmac1_regs_xmac_config_rx_nibble_fifo 0x1018B728U
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo       0x00001000U

#define MSK_NX51_xmac_config_rx_nibble_fifo_sample_phase              0x00000007U
#define SRT_NX51_xmac_config_rx_nibble_fifo_sample_phase              0
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_sample_phase         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_sample_phase      0x00000000U
#define MSK_NX51_xmac_config_rx_nibble_fifo_delay_rx_data             0x00000008U
#define SRT_NX51_xmac_config_rx_nibble_fifo_delay_rx_data             3
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_delay_rx_data        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_delay_rx_data     0x00000000U
#define MSK_NX51_xmac_config_rx_nibble_fifo_fifo_depth_add            0x00000030U
#define SRT_NX51_xmac_config_rx_nibble_fifo_fifo_depth_add            4
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_fifo_depth_add       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_fifo_depth_add    0x00000000U
#define MSK_NX51_xmac_config_rx_nibble_fifo_fifo_depth                0x000003c0U
#define SRT_NX51_xmac_config_rx_nibble_fifo_fifo_depth                6
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_fifo_depth           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_fifo_depth        0x00000000U
#define MSK_NX51_xmac_config_rx_nibble_fifo_rx_write_phase            0x00000c00U
#define SRT_NX51_xmac_config_rx_nibble_fifo_rx_write_phase            10
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_rx_write_phase       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_rx_write_phase    0x00000000U
#define MSK_NX51_xmac_config_rx_nibble_fifo_rpu_sync_delay            0x00003000U
#define SRT_NX51_xmac_config_rx_nibble_fifo_rpu_sync_delay            12
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_rpu_sync_delay       0x00001000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_rpu_sync_delay    0x00000001U
#define MSK_NX51_xmac_config_rx_nibble_fifo_rx_err_low_active         0x00004000U
#define SRT_NX51_xmac_config_rx_nibble_fifo_rx_err_low_active         14
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_rx_err_low_active    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_rx_err_low_active 0x00000000U
#define MSK_NX51_xmac_config_rx_nibble_fifo_crs_low_active            0x00008000U
#define SRT_NX51_xmac_config_rx_nibble_fifo_crs_low_active            15
#define DFLT_VAL_NX51_xmac_config_rx_nibble_fifo_crs_low_active       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_rx_nibble_fifo_crs_low_active    0x00000000U

/* all used bits of 'NX51_xmac_config_rx_nibble_fifo': */
#define MSK_USED_BITS_NX51_xmac_config_rx_nibble_fifo 0x0000ffffU

enum {
	BFW_NX51_xmac_config_rx_nibble_fifo_sample_phase      = 3,  /* [2:0] */
	BFW_NX51_xmac_config_rx_nibble_fifo_delay_rx_data     = 1,  /* [3] */
	BFW_NX51_xmac_config_rx_nibble_fifo_fifo_depth_add    = 2,  /* [5:4] */
	BFW_NX51_xmac_config_rx_nibble_fifo_fifo_depth        = 4,  /* [9:6] */
	BFW_NX51_xmac_config_rx_nibble_fifo_rx_write_phase    = 2,  /* [11:10] */
	BFW_NX51_xmac_config_rx_nibble_fifo_rpu_sync_delay    = 2,  /* [13:12] */
	BFW_NX51_xmac_config_rx_nibble_fifo_rx_err_low_active = 1,  /* [14] */
	BFW_NX51_xmac_config_rx_nibble_fifo_crs_low_active    = 1,  /* [15] */
	BFW_NX51_xmac_config_rx_nibble_fifo_reserved1         = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CONFIG_RX_NIBBLE_FIFO_BIT_Ttag {
	unsigned int sample_phase      : BFW_NX51_xmac_config_rx_nibble_fifo_sample_phase;      /* Phase of mii_rx_clk, where mii_rx_d, rx_dv, rx_err, crs, col are sampled:                                                                  */
	                                                                                        /* This value is used for input of MII data independant on RX-Nibble-FIFO.                                                                    */
	                                                                                        /* Don't change default, unless you know what you are doing !                                                                                 */
	                                                                                        /* 0: sample at posedge rx_clk + 1cc                                                                                                          */
	                                                                                        /* 1: sample at posedge rx_clk + 2cc                                                                                                          */
	                                                                                        /* 2: sample at posedge rx_clk + 3cc                                                                                                          */
	                                                                                        /* 3: sample at posedge rx_clk + 4cc                                                                                                          */
	                                                                                        /* 4: sample at negedge rx_clk + 3cc                                                                                                          */
	                                                                                        /* 5: sample at negedge rx_clk + 4cc                                                                                                          */
	                                                                                        /* 6: sample at negedge rx_clk + 1cc                                                                                                          */
	                                                                                        /* 7: sample at negedge rx_clk + 2cc                                                                                                          */
	unsigned int delay_rx_data     : BFW_NX51_xmac_config_rx_nibble_fifo_delay_rx_data;     /* Delay mii inputs (rx_d, rx_dv, rx_err, crs, col) by 1 clockcycle before sampling them.                                                     */
	                                                                                        /* Enable this, if rx_d gets invalid shortly after rx_clk (hold<10ns).                                                                        */
	                                                                                        /* Disable otherwise.                                                                                                                         */
	unsigned int fifo_depth_add    : BFW_NX51_xmac_config_rx_nibble_fifo_fifo_depth_add;    /* Fill level additional wait cycles                                                                                                          */
	                                                                                        /* Allows to increase the garanteed delay of the fifo in bitclock units instead of full nibbles.                                              */
	                                                                                        /* The minimum depth of the fifo in bittimes is calculated as: TotalDepth = fifo_depth * 4 - 3 + fifo_depth_add.                              */
	                                                                                        /* Fifo_depth=1 and fifo_depth_add=2 leads to a guaranteed fifo buffer of 3bt=30ns, which should be sufficient for Ethernet (+/- 100ppm).     */
	unsigned int fifo_depth        : BFW_NX51_xmac_config_rx_nibble_fifo_fifo_depth;        /* Fill level (= number of nibbles) up to which RX-Nibble-FIFO is filled, before reading to rx register starts.                               */
	                                                                                        /* 0 means, RX-Nibble-FIFO is turned off, data is sampled directly to rx register (with jitter), FIFO is reset.                               */
	unsigned int rx_write_phase    : BFW_NX51_xmac_config_rx_nibble_fifo_rx_write_phase;    /* Phases, in which nibbles from RX-Nibble-FIFO are written to rx register:                                                                   */
	                                                                                        /* If RX-Nibble-FIFO is enabled (fifo_depth!=0), the sync-signal (copies data to rx register) is generated by a counter (instead of rx_clk),  */
	                                                                                        /* that activates the sync-signal every 4 clock-cycles. 'read_phase' defines the phase of that counter, in which sync-signal is active.       */
	                                                                                        /* If mii_tx_clk is derived from system_clk (e.g. sercos), this allows to synchronize RPU and TPU program flow on mii_tx_clk.                 */
	unsigned int rpu_sync_delay    : BFW_NX51_xmac_config_rx_nibble_fifo_rpu_sync_delay;    /* Delay between rx_write_phase and RPU-sync pulse:                                                                                           */
	                                                                                        /* By this value the RPU-sync pulse is delayed by 0, 1, 2 or 3 clockcycles (x10ns).                                                           */
	unsigned int rx_err_low_active : BFW_NX51_xmac_config_rx_nibble_fifo_rx_err_low_active; /* to generate status_mii2-rx_err_was_here signal:                                                                                            */
	                                                                                        /* 0: activate rx_err_was_here if rx_err=1                                                                                                    */
	                                                                                        /* 1: activate rx_err_was_here if rx_err=0                                                                                                    */
	unsigned int crs_low_active    : BFW_NX51_xmac_config_rx_nibble_fifo_crs_low_active;    /* to generate status_mii2-crs_was_here signal:                                                                                               */
	                                                                                        /* 0: activate crs_was_here if crs=1                                                                                                          */
	                                                                                        /* 1: activate crs_was_here if crs=0                                                                                                          */
	unsigned int reserved1         : BFW_NX51_xmac_config_rx_nibble_fifo_reserved1;         /* reserved                                                                                                                                   */
} NX51_XMAC_CONFIG_RX_NIBBLE_FIFO_BIT_T;

typedef union {
	unsigned int                          val;
	NX51_XMAC_CONFIG_RX_NIBBLE_FIFO_BIT_T bf;
} NX51_XMAC_CONFIG_RX_NIBBLE_FIFO_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_tx_nibble_fifo */
/* => xMAC TX NII Nibble FIFO config register */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_tx_nibble_fifo        0x0000012CU
#define Adr_NX51_xmac0_regs_xmac_config_tx_nibble_fifo 0x1018B52CU
#define Adr_NX51_xmac1_regs_xmac_config_tx_nibble_fifo 0x1018B72CU
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo       0x00000000U

#define MSK_NX51_xmac_config_tx_nibble_fifo_output_phase                 0x00000007U
#define SRT_NX51_xmac_config_tx_nibble_fifo_output_phase                 0
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_output_phase            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_output_phase         0x00000000U
#define MSK_NX51_xmac_config_tx_nibble_fifo_fifo_depth_add               0x00000018U
#define SRT_NX51_xmac_config_tx_nibble_fifo_fifo_depth_add               3
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_fifo_depth_add          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_fifo_depth_add       0x00000000U
#define MSK_NX51_xmac_config_tx_nibble_fifo_fifo_depth                   0x000001e0U
#define SRT_NX51_xmac_config_tx_nibble_fifo_fifo_depth                   5
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_fifo_depth              0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_fifo_depth           0x00000000U
#define MSK_NX51_xmac_config_tx_nibble_fifo_tx_read_phase                0x00000600U
#define SRT_NX51_xmac_config_tx_nibble_fifo_tx_read_phase                9
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_tx_read_phase           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_tx_read_phase        0x00000000U
#define MSK_NX51_xmac_config_tx_nibble_fifo_tpu_sync_delay               0x00001800U
#define SRT_NX51_xmac_config_tx_nibble_fifo_tpu_sync_delay               11
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_tpu_sync_delay          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_tpu_sync_delay       0x00000000U
#define MSK_NX51_xmac_config_tx_nibble_fifo_outputedge_tx_clk            0x00002000U
#define SRT_NX51_xmac_config_tx_nibble_fifo_outputedge_tx_clk            13
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_outputedge_tx_clk       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_outputedge_tx_clk    0x00000000U
#define MSK_NX51_xmac_config_tx_nibble_fifo_send_at_tx_count_pos         0x00004000U
#define SRT_NX51_xmac_config_tx_nibble_fifo_send_at_tx_count_pos         14
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_send_at_tx_count_pos    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_send_at_tx_count_pos 0x00000000U
#define MSK_NX51_xmac_config_tx_nibble_fifo_col_low_active               0x00008000U
#define SRT_NX51_xmac_config_tx_nibble_fifo_col_low_active               15
#define DFLT_VAL_NX51_xmac_config_tx_nibble_fifo_col_low_active          0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_tx_nibble_fifo_col_low_active       0x00000000U

/* all used bits of 'NX51_xmac_config_tx_nibble_fifo': */
#define MSK_USED_BITS_NX51_xmac_config_tx_nibble_fifo 0x0000ffffU

enum {
	BFW_NX51_xmac_config_tx_nibble_fifo_output_phase         = 3,  /* [2:0] */
	BFW_NX51_xmac_config_tx_nibble_fifo_fifo_depth_add       = 2,  /* [4:3] */
	BFW_NX51_xmac_config_tx_nibble_fifo_fifo_depth           = 4,  /* [8:5] */
	BFW_NX51_xmac_config_tx_nibble_fifo_tx_read_phase        = 2,  /* [10:9] */
	BFW_NX51_xmac_config_tx_nibble_fifo_tpu_sync_delay       = 2,  /* [12:11] */
	BFW_NX51_xmac_config_tx_nibble_fifo_outputedge_tx_clk    = 1,  /* [13] */
	BFW_NX51_xmac_config_tx_nibble_fifo_send_at_tx_count_pos = 1,  /* [14] */
	BFW_NX51_xmac_config_tx_nibble_fifo_col_low_active       = 1,  /* [15] */
	BFW_NX51_xmac_config_tx_nibble_fifo_reserved1            = 16  /* [31:16] */
};

typedef struct NX51_XMAC_CONFIG_TX_NIBBLE_FIFO_BIT_Ttag {
	unsigned int output_phase         : BFW_NX51_xmac_config_tx_nibble_fifo_output_phase;         /* Phase of mii_tx_clk, where mii_tx_d, tx_en, tx_err outputs are changed in relation to incoming mii_txclk:                              */
	                                                                                              /* This value is used for output of MII data independant on TX-Nibble-FIFO.                                                               */
	                                                                                              /* Don't change default, unless you know what you are doing !                                                                             */
	                                                                                              /* 0: change output at posedge tx_clk + 2cc                                                                                               */
	                                                                                              /* 1: change output at posedge tx_clk + 3cc                                                                                               */
	                                                                                              /* 2: change output at posedge tx_clk + 4cc                                                                                               */
	                                                                                              /* 3: change output at posedge tx_clk + 5cc                                                                                               */
	                                                                                              /* 4: change output at negedge tx_clk + 4cc                                                                                               */
	                                                                                              /* 5: change output at negedge tx_clk + 5cc                                                                                               */
	                                                                                              /* 6: change output at negedge tx_clk + 2cc                                                                                               */
	                                                                                              /* 7: change output at negedge tx_clk + 3cc                                                                                               */
	unsigned int fifo_depth_add       : BFW_NX51_xmac_config_tx_nibble_fifo_fifo_depth_add;       /* Fill level additional wait cycles                                                                                                      */
	                                                                                              /* Allows to increase the garanteed delay of the fifo in bitclock units instead of full nibbles.                                          */
	                                                                                              /* The minimum depth of the fifo in bittimes is calculated as: TotalDepth = fifo_depth * 4 - 3 + fifo_depth_add.                          */
	                                                                                              /* Fifo_depth=1 and fifo_depth_add=2 leads to a guaranteed fifo buffer of 3bt=30ns, which should be sufficient for Ethernet (+/- 100ppm). */
	unsigned int fifo_depth           : BFW_NX51_xmac_config_tx_nibble_fifo_fifo_depth;           /* Fill level (= number of nibbles) up to which TX-Nibble-FIFO is filled, before output to external pins starts.                          */
	                                                                                              /* 0 means, TX-Nibble-FIFO is turned off, data is sampled directly from tx register (with jitter), FIFO is reset.                         */
	unsigned int tx_read_phase        : BFW_NX51_xmac_config_tx_nibble_fifo_tx_read_phase;        /* TX register read phase:                                                                                                                */
	                                                                                              /* If TX-Nibble-FIFO is enabled (fifo_depth!=0), TX-register is only dependant on a global 2-bit-counter.                                 */
	                                                                                              /* This value is used as phase of global 2-bit-counter, in which nibbles from tx register are read to TX-Nibble-FIFO.                     */
	                                                                                              /* This phase also directly influences the TPU-sync pulse.                                                                                */
	                                                                                              /* If TX-Nibble-FIFO is disabled (fifo_depth=0), TX-register is only dependant on external mii_txclk.                                     */
	                                                                                              /* In this case the phase, in which nibbles from tx register are read to TX-Nibble-FIFO, is defined by (output_phase - tx_read_phase).    */
	unsigned int tpu_sync_delay       : BFW_NX51_xmac_config_tx_nibble_fifo_tpu_sync_delay;       /* Delay between read of TX-register and TPU-sync pulse:                                                                                  */
	                                                                                              /* By this value the TPU-sync pulse is delayed by 0, 1, 2 or 3 clockcycles (x10ns).                                                       */
	                                                                                              /* This value can be used to optimize propagation delay from RPU to TPU, specially in HUB or SERCOSIII.                                   */
	unsigned int outputedge_tx_clk    : BFW_NX51_xmac_config_tx_nibble_fifo_outputedge_tx_clk;    /* MII output data is changed (active for 1cc)                                                                                            */
	                                                                                              /* This bit is read-only.                                                                                                                 */
	unsigned int send_at_tx_count_pos : BFW_NX51_xmac_config_tx_nibble_fifo_send_at_tx_count_pos; /* Start transmission if fill_level reached and tx_count[15]==0.                                                                          */
	                                                                                              /* Used for reconstruction of IFG.                                                                                                        */
	unsigned int col_low_active       : BFW_NX51_xmac_config_tx_nibble_fifo_col_low_active;       /* to generate status_mii2-col_was_here signal:                                                                                           */
	                                                                                              /* 0: activate col_was_here if col=1                                                                                                      */
	                                                                                              /* 1: activate col_was_here if col=0                                                                                                      */
	unsigned int reserved1            : BFW_NX51_xmac_config_tx_nibble_fifo_reserved1;            /* reserved                                                                                                                               */
} NX51_XMAC_CONFIG_TX_NIBBLE_FIFO_BIT_T;

typedef union {
	unsigned int                          val;
	NX51_XMAC_CONFIG_TX_NIBBLE_FIFO_BIT_T bf;
} NX51_XMAC_CONFIG_TX_NIBBLE_FIFO_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_sbu */
/* => xMAC Config Register for SBU */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_sbu        0x00000130U
#define Adr_NX51_xmac0_regs_xmac_config_sbu 0x1018B530U
#define Adr_NX51_xmac1_regs_xmac_config_sbu 0x1018B730U
#define DFLT_VAL_NX51_xmac_config_sbu       0x00000080U

#define MSK_NX51_xmac_config_sbu_sync_to_eclk                         0x00000001U
#define SRT_NX51_xmac_config_sbu_sync_to_eclk                         0
#define DFLT_VAL_NX51_xmac_config_sbu_sync_to_eclk                    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_sync_to_eclk                 0x00000000U
#define MSK_NX51_xmac_config_sbu_sync_to_bitstream                    0x00000002U
#define SRT_NX51_xmac_config_sbu_sync_to_bitstream                    1
#define DFLT_VAL_NX51_xmac_config_sbu_sync_to_bitstream               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_sync_to_bitstream            0x00000000U
#define MSK_NX51_xmac_config_sbu_sync_to_posedge                      0x00000004U
#define SRT_NX51_xmac_config_sbu_sync_to_posedge                      2
#define DFLT_VAL_NX51_xmac_config_sbu_sync_to_posedge                 0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_sync_to_posedge              0x00000000U
#define MSK_NX51_xmac_config_sbu_sync_to_negedge                      0x00000008U
#define SRT_NX51_xmac_config_sbu_sync_to_negedge                      3
#define DFLT_VAL_NX51_xmac_config_sbu_sync_to_negedge                 0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_sync_to_negedge              0x00000000U
#define MSK_NX51_xmac_config_sbu_count_modulo                         0x00000010U
#define SRT_NX51_xmac_config_sbu_count_modulo                         4
#define DFLT_VAL_NX51_xmac_config_sbu_count_modulo                    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_count_modulo                 0x00000000U
#define MSK_NX51_xmac_config_sbu_invert_bit                           0x00000020U
#define SRT_NX51_xmac_config_sbu_invert_bit                           5
#define DFLT_VAL_NX51_xmac_config_sbu_invert_bit                      0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_invert_bit                   0x00000000U
#define MSK_NX51_xmac_config_sbu_predivide_clk                        0x00000040U
#define SRT_NX51_xmac_config_sbu_predivide_clk                        6
#define DFLT_VAL_NX51_xmac_config_sbu_predivide_clk                   0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_predivide_clk                0x00000000U
#define MSK_NX51_xmac_config_sbu_phy_led_en                           0x00000080U
#define SRT_NX51_xmac_config_sbu_phy_led_en                           7
#define DFLT_VAL_NX51_xmac_config_sbu_phy_led_en                      0x00000080U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_phy_led_en                   0x00000001U
#define MSK_NX51_xmac_config_sbu_ext_mode                             0x00000300U
#define SRT_NX51_xmac_config_sbu_ext_mode                             8
#define DFLT_VAL_NX51_xmac_config_sbu_ext_mode                        0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_ext_mode                     0x00000000U
#define MSK_NX51_xmac_config_sbu_drop_bit_at_sync                     0x00000400U
#define SRT_NX51_xmac_config_sbu_drop_bit_at_sync                     10
#define DFLT_VAL_NX51_xmac_config_sbu_drop_bit_at_sync                0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_drop_bit_at_sync             0x00000000U
#define MSK_NX51_xmac_config_sbu_disable_sync_in_sample_phase         0x00000800U
#define SRT_NX51_xmac_config_sbu_disable_sync_in_sample_phase         11
#define DFLT_VAL_NX51_xmac_config_sbu_disable_sync_in_sample_phase    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_disable_sync_in_sample_phase 0x00000000U
#define MSK_NX51_xmac_config_sbu_filter_sample_rate                   0x00007000U
#define SRT_NX51_xmac_config_sbu_filter_sample_rate                   12
#define DFLT_VAL_NX51_xmac_config_sbu_filter_sample_rate              0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu_filter_sample_rate           0x00000000U

/* all used bits of 'NX51_xmac_config_sbu': */
#define MSK_USED_BITS_NX51_xmac_config_sbu 0x00007fffU

enum {
	BFW_NX51_xmac_config_sbu_sync_to_eclk                 = 1,  /* [0] */
	BFW_NX51_xmac_config_sbu_sync_to_bitstream            = 1,  /* [1] */
	BFW_NX51_xmac_config_sbu_sync_to_posedge              = 1,  /* [2] */
	BFW_NX51_xmac_config_sbu_sync_to_negedge              = 1,  /* [3] */
	BFW_NX51_xmac_config_sbu_count_modulo                 = 1,  /* [4] */
	BFW_NX51_xmac_config_sbu_invert_bit                   = 1,  /* [5] */
	BFW_NX51_xmac_config_sbu_predivide_clk                = 1,  /* [6] */
	BFW_NX51_xmac_config_sbu_phy_led_en                   = 1,  /* [7] */
	BFW_NX51_xmac_config_sbu_ext_mode                     = 2,  /* [9:8] */
	BFW_NX51_xmac_config_sbu_drop_bit_at_sync             = 1,  /* [10] */
	BFW_NX51_xmac_config_sbu_disable_sync_in_sample_phase = 1,  /* [11] */
	BFW_NX51_xmac_config_sbu_filter_sample_rate           = 3,  /* [14:12] */
	BFW_NX51_xmac_config_sbu_reserved1                    = 17  /* [31:15] */
};

typedef struct NX51_XMAC_CONFIG_SBU_BIT_Ttag {
	unsigned int sync_to_eclk                 : BFW_NX51_xmac_config_sbu_sync_to_eclk;                 /* Synchronize rate_multiplier to external clock,                                                              */
	                                                                                                   /* rate_mul is set to rate_mul_start at pos/negedge of eclk                                                    */
	unsigned int sync_to_bitstream            : BFW_NX51_xmac_config_sbu_sync_to_bitstream;            /* Synchronize rate_multiplier to data_in,                                                                     */
	                                                                                                   /* rate_mul is set to rate_mul_start at pos/negedge of data_in                                                 */
	unsigned int sync_to_posedge              : BFW_NX51_xmac_config_sbu_sync_to_posedge;              /* Synchronization of rate_multiplier works on positive edges of data_in/eclk                                  */
	unsigned int sync_to_negedge              : BFW_NX51_xmac_config_sbu_sync_to_negedge;              /* Synchronization of rate_multiplier works on negative edges of data_in/eclk                                  */
	unsigned int count_modulo                 : BFW_NX51_xmac_config_sbu_count_modulo;                 /* rate_multiplier continues counting after maximum value is reached                                           */
	unsigned int invert_bit                   : BFW_NX51_xmac_config_sbu_invert_bit;                   /* Invert incoming bit (only in bitstream mode).                                                               */
	                                                                                                   /* This register does not influence syncronization (sync_to_bitstream),                                        */
	                                                                                                   /* only bits collected in rx-register are inverted.                                                            */
	unsigned int predivide_clk                : BFW_NX51_xmac_config_sbu_predivide_clk;                /* use a clock frequency divided by 256                                                                        */
	unsigned int phy_led_en                   : BFW_NX51_xmac_config_sbu_phy_led_en;                   /* switch between GPIO 2..5 and PHY LED signals of internal PHYs in status_shared register                     */
	                                                                                                   /* 1: use PHY LED inputs for xmac_status_shared[5:2]                                                           */
	                                                                                                   /* 0: use GPIO2..5 inputs for xmac_status_shared[5:2]                                                          */
	unsigned int ext_mode                     : BFW_NX51_xmac_config_sbu_ext_mode;                     /* Mode of external interface:                                                                                 */
	                                                                                                   /* 00: Single bit mode                                                                                         */
	                                                                                                   /* 01: MII mode                                                                                                */
	                                                                                                   /* 10: All-in mode (reserved)                                                                                  */
	                                                                                                   /* 11: reserved                                                                                                */
	unsigned int drop_bit_at_sync             : BFW_NX51_xmac_config_sbu_drop_bit_at_sync;             /* If a sync event happens while sampling, the appropriate Bit is dropped:                                     */
	                                                                                                   /* 0: If a sync-pulse from eclk or bitstream happens between start_sample_pos and stop_sample_pos,             */
	                                                                                                   /*    the rate_multiplier is synced (=0) and the appropriate bit (even if not completely sampled) is           */
	                                                                                                   /*    forwarded to rx register.                                                                                */
	                                                                                                   /*    This setting is usefull, if sample phase is configured closed to the end of the bit period.              */
	                                                                                                   /* 1: If a sync-pulse from eclk or bitstream happens between start_sample_pos and stop_sample_pos,             */
	                                                                                                   /*    the rate_multiplier is synced (=0) but the appropriate bit is dropped.                                   */
	                                                                                                   /*    This setting is usefull, if sample phase is configured closed to the start of the bit period.            */
	unsigned int disable_sync_in_sample_phase : BFW_NX51_xmac_config_sbu_disable_sync_in_sample_phase; /* Completely ignore sync-pulses during sample phase:                                                          */
	                                                                                                   /* 1: Between start_sample_pos and stop_sample_pos, sync-pulses from eclk or bitstream are completely ignored. */
	                                                                                                   /*    Also rate_multiplier is not synced.                                                                      */
	unsigned int filter_sample_rate           : BFW_NX51_xmac_config_sbu_filter_sample_rate;           /* xMAC signalfilter sample rate:                                                                              */
	                                                                                                   /* Sample rate for bitstream-input (xm0_rx) and eclk-input (xm0_eclk).                                         */
	                                                                                                   /* Filters sample input signal all n clockccycles, then use majority of last three sampled inputs for output.  */
	                                                                                                   /* Remark: Filter must be disabled in MII mode.                                                                */
	                                                                                                   /* 000: filter off (asynchronous throughput)                                                                   */
	                                                                                                   /* 001: 1x clk   - remove spikes <  10ns, passes signals <  50MHz, 20ns delay                                  */
	                                                                                                   /* 010: 2x clk   - remove spikes <  20ns, passes signals <  25MHz, 40ns delay                                  */
	                                                                                                   /* 011: 5x clk   - remove spikes <  50ns, passes signals <  10MHz, 100ns delay                                 */
	                                                                                                   /* 100: 10x clk  - remove spikes < 100ns, passes signals <   5MHz, 200ns delay                                 */
	                                                                                                   /* 101: 20x clk  - remove spikes < 200ns, passes signals < 2,5MHz, 400ns delay                                 */
	                                                                                                   /* 110: 50x clk  - remove spikes < 500ns, passes signals <   1MHz, 1us delay                                   */
	                                                                                                   /* 111: 100x clk - remove spikes < 1us,   passes signals < 500kHz, 2us delay                                   */
	unsigned int reserved1                    : BFW_NX51_xmac_config_sbu_reserved1;                    /* reserved                                                                                                    */
} NX51_XMAC_CONFIG_SBU_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_CONFIG_SBU_BIT_T bf;
} NX51_XMAC_CONFIG_SBU_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_sbu2 */
/* => xMAC 2nd Config Register for SBU */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_sbu2        0x00000134U
#define Adr_NX51_xmac0_regs_xmac_config_sbu2 0x1018B534U
#define Adr_NX51_xmac1_regs_xmac_config_sbu2 0x1018B734U
#define DFLT_VAL_NX51_xmac_config_sbu2       0x00000008U

#define MSK_NX51_xmac_config_sbu2_rx_nof_bits                    0x0000000fU
#define SRT_NX51_xmac_config_sbu2_rx_nof_bits                    0
#define DFLT_VAL_NX51_xmac_config_sbu2_rx_nof_bits               0x00000008U
#define DFLT_BF_VAL_NX51_xmac_config_sbu2_rx_nof_bits            0x00000008U
#define MSK_NX51_xmac_config_sbu2_rx_shift_lr                    0x00000010U
#define SRT_NX51_xmac_config_sbu2_rx_shift_lr                    4
#define DFLT_VAL_NX51_xmac_config_sbu2_rx_shift_lr               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu2_rx_shift_lr            0x00000000U
#define MSK_NX51_xmac_config_sbu2_rx_count_stops_at_ovfl         0x00000020U
#define SRT_NX51_xmac_config_sbu2_rx_count_stops_at_ovfl         5
#define DFLT_VAL_NX51_xmac_config_sbu2_rx_count_stops_at_ovfl    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu2_rx_count_stops_at_ovfl 0x00000000U
#define MSK_NX51_xmac_config_sbu2_urx_write_odd                  0x00000040U
#define SRT_NX51_xmac_config_sbu2_urx_write_odd                  6
#define DFLT_VAL_NX51_xmac_config_sbu2_urx_write_odd             0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu2_urx_write_odd          0x00000000U
#define MSK_NX51_xmac_config_sbu2_rx_clk_phase                   0x00000380U
#define SRT_NX51_xmac_config_sbu2_rx_clk_phase                   7
#define DFLT_VAL_NX51_xmac_config_sbu2_rx_clk_phase              0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_sbu2_rx_clk_phase           0x00000000U

/* all used bits of 'NX51_xmac_config_sbu2': */
#define MSK_USED_BITS_NX51_xmac_config_sbu2 0x000003ffU

enum {
	BFW_NX51_xmac_config_sbu2_rx_nof_bits            = 4,  /* [3:0] */
	BFW_NX51_xmac_config_sbu2_rx_shift_lr            = 1,  /* [4] */
	BFW_NX51_xmac_config_sbu2_rx_count_stops_at_ovfl = 1,  /* [5] */
	BFW_NX51_xmac_config_sbu2_urx_write_odd          = 1,  /* [6] */
	BFW_NX51_xmac_config_sbu2_rx_clk_phase           = 3,  /* [9:7] */
	BFW_NX51_xmac_config_sbu2_reserved1              = 22  /* [31:10] */
};

typedef struct NX51_XMAC_CONFIG_SBU2_BIT_Ttag {
	unsigned int rx_nof_bits            : BFW_NX51_xmac_config_sbu2_rx_nof_bits;            /* Preset value for rx_hw_count:                                                                   */
	                                                                                        /* In protocols using rx_hw mechanism to collect received bits in software,                        */
	                                                                                        /* received bits are stored in rx_hw register and rx_hw_count (down-)counts the                    */
	                                                                                        /* number of received bits.                                                                        */
	                                                                                        /* This value is the preset value for rx_hw_count, after 0 was reached.                            */
	unsigned int rx_shift_lr            : BFW_NX51_xmac_config_sbu2_rx_shift_lr;            /* 1: SBU writes incoming bits to position 0 of register rx and shifts rx left,                    */
	                                                                                        /* 0: SBU writes incoming bits to position 15 of register rx and shifts rx right                   */
	unsigned int rx_count_stops_at_ovfl : BFW_NX51_xmac_config_sbu2_rx_count_stops_at_ovfl; /* 1: rx_count stops counting after overflow                                                       */
	                                                                                        /* 0: rx_count continues counting at overflow                                                      */
	unsigned int urx_write_odd          : BFW_NX51_xmac_config_sbu2_urx_write_odd;          /* This bit toggles with every write access to URX-FIFO.                                           */
	                                                                                        /* This bit has a delay of 1cc, i.e. gets active in the next but one cycle after writing URX-FIFO. */
	unsigned int rx_clk_phase           : BFW_NX51_xmac_config_sbu2_rx_clk_phase;           /* Phase of mii_rx_clk in steps of 1,25ns (read only):                                             */
	                                                                                        /* Phase is delayed according to rx-data (changes with rx register).                               */
	                                                                                        /* This works only if config_rx_nibble_fifo-fifo_depth = 0.                                        */
	unsigned int reserved1              : BFW_NX51_xmac_config_sbu2_reserved1;              /* reserved                                                                                        */
} NX51_XMAC_CONFIG_SBU2_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_CONFIG_SBU2_BIT_T bf;
} NX51_XMAC_CONFIG_SBU2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sbu_rate_mul_add */
/* => xMAC SBU rate_mul_add: */
/*    Value added each cc to Rate Multiplier. */
/*    rate_mul_add = eclk / clk * 65536 */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sbu_rate_mul_add        0x00000138U
#define Adr_NX51_xmac0_regs_xmac_sbu_rate_mul_add 0x1018B538U
#define Adr_NX51_xmac1_regs_xmac_sbu_rate_mul_add 0x1018B738U
#define DFLT_VAL_NX51_xmac_sbu_rate_mul_add       0x00000001U

#define MSK_NX51_xmac_sbu_rate_mul_add_rate_mul_add         0x0000ffffU
#define SRT_NX51_xmac_sbu_rate_mul_add_rate_mul_add         0
#define DFLT_VAL_NX51_xmac_sbu_rate_mul_add_rate_mul_add    0x00000001U
#define DFLT_BF_VAL_NX51_xmac_sbu_rate_mul_add_rate_mul_add 0x00000001U

/* all used bits of 'NX51_xmac_sbu_rate_mul_add': */
#define MSK_USED_BITS_NX51_xmac_sbu_rate_mul_add 0x0000ffffU

enum {
	BFW_NX51_xmac_sbu_rate_mul_add_rate_mul_add = 16, /* [15:0] */
	BFW_NX51_xmac_sbu_rate_mul_add_reserved1    = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SBU_RATE_MUL_ADD_BIT_Ttag {
	unsigned int rate_mul_add : BFW_NX51_xmac_sbu_rate_mul_add_rate_mul_add; /* Value added each cc to Rate Multiplier.                                             */
	                                                                         /* If rate_mul_add=1:      rate_mul counts from [rate_mul_start:65535]                 */
	                                                                         /* else (rate_mul_add!=1): rate_mul counts from [0:65535].                             */
	                                                                         /* Special case:                                                                       */
	                                                                         /* If rate_mul_add=1 && rate_mul_start=65535 SBU samples bitstream_in each cc into rx, */
	                                                                         /* sampling enabled/disabled with rate_mul_add=1/0.                                    */
	unsigned int reserved1    : BFW_NX51_xmac_sbu_rate_mul_add_reserved1;    /* reserved                                                                            */
} NX51_XMAC_SBU_RATE_MUL_ADD_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XMAC_SBU_RATE_MUL_ADD_BIT_T bf;
} NX51_XMAC_SBU_RATE_MUL_ADD_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sbu_rate_mul_start */
/* => xMAC SBU rate_mul_start */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sbu_rate_mul_start        0x0000013CU
#define Adr_NX51_xmac0_regs_xmac_sbu_rate_mul_start 0x1018B53CU
#define Adr_NX51_xmac1_regs_xmac_sbu_rate_mul_start 0x1018B73CU
#define DFLT_VAL_NX51_xmac_sbu_rate_mul_start       0x00000000U

#define MSK_NX51_xmac_sbu_rate_mul_start_rate_mul_start         0x0000ffffU
#define SRT_NX51_xmac_sbu_rate_mul_start_rate_mul_start         0
#define DFLT_VAL_NX51_xmac_sbu_rate_mul_start_rate_mul_start    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_sbu_rate_mul_start_rate_mul_start 0x00000000U

/* all used bits of 'NX51_xmac_sbu_rate_mul_start': */
#define MSK_USED_BITS_NX51_xmac_sbu_rate_mul_start 0x0000ffffU

enum {
	BFW_NX51_xmac_sbu_rate_mul_start_rate_mul_start = 16, /* [15:0] */
	BFW_NX51_xmac_sbu_rate_mul_start_reserved1      = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SBU_RATE_MUL_START_BIT_Ttag {
	unsigned int rate_mul_start : BFW_NX51_xmac_sbu_rate_mul_start_rate_mul_start; /* Value, the Rate Multiplier is set to at sync */
	unsigned int reserved1      : BFW_NX51_xmac_sbu_rate_mul_start_reserved1;      /* reserved                                     */
} NX51_XMAC_SBU_RATE_MUL_START_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_XMAC_SBU_RATE_MUL_START_BIT_T bf;
} NX51_XMAC_SBU_RATE_MUL_START_T;

/* --------------------------------------------------------------------- */
/* Register xmac_sbu_rate_mul */
/* => xMAC SBU rate_mul */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_sbu_rate_mul        0x00000140U
#define Adr_NX51_xmac0_regs_xmac_sbu_rate_mul 0x1018B540U
#define Adr_NX51_xmac1_regs_xmac_sbu_rate_mul 0x1018B740U
#define DFLT_VAL_NX51_xmac_sbu_rate_mul       0x0000ffffU

#define MSK_NX51_xmac_sbu_rate_mul_rate_mul         0x0000ffffU
#define SRT_NX51_xmac_sbu_rate_mul_rate_mul         0
#define DFLT_VAL_NX51_xmac_sbu_rate_mul_rate_mul    0x0000ffffU
#define DFLT_BF_VAL_NX51_xmac_sbu_rate_mul_rate_mul 0x0000ffffU

/* all used bits of 'NX51_xmac_sbu_rate_mul': */
#define MSK_USED_BITS_NX51_xmac_sbu_rate_mul 0x0000ffffU

enum {
	BFW_NX51_xmac_sbu_rate_mul_rate_mul  = 16, /* [15:0] */
	BFW_NX51_xmac_sbu_rate_mul_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_SBU_RATE_MUL_BIT_Ttag {
	unsigned int rate_mul  : BFW_NX51_xmac_sbu_rate_mul_rate_mul;  /* current value of Rate Multiplier */
	unsigned int reserved1 : BFW_NX51_xmac_sbu_rate_mul_reserved1; /* reserved                         */
} NX51_XMAC_SBU_RATE_MUL_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XMAC_SBU_RATE_MUL_BIT_T bf;
} NX51_XMAC_SBU_RATE_MUL_T;

/* --------------------------------------------------------------------- */
/* Register xmac_start_sample_pos */
/* => xMAC SBU start_sample_pos */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_start_sample_pos        0x00000144U
#define Adr_NX51_xmac0_regs_xmac_start_sample_pos 0x1018B544U
#define Adr_NX51_xmac1_regs_xmac_start_sample_pos 0x1018B744U
#define DFLT_VAL_NX51_xmac_start_sample_pos       0x00000000U

#define MSK_NX51_xmac_start_sample_pos_start_sample_pos         0x0000ffffU
#define SRT_NX51_xmac_start_sample_pos_start_sample_pos         0
#define DFLT_VAL_NX51_xmac_start_sample_pos_start_sample_pos    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_start_sample_pos_start_sample_pos 0x00000000U

/* all used bits of 'NX51_xmac_start_sample_pos': */
#define MSK_USED_BITS_NX51_xmac_start_sample_pos 0x0000ffffU

enum {
	BFW_NX51_xmac_start_sample_pos_start_sample_pos = 16, /* [15:0] */
	BFW_NX51_xmac_start_sample_pos_reserved1        = 16  /* [31:16] */
};

typedef struct NX51_XMAC_START_SAMPLE_POS_BIT_Ttag {
	unsigned int start_sample_pos : BFW_NX51_xmac_start_sample_pos_start_sample_pos; /* Data is sampled and averaged between start_sample_pos and stop_sample_pos, in detail:                       */
	                                                                                 /* start_sample_pos <  stop_sample_pos: sample if start_sample_pos <= rate_mul < stop_sample_pos               */
	                                                                                 /* start_sample_pos >= stop_sample_pos: sample if start_sample_pos <= rate_mul  or  rate_mul < stop_sample_pos */
	                                                                                 /* For more details see XMAC/doc/sbu_state_machine.vsd.                                                        */
	unsigned int reserved1        : BFW_NX51_xmac_start_sample_pos_reserved1;        /* reserved                                                                                                    */
} NX51_XMAC_START_SAMPLE_POS_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XMAC_START_SAMPLE_POS_BIT_T bf;
} NX51_XMAC_START_SAMPLE_POS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_stop_sample_pos */
/* => xMAC SBU stop_sample_pos */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_stop_sample_pos        0x00000148U
#define Adr_NX51_xmac0_regs_xmac_stop_sample_pos 0x1018B548U
#define Adr_NX51_xmac1_regs_xmac_stop_sample_pos 0x1018B748U
#define DFLT_VAL_NX51_xmac_stop_sample_pos       0x00000000U

#define MSK_NX51_xmac_stop_sample_pos_stop_sample_pos         0x0000ffffU
#define SRT_NX51_xmac_stop_sample_pos_stop_sample_pos         0
#define DFLT_VAL_NX51_xmac_stop_sample_pos_stop_sample_pos    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_stop_sample_pos_stop_sample_pos 0x00000000U

/* all used bits of 'NX51_xmac_stop_sample_pos': */
#define MSK_USED_BITS_NX51_xmac_stop_sample_pos 0x0000ffffU

enum {
	BFW_NX51_xmac_stop_sample_pos_stop_sample_pos = 16, /* [15:0] */
	BFW_NX51_xmac_stop_sample_pos_reserved1       = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STOP_SAMPLE_POS_BIT_Ttag {
	unsigned int stop_sample_pos : BFW_NX51_xmac_stop_sample_pos_stop_sample_pos; /* Data is sampled and averaged between start_sample_pos and stop_sample_pos, in detail:                       */
	                                                                              /* start_sample_pos <  stop_sample_pos: sample if start_sample_pos <= rate_mul < stop_sample_pos               */
	                                                                              /* start_sample_pos >= stop_sample_pos: sample if start_sample_pos <= rate_mul  or  rate_mul < stop_sample_pos */
	                                                                              /* For more details see XMAC/doc/sbu_state_machine.vsd.                                                        */
	unsigned int reserved1       : BFW_NX51_xmac_stop_sample_pos_reserved1;       /* reserved                                                                                                    */
} NX51_XMAC_STOP_SAMPLE_POS_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_XMAC_STOP_SAMPLE_POS_BIT_T bf;
} NX51_XMAC_STOP_SAMPLE_POS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_obu */
/* => xMAC Config Register for OBU */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_obu        0x0000014CU
#define Adr_NX51_xmac0_regs_xmac_config_obu 0x1018B54CU
#define Adr_NX51_xmac1_regs_xmac_config_obu 0x1018B74CU
#define DFLT_VAL_NX51_xmac_config_obu       0x00000180U

#define MSK_NX51_xmac_config_obu_sync_to_eclk                         0x00000001U
#define SRT_NX51_xmac_config_obu_sync_to_eclk                         0
#define DFLT_VAL_NX51_xmac_config_obu_sync_to_eclk                    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_sync_to_eclk                 0x00000000U
#define MSK_NX51_xmac_config_obu_sync_to_bitstream                    0x00000002U
#define SRT_NX51_xmac_config_obu_sync_to_bitstream                    1
#define DFLT_VAL_NX51_xmac_config_obu_sync_to_bitstream               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_sync_to_bitstream            0x00000000U
#define MSK_NX51_xmac_config_obu_sync_to_posedge                      0x00000004U
#define SRT_NX51_xmac_config_obu_sync_to_posedge                      2
#define DFLT_VAL_NX51_xmac_config_obu_sync_to_posedge                 0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_sync_to_posedge              0x00000000U
#define MSK_NX51_xmac_config_obu_sync_to_negedge                      0x00000008U
#define SRT_NX51_xmac_config_obu_sync_to_negedge                      3
#define DFLT_VAL_NX51_xmac_config_obu_sync_to_negedge                 0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_sync_to_negedge              0x00000000U
#define MSK_NX51_xmac_config_obu_count_modulo                         0x00000010U
#define SRT_NX51_xmac_config_obu_count_modulo                         4
#define DFLT_VAL_NX51_xmac_config_obu_count_modulo                    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_count_modulo                 0x00000000U
#define MSK_NX51_xmac_config_obu_invert_tx_oe                         0x00000020U
#define SRT_NX51_xmac_config_obu_invert_tx_oe                         5
#define DFLT_VAL_NX51_xmac_config_obu_invert_tx_oe                    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_invert_tx_oe                 0x00000000U
#define MSK_NX51_xmac_config_obu_predivide_clk                        0x00000040U
#define SRT_NX51_xmac_config_obu_predivide_clk                        6
#define DFLT_VAL_NX51_xmac_config_obu_predivide_clk                   0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_predivide_clk                0x00000000U
#define MSK_NX51_xmac_config_obu_tx_three_state                       0x00000080U
#define SRT_NX51_xmac_config_obu_tx_three_state                       7
#define DFLT_VAL_NX51_xmac_config_obu_tx_three_state                  0x00000080U
#define DFLT_BF_VAL_NX51_xmac_config_obu_tx_three_state               0x00000001U
#define MSK_NX51_xmac_config_obu_eclk_noe                             0x00000100U
#define SRT_NX51_xmac_config_obu_eclk_noe                             8
#define DFLT_VAL_NX51_xmac_config_obu_eclk_noe                        0x00000100U
#define DFLT_BF_VAL_NX51_xmac_config_obu_eclk_noe                     0x00000001U
#define MSK_NX51_xmac_config_obu_sample_bitstream_eclk                0x00000200U
#define SRT_NX51_xmac_config_obu_sample_bitstream_eclk                9
#define DFLT_VAL_NX51_xmac_config_obu_sample_bitstream_eclk           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_sample_bitstream_eclk        0x00000000U
#define MSK_NX51_xmac_config_obu_repeat_bit_at_sync                   0x00000400U
#define SRT_NX51_xmac_config_obu_repeat_bit_at_sync                   10
#define DFLT_VAL_NX51_xmac_config_obu_repeat_bit_at_sync              0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_repeat_bit_at_sync           0x00000000U
#define MSK_NX51_xmac_config_obu_disable_sync_in_output_phase         0x00000800U
#define SRT_NX51_xmac_config_obu_disable_sync_in_output_phase         11
#define DFLT_VAL_NX51_xmac_config_obu_disable_sync_in_output_phase    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu_disable_sync_in_output_phase 0x00000000U

/* all used bits of 'NX51_xmac_config_obu': */
#define MSK_USED_BITS_NX51_xmac_config_obu 0x00000fffU

enum {
	BFW_NX51_xmac_config_obu_sync_to_eclk                 = 1,  /* [0] */
	BFW_NX51_xmac_config_obu_sync_to_bitstream            = 1,  /* [1] */
	BFW_NX51_xmac_config_obu_sync_to_posedge              = 1,  /* [2] */
	BFW_NX51_xmac_config_obu_sync_to_negedge              = 1,  /* [3] */
	BFW_NX51_xmac_config_obu_count_modulo                 = 1,  /* [4] */
	BFW_NX51_xmac_config_obu_invert_tx_oe                 = 1,  /* [5] */
	BFW_NX51_xmac_config_obu_predivide_clk                = 1,  /* [6] */
	BFW_NX51_xmac_config_obu_tx_three_state               = 1,  /* [7] */
	BFW_NX51_xmac_config_obu_eclk_noe                     = 1,  /* [8] */
	BFW_NX51_xmac_config_obu_sample_bitstream_eclk        = 1,  /* [9] */
	BFW_NX51_xmac_config_obu_repeat_bit_at_sync           = 1,  /* [10] */
	BFW_NX51_xmac_config_obu_disable_sync_in_output_phase = 1,  /* [11] */
	BFW_NX51_xmac_config_obu_reserved1                    = 20  /* [31:12] */
};

typedef struct NX51_XMAC_CONFIG_OBU_BIT_Ttag {
	unsigned int sync_to_eclk                 : BFW_NX51_xmac_config_obu_sync_to_eclk;                 /* Synchronize rate_multiplier to external clock,                                                            */
	                                                                                                   /* rate_mul is set to rate_mul_start at pos/negedge of eclk                                                  */
	unsigned int sync_to_bitstream            : BFW_NX51_xmac_config_obu_sync_to_bitstream;            /* Synchronize rate_multiplier to data_in,                                                                   */
	                                                                                                   /* rate_mul is set to rate_mul_start at pos/negedge of data_in                                               */
	unsigned int sync_to_posedge              : BFW_NX51_xmac_config_obu_sync_to_posedge;              /* Synchronization of rate_multiplier works on positive edges of data_in/eclk                                */
	unsigned int sync_to_negedge              : BFW_NX51_xmac_config_obu_sync_to_negedge;              /* Synchronization of rate_multiplier works on negative edges of data_in/eclk                                */
	unsigned int count_modulo                 : BFW_NX51_xmac_config_obu_count_modulo;                 /* rate_multiplier continues counting after maximum value is reached                                         */
	unsigned int invert_tx_oe                 : BFW_NX51_xmac_config_obu_invert_tx_oe;                 /* Invert outgoing tx_bit_oe:                                                                                */
	                                                                                                   /* Only the output_enable going to pad tx_bit_oe (mii_txen) is inverted,                                     */
	                                                                                                   /* the output enable driving tx_bit (mii_txd[0]) keeps its functionality.                                    */
	                                                                                                   /* Incoming bits can be inverted by xmac_config_sbu-invert_bit.                                              */
	unsigned int predivide_clk                : BFW_NX51_xmac_config_obu_predivide_clk;                /* use a clock frequency divided by 256                                                                      */
	unsigned int tx_three_state               : BFW_NX51_xmac_config_obu_tx_three_state;               /* deactivates output enable of actually transmitted bit (or nibble in mii-mode)                             */
	unsigned int eclk_noe                     : BFW_NX51_xmac_config_obu_eclk_noe;                     /* inv. output enable of eclk: 0: eclk generated by xMAC, 1: eclk coming from external                       */
	unsigned int sample_bitstream_eclk        : BFW_NX51_xmac_config_obu_sample_bitstream_eclk;        /* 1: sample outgoing bitstream and its oe with eclk (posedge).                                              */
	unsigned int repeat_bit_at_sync           : BFW_NX51_xmac_config_obu_repeat_bit_at_sync;           /* If a sync event happens in active output phase, the appropriate Bit is repeated:                          */
	                                                                                                   /* 0: If a sync-pulse from eclk or bitstream happens between start_trans_pos and stop_trans_pos,             */
	                                                                                                   /*    the rate_multiplier is synced (=0) and the next bit is requested from tx-register.                     */
	                                                                                                   /*    This setting is usefull, if output phase is configured closed to the end of the bit period.            */
	                                                                                                   /* 1: If a sync-pulse from eclk or bitstream happens between start_trans_pos and stop_trans_pos,             */
	                                                                                                   /*    the rate_multiplier is synced (=0) but the appropriate bit is repeated,                                */
	                                                                                                   /*    no new bit is requested from tx-register.                                                              */
	                                                                                                   /*    This setting is usefull, if output phase is configured closed to the start of the bit period.          */
	unsigned int disable_sync_in_output_phase : BFW_NX51_xmac_config_obu_disable_sync_in_output_phase; /* Completely ignore sync-pulses during active output phase:                                                 */
	                                                                                                   /* 1: Between start_trans_pos and stop_trans_pos, sync-pulses from eclk or bitstream are completely ignored. */
	                                                                                                   /*    Also rate_multiplier is not synced.                                                                    */
	unsigned int reserved1                    : BFW_NX51_xmac_config_obu_reserved1;                    /* reserved                                                                                                  */
} NX51_XMAC_CONFIG_OBU_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_CONFIG_OBU_BIT_T bf;
} NX51_XMAC_CONFIG_OBU_T;

/* --------------------------------------------------------------------- */
/* Register xmac_config_obu2 */
/* => xMAC 2nd Config Register for OBU */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_config_obu2        0x00000150U
#define Adr_NX51_xmac0_regs_xmac_config_obu2 0x1018B550U
#define Adr_NX51_xmac1_regs_xmac_config_obu2 0x1018B750U
#define DFLT_VAL_NX51_xmac_config_obu2       0x000007c8U

#define MSK_NX51_xmac_config_obu2_tx_nof_bits                    0x0000000fU
#define SRT_NX51_xmac_config_obu2_tx_nof_bits                    0
#define DFLT_VAL_NX51_xmac_config_obu2_tx_nof_bits               0x00000008U
#define DFLT_BF_VAL_NX51_xmac_config_obu2_tx_nof_bits            0x00000008U
#define MSK_NX51_xmac_config_obu2_tx_shift_lr                    0x00000010U
#define SRT_NX51_xmac_config_obu2_tx_shift_lr                    4
#define DFLT_VAL_NX51_xmac_config_obu2_tx_shift_lr               0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu2_tx_shift_lr            0x00000000U
#define MSK_NX51_xmac_config_obu2_tx_count_stops_at_ovfl         0x00000020U
#define SRT_NX51_xmac_config_obu2_tx_count_stops_at_ovfl         5
#define DFLT_VAL_NX51_xmac_config_obu2_tx_count_stops_at_ovfl    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu2_tx_count_stops_at_ovfl 0x00000000U
#define MSK_NX51_xmac_config_obu2_utx_watermark                  0x000007c0U
#define SRT_NX51_xmac_config_obu2_utx_watermark                  6
#define DFLT_VAL_NX51_xmac_config_obu2_utx_watermark             0x000007c0U
#define DFLT_BF_VAL_NX51_xmac_config_obu2_utx_watermark          0x0000001fU
#define MSK_NX51_xmac_config_obu2_tx_clk_phase                   0x00003800U
#define SRT_NX51_xmac_config_obu2_tx_clk_phase                   11
#define DFLT_VAL_NX51_xmac_config_obu2_tx_clk_phase              0x00000000U
#define DFLT_BF_VAL_NX51_xmac_config_obu2_tx_clk_phase           0x00000000U

/* all used bits of 'NX51_xmac_config_obu2': */
#define MSK_USED_BITS_NX51_xmac_config_obu2 0x00003fffU

enum {
	BFW_NX51_xmac_config_obu2_tx_nof_bits            = 4,  /* [3:0] */
	BFW_NX51_xmac_config_obu2_tx_shift_lr            = 1,  /* [4] */
	BFW_NX51_xmac_config_obu2_tx_count_stops_at_ovfl = 1,  /* [5] */
	BFW_NX51_xmac_config_obu2_utx_watermark          = 5,  /* [10:6] */
	BFW_NX51_xmac_config_obu2_tx_clk_phase           = 3,  /* [13:11] */
	BFW_NX51_xmac_config_obu2_reserved1              = 18  /* [31:14] */
};

typedef struct NX51_XMAC_CONFIG_OBU2_BIT_Ttag {
	unsigned int tx_nof_bits            : BFW_NX51_xmac_config_obu2_tx_nof_bits;            /* Number of bits read by OBU from tx-register.                                                                        */
	                                                                                        /* Only used by tx_hw_count.                                                                                           */
	unsigned int tx_shift_lr            : BFW_NX51_xmac_config_obu2_tx_shift_lr;            /* 1: OBU reads outgoing bits from position 15 of register tx and shifts tx left,                                      */
	                                                                                        /* 0: OBU reads outgoing bits from position 0 of register tx and shifts tx right                                       */
	unsigned int tx_count_stops_at_ovfl : BFW_NX51_xmac_config_obu2_tx_count_stops_at_ovfl; /* 1: tx_count stops counting after overflow                                                                           */
	                                                                                        /* 0: tx_count continues counting at overflow                                                                          */
	unsigned int utx_watermark          : BFW_NX51_xmac_config_obu2_utx_watermark;          /* Watermark for xPEC event tx_nxt2.                                                                                   */
	                                                                                        /* tx_nxt2 is active, when there is at least 2 free entries to fill level (utx_watermark+1).                           */
	                                                                                        /* Due to internal pipeline structure tx_nxt2 need not be inactive, if there is watermark or more entries in the FIFO. */
	                                                                                        /* Allowed range is [2..31].                                                                                           */
	                                                                                        /* Value can only be changed, if FIFO is empty.                                                                        */
	                                                                                        /* Example1: utx_watermark=2:  tx_nxt2 is active if utx_fill_level < 2.                                                */
	                                                                                        /* Example2: utx_watermark=31: tx_nxt2 is active if utx_fill_level < 31.                                               */
	                                                                                        /*                             tx_nxt2 need not be inactive if utx_fill_level >= 31.                                   */
	unsigned int tx_clk_phase           : BFW_NX51_xmac_config_obu2_tx_clk_phase;           /* phase of mii_tx_clk in steps of 1,25ns (read only)                                                                  */
	unsigned int reserved1              : BFW_NX51_xmac_config_obu2_reserved1;              /* reserved                                                                                                            */
} NX51_XMAC_CONFIG_OBU2_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XMAC_CONFIG_OBU2_BIT_T bf;
} NX51_XMAC_CONFIG_OBU2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_obu_rate_mul_add */
/* => xMAC OBU rate_mul_add: */
/*    Value added each cc to Rate Multiplier. */
/*    rate_mul_add = eclk / clk * 65536 */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_obu_rate_mul_add        0x00000154U
#define Adr_NX51_xmac0_regs_xmac_obu_rate_mul_add 0x1018B554U
#define Adr_NX51_xmac1_regs_xmac_obu_rate_mul_add 0x1018B754U
#define DFLT_VAL_NX51_xmac_obu_rate_mul_add       0x00000001U

#define MSK_NX51_xmac_obu_rate_mul_add_rate_mul_add         0x0000ffffU
#define SRT_NX51_xmac_obu_rate_mul_add_rate_mul_add         0
#define DFLT_VAL_NX51_xmac_obu_rate_mul_add_rate_mul_add    0x00000001U
#define DFLT_BF_VAL_NX51_xmac_obu_rate_mul_add_rate_mul_add 0x00000001U

/* all used bits of 'NX51_xmac_obu_rate_mul_add': */
#define MSK_USED_BITS_NX51_xmac_obu_rate_mul_add 0x0000ffffU

enum {
	BFW_NX51_xmac_obu_rate_mul_add_rate_mul_add = 16, /* [15:0] */
	BFW_NX51_xmac_obu_rate_mul_add_reserved1    = 16  /* [31:16] */
};

typedef struct NX51_XMAC_OBU_RATE_MUL_ADD_BIT_Ttag {
	unsigned int rate_mul_add : BFW_NX51_xmac_obu_rate_mul_add_rate_mul_add; /* Value added each cc to Rate Multiplier.                                   */
	                                                                         /* If rate_mul_add=1:      rate_mul counts from [rate_mul_start:65535]       */
	                                                                         /* else (rate_mul_add!=1): rate_mul counts from [0:65535]                    */
	                                                                         /* Special case:                                                             */
	                                                                         /* If rate_mul_add=1 && rate_mul_start=65535 OBU outputs in each cc from tx. */
	                                                                         /* output enabled/disabled with rate_mul_add=1/0.                            */
	unsigned int reserved1    : BFW_NX51_xmac_obu_rate_mul_add_reserved1;    /* reserved                                                                  */
} NX51_XMAC_OBU_RATE_MUL_ADD_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XMAC_OBU_RATE_MUL_ADD_BIT_T bf;
} NX51_XMAC_OBU_RATE_MUL_ADD_T;

/* --------------------------------------------------------------------- */
/* Register xmac_obu_rate_mul_start */
/* => xMAC OBU rate_mul_start */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_obu_rate_mul_start        0x00000158U
#define Adr_NX51_xmac0_regs_xmac_obu_rate_mul_start 0x1018B558U
#define Adr_NX51_xmac1_regs_xmac_obu_rate_mul_start 0x1018B758U
#define DFLT_VAL_NX51_xmac_obu_rate_mul_start       0x00000000U

#define MSK_NX51_xmac_obu_rate_mul_start_rate_mul_start         0x0000ffffU
#define SRT_NX51_xmac_obu_rate_mul_start_rate_mul_start         0
#define DFLT_VAL_NX51_xmac_obu_rate_mul_start_rate_mul_start    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_obu_rate_mul_start_rate_mul_start 0x00000000U

/* all used bits of 'NX51_xmac_obu_rate_mul_start': */
#define MSK_USED_BITS_NX51_xmac_obu_rate_mul_start 0x0000ffffU

enum {
	BFW_NX51_xmac_obu_rate_mul_start_rate_mul_start = 16, /* [15:0] */
	BFW_NX51_xmac_obu_rate_mul_start_reserved1      = 16  /* [31:16] */
};

typedef struct NX51_XMAC_OBU_RATE_MUL_START_BIT_Ttag {
	unsigned int rate_mul_start : BFW_NX51_xmac_obu_rate_mul_start_rate_mul_start; /* Value, the Rate Multiplier is set to at sync */
	unsigned int reserved1      : BFW_NX51_xmac_obu_rate_mul_start_reserved1;      /* reserved                                     */
} NX51_XMAC_OBU_RATE_MUL_START_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_XMAC_OBU_RATE_MUL_START_BIT_T bf;
} NX51_XMAC_OBU_RATE_MUL_START_T;

/* --------------------------------------------------------------------- */
/* Register xmac_obu_rate_mul */
/* => xMAC OBU rate_mul */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_obu_rate_mul        0x0000015CU
#define Adr_NX51_xmac0_regs_xmac_obu_rate_mul 0x1018B55CU
#define Adr_NX51_xmac1_regs_xmac_obu_rate_mul 0x1018B75CU
#define DFLT_VAL_NX51_xmac_obu_rate_mul       0x0000ffffU

#define MSK_NX51_xmac_obu_rate_mul_rate_mul         0x0000ffffU
#define SRT_NX51_xmac_obu_rate_mul_rate_mul         0
#define DFLT_VAL_NX51_xmac_obu_rate_mul_rate_mul    0x0000ffffU
#define DFLT_BF_VAL_NX51_xmac_obu_rate_mul_rate_mul 0x0000ffffU

/* all used bits of 'NX51_xmac_obu_rate_mul': */
#define MSK_USED_BITS_NX51_xmac_obu_rate_mul 0x0000ffffU

enum {
	BFW_NX51_xmac_obu_rate_mul_rate_mul  = 16, /* [15:0] */
	BFW_NX51_xmac_obu_rate_mul_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_OBU_RATE_MUL_BIT_Ttag {
	unsigned int rate_mul  : BFW_NX51_xmac_obu_rate_mul_rate_mul;  /* current value of Rate Multiplier */
	unsigned int reserved1 : BFW_NX51_xmac_obu_rate_mul_reserved1; /* reserved                         */
} NX51_XMAC_OBU_RATE_MUL_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XMAC_OBU_RATE_MUL_BIT_T bf;
} NX51_XMAC_OBU_RATE_MUL_T;

/* --------------------------------------------------------------------- */
/* Register xmac_start_trans_pos */
/* => xMAC SBU start_trans_pos */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_start_trans_pos        0x00000160U
#define Adr_NX51_xmac0_regs_xmac_start_trans_pos 0x1018B560U
#define Adr_NX51_xmac1_regs_xmac_start_trans_pos 0x1018B760U
#define DFLT_VAL_NX51_xmac_start_trans_pos       0x00000000U

#define MSK_NX51_xmac_start_trans_pos_start_trans_pos         0x0000ffffU
#define SRT_NX51_xmac_start_trans_pos_start_trans_pos         0
#define DFLT_VAL_NX51_xmac_start_trans_pos_start_trans_pos    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_start_trans_pos_start_trans_pos 0x00000000U

/* all used bits of 'NX51_xmac_start_trans_pos': */
#define MSK_USED_BITS_NX51_xmac_start_trans_pos 0x0000ffffU

enum {
	BFW_NX51_xmac_start_trans_pos_start_trans_pos = 16, /* [15:0] */
	BFW_NX51_xmac_start_trans_pos_reserved1       = 16  /* [31:16] */
};

typedef struct NX51_XMAC_START_TRANS_POS_BIT_Ttag {
	unsigned int start_trans_pos : BFW_NX51_xmac_start_trans_pos_start_trans_pos; /* bitstream_out and bitstream_oe change their value at start_trans_pos = rate_mul */
	unsigned int reserved1       : BFW_NX51_xmac_start_trans_pos_reserved1;       /* reserved                                                                        */
} NX51_XMAC_START_TRANS_POS_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_XMAC_START_TRANS_POS_BIT_T bf;
} NX51_XMAC_START_TRANS_POS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_stop_trans_pos */
/* => xMAC SBU stop_trans_pos */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_stop_trans_pos        0x00000164U
#define Adr_NX51_xmac0_regs_xmac_stop_trans_pos 0x1018B564U
#define Adr_NX51_xmac1_regs_xmac_stop_trans_pos 0x1018B764U
#define DFLT_VAL_NX51_xmac_stop_trans_pos       0x00000000U

#define MSK_NX51_xmac_stop_trans_pos_stop_trans_pos         0x0000ffffU
#define SRT_NX51_xmac_stop_trans_pos_stop_trans_pos         0
#define DFLT_VAL_NX51_xmac_stop_trans_pos_stop_trans_pos    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_stop_trans_pos_stop_trans_pos 0x00000000U

/* all used bits of 'NX51_xmac_stop_trans_pos': */
#define MSK_USED_BITS_NX51_xmac_stop_trans_pos 0x0000ffffU

enum {
	BFW_NX51_xmac_stop_trans_pos_stop_trans_pos = 16, /* [15:0] */
	BFW_NX51_xmac_stop_trans_pos_reserved1      = 16  /* [31:16] */
};

typedef struct NX51_XMAC_STOP_TRANS_POS_BIT_Ttag {
	unsigned int stop_trans_pos : BFW_NX51_xmac_stop_trans_pos_stop_trans_pos; /* bitstream_oe becomes 0 between start_trans_pos and stop_trans_pos, in detail:                                   */
	                                                                           /* start_trans_pos <  stop_trans_pos: bitstream_oe=0 if start_trans_pos <= rate_mul < stop_trans_pos               */
	                                                                           /* start_trans_pos >= stop_trans_pos: bitstream_oe=0 if start_trans_pos <= rate_mul  or  rate_mul < stop_trans_pos */
	                                                                           /* For more details see XMAC/doc/obu_state_machine.vsd.                                                            */
	unsigned int reserved1      : BFW_NX51_xmac_stop_trans_pos_reserved1;      /* reserved                                                                                                        */
} NX51_XMAC_STOP_TRANS_POS_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_XMAC_STOP_TRANS_POS_BIT_T bf;
} NX51_XMAC_STOP_TRANS_POS_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpu_count1 */
/* => xMAC RPU Counter 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpu_count1        0x00000168U
#define Adr_NX51_xmac0_regs_xmac_rpu_count1 0x1018B568U
#define Adr_NX51_xmac1_regs_xmac_rpu_count1 0x1018B768U
#define DFLT_VAL_NX51_xmac_rpu_count1       0x00000000U

#define MSK_NX51_xmac_rpu_count1_rpu_count1         0x0000ffffU
#define SRT_NX51_xmac_rpu_count1_rpu_count1         0
#define DFLT_VAL_NX51_xmac_rpu_count1_rpu_count1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rpu_count1_rpu_count1 0x00000000U

/* all used bits of 'NX51_xmac_rpu_count1': */
#define MSK_USED_BITS_NX51_xmac_rpu_count1 0x0000ffffU

enum {
	BFW_NX51_xmac_rpu_count1_rpu_count1 = 16, /* [15:0] */
	BFW_NX51_xmac_rpu_count1_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RPU_COUNT1_BIT_Ttag {
	unsigned int rpu_count1 : BFW_NX51_xmac_rpu_count1_rpu_count1; /* Counter incremented by rpu-hw_support bit cnt1 */
	unsigned int reserved1  : BFW_NX51_xmac_rpu_count1_reserved1;  /* reserved                                       */
} NX51_XMAC_RPU_COUNT1_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_RPU_COUNT1_BIT_T bf;
} NX51_XMAC_RPU_COUNT1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpu_count2 */
/* => xMAC RPU Counter 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpu_count2        0x0000016CU
#define Adr_NX51_xmac0_regs_xmac_rpu_count2 0x1018B56CU
#define Adr_NX51_xmac1_regs_xmac_rpu_count2 0x1018B76CU
#define DFLT_VAL_NX51_xmac_rpu_count2       0x00000000U

#define MSK_NX51_xmac_rpu_count2_rpu_count2         0x0000ffffU
#define SRT_NX51_xmac_rpu_count2_rpu_count2         0
#define DFLT_VAL_NX51_xmac_rpu_count2_rpu_count2    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rpu_count2_rpu_count2 0x00000000U

/* all used bits of 'NX51_xmac_rpu_count2': */
#define MSK_USED_BITS_NX51_xmac_rpu_count2 0x0000ffffU

enum {
	BFW_NX51_xmac_rpu_count2_rpu_count2 = 16, /* [15:0] */
	BFW_NX51_xmac_rpu_count2_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RPU_COUNT2_BIT_Ttag {
	unsigned int rpu_count2 : BFW_NX51_xmac_rpu_count2_rpu_count2; /* Counter incremented by rpu-hw_support bit cnt2 */
	unsigned int reserved1  : BFW_NX51_xmac_rpu_count2_reserved1;  /* reserved                                       */
} NX51_XMAC_RPU_COUNT2_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_RPU_COUNT2_BIT_T bf;
} NX51_XMAC_RPU_COUNT2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpu_count1 */
/* => xMAC TPU Counter 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpu_count1        0x00000170U
#define Adr_NX51_xmac0_regs_xmac_tpu_count1 0x1018B570U
#define Adr_NX51_xmac1_regs_xmac_tpu_count1 0x1018B770U
#define DFLT_VAL_NX51_xmac_tpu_count1       0x00000000U

#define MSK_NX51_xmac_tpu_count1_tpu_count1         0x0000ffffU
#define SRT_NX51_xmac_tpu_count1_tpu_count1         0
#define DFLT_VAL_NX51_xmac_tpu_count1_tpu_count1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tpu_count1_tpu_count1 0x00000000U

/* all used bits of 'NX51_xmac_tpu_count1': */
#define MSK_USED_BITS_NX51_xmac_tpu_count1 0x0000ffffU

enum {
	BFW_NX51_xmac_tpu_count1_tpu_count1 = 16, /* [15:0] */
	BFW_NX51_xmac_tpu_count1_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TPU_COUNT1_BIT_Ttag {
	unsigned int tpu_count1 : BFW_NX51_xmac_tpu_count1_tpu_count1; /* Counter incremented by tpu-hw_support bit cnt1 */
	unsigned int reserved1  : BFW_NX51_xmac_tpu_count1_reserved1;  /* reserved                                       */
} NX51_XMAC_TPU_COUNT1_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_TPU_COUNT1_BIT_T bf;
} NX51_XMAC_TPU_COUNT1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpu_count2 */
/* => xMAC TPU Counter 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpu_count2        0x00000174U
#define Adr_NX51_xmac0_regs_xmac_tpu_count2 0x1018B574U
#define Adr_NX51_xmac1_regs_xmac_tpu_count2 0x1018B774U
#define DFLT_VAL_NX51_xmac_tpu_count2       0x00000000U

#define MSK_NX51_xmac_tpu_count2_tpu_count2         0x0000ffffU
#define SRT_NX51_xmac_tpu_count2_tpu_count2         0
#define DFLT_VAL_NX51_xmac_tpu_count2_tpu_count2    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tpu_count2_tpu_count2 0x00000000U

/* all used bits of 'NX51_xmac_tpu_count2': */
#define MSK_USED_BITS_NX51_xmac_tpu_count2 0x0000ffffU

enum {
	BFW_NX51_xmac_tpu_count2_tpu_count2 = 16, /* [15:0] */
	BFW_NX51_xmac_tpu_count2_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TPU_COUNT2_BIT_Ttag {
	unsigned int tpu_count2 : BFW_NX51_xmac_tpu_count2_tpu_count2; /* Counter incremented by tpu-hw_support bit cnt2 */
	unsigned int reserved1  : BFW_NX51_xmac_tpu_count2_reserved1;  /* reserved                                       */
} NX51_XMAC_TPU_COUNT2_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_TPU_COUNT2_BIT_T bf;
} NX51_XMAC_TPU_COUNT2_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_count */
/* => xMAC RX Counter */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_count        0x00000178U
#define Adr_NX51_xmac0_regs_xmac_rx_count 0x1018B578U
#define Adr_NX51_xmac1_regs_xmac_rx_count 0x1018B778U
#define DFLT_VAL_NX51_xmac_rx_count       0x00000000U

#define MSK_NX51_xmac_rx_count_rx_count         0x0000ffffU
#define SRT_NX51_xmac_rx_count_rx_count         0
#define DFLT_VAL_NX51_xmac_rx_count_rx_count    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_count_rx_count 0x00000000U

/* all used bits of 'NX51_xmac_rx_count': */
#define MSK_USED_BITS_NX51_xmac_rx_count 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_count_rx_count  = 16, /* [15:0] */
	BFW_NX51_xmac_rx_count_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_COUNT_BIT_Ttag {
	unsigned int rx_count  : BFW_NX51_xmac_rx_count_rx_count;  /* Counter running on eclk */
	unsigned int reserved1 : BFW_NX51_xmac_rx_count_reserved1; /* reserved                */
} NX51_XMAC_RX_COUNT_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_RX_COUNT_BIT_T bf;
} NX51_XMAC_RX_COUNT_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_count */
/* => xMAC TX Counter */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_count        0x0000017CU
#define Adr_NX51_xmac0_regs_xmac_tx_count 0x1018B57CU
#define Adr_NX51_xmac1_regs_xmac_tx_count 0x1018B77CU
#define DFLT_VAL_NX51_xmac_tx_count       0x00000000U

#define MSK_NX51_xmac_tx_count_tx_count         0x0000ffffU
#define SRT_NX51_xmac_tx_count_tx_count         0
#define DFLT_VAL_NX51_xmac_tx_count_tx_count    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_count_tx_count 0x00000000U

/* all used bits of 'NX51_xmac_tx_count': */
#define MSK_USED_BITS_NX51_xmac_tx_count 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_count_tx_count  = 16, /* [15:0] */
	BFW_NX51_xmac_tx_count_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_COUNT_BIT_Ttag {
	unsigned int tx_count  : BFW_NX51_xmac_tx_count_tx_count;  /* Counter running on eclk */
	unsigned int reserved1 : BFW_NX51_xmac_tx_count_reserved1; /* reserved                */
} NX51_XMAC_TX_COUNT_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_TX_COUNT_BIT_T bf;
} NX51_XMAC_TX_COUNT_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpm_mask0 */
/* => xMAC Receive Pattern Match Mask 0 Register: */
/*    Defines, which bits are compared between xmac_rpm_val0 and xmac_rx. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpm_mask0        0x00000180U
#define Adr_NX51_xmac0_regs_xmac_rpm_mask0 0x1018B580U
#define Adr_NX51_xmac1_regs_xmac_rpm_mask0 0x1018B780U
#define DFLT_VAL_NX51_xmac_rpm_mask0       0x00000000U

#define MSK_NX51_xmac_rpm_mask0_pm_mask0         0x0000ffffU
#define SRT_NX51_xmac_rpm_mask0_pm_mask0         0
#define DFLT_VAL_NX51_xmac_rpm_mask0_pm_mask0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rpm_mask0_pm_mask0 0x00000000U

/* all used bits of 'NX51_xmac_rpm_mask0': */
#define MSK_USED_BITS_NX51_xmac_rpm_mask0 0x0000ffffU

enum {
	BFW_NX51_xmac_rpm_mask0_pm_mask0  = 16, /* [15:0] */
	BFW_NX51_xmac_rpm_mask0_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RPM_MASK0_BIT_Ttag {
	unsigned int pm_mask0  : BFW_NX51_xmac_rpm_mask0_pm_mask0;  /* Pattern Match Mask:                                   */
	                                                            /* 1: compare this position of xmac_rpm_val0 and xmac_rx */
	                                                            /* 0: ignore  this position of xmac_rpm_val0 and xmac_rx */
	unsigned int reserved1 : BFW_NX51_xmac_rpm_mask0_reserved1; /* reserved                                              */
} NX51_XMAC_RPM_MASK0_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XMAC_RPM_MASK0_BIT_T bf;
} NX51_XMAC_RPM_MASK0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpm_val0 */
/* => xMAC Receive Pattern Match Value 0 Register: */
/*    Defines value of bits to be compared with xmac_rx. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpm_val0        0x00000184U
#define Adr_NX51_xmac0_regs_xmac_rpm_val0 0x1018B584U
#define Adr_NX51_xmac1_regs_xmac_rpm_val0 0x1018B784U
#define DFLT_VAL_NX51_xmac_rpm_val0       0x00000000U

#define MSK_NX51_xmac_rpm_val0_pm_val0         0x0000ffffU
#define SRT_NX51_xmac_rpm_val0_pm_val0         0
#define DFLT_VAL_NX51_xmac_rpm_val0_pm_val0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rpm_val0_pm_val0 0x00000000U

/* all used bits of 'NX51_xmac_rpm_val0': */
#define MSK_USED_BITS_NX51_xmac_rpm_val0 0x0000ffffU

enum {
	BFW_NX51_xmac_rpm_val0_pm_val0   = 16, /* [15:0] */
	BFW_NX51_xmac_rpm_val0_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RPM_VAL0_BIT_Ttag {
	unsigned int pm_val0   : BFW_NX51_xmac_rpm_val0_pm_val0;   /* Pattern Match Value */
	unsigned int reserved1 : BFW_NX51_xmac_rpm_val0_reserved1; /* reserved            */
} NX51_XMAC_RPM_VAL0_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_RPM_VAL0_BIT_T bf;
} NX51_XMAC_RPM_VAL0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpm_mask1 */
/* => xMAC Receive Pattern Match Mask 1 Register: */
/*    Defines, which bits are compared between xmac_rpm_val1 and xmac_rx */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpm_mask1        0x00000188U
#define Adr_NX51_xmac0_regs_xmac_rpm_mask1 0x1018B588U
#define Adr_NX51_xmac1_regs_xmac_rpm_mask1 0x1018B788U
#define DFLT_VAL_NX51_xmac_rpm_mask1       0x00000000U

#define MSK_NX51_xmac_rpm_mask1_pm_mask1         0x0000ffffU
#define SRT_NX51_xmac_rpm_mask1_pm_mask1         0
#define DFLT_VAL_NX51_xmac_rpm_mask1_pm_mask1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rpm_mask1_pm_mask1 0x00000000U

/* all used bits of 'NX51_xmac_rpm_mask1': */
#define MSK_USED_BITS_NX51_xmac_rpm_mask1 0x0000ffffU

enum {
	BFW_NX51_xmac_rpm_mask1_pm_mask1  = 16, /* [15:0] */
	BFW_NX51_xmac_rpm_mask1_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RPM_MASK1_BIT_Ttag {
	unsigned int pm_mask1  : BFW_NX51_xmac_rpm_mask1_pm_mask1;  /* Pattern Match Mask:                                   */
	                                                            /* 1: compare this position of xmac_rpm_val1 and xmac_rx */
	                                                            /* 0: ignore  this position of xmac_rpm_val1 and xmac_rx */
	unsigned int reserved1 : BFW_NX51_xmac_rpm_mask1_reserved1; /* reserved                                              */
} NX51_XMAC_RPM_MASK1_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XMAC_RPM_MASK1_BIT_T bf;
} NX51_XMAC_RPM_MASK1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rpm_val1 */
/* => xMAC Receive Pattern Match Value 1 Register: */
/*    Defines value of bits to be compared with xmac_rx. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rpm_val1        0x0000018CU
#define Adr_NX51_xmac0_regs_xmac_rpm_val1 0x1018B58CU
#define Adr_NX51_xmac1_regs_xmac_rpm_val1 0x1018B78CU
#define DFLT_VAL_NX51_xmac_rpm_val1       0x00000000U

#define MSK_NX51_xmac_rpm_val1_pm_val1         0x0000ffffU
#define SRT_NX51_xmac_rpm_val1_pm_val1         0
#define DFLT_VAL_NX51_xmac_rpm_val1_pm_val1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rpm_val1_pm_val1 0x00000000U

/* all used bits of 'NX51_xmac_rpm_val1': */
#define MSK_USED_BITS_NX51_xmac_rpm_val1 0x0000ffffU

enum {
	BFW_NX51_xmac_rpm_val1_pm_val1   = 16, /* [15:0] */
	BFW_NX51_xmac_rpm_val1_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RPM_VAL1_BIT_Ttag {
	unsigned int pm_val1   : BFW_NX51_xmac_rpm_val1_pm_val1;   /* Pattern Match Value */
	unsigned int reserved1 : BFW_NX51_xmac_rpm_val1_reserved1; /* reserved            */
} NX51_XMAC_RPM_VAL1_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_RPM_VAL1_BIT_T bf;
} NX51_XMAC_RPM_VAL1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpm_mask0 */
/* => xMAC Transmit Pattern Match Mask 0 Register: */
/*    Defines, which bits are compared between xmac_tpm_val0 and xmac_tx_sent. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpm_mask0        0x00000190U
#define Adr_NX51_xmac0_regs_xmac_tpm_mask0 0x1018B590U
#define Adr_NX51_xmac1_regs_xmac_tpm_mask0 0x1018B790U
#define DFLT_VAL_NX51_xmac_tpm_mask0       0x00000000U

#define MSK_NX51_xmac_tpm_mask0_pm_mask0         0x0000ffffU
#define SRT_NX51_xmac_tpm_mask0_pm_mask0         0
#define DFLT_VAL_NX51_xmac_tpm_mask0_pm_mask0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tpm_mask0_pm_mask0 0x00000000U

/* all used bits of 'NX51_xmac_tpm_mask0': */
#define MSK_USED_BITS_NX51_xmac_tpm_mask0 0x0000ffffU

enum {
	BFW_NX51_xmac_tpm_mask0_pm_mask0  = 16, /* [15:0] */
	BFW_NX51_xmac_tpm_mask0_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TPM_MASK0_BIT_Ttag {
	unsigned int pm_mask0  : BFW_NX51_xmac_tpm_mask0_pm_mask0;  /* Pattern Match Mask:                                        */
	                                                            /* 1: compare this position of xmac_tpm_val0 and xmac_tx_sent */
	                                                            /* 0: ignore  this position of xmac_tpm_val0 and xmac_tx_sent */
	unsigned int reserved1 : BFW_NX51_xmac_tpm_mask0_reserved1; /* reserved                                                   */
} NX51_XMAC_TPM_MASK0_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XMAC_TPM_MASK0_BIT_T bf;
} NX51_XMAC_TPM_MASK0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpm_val0 */
/* => xMAC Transmit Pattern Match Value 0 Register: */
/*    Defines value of bits to be compared with xmac_tx_sent. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpm_val0        0x00000194U
#define Adr_NX51_xmac0_regs_xmac_tpm_val0 0x1018B594U
#define Adr_NX51_xmac1_regs_xmac_tpm_val0 0x1018B794U
#define DFLT_VAL_NX51_xmac_tpm_val0       0x00000000U

#define MSK_NX51_xmac_tpm_val0_pm_val0         0x0000ffffU
#define SRT_NX51_xmac_tpm_val0_pm_val0         0
#define DFLT_VAL_NX51_xmac_tpm_val0_pm_val0    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tpm_val0_pm_val0 0x00000000U

/* all used bits of 'NX51_xmac_tpm_val0': */
#define MSK_USED_BITS_NX51_xmac_tpm_val0 0x0000ffffU

enum {
	BFW_NX51_xmac_tpm_val0_pm_val0   = 16, /* [15:0] */
	BFW_NX51_xmac_tpm_val0_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TPM_VAL0_BIT_Ttag {
	unsigned int pm_val0   : BFW_NX51_xmac_tpm_val0_pm_val0;   /* Pattern Match Value */
	unsigned int reserved1 : BFW_NX51_xmac_tpm_val0_reserved1; /* reserved            */
} NX51_XMAC_TPM_VAL0_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_TPM_VAL0_BIT_T bf;
} NX51_XMAC_TPM_VAL0_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpm_mask1 */
/* => xMAC Transmit Pattern Match Mask 1 Register: */
/*    Defines, which bits are compared between xmac_tpm_val1 and xmac_tx_sent. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpm_mask1        0x00000198U
#define Adr_NX51_xmac0_regs_xmac_tpm_mask1 0x1018B598U
#define Adr_NX51_xmac1_regs_xmac_tpm_mask1 0x1018B798U
#define DFLT_VAL_NX51_xmac_tpm_mask1       0x00000000U

#define MSK_NX51_xmac_tpm_mask1_pm_mask1         0x0000ffffU
#define SRT_NX51_xmac_tpm_mask1_pm_mask1         0
#define DFLT_VAL_NX51_xmac_tpm_mask1_pm_mask1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tpm_mask1_pm_mask1 0x00000000U

/* all used bits of 'NX51_xmac_tpm_mask1': */
#define MSK_USED_BITS_NX51_xmac_tpm_mask1 0x0000ffffU

enum {
	BFW_NX51_xmac_tpm_mask1_pm_mask1  = 16, /* [15:0] */
	BFW_NX51_xmac_tpm_mask1_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TPM_MASK1_BIT_Ttag {
	unsigned int pm_mask1  : BFW_NX51_xmac_tpm_mask1_pm_mask1;  /* Pattern Match Mask:                                        */
	                                                            /* 1: compare this position of xmac_tpm_val1 and xmac_tx_sent */
	                                                            /* 0: ignore  this position of xmac_tpm_val1 and xmac_tx_sent */
	unsigned int reserved1 : BFW_NX51_xmac_tpm_mask1_reserved1; /* reserved                                                   */
} NX51_XMAC_TPM_MASK1_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XMAC_TPM_MASK1_BIT_T bf;
} NX51_XMAC_TPM_MASK1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tpm_val1 */
/* => xMAC Transmit Pattern Match Value 1 Register: */
/*    Defines value of bits to be compared with xmac_tx_sent. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tpm_val1        0x0000019CU
#define Adr_NX51_xmac0_regs_xmac_tpm_val1 0x1018B59CU
#define Adr_NX51_xmac1_regs_xmac_tpm_val1 0x1018B79CU
#define DFLT_VAL_NX51_xmac_tpm_val1       0x00000000U

#define MSK_NX51_xmac_tpm_val1_pm_val1         0x0000ffffU
#define SRT_NX51_xmac_tpm_val1_pm_val1         0
#define DFLT_VAL_NX51_xmac_tpm_val1_pm_val1    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tpm_val1_pm_val1 0x00000000U

/* all used bits of 'NX51_xmac_tpm_val1': */
#define MSK_USED_BITS_NX51_xmac_tpm_val1 0x0000ffffU

enum {
	BFW_NX51_xmac_tpm_val1_pm_val1   = 16, /* [15:0] */
	BFW_NX51_xmac_tpm_val1_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TPM_VAL1_BIT_Ttag {
	unsigned int pm_val1   : BFW_NX51_xmac_tpm_val1_pm_val1;   /* Pattern Match Value */
	unsigned int reserved1 : BFW_NX51_xmac_tpm_val1_reserved1; /* reserved            */
} NX51_XMAC_TPM_VAL1_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_TPM_VAL1_BIT_T bf;
} NX51_XMAC_TPM_VAL1_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc32_l */
/* => xMAC RX CRC32 lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc32_l        0x000001C0U
#define Adr_NX51_xmac0_regs_xmac_rx_crc32_l 0x1018B5C0U
#define Adr_NX51_xmac1_regs_xmac_rx_crc32_l 0x1018B7C0U
#define DFLT_VAL_NX51_xmac_rx_crc32_l       0x00000000U

#define MSK_NX51_xmac_rx_crc32_l_rx_crc32_l         0x0000ffffU
#define SRT_NX51_xmac_rx_crc32_l_rx_crc32_l         0
#define DFLT_VAL_NX51_xmac_rx_crc32_l_rx_crc32_l    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_l_rx_crc32_l 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc32_l': */
#define MSK_USED_BITS_NX51_xmac_rx_crc32_l 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_crc32_l_rx_crc32_l = 16, /* [15:0] */
	BFW_NX51_xmac_rx_crc32_l_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_CRC32_L_BIT_Ttag {
	unsigned int rx_crc32_l : BFW_NX51_xmac_rx_crc32_l_rx_crc32_l; /* lower bits of RX-CRC32 */
	unsigned int reserved1  : BFW_NX51_xmac_rx_crc32_l_reserved1;  /* reserved               */
} NX51_XMAC_RX_CRC32_L_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_RX_CRC32_L_BIT_T bf;
} NX51_XMAC_RX_CRC32_L_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc32_h */
/* => xMAC RX CRC32 upper part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc32_h        0x000001C4U
#define Adr_NX51_xmac0_regs_xmac_rx_crc32_h 0x1018B5C4U
#define Adr_NX51_xmac1_regs_xmac_rx_crc32_h 0x1018B7C4U
#define DFLT_VAL_NX51_xmac_rx_crc32_h       0x00000000U

#define MSK_NX51_xmac_rx_crc32_h_rx_crc32_h         0x0000ffffU
#define SRT_NX51_xmac_rx_crc32_h_rx_crc32_h         0
#define DFLT_VAL_NX51_xmac_rx_crc32_h_rx_crc32_h    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_h_rx_crc32_h 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc32_h': */
#define MSK_USED_BITS_NX51_xmac_rx_crc32_h 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_crc32_h_rx_crc32_h = 16, /* [15:0] */
	BFW_NX51_xmac_rx_crc32_h_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_CRC32_H_BIT_Ttag {
	unsigned int rx_crc32_h : BFW_NX51_xmac_rx_crc32_h_rx_crc32_h; /* upper bits of RX-CRC32 */
	unsigned int reserved1  : BFW_NX51_xmac_rx_crc32_h_reserved1;  /* reserved               */
} NX51_XMAC_RX_CRC32_H_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_RX_CRC32_H_BIT_T bf;
} NX51_XMAC_RX_CRC32_H_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc32_cfg */
/* => xMAC RX CRC32 Config Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc32_cfg        0x000001C8U
#define Adr_NX51_xmac0_regs_xmac_rx_crc32_cfg 0x1018B5C8U
#define Adr_NX51_xmac1_regs_xmac_rx_crc32_cfg 0x1018B7C8U
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg       0x00000000U

#define MSK_NX51_xmac_rx_crc32_cfg_shift_right         0x00000001U
#define SRT_NX51_xmac_rx_crc32_cfg_shift_right         0
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg_shift_right    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_cfg_shift_right 0x00000000U
#define MSK_NX51_xmac_rx_crc32_cfg_zero                0x00000002U
#define SRT_NX51_xmac_rx_crc32_cfg_zero                1
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg_zero           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_cfg_zero        0x00000000U
#define MSK_NX51_xmac_rx_crc32_cfg_invert              0x00000004U
#define SRT_NX51_xmac_rx_crc32_cfg_invert              2
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg_invert         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_cfg_invert      0x00000000U
#define MSK_NX51_xmac_rx_crc32_cfg_nof_bits            0x00000300U
#define SRT_NX51_xmac_rx_crc32_cfg_nof_bits            8
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg_nof_bits       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_cfg_nof_bits    0x00000000U
#define MSK_NX51_xmac_rx_crc32_cfg_direct_div          0x00000400U
#define SRT_NX51_xmac_rx_crc32_cfg_direct_div          10
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg_direct_div     0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_cfg_direct_div  0x00000000U
#define MSK_NX51_xmac_rx_crc32_cfg_endian              0x00000800U
#define SRT_NX51_xmac_rx_crc32_cfg_endian              11
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg_endian         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_cfg_endian      0x00000000U
#define MSK_NX51_xmac_rx_crc32_cfg_swap_output         0x00001000U
#define SRT_NX51_xmac_rx_crc32_cfg_swap_output         12
#define DFLT_VAL_NX51_xmac_rx_crc32_cfg_swap_output    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc32_cfg_swap_output 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc32_cfg': */
#define MSK_USED_BITS_NX51_xmac_rx_crc32_cfg 0x00001f07U

enum {
	BFW_NX51_xmac_rx_crc32_cfg_shift_right = 1,  /* [0] */
	BFW_NX51_xmac_rx_crc32_cfg_zero        = 1,  /* [1] */
	BFW_NX51_xmac_rx_crc32_cfg_invert      = 1,  /* [2] */
	BFW_NX51_xmac_rx_crc32_cfg_reserved1   = 5,  /* [7:3] */
	BFW_NX51_xmac_rx_crc32_cfg_nof_bits    = 2,  /* [9:8] */
	BFW_NX51_xmac_rx_crc32_cfg_direct_div  = 1,  /* [10] */
	BFW_NX51_xmac_rx_crc32_cfg_endian      = 1,  /* [11] */
	BFW_NX51_xmac_rx_crc32_cfg_swap_output = 1,  /* [12] */
	BFW_NX51_xmac_rx_crc32_cfg_reserved2   = 19  /* [31:13] */
};

typedef struct NX51_XMAC_RX_CRC32_CFG_BIT_Ttag {
	unsigned int shift_right : BFW_NX51_xmac_rx_crc32_cfg_shift_right; /* Shift RX CRC32 from left to right                                      */
	                                                                   /* (usually used with crc_swap_output but inverted in case of crc_endian) */
	unsigned int zero        : BFW_NX51_xmac_rx_crc32_cfg_zero;        /* Set input of RX CRC32 to zero (before invert)                          */
	unsigned int invert      : BFW_NX51_xmac_rx_crc32_cfg_invert;      /* Invert input of RX CRC32                                               */
	unsigned int reserved1   : BFW_NX51_xmac_rx_crc32_cfg_reserved1;   /* reserved                                                               */
	unsigned int nof_bits    : BFW_NX51_xmac_rx_crc32_cfg_nof_bits;    /* 1(0),2(1),4(2),8(3) Bits from rx register to be executed in parallel   */
	unsigned int direct_div  : BFW_NX51_xmac_rx_crc32_cfg_direct_div;  /* calculate direct polynomial division without n zeros after frame       */
	unsigned int endian      : BFW_NX51_xmac_rx_crc32_cfg_endian;      /* Swap incoming bits in case of nof_bits = 2,4,8                         */
	unsigned int swap_output : BFW_NX51_xmac_rx_crc32_cfg_swap_output; /* Swap output of crc at PU access                                        */
	unsigned int reserved2   : BFW_NX51_xmac_rx_crc32_cfg_reserved2;   /* reserved                                                               */
} NX51_XMAC_RX_CRC32_CFG_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XMAC_RX_CRC32_CFG_BIT_T bf;
} NX51_XMAC_RX_CRC32_CFG_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc32_l */
/* => xMAC TX CRC32 lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc32_l        0x000001CCU
#define Adr_NX51_xmac0_regs_xmac_tx_crc32_l 0x1018B5CCU
#define Adr_NX51_xmac1_regs_xmac_tx_crc32_l 0x1018B7CCU
#define DFLT_VAL_NX51_xmac_tx_crc32_l       0x00000000U

#define MSK_NX51_xmac_tx_crc32_l_tx_crc32_l         0x0000ffffU
#define SRT_NX51_xmac_tx_crc32_l_tx_crc32_l         0
#define DFLT_VAL_NX51_xmac_tx_crc32_l_tx_crc32_l    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_l_tx_crc32_l 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc32_l': */
#define MSK_USED_BITS_NX51_xmac_tx_crc32_l 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_crc32_l_tx_crc32_l = 16, /* [15:0] */
	BFW_NX51_xmac_tx_crc32_l_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_CRC32_L_BIT_Ttag {
	unsigned int tx_crc32_l : BFW_NX51_xmac_tx_crc32_l_tx_crc32_l; /* lower bits of TX-CRC32 */
	unsigned int reserved1  : BFW_NX51_xmac_tx_crc32_l_reserved1;  /* reserved               */
} NX51_XMAC_TX_CRC32_L_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_TX_CRC32_L_BIT_T bf;
} NX51_XMAC_TX_CRC32_L_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc32_h */
/* => xMAC TX CRC32 upper part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc32_h        0x000001D0U
#define Adr_NX51_xmac0_regs_xmac_tx_crc32_h 0x1018B5D0U
#define Adr_NX51_xmac1_regs_xmac_tx_crc32_h 0x1018B7D0U
#define DFLT_VAL_NX51_xmac_tx_crc32_h       0x00000000U

#define MSK_NX51_xmac_tx_crc32_h_tx_crc32_h         0x0000ffffU
#define SRT_NX51_xmac_tx_crc32_h_tx_crc32_h         0
#define DFLT_VAL_NX51_xmac_tx_crc32_h_tx_crc32_h    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_h_tx_crc32_h 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc32_h': */
#define MSK_USED_BITS_NX51_xmac_tx_crc32_h 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_crc32_h_tx_crc32_h = 16, /* [15:0] */
	BFW_NX51_xmac_tx_crc32_h_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_CRC32_H_BIT_Ttag {
	unsigned int tx_crc32_h : BFW_NX51_xmac_tx_crc32_h_tx_crc32_h; /* upper bits of TX-CRC32 */
	unsigned int reserved1  : BFW_NX51_xmac_tx_crc32_h_reserved1;  /* reserved               */
} NX51_XMAC_TX_CRC32_H_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_TX_CRC32_H_BIT_T bf;
} NX51_XMAC_TX_CRC32_H_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc32_cfg */
/* => xMAC TX CRC32 Config Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc32_cfg        0x000001D4U
#define Adr_NX51_xmac0_regs_xmac_tx_crc32_cfg 0x1018B5D4U
#define Adr_NX51_xmac1_regs_xmac_tx_crc32_cfg 0x1018B7D4U
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg       0x00000000U

#define MSK_NX51_xmac_tx_crc32_cfg_shift_right         0x00000001U
#define SRT_NX51_xmac_tx_crc32_cfg_shift_right         0
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg_shift_right    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_cfg_shift_right 0x00000000U
#define MSK_NX51_xmac_tx_crc32_cfg_zero                0x00000002U
#define SRT_NX51_xmac_tx_crc32_cfg_zero                1
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg_zero           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_cfg_zero        0x00000000U
#define MSK_NX51_xmac_tx_crc32_cfg_invert              0x00000004U
#define SRT_NX51_xmac_tx_crc32_cfg_invert              2
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg_invert         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_cfg_invert      0x00000000U
#define MSK_NX51_xmac_tx_crc32_cfg_nof_bits            0x00000300U
#define SRT_NX51_xmac_tx_crc32_cfg_nof_bits            8
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg_nof_bits       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_cfg_nof_bits    0x00000000U
#define MSK_NX51_xmac_tx_crc32_cfg_direct_div          0x00000400U
#define SRT_NX51_xmac_tx_crc32_cfg_direct_div          10
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg_direct_div     0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_cfg_direct_div  0x00000000U
#define MSK_NX51_xmac_tx_crc32_cfg_endian              0x00000800U
#define SRT_NX51_xmac_tx_crc32_cfg_endian              11
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg_endian         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_cfg_endian      0x00000000U
#define MSK_NX51_xmac_tx_crc32_cfg_swap_output         0x00001000U
#define SRT_NX51_xmac_tx_crc32_cfg_swap_output         12
#define DFLT_VAL_NX51_xmac_tx_crc32_cfg_swap_output    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc32_cfg_swap_output 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc32_cfg': */
#define MSK_USED_BITS_NX51_xmac_tx_crc32_cfg 0x00001f07U

enum {
	BFW_NX51_xmac_tx_crc32_cfg_shift_right = 1,  /* [0] */
	BFW_NX51_xmac_tx_crc32_cfg_zero        = 1,  /* [1] */
	BFW_NX51_xmac_tx_crc32_cfg_invert      = 1,  /* [2] */
	BFW_NX51_xmac_tx_crc32_cfg_reserved1   = 5,  /* [7:3] */
	BFW_NX51_xmac_tx_crc32_cfg_nof_bits    = 2,  /* [9:8] */
	BFW_NX51_xmac_tx_crc32_cfg_direct_div  = 1,  /* [10] */
	BFW_NX51_xmac_tx_crc32_cfg_endian      = 1,  /* [11] */
	BFW_NX51_xmac_tx_crc32_cfg_swap_output = 1,  /* [12] */
	BFW_NX51_xmac_tx_crc32_cfg_reserved2   = 19  /* [31:13] */
};

typedef struct NX51_XMAC_TX_CRC32_CFG_BIT_Ttag {
	unsigned int shift_right : BFW_NX51_xmac_tx_crc32_cfg_shift_right; /* Shift TX CRC32 from left to right                                      */
	                                                                   /* (usually used with crc_swap_output but inverted in case of crc_endian) */
	unsigned int zero        : BFW_NX51_xmac_tx_crc32_cfg_zero;        /* Set input of TX CRC32 to zero (before invert)                          */
	unsigned int invert      : BFW_NX51_xmac_tx_crc32_cfg_invert;      /* Invert input of TX CRC32                                               */
	unsigned int reserved1   : BFW_NX51_xmac_tx_crc32_cfg_reserved1;   /* reserved                                                               */
	unsigned int nof_bits    : BFW_NX51_xmac_tx_crc32_cfg_nof_bits;    /* 1(0),2(1),4(2),8(3) Bits from tx_register to be executed in parallel   */
	unsigned int direct_div  : BFW_NX51_xmac_tx_crc32_cfg_direct_div;  /* calculate direct polynomial division without n zeros after frame       */
	unsigned int endian      : BFW_NX51_xmac_tx_crc32_cfg_endian;      /* Swap incoming bits in case of nof_bits = 2,4,8                         */
	unsigned int swap_output : BFW_NX51_xmac_tx_crc32_cfg_swap_output; /* Swap output of crc at PU access                                        */
	unsigned int reserved2   : BFW_NX51_xmac_tx_crc32_cfg_reserved2;   /* reserved                                                               */
} NX51_XMAC_TX_CRC32_CFG_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XMAC_TX_CRC32_CFG_BIT_T bf;
} NX51_XMAC_TX_CRC32_CFG_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc_polynomial_l */
/* => xMAC RX CRC Polynomial lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc_polynomial_l        0x000001D8U
#define Adr_NX51_xmac0_regs_xmac_rx_crc_polynomial_l 0x1018B5D8U
#define Adr_NX51_xmac1_regs_xmac_rx_crc_polynomial_l 0x1018B7D8U
#define DFLT_VAL_NX51_xmac_rx_crc_polynomial_l       0x00000000U

#define MSK_NX51_xmac_rx_crc_polynomial_l_rx_pol_l         0x0000ffffU
#define SRT_NX51_xmac_rx_crc_polynomial_l_rx_pol_l         0
#define DFLT_VAL_NX51_xmac_rx_crc_polynomial_l_rx_pol_l    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_polynomial_l_rx_pol_l 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc_polynomial_l': */
#define MSK_USED_BITS_NX51_xmac_rx_crc_polynomial_l 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_crc_polynomial_l_rx_pol_l  = 16, /* [15:0] */
	BFW_NX51_xmac_rx_crc_polynomial_l_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_CRC_POLYNOMIAL_L_BIT_Ttag {
	unsigned int rx_pol_l  : BFW_NX51_xmac_rx_crc_polynomial_l_rx_pol_l;  /* lower bits of RX-CRC Polynomial */
	unsigned int reserved1 : BFW_NX51_xmac_rx_crc_polynomial_l_reserved1; /* reserved                        */
} NX51_XMAC_RX_CRC_POLYNOMIAL_L_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XMAC_RX_CRC_POLYNOMIAL_L_BIT_T bf;
} NX51_XMAC_RX_CRC_POLYNOMIAL_L_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc_polynomial_h */
/* => xMAC RX CRC Polynomial lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc_polynomial_h        0x000001DCU
#define Adr_NX51_xmac0_regs_xmac_rx_crc_polynomial_h 0x1018B5DCU
#define Adr_NX51_xmac1_regs_xmac_rx_crc_polynomial_h 0x1018B7DCU
#define DFLT_VAL_NX51_xmac_rx_crc_polynomial_h       0x00000000U

#define MSK_NX51_xmac_rx_crc_polynomial_h_rx_pol_h         0x0000ffffU
#define SRT_NX51_xmac_rx_crc_polynomial_h_rx_pol_h         0
#define DFLT_VAL_NX51_xmac_rx_crc_polynomial_h_rx_pol_h    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_polynomial_h_rx_pol_h 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc_polynomial_h': */
#define MSK_USED_BITS_NX51_xmac_rx_crc_polynomial_h 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_crc_polynomial_h_rx_pol_h  = 16, /* [15:0] */
	BFW_NX51_xmac_rx_crc_polynomial_h_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_CRC_POLYNOMIAL_H_BIT_Ttag {
	unsigned int rx_pol_h  : BFW_NX51_xmac_rx_crc_polynomial_h_rx_pol_h;  /* upper bits of RX-CRC Polynomial */
	unsigned int reserved1 : BFW_NX51_xmac_rx_crc_polynomial_h_reserved1; /* reserved                        */
} NX51_XMAC_RX_CRC_POLYNOMIAL_H_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XMAC_RX_CRC_POLYNOMIAL_H_BIT_T bf;
} NX51_XMAC_RX_CRC_POLYNOMIAL_H_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc_l */
/* => xMAC RX CRC lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc_l        0x000001E0U
#define Adr_NX51_xmac0_regs_xmac_rx_crc_l 0x1018B5E0U
#define Adr_NX51_xmac1_regs_xmac_rx_crc_l 0x1018B7E0U
#define DFLT_VAL_NX51_xmac_rx_crc_l       0x00000000U

#define MSK_NX51_xmac_rx_crc_l_rx_crc_l         0x0000ffffU
#define SRT_NX51_xmac_rx_crc_l_rx_crc_l         0
#define DFLT_VAL_NX51_xmac_rx_crc_l_rx_crc_l    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_l_rx_crc_l 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc_l': */
#define MSK_USED_BITS_NX51_xmac_rx_crc_l 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_crc_l_rx_crc_l  = 16, /* [15:0] */
	BFW_NX51_xmac_rx_crc_l_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_CRC_L_BIT_Ttag {
	unsigned int rx_crc_l  : BFW_NX51_xmac_rx_crc_l_rx_crc_l;  /* lower bits of RX-CRC */
	unsigned int reserved1 : BFW_NX51_xmac_rx_crc_l_reserved1; /* reserved             */
} NX51_XMAC_RX_CRC_L_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_RX_CRC_L_BIT_T bf;
} NX51_XMAC_RX_CRC_L_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc_h */
/* => xMAC RX CRC upper part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc_h        0x000001E4U
#define Adr_NX51_xmac0_regs_xmac_rx_crc_h 0x1018B5E4U
#define Adr_NX51_xmac1_regs_xmac_rx_crc_h 0x1018B7E4U
#define DFLT_VAL_NX51_xmac_rx_crc_h       0x00000000U

#define MSK_NX51_xmac_rx_crc_h_rx_crc_h         0x0000ffffU
#define SRT_NX51_xmac_rx_crc_h_rx_crc_h         0
#define DFLT_VAL_NX51_xmac_rx_crc_h_rx_crc_h    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_h_rx_crc_h 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc_h': */
#define MSK_USED_BITS_NX51_xmac_rx_crc_h 0x0000ffffU

enum {
	BFW_NX51_xmac_rx_crc_h_rx_crc_h  = 16, /* [15:0] */
	BFW_NX51_xmac_rx_crc_h_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_RX_CRC_H_BIT_Ttag {
	unsigned int rx_crc_h  : BFW_NX51_xmac_rx_crc_h_rx_crc_h;  /* upper bits of RX-CRC */
	unsigned int reserved1 : BFW_NX51_xmac_rx_crc_h_reserved1; /* reserved             */
} NX51_XMAC_RX_CRC_H_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_RX_CRC_H_BIT_T bf;
} NX51_XMAC_RX_CRC_H_T;

/* --------------------------------------------------------------------- */
/* Register xmac_rx_crc_cfg */
/* => xMAC RX CRC Config Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_rx_crc_cfg        0x000001E8U
#define Adr_NX51_xmac0_regs_xmac_rx_crc_cfg 0x1018B5E8U
#define Adr_NX51_xmac1_regs_xmac_rx_crc_cfg 0x1018B7E8U
#define DFLT_VAL_NX51_xmac_rx_crc_cfg       0x00000000U

#define MSK_NX51_xmac_rx_crc_cfg_shift_right         0x00000001U
#define SRT_NX51_xmac_rx_crc_cfg_shift_right         0
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_shift_right    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_shift_right 0x00000000U
#define MSK_NX51_xmac_rx_crc_cfg_zero                0x00000002U
#define SRT_NX51_xmac_rx_crc_cfg_zero                1
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_zero           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_zero        0x00000000U
#define MSK_NX51_xmac_rx_crc_cfg_invert              0x00000004U
#define SRT_NX51_xmac_rx_crc_cfg_invert              2
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_invert         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_invert      0x00000000U
#define MSK_NX51_xmac_rx_crc_cfg_len                 0x000000f8U
#define SRT_NX51_xmac_rx_crc_cfg_len                 3
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_len            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_len         0x00000000U
#define MSK_NX51_xmac_rx_crc_cfg_nof_bits            0x00000300U
#define SRT_NX51_xmac_rx_crc_cfg_nof_bits            8
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_nof_bits       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_nof_bits    0x00000000U
#define MSK_NX51_xmac_rx_crc_cfg_direct_div          0x00000400U
#define SRT_NX51_xmac_rx_crc_cfg_direct_div          10
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_direct_div     0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_direct_div  0x00000000U
#define MSK_NX51_xmac_rx_crc_cfg_endian              0x00000800U
#define SRT_NX51_xmac_rx_crc_cfg_endian              11
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_endian         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_endian      0x00000000U
#define MSK_NX51_xmac_rx_crc_cfg_swap_output         0x00001000U
#define SRT_NX51_xmac_rx_crc_cfg_swap_output         12
#define DFLT_VAL_NX51_xmac_rx_crc_cfg_swap_output    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_rx_crc_cfg_swap_output 0x00000000U

/* all used bits of 'NX51_xmac_rx_crc_cfg': */
#define MSK_USED_BITS_NX51_xmac_rx_crc_cfg 0x00001fffU

enum {
	BFW_NX51_xmac_rx_crc_cfg_shift_right = 1,  /* [0] */
	BFW_NX51_xmac_rx_crc_cfg_zero        = 1,  /* [1] */
	BFW_NX51_xmac_rx_crc_cfg_invert      = 1,  /* [2] */
	BFW_NX51_xmac_rx_crc_cfg_len         = 5,  /* [7:3] */
	BFW_NX51_xmac_rx_crc_cfg_nof_bits    = 2,  /* [9:8] */
	BFW_NX51_xmac_rx_crc_cfg_direct_div  = 1,  /* [10] */
	BFW_NX51_xmac_rx_crc_cfg_endian      = 1,  /* [11] */
	BFW_NX51_xmac_rx_crc_cfg_swap_output = 1,  /* [12] */
	BFW_NX51_xmac_rx_crc_cfg_reserved1   = 19  /* [31:13] */
};

typedef struct NX51_XMAC_RX_CRC_CFG_BIT_Ttag {
	unsigned int shift_right : BFW_NX51_xmac_rx_crc_cfg_shift_right; /* Shift RX CRC from left to right                                        */
	                                                                 /* (usually used with crc_swap_output but inverted in case of crc_endian) */
	unsigned int zero        : BFW_NX51_xmac_rx_crc_cfg_zero;        /* Set input of RX CRC to zero (before invert)                            */
	unsigned int invert      : BFW_NX51_xmac_rx_crc_cfg_invert;      /* Invert input of RX CRC                                                 */
	unsigned int len         : BFW_NX51_xmac_rx_crc_cfg_len;         /* Length of RX_CRC minus 1 (0-31)                                        */
	unsigned int nof_bits    : BFW_NX51_xmac_rx_crc_cfg_nof_bits;    /* 1(0),2(1),4(2),8(3) Bits from rx register to be executed in parallel   */
	unsigned int direct_div  : BFW_NX51_xmac_rx_crc_cfg_direct_div;  /* calculate direct polynomial division without n zeros after frame       */
	unsigned int endian      : BFW_NX51_xmac_rx_crc_cfg_endian;      /* Swap incoming bits in case of nof_bits = 2,4,8                         */
	unsigned int swap_output : BFW_NX51_xmac_rx_crc_cfg_swap_output; /* Swap output of crc at PU access                                        */
	unsigned int reserved1   : BFW_NX51_xmac_rx_crc_cfg_reserved1;   /* reserved                                                               */
} NX51_XMAC_RX_CRC_CFG_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_RX_CRC_CFG_BIT_T bf;
} NX51_XMAC_RX_CRC_CFG_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc_polynomial_l */
/* => xMAC TX CRC Polynomial lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc_polynomial_l        0x000001ECU
#define Adr_NX51_xmac0_regs_xmac_tx_crc_polynomial_l 0x1018B5ECU
#define Adr_NX51_xmac1_regs_xmac_tx_crc_polynomial_l 0x1018B7ECU
#define DFLT_VAL_NX51_xmac_tx_crc_polynomial_l       0x00000000U

#define MSK_NX51_xmac_tx_crc_polynomial_l_tx_pol_l         0x0000ffffU
#define SRT_NX51_xmac_tx_crc_polynomial_l_tx_pol_l         0
#define DFLT_VAL_NX51_xmac_tx_crc_polynomial_l_tx_pol_l    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_polynomial_l_tx_pol_l 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc_polynomial_l': */
#define MSK_USED_BITS_NX51_xmac_tx_crc_polynomial_l 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_crc_polynomial_l_tx_pol_l  = 16, /* [15:0] */
	BFW_NX51_xmac_tx_crc_polynomial_l_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_CRC_POLYNOMIAL_L_BIT_Ttag {
	unsigned int tx_pol_l  : BFW_NX51_xmac_tx_crc_polynomial_l_tx_pol_l;  /* lower bits of TX-CRC Polynomial */
	unsigned int reserved1 : BFW_NX51_xmac_tx_crc_polynomial_l_reserved1; /* reserved                        */
} NX51_XMAC_TX_CRC_POLYNOMIAL_L_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XMAC_TX_CRC_POLYNOMIAL_L_BIT_T bf;
} NX51_XMAC_TX_CRC_POLYNOMIAL_L_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc_polynomial_h */
/* => xMAC TX CRC Polynomial lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc_polynomial_h        0x000001F0U
#define Adr_NX51_xmac0_regs_xmac_tx_crc_polynomial_h 0x1018B5F0U
#define Adr_NX51_xmac1_regs_xmac_tx_crc_polynomial_h 0x1018B7F0U
#define DFLT_VAL_NX51_xmac_tx_crc_polynomial_h       0x00000000U

#define MSK_NX51_xmac_tx_crc_polynomial_h_tx_pol_h         0x0000ffffU
#define SRT_NX51_xmac_tx_crc_polynomial_h_tx_pol_h         0
#define DFLT_VAL_NX51_xmac_tx_crc_polynomial_h_tx_pol_h    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_polynomial_h_tx_pol_h 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc_polynomial_h': */
#define MSK_USED_BITS_NX51_xmac_tx_crc_polynomial_h 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_crc_polynomial_h_tx_pol_h  = 16, /* [15:0] */
	BFW_NX51_xmac_tx_crc_polynomial_h_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_CRC_POLYNOMIAL_H_BIT_Ttag {
	unsigned int tx_pol_h  : BFW_NX51_xmac_tx_crc_polynomial_h_tx_pol_h;  /* upper bits of TX-CRC Polynomial */
	unsigned int reserved1 : BFW_NX51_xmac_tx_crc_polynomial_h_reserved1; /* reserved                        */
} NX51_XMAC_TX_CRC_POLYNOMIAL_H_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XMAC_TX_CRC_POLYNOMIAL_H_BIT_T bf;
} NX51_XMAC_TX_CRC_POLYNOMIAL_H_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc_l */
/* => xMAC TX CRC lower part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc_l        0x000001F4U
#define Adr_NX51_xmac0_regs_xmac_tx_crc_l 0x1018B5F4U
#define Adr_NX51_xmac1_regs_xmac_tx_crc_l 0x1018B7F4U
#define DFLT_VAL_NX51_xmac_tx_crc_l       0x00000000U

#define MSK_NX51_xmac_tx_crc_l_tx_crc_l         0x0000ffffU
#define SRT_NX51_xmac_tx_crc_l_tx_crc_l         0
#define DFLT_VAL_NX51_xmac_tx_crc_l_tx_crc_l    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_l_tx_crc_l 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc_l': */
#define MSK_USED_BITS_NX51_xmac_tx_crc_l 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_crc_l_tx_crc_l  = 16, /* [15:0] */
	BFW_NX51_xmac_tx_crc_l_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_CRC_L_BIT_Ttag {
	unsigned int tx_crc_l  : BFW_NX51_xmac_tx_crc_l_tx_crc_l;  /* lower bits of TX-CRC */
	unsigned int reserved1 : BFW_NX51_xmac_tx_crc_l_reserved1; /* reserved             */
} NX51_XMAC_TX_CRC_L_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_TX_CRC_L_BIT_T bf;
} NX51_XMAC_TX_CRC_L_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc_h */
/* => xMAC TX CRC upper part */
/*    This register has a write pipeline delay of 1 clock cycle. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc_h        0x000001F8U
#define Adr_NX51_xmac0_regs_xmac_tx_crc_h 0x1018B5F8U
#define Adr_NX51_xmac1_regs_xmac_tx_crc_h 0x1018B7F8U
#define DFLT_VAL_NX51_xmac_tx_crc_h       0x00000000U

#define MSK_NX51_xmac_tx_crc_h_tx_crc_h         0x0000ffffU
#define SRT_NX51_xmac_tx_crc_h_tx_crc_h         0
#define DFLT_VAL_NX51_xmac_tx_crc_h_tx_crc_h    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_h_tx_crc_h 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc_h': */
#define MSK_USED_BITS_NX51_xmac_tx_crc_h 0x0000ffffU

enum {
	BFW_NX51_xmac_tx_crc_h_tx_crc_h  = 16, /* [15:0] */
	BFW_NX51_xmac_tx_crc_h_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XMAC_TX_CRC_H_BIT_Ttag {
	unsigned int tx_crc_h  : BFW_NX51_xmac_tx_crc_h_tx_crc_h;  /* upper bits of TX-CRC */
	unsigned int reserved1 : BFW_NX51_xmac_tx_crc_h_reserved1; /* reserved             */
} NX51_XMAC_TX_CRC_H_BIT_T;

typedef union {
	unsigned int             val;
	NX51_XMAC_TX_CRC_H_BIT_T bf;
} NX51_XMAC_TX_CRC_H_T;

/* --------------------------------------------------------------------- */
/* Register xmac_tx_crc_cfg */
/* => xMAC TX CRC Config Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xmac_tx_crc_cfg        0x000001FCU
#define Adr_NX51_xmac0_regs_xmac_tx_crc_cfg 0x1018B5FCU
#define Adr_NX51_xmac1_regs_xmac_tx_crc_cfg 0x1018B7FCU
#define DFLT_VAL_NX51_xmac_tx_crc_cfg       0x00000000U

#define MSK_NX51_xmac_tx_crc_cfg_shift_right         0x00000001U
#define SRT_NX51_xmac_tx_crc_cfg_shift_right         0
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_shift_right    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_shift_right 0x00000000U
#define MSK_NX51_xmac_tx_crc_cfg_zero                0x00000002U
#define SRT_NX51_xmac_tx_crc_cfg_zero                1
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_zero           0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_zero        0x00000000U
#define MSK_NX51_xmac_tx_crc_cfg_invert              0x00000004U
#define SRT_NX51_xmac_tx_crc_cfg_invert              2
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_invert         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_invert      0x00000000U
#define MSK_NX51_xmac_tx_crc_cfg_len                 0x000000f8U
#define SRT_NX51_xmac_tx_crc_cfg_len                 3
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_len            0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_len         0x00000000U
#define MSK_NX51_xmac_tx_crc_cfg_nof_bits            0x00000300U
#define SRT_NX51_xmac_tx_crc_cfg_nof_bits            8
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_nof_bits       0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_nof_bits    0x00000000U
#define MSK_NX51_xmac_tx_crc_cfg_direct_div          0x00000400U
#define SRT_NX51_xmac_tx_crc_cfg_direct_div          10
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_direct_div     0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_direct_div  0x00000000U
#define MSK_NX51_xmac_tx_crc_cfg_endian              0x00000800U
#define SRT_NX51_xmac_tx_crc_cfg_endian              11
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_endian         0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_endian      0x00000000U
#define MSK_NX51_xmac_tx_crc_cfg_swap_output         0x00001000U
#define SRT_NX51_xmac_tx_crc_cfg_swap_output         12
#define DFLT_VAL_NX51_xmac_tx_crc_cfg_swap_output    0x00000000U
#define DFLT_BF_VAL_NX51_xmac_tx_crc_cfg_swap_output 0x00000000U

/* all used bits of 'NX51_xmac_tx_crc_cfg': */
#define MSK_USED_BITS_NX51_xmac_tx_crc_cfg 0x00001fffU

enum {
	BFW_NX51_xmac_tx_crc_cfg_shift_right = 1,  /* [0] */
	BFW_NX51_xmac_tx_crc_cfg_zero        = 1,  /* [1] */
	BFW_NX51_xmac_tx_crc_cfg_invert      = 1,  /* [2] */
	BFW_NX51_xmac_tx_crc_cfg_len         = 5,  /* [7:3] */
	BFW_NX51_xmac_tx_crc_cfg_nof_bits    = 2,  /* [9:8] */
	BFW_NX51_xmac_tx_crc_cfg_direct_div  = 1,  /* [10] */
	BFW_NX51_xmac_tx_crc_cfg_endian      = 1,  /* [11] */
	BFW_NX51_xmac_tx_crc_cfg_swap_output = 1,  /* [12] */
	BFW_NX51_xmac_tx_crc_cfg_reserved1   = 19  /* [31:13] */
};

typedef struct NX51_XMAC_TX_CRC_CFG_BIT_Ttag {
	unsigned int shift_right : BFW_NX51_xmac_tx_crc_cfg_shift_right; /* Shift TX CRC from left to right                                        */
	                                                                 /* (usually used with crc_swap_output but inverted in case of crc_endian) */
	unsigned int zero        : BFW_NX51_xmac_tx_crc_cfg_zero;        /* Set input of TX CRC to zero (before invert)                            */
	unsigned int invert      : BFW_NX51_xmac_tx_crc_cfg_invert;      /* Invert input of TX CRC                                                 */
	unsigned int len         : BFW_NX51_xmac_tx_crc_cfg_len;         /* Length of TX_CRC minus 1 (0-31)                                        */
	unsigned int nof_bits    : BFW_NX51_xmac_tx_crc_cfg_nof_bits;    /* 1(0),2(1),4(2),8(3) Bits from tx_register to be executed in parallel   */
	unsigned int direct_div  : BFW_NX51_xmac_tx_crc_cfg_direct_div;  /* calculate direct polynomial division without n zeros after frame       */
	unsigned int endian      : BFW_NX51_xmac_tx_crc_cfg_endian;      /* Swap incoming bits in case of nof_bits = 2,4,8                         */
	unsigned int swap_output : BFW_NX51_xmac_tx_crc_cfg_swap_output; /* Swap output of crc at PU access                                        */
	unsigned int reserved1   : BFW_NX51_xmac_tx_crc_cfg_reserved1;   /* reserved                                                               */
} NX51_XMAC_TX_CRC_CFG_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XMAC_TX_CRC_CFG_BIT_T bf;
} NX51_XMAC_TX_CRC_CFG_T;


/* ===================================================================== */

/* AREA pointer_fifo */
/* Area of pointer_fifo, pointer_fifo_motion */

/* ===================================================================== */

#define Addr_NX51_pointer_fifo        0x1018B800U
#define Addr_NX51_pointer_fifo_motion 0x10100000U

/* --------------------------------------------------------------------- */
/* Register pfifo_start */
/* => Pointer FIFO table: */
/*    Each of the following 32 addresses accesses a FIFO. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_start                 0x00000000U
#define Adr_NX51_pointer_fifo_pfifo_start        0x1018B800U
#define Adr_NX51_pointer_fifo_motion_pfifo_start 0x10100000U
#define DFLT_VAL_NX51_pfifo_start                0x00000000U

#define MSK_NX51_pfifo_start_fifo_data         0xffffffffU
#define SRT_NX51_pfifo_start_fifo_data         0
#define DFLT_VAL_NX51_pfifo_start_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_pfifo_start_fifo_data 0x00000000U

/* all used bits of 'NX51_pfifo_start': */
#define MSK_USED_BITS_NX51_pfifo_start 0xffffffffU

enum {
	BFW_NX51_pfifo_start_fifo_data = 32  /* [31:0] */
};

typedef struct NX51_PFIFO_START_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_pfifo_start_fifo_data; /* In/output data to/from FIFO:      */
	                                                         /* write access: write data to FIFO  */
	                                                         /* read access:  read data from FIFO */
} NX51_PFIFO_START_BIT_T;

typedef union {
	unsigned int           val;
	NX51_PFIFO_START_BIT_T bf;
} NX51_PFIFO_START_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_end */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_end                 0x0000007CU
#define Adr_NX51_pointer_fifo_pfifo_end        0x1018B87CU
#define Adr_NX51_pointer_fifo_motion_pfifo_end 0x1010007CU

/* --------------------------------------------------------------------- */
/* Register pfifo_border_start */
/* => Pointer FIFO Upper Borders table: */
/*    The sizes of all FIFOs are programmable. The total size of all FIFOs must not exceed 3200 dwords. \ */
/*    Each of the following 32 addresses accesses the upper border of the appropriate FIFO in a 3200x32 bit RAM. \ */
/*    All upper borders should be rising with number of FIFO. \ */
/*    Each FIFO starts at the upper border + 1 of the preceding FIFO and ends at its upper border. */
/*    If a border between two FIFOs is moved, the adjacent FIFOs should be reset first. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_border_start                 0x00000080U
#define Adr_NX51_pointer_fifo_pfifo_border_start        0x1018B880U
#define Adr_NX51_pointer_fifo_motion_pfifo_border_start 0x10100080U
#define DFLT_VAL_NX51_pfifo_border_start                0x00000000U

#define MSK_NX51_pfifo_border_start_border         0x00000fffU
#define SRT_NX51_pfifo_border_start_border         0
#define DFLT_VAL_NX51_pfifo_border_start_border    0x00000000U
#define DFLT_BF_VAL_NX51_pfifo_border_start_border 0x00000000U

/* all used bits of 'NX51_pfifo_border_start': */
#define MSK_USED_BITS_NX51_pfifo_border_start 0x00000fffU

enum {
	BFW_NX51_pfifo_border_start_border    = 12, /* [11:0] */
	BFW_NX51_pfifo_border_start_reserved1 = 20  /* [31:12] */
};

typedef struct NX51_PFIFO_BORDER_START_BIT_Ttag {
	unsigned int border    : BFW_NX51_pfifo_border_start_border;    /* last address of RAM used by appropriate FIFO, = (first address-1) of next FIFO. */
	                                                                /* Default depth of all FIFOs is 100.                                              */
	unsigned int reserved1 : BFW_NX51_pfifo_border_start_reserved1; /* reserved                                                                        */
} NX51_PFIFO_BORDER_START_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_PFIFO_BORDER_START_BIT_T bf;
} NX51_PFIFO_BORDER_START_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_border_end */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_border_end                 0x000000FCU
#define Adr_NX51_pointer_fifo_pfifo_border_end        0x1018B8FCU
#define Adr_NX51_pointer_fifo_motion_pfifo_border_end 0x101000FCU

/* --------------------------------------------------------------------- */
/* Register pfifo_reset */
/* => Pointer FIFO Reset Vector: */
/*    This register allows to reset each of 32 FIFOs, \ */
/*    i.e. set read and write pointer to lower border of FIFO, reset full, overflow, underrun flag and set empty flag. */
/*    The reset flag of adjacent FIFOs should be set before resizing the FIFO. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_reset                 0x00000100U
#define Adr_NX51_pointer_fifo_pfifo_reset        0x1018B900U
#define Adr_NX51_pointer_fifo_motion_pfifo_reset 0x10100100U
#define DFLT_VAL_NX51_pfifo_reset                0x00000000U

#define MSK_NX51_pfifo_reset_reset_fifo         0xffffffffU
#define SRT_NX51_pfifo_reset_reset_fifo         0
#define DFLT_VAL_NX51_pfifo_reset_reset_fifo    0x00000000U
#define DFLT_BF_VAL_NX51_pfifo_reset_reset_fifo 0x00000000U

/* all used bits of 'NX51_pfifo_reset': */
#define MSK_USED_BITS_NX51_pfifo_reset 0xffffffffU

enum {
	BFW_NX51_pfifo_reset_reset_fifo = 32  /* [31:0] */
};

typedef struct NX51_PFIFO_RESET_BIT_Ttag {
	unsigned int reset_fifo : BFW_NX51_pfifo_reset_reset_fifo; /* Reset Vector, 1 bit per FIFO: */
	                                                           /* 1: reset FIFO                 */
	                                                           /* 0: normal work mode           */
} NX51_PFIFO_RESET_BIT_T;

typedef union {
	unsigned int           val;
	NX51_PFIFO_RESET_BIT_T bf;
} NX51_PFIFO_RESET_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_full */
/* => Pointer FIFO Full Vector: */
/*    This read only address shows the fifo_full flag of each FIFO. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_full                 0x00000104U
#define Adr_NX51_pointer_fifo_pfifo_full        0x1018B904U
#define Adr_NX51_pointer_fifo_motion_pfifo_full 0x10100104U

#define MSK_NX51_pfifo_full_fifo_full 0xffffffffU
#define SRT_NX51_pfifo_full_fifo_full 0

/* all used bits of 'NX51_pfifo_full': */
#define MSK_USED_BITS_NX51_pfifo_full 0xffffffffU

enum {
	BFW_NX51_pfifo_full_fifo_full = 32  /* [31:0] */
};

typedef struct NX51_PFIFO_FULL_BIT_Ttag {
	unsigned int fifo_full : BFW_NX51_pfifo_full_fifo_full; /* FIFO full vector, 1 bit per FIFO */
} NX51_PFIFO_FULL_BIT_T;

typedef union {
	unsigned int          val;
	NX51_PFIFO_FULL_BIT_T bf;
} NX51_PFIFO_FULL_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_empty */
/* => Pointer FIFO Empty Vector: */
/*    This read only address shows the fifo_empty flag of each FIFO. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_empty                 0x00000108U
#define Adr_NX51_pointer_fifo_pfifo_empty        0x1018B908U
#define Adr_NX51_pointer_fifo_motion_pfifo_empty 0x10100108U

#define MSK_NX51_pfifo_empty_fifo_empty 0xffffffffU
#define SRT_NX51_pfifo_empty_fifo_empty 0

/* all used bits of 'NX51_pfifo_empty': */
#define MSK_USED_BITS_NX51_pfifo_empty 0xffffffffU

enum {
	BFW_NX51_pfifo_empty_fifo_empty = 32  /* [31:0] */
};

typedef struct NX51_PFIFO_EMPTY_BIT_Ttag {
	unsigned int fifo_empty : BFW_NX51_pfifo_empty_fifo_empty; /* FIFO empty vector, 1 bit per FIFO */
} NX51_PFIFO_EMPTY_BIT_T;

typedef union {
	unsigned int           val;
	NX51_PFIFO_EMPTY_BIT_T bf;
} NX51_PFIFO_EMPTY_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_overflow */
/* => Pointer FIFO Overflow Vector: */
/*    This read only address shows the fifo_overflow flag of each FIFO. */
/*    If the FIFO had an overflow, it should be reset. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_overflow                 0x0000010CU
#define Adr_NX51_pointer_fifo_pfifo_overflow        0x1018B90CU
#define Adr_NX51_pointer_fifo_motion_pfifo_overflow 0x1010010CU

#define MSK_NX51_pfifo_overflow_fifo_overflow 0xffffffffU
#define SRT_NX51_pfifo_overflow_fifo_overflow 0

/* all used bits of 'NX51_pfifo_overflow': */
#define MSK_USED_BITS_NX51_pfifo_overflow 0xffffffffU

enum {
	BFW_NX51_pfifo_overflow_fifo_overflow = 32  /* [31:0] */
};

typedef struct NX51_PFIFO_OVERFLOW_BIT_Ttag {
	unsigned int fifo_overflow : BFW_NX51_pfifo_overflow_fifo_overflow; /* FIFO overflow vector, 1 bit per FIFO */
} NX51_PFIFO_OVERFLOW_BIT_T;

typedef union {
	unsigned int              val;
	NX51_PFIFO_OVERFLOW_BIT_T bf;
} NX51_PFIFO_OVERFLOW_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_underrun */
/* => Pointer FIFO Underrun Vector: */
/*    This read only address shows the fifo_underrun flag of each FIFO. */
/*    If the FIFO had an underrun, it should be reset. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_underrun                 0x00000110U
#define Adr_NX51_pointer_fifo_pfifo_underrun        0x1018B910U
#define Adr_NX51_pointer_fifo_motion_pfifo_underrun 0x10100110U

#define MSK_NX51_pfifo_underrun_fifo_underrun 0xffffffffU
#define SRT_NX51_pfifo_underrun_fifo_underrun 0

/* all used bits of 'NX51_pfifo_underrun': */
#define MSK_USED_BITS_NX51_pfifo_underrun 0xffffffffU

enum {
	BFW_NX51_pfifo_underrun_fifo_underrun = 32  /* [31:0] */
};

typedef struct NX51_PFIFO_UNDERRUN_BIT_Ttag {
	unsigned int fifo_underrun : BFW_NX51_pfifo_underrun_fifo_underrun; /* FIFO underrun vector, 1 bit per FIFO */
} NX51_PFIFO_UNDERRUN_BIT_T;

typedef union {
	unsigned int              val;
	NX51_PFIFO_UNDERRUN_BIT_T bf;
} NX51_PFIFO_UNDERRUN_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_fill_level_start */
/* => Pointer FIFO Fill-Level table: */
/*    Each of the following 32 addresses reads the fill-level of the appropriate FIFO. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_fill_level_start                 0x00000180U
#define Adr_NX51_pointer_fifo_pfifo_fill_level_start        0x1018B980U
#define Adr_NX51_pointer_fifo_motion_pfifo_fill_level_start 0x10100180U

#define MSK_NX51_pfifo_fill_level_start_fill_level 0x000003ffU
#define SRT_NX51_pfifo_fill_level_start_fill_level 0

/* all used bits of 'NX51_pfifo_fill_level_start': */
#define MSK_USED_BITS_NX51_pfifo_fill_level_start 0x000003ffU

enum {
	BFW_NX51_pfifo_fill_level_start_fill_level = 10, /* [9:0] */
	BFW_NX51_pfifo_fill_level_start_reserved1  = 22  /* [31:10] */
};

typedef struct NX51_PFIFO_FILL_LEVEL_START_BIT_Ttag {
	unsigned int fill_level : BFW_NX51_pfifo_fill_level_start_fill_level; /* actual number of words in appropriate FIFO       */
	                                                                      /* (not valid, if FIFO had an overflow or underrun) */
	unsigned int reserved1  : BFW_NX51_pfifo_fill_level_start_reserved1;  /* reserved                                         */
} NX51_PFIFO_FILL_LEVEL_START_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_PFIFO_FILL_LEVEL_START_BIT_T bf;
} NX51_PFIFO_FILL_LEVEL_START_T;

/* --------------------------------------------------------------------- */
/* Register pfifo_fill_level_end */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pfifo_fill_level_end                 0x000001FCU
#define Adr_NX51_pointer_fifo_pfifo_fill_level_end        0x1018B9FCU
#define Adr_NX51_pointer_fifo_motion_pfifo_fill_level_end 0x101001FCU


/* ===================================================================== */

/* Area of fmmusm */

/* ===================================================================== */

#define Addr_NX51_fmmusm 0x1018BA00U

/* --------------------------------------------------------------------- */
/* Register fmmu0_cfg_log_startaddr */
/* => FMMU 0 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu0_cfg_log_startaddr    0x00000000U
#define Adr_NX51_fmmusm_fmmu0_cfg_log_startaddr 0x1018BA00U
#define Adr_NX51_fmmu0_cfg_log_startaddr        0x1018BA00U
#define DFLT_VAL_NX51_fmmu0_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu0_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu0_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu0_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu0_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu0_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu0_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU0_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu0_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU0_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU0_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU0_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu0_cfg_length */
/* => FMMU 0 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu0_cfg_length    0x00000004U
#define Adr_NX51_fmmusm_fmmu0_cfg_length 0x1018BA04U
#define Adr_NX51_fmmu0_cfg_length        0x1018BA04U
#define DFLT_VAL_NX51_fmmu0_cfg_length   0x07000000U

#define MSK_NX51_fmmu0_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu0_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu0_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu0_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu0_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu0_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu0_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu0_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu0_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu0_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu0_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu0_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu0_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu0_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu0_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu0_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu0_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU0_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu0_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu0_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu0_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu0_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu0_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu0_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU0_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU0_CFG_LENGTH_BIT_T bf;
} NX51_FMMU0_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu0_cfg_phys_startaddr */
/* => FMMU 0 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu0_cfg_phys_startaddr    0x00000008U
#define Adr_NX51_fmmusm_fmmu0_cfg_phys_startaddr 0x1018BA08U
#define Adr_NX51_fmmu0_cfg_phys_startaddr        0x1018BA08U
#define DFLT_VAL_NX51_fmmu0_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu0_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu0_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu0_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu0_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu0_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu0_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu0_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu0_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu0_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu0_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu0_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu0_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu0_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu0_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu0_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu0_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu0_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu0_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu0_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu0_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu0_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU0_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu0_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu0_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu0_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu0_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu0_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel  */
	unsigned int proc_wr_enable : BFW_NX51_fmmu0_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu0_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU0_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU0_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU0_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu0_cfg_enable */
/* => FMMU 0 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu0_cfg_enable    0x0000000CU
#define Adr_NX51_fmmusm_fmmu0_cfg_enable 0x1018BA0CU
#define Adr_NX51_fmmu0_cfg_enable        0x1018BA0CU
#define DFLT_VAL_NX51_fmmu0_cfg_enable   0x00000000U

#define MSK_NX51_fmmu0_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu0_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu0_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu0_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu0_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu0_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu0_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu0_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU0_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu0_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu0_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU0_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU0_CFG_ENABLE_BIT_T bf;
} NX51_FMMU0_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register fmmu1_cfg_log_startaddr */
/* => FMMU 1 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu1_cfg_log_startaddr    0x00000010U
#define Adr_NX51_fmmusm_fmmu1_cfg_log_startaddr 0x1018BA10U
#define Adr_NX51_fmmu1_cfg_log_startaddr        0x1018BA10U
#define DFLT_VAL_NX51_fmmu1_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu1_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu1_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu1_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu1_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu1_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu1_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU1_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu1_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU1_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU1_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU1_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu1_cfg_length */
/* => FMMU 1 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu1_cfg_length    0x00000014U
#define Adr_NX51_fmmusm_fmmu1_cfg_length 0x1018BA14U
#define Adr_NX51_fmmu1_cfg_length        0x1018BA14U
#define DFLT_VAL_NX51_fmmu1_cfg_length   0x07000000U

#define MSK_NX51_fmmu1_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu1_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu1_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu1_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu1_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu1_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu1_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu1_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu1_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu1_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu1_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu1_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu1_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu1_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu1_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu1_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu1_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU1_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu1_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu1_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu1_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu1_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu1_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu1_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU1_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU1_CFG_LENGTH_BIT_T bf;
} NX51_FMMU1_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu1_cfg_phys_startaddr */
/* => FMMU 1 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu1_cfg_phys_startaddr    0x00000018U
#define Adr_NX51_fmmusm_fmmu1_cfg_phys_startaddr 0x1018BA18U
#define Adr_NX51_fmmu1_cfg_phys_startaddr        0x1018BA18U
#define DFLT_VAL_NX51_fmmu1_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu1_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu1_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu1_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu1_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu1_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu1_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu1_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu1_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu1_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu1_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu1_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu1_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu1_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu1_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu1_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu1_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu1_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu1_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu1_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu1_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu1_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU1_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu1_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu1_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu1_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu1_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu1_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel. */
	unsigned int proc_wr_enable : BFW_NX51_fmmu1_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu1_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU1_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU1_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU1_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu1_cfg_enable */
/* => FMMU 1 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu1_cfg_enable    0x0000001CU
#define Adr_NX51_fmmusm_fmmu1_cfg_enable 0x1018BA1CU
#define Adr_NX51_fmmu1_cfg_enable        0x1018BA1CU
#define DFLT_VAL_NX51_fmmu1_cfg_enable   0x00000000U

#define MSK_NX51_fmmu1_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu1_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu1_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu1_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu1_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu1_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu1_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu1_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU1_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu1_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu1_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU1_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU1_CFG_ENABLE_BIT_T bf;
} NX51_FMMU1_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register fmmu2_cfg_log_startaddr */
/* => FMMU 2 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu2_cfg_log_startaddr    0x00000020U
#define Adr_NX51_fmmusm_fmmu2_cfg_log_startaddr 0x1018BA20U
#define Adr_NX51_fmmu2_cfg_log_startaddr        0x1018BA20U
#define DFLT_VAL_NX51_fmmu2_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu2_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu2_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu2_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu2_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu2_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu2_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU2_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu2_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU2_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU2_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU2_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu2_cfg_length */
/* => FMMU 2 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu2_cfg_length    0x00000024U
#define Adr_NX51_fmmusm_fmmu2_cfg_length 0x1018BA24U
#define Adr_NX51_fmmu2_cfg_length        0x1018BA24U
#define DFLT_VAL_NX51_fmmu2_cfg_length   0x07000000U

#define MSK_NX51_fmmu2_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu2_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu2_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu2_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu2_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu2_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu2_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu2_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu2_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu2_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu2_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu2_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu2_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu2_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu2_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu2_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu2_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU2_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu2_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu2_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu2_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu2_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu2_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu2_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU2_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU2_CFG_LENGTH_BIT_T bf;
} NX51_FMMU2_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu2_cfg_phys_startaddr */
/* => FMMU 2 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu2_cfg_phys_startaddr    0x00000028U
#define Adr_NX51_fmmusm_fmmu2_cfg_phys_startaddr 0x1018BA28U
#define Adr_NX51_fmmu2_cfg_phys_startaddr        0x1018BA28U
#define DFLT_VAL_NX51_fmmu2_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu2_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu2_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu2_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu2_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu2_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu2_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu2_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu2_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu2_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu2_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu2_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu2_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu2_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu2_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu2_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu2_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu2_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu2_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu2_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu2_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu2_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU2_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu2_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu2_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu2_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu2_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu2_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel. */
	unsigned int proc_wr_enable : BFW_NX51_fmmu2_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu2_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU2_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU2_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU2_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu2_cfg_enable */
/* => FMMU 2 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu2_cfg_enable    0x0000002CU
#define Adr_NX51_fmmusm_fmmu2_cfg_enable 0x1018BA2CU
#define Adr_NX51_fmmu2_cfg_enable        0x1018BA2CU
#define DFLT_VAL_NX51_fmmu2_cfg_enable   0x00000000U

#define MSK_NX51_fmmu2_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu2_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu2_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu2_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu2_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu2_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu2_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu2_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU2_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu2_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu2_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU2_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU2_CFG_ENABLE_BIT_T bf;
} NX51_FMMU2_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register fmmu3_cfg_log_startaddr */
/* => FMMU 3 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu3_cfg_log_startaddr    0x00000030U
#define Adr_NX51_fmmusm_fmmu3_cfg_log_startaddr 0x1018BA30U
#define Adr_NX51_fmmu3_cfg_log_startaddr        0x1018BA30U
#define DFLT_VAL_NX51_fmmu3_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu3_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu3_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu3_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu3_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu3_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu3_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU3_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu3_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU3_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU3_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU3_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu3_cfg_length */
/* => FMMU 3 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu3_cfg_length    0x00000034U
#define Adr_NX51_fmmusm_fmmu3_cfg_length 0x1018BA34U
#define Adr_NX51_fmmu3_cfg_length        0x1018BA34U
#define DFLT_VAL_NX51_fmmu3_cfg_length   0x07000000U

#define MSK_NX51_fmmu3_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu3_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu3_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu3_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu3_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu3_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu3_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu3_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu3_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu3_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu3_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu3_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu3_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu3_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu3_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu3_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu3_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU3_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu3_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu3_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu3_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu3_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu3_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu3_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU3_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU3_CFG_LENGTH_BIT_T bf;
} NX51_FMMU3_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu3_cfg_phys_startaddr */
/* => FMMU 3 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu3_cfg_phys_startaddr    0x00000038U
#define Adr_NX51_fmmusm_fmmu3_cfg_phys_startaddr 0x1018BA38U
#define Adr_NX51_fmmu3_cfg_phys_startaddr        0x1018BA38U
#define DFLT_VAL_NX51_fmmu3_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu3_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu3_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu3_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu3_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu3_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu3_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu3_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu3_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu3_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu3_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu3_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu3_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu3_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu3_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu3_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu3_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu3_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu3_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu3_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu3_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu3_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU3_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu3_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu3_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu3_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu3_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu3_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel. */
	unsigned int proc_wr_enable : BFW_NX51_fmmu3_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu3_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU3_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU3_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU3_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu3_cfg_enable */
/* => FMMU 3 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu3_cfg_enable    0x0000003CU
#define Adr_NX51_fmmusm_fmmu3_cfg_enable 0x1018BA3CU
#define Adr_NX51_fmmu3_cfg_enable        0x1018BA3CU
#define DFLT_VAL_NX51_fmmu3_cfg_enable   0x00000000U

#define MSK_NX51_fmmu3_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu3_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu3_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu3_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu3_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu3_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu3_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu3_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU3_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu3_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu3_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU3_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU3_CFG_ENABLE_BIT_T bf;
} NX51_FMMU3_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register fmmu4_cfg_log_startaddr */
/* => FMMU 4 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu4_cfg_log_startaddr    0x00000040U
#define Adr_NX51_fmmusm_fmmu4_cfg_log_startaddr 0x1018BA40U
#define Adr_NX51_fmmu4_cfg_log_startaddr        0x1018BA40U
#define DFLT_VAL_NX51_fmmu4_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu4_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu4_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu4_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu4_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu4_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu4_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU4_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu4_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU4_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU4_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU4_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu4_cfg_length */
/* => FMMU 4 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu4_cfg_length    0x00000044U
#define Adr_NX51_fmmusm_fmmu4_cfg_length 0x1018BA44U
#define Adr_NX51_fmmu4_cfg_length        0x1018BA44U
#define DFLT_VAL_NX51_fmmu4_cfg_length   0x07000000U

#define MSK_NX51_fmmu4_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu4_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu4_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu4_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu4_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu4_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu4_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu4_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu4_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu4_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu4_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu4_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu4_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu4_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu4_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu4_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu4_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU4_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu4_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu4_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu4_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu4_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu4_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu4_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU4_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU4_CFG_LENGTH_BIT_T bf;
} NX51_FMMU4_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu4_cfg_phys_startaddr */
/* => FMMU 4 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu4_cfg_phys_startaddr    0x00000048U
#define Adr_NX51_fmmusm_fmmu4_cfg_phys_startaddr 0x1018BA48U
#define Adr_NX51_fmmu4_cfg_phys_startaddr        0x1018BA48U
#define DFLT_VAL_NX51_fmmu4_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu4_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu4_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu4_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu4_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu4_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu4_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu4_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu4_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu4_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu4_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu4_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu4_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu4_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu4_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu4_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu4_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu4_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu4_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu4_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu4_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu4_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU4_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu4_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu4_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu4_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu4_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu4_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel. */
	unsigned int proc_wr_enable : BFW_NX51_fmmu4_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu4_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU4_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU4_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU4_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu4_cfg_enable */
/* => FMMU 4 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu4_cfg_enable    0x0000004CU
#define Adr_NX51_fmmusm_fmmu4_cfg_enable 0x1018BA4CU
#define Adr_NX51_fmmu4_cfg_enable        0x1018BA4CU
#define DFLT_VAL_NX51_fmmu4_cfg_enable   0x00000000U

#define MSK_NX51_fmmu4_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu4_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu4_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu4_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu4_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu4_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu4_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu4_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU4_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu4_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu4_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU4_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU4_CFG_ENABLE_BIT_T bf;
} NX51_FMMU4_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register fmmu5_cfg_log_startaddr */
/* => FMMU 5 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu5_cfg_log_startaddr    0x00000050U
#define Adr_NX51_fmmusm_fmmu5_cfg_log_startaddr 0x1018BA50U
#define Adr_NX51_fmmu5_cfg_log_startaddr        0x1018BA50U
#define DFLT_VAL_NX51_fmmu5_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu5_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu5_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu5_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu5_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu5_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu5_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU5_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu5_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU5_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU5_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU5_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu5_cfg_length */
/* => FMMU 5 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu5_cfg_length    0x00000054U
#define Adr_NX51_fmmusm_fmmu5_cfg_length 0x1018BA54U
#define Adr_NX51_fmmu5_cfg_length        0x1018BA54U
#define DFLT_VAL_NX51_fmmu5_cfg_length   0x07000000U

#define MSK_NX51_fmmu5_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu5_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu5_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu5_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu5_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu5_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu5_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu5_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu5_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu5_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu5_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu5_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu5_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu5_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu5_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu5_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu5_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU5_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu5_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu5_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu5_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu5_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu5_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu5_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU5_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU5_CFG_LENGTH_BIT_T bf;
} NX51_FMMU5_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu5_cfg_phys_startaddr */
/* => FMMU 5 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu5_cfg_phys_startaddr    0x00000058U
#define Adr_NX51_fmmusm_fmmu5_cfg_phys_startaddr 0x1018BA58U
#define Adr_NX51_fmmu5_cfg_phys_startaddr        0x1018BA58U
#define DFLT_VAL_NX51_fmmu5_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu5_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu5_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu5_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu5_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu5_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu5_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu5_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu5_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu5_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu5_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu5_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu5_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu5_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu5_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu5_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu5_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu5_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu5_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu5_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu5_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu5_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU5_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu5_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu5_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu5_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu5_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu5_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel. */
	unsigned int proc_wr_enable : BFW_NX51_fmmu5_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu5_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU5_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU5_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU5_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu5_cfg_enable */
/* => FMMU 5 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu5_cfg_enable    0x0000005CU
#define Adr_NX51_fmmusm_fmmu5_cfg_enable 0x1018BA5CU
#define Adr_NX51_fmmu5_cfg_enable        0x1018BA5CU
#define DFLT_VAL_NX51_fmmu5_cfg_enable   0x00000000U

#define MSK_NX51_fmmu5_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu5_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu5_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu5_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu5_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu5_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu5_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu5_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU5_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu5_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu5_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU5_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU5_CFG_ENABLE_BIT_T bf;
} NX51_FMMU5_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register fmmu6_cfg_log_startaddr */
/* => FMMU 6 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu6_cfg_log_startaddr    0x00000060U
#define Adr_NX51_fmmusm_fmmu6_cfg_log_startaddr 0x1018BA60U
#define Adr_NX51_fmmu6_cfg_log_startaddr        0x1018BA60U
#define DFLT_VAL_NX51_fmmu6_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu6_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu6_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu6_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu6_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu6_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu6_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU6_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu6_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU6_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU6_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU6_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu6_cfg_length */
/* => FMMU 6 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu6_cfg_length    0x00000064U
#define Adr_NX51_fmmusm_fmmu6_cfg_length 0x1018BA64U
#define Adr_NX51_fmmu6_cfg_length        0x1018BA64U
#define DFLT_VAL_NX51_fmmu6_cfg_length   0x07000000U

#define MSK_NX51_fmmu6_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu6_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu6_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu6_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu6_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu6_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu6_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu6_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu6_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu6_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu6_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu6_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu6_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu6_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu6_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu6_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu6_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU6_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu6_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu6_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu6_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu6_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu6_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu6_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU6_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU6_CFG_LENGTH_BIT_T bf;
} NX51_FMMU6_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu6_cfg_phys_startaddr */
/* => FMMU 6 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu6_cfg_phys_startaddr    0x00000068U
#define Adr_NX51_fmmusm_fmmu6_cfg_phys_startaddr 0x1018BA68U
#define Adr_NX51_fmmu6_cfg_phys_startaddr        0x1018BA68U
#define DFLT_VAL_NX51_fmmu6_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu6_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu6_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu6_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu6_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu6_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu6_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu6_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu6_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu6_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu6_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu6_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu6_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu6_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu6_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu6_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu6_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu6_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu6_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu6_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu6_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu6_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU6_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu6_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu6_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu6_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu6_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu6_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel. */
	unsigned int proc_wr_enable : BFW_NX51_fmmu6_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu6_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU6_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU6_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU6_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu6_cfg_enable */
/* => FMMU 6 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu6_cfg_enable    0x0000006CU
#define Adr_NX51_fmmusm_fmmu6_cfg_enable 0x1018BA6CU
#define Adr_NX51_fmmu6_cfg_enable        0x1018BA6CU
#define DFLT_VAL_NX51_fmmu6_cfg_enable   0x00000000U

#define MSK_NX51_fmmu6_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu6_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu6_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu6_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu6_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu6_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu6_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu6_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU6_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu6_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu6_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU6_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU6_CFG_ENABLE_BIT_T bf;
} NX51_FMMU6_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register fmmu7_cfg_log_startaddr */
/* => FMMU 7 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu7_cfg_log_startaddr    0x00000070U
#define Adr_NX51_fmmusm_fmmu7_cfg_log_startaddr 0x1018BA70U
#define Adr_NX51_fmmu7_cfg_log_startaddr        0x1018BA70U
#define DFLT_VAL_NX51_fmmu7_cfg_log_startaddr   0x00000000U

#define MSK_NX51_fmmu7_cfg_log_startaddr_log_startaddr         0xffffffffU
#define SRT_NX51_fmmu7_cfg_log_startaddr_log_startaddr         0
#define DFLT_VAL_NX51_fmmu7_cfg_log_startaddr_log_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_log_startaddr_log_startaddr 0x00000000U

/* all used bits of 'NX51_fmmu7_cfg_log_startaddr': */
#define MSK_USED_BITS_NX51_fmmu7_cfg_log_startaddr 0xffffffffU

enum {
	BFW_NX51_fmmu7_cfg_log_startaddr_log_startaddr = 32  /* [31:0] */
};

typedef struct NX51_FMMU7_CFG_LOG_STARTADDR_BIT_Ttag {
	unsigned int log_startaddr : BFW_NX51_fmmu7_cfg_log_startaddr_log_startaddr; /* Logical start address of FMMU-area */
} NX51_FMMU7_CFG_LOG_STARTADDR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_FMMU7_CFG_LOG_STARTADDR_BIT_T bf;
} NX51_FMMU7_CFG_LOG_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu7_cfg_length */
/* => FMMU 7 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu7_cfg_length    0x00000074U
#define Adr_NX51_fmmusm_fmmu7_cfg_length 0x1018BA74U
#define Adr_NX51_fmmu7_cfg_length        0x1018BA74U
#define DFLT_VAL_NX51_fmmu7_cfg_length   0x07000000U

#define MSK_NX51_fmmu7_cfg_length_length                0x00001fffU
#define SRT_NX51_fmmu7_cfg_length_length                0
#define DFLT_VAL_NX51_fmmu7_cfg_length_length           0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_length_length        0x00000000U
#define MSK_NX51_fmmu7_cfg_length_log_start_bit         0x00070000U
#define SRT_NX51_fmmu7_cfg_length_log_start_bit         16
#define DFLT_VAL_NX51_fmmu7_cfg_length_log_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_length_log_start_bit 0x00000000U
#define MSK_NX51_fmmu7_cfg_length_log_stop_bit          0x07000000U
#define SRT_NX51_fmmu7_cfg_length_log_stop_bit          24
#define DFLT_VAL_NX51_fmmu7_cfg_length_log_stop_bit     0x07000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_length_log_stop_bit  0x00000007U

/* all used bits of 'NX51_fmmu7_cfg_length': */
#define MSK_USED_BITS_NX51_fmmu7_cfg_length 0x07071fffU

enum {
	BFW_NX51_fmmu7_cfg_length_length        = 13, /* [12:0] */
	BFW_NX51_fmmu7_cfg_length_reserved1     = 3,  /* [15:13] */
	BFW_NX51_fmmu7_cfg_length_log_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu7_cfg_length_reserved2     = 5,  /* [23:19] */
	BFW_NX51_fmmu7_cfg_length_log_stop_bit  = 3,  /* [26:24] */
	BFW_NX51_fmmu7_cfg_length_reserved3     = 5   /* [31:27] */
};

typedef struct NX51_FMMU7_CFG_LENGTH_BIT_Ttag {
	unsigned int length        : BFW_NX51_fmmu7_cfg_length_length;        /* Length of FMMU-area in bytes                    */
	unsigned int reserved1     : BFW_NX51_fmmu7_cfg_length_reserved1;     /* reserved                                        */
	unsigned int log_start_bit : BFW_NX51_fmmu7_cfg_length_log_start_bit; /* Logical start bit, used for bitwise addressing. */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved2     : BFW_NX51_fmmu7_cfg_length_reserved2;     /* reserved                                        */
	unsigned int log_stop_bit  : BFW_NX51_fmmu7_cfg_length_log_stop_bit;  /* Logical stop bit, used for bitwise addressing.  */
	                                                                      /* Restricted at netX for use inside one byte.     */
	unsigned int reserved3     : BFW_NX51_fmmu7_cfg_length_reserved3;     /* reserved                                        */
} NX51_FMMU7_CFG_LENGTH_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU7_CFG_LENGTH_BIT_T bf;
} NX51_FMMU7_CFG_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register fmmu7_cfg_phys_startaddr */
/* => FMMU 7 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu7_cfg_phys_startaddr    0x00000078U
#define Adr_NX51_fmmusm_fmmu7_cfg_phys_startaddr 0x1018BA78U
#define Adr_NX51_fmmu7_cfg_phys_startaddr        0x1018BA78U
#define DFLT_VAL_NX51_fmmu7_cfg_phys_startaddr   0x00000000U

#define MSK_NX51_fmmu7_cfg_phys_startaddr_phys_startaddr         0x00003fffU
#define SRT_NX51_fmmu7_cfg_phys_startaddr_phys_startaddr         0
#define DFLT_VAL_NX51_fmmu7_cfg_phys_startaddr_phys_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_phys_startaddr_phys_startaddr 0x00000000U
#define MSK_NX51_fmmu7_cfg_phys_startaddr_phys_start_bit         0x00070000U
#define SRT_NX51_fmmu7_cfg_phys_startaddr_phys_start_bit         16
#define DFLT_VAL_NX51_fmmu7_cfg_phys_startaddr_phys_start_bit    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_phys_startaddr_phys_start_bit 0x00000000U
#define MSK_NX51_fmmu7_cfg_phys_startaddr_proc_rd_enable         0x01000000U
#define SRT_NX51_fmmu7_cfg_phys_startaddr_proc_rd_enable         24
#define DFLT_VAL_NX51_fmmu7_cfg_phys_startaddr_proc_rd_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_phys_startaddr_proc_rd_enable 0x00000000U
#define MSK_NX51_fmmu7_cfg_phys_startaddr_proc_wr_enable         0x02000000U
#define SRT_NX51_fmmu7_cfg_phys_startaddr_proc_wr_enable         25
#define DFLT_VAL_NX51_fmmu7_cfg_phys_startaddr_proc_wr_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_phys_startaddr_proc_wr_enable 0x00000000U

/* all used bits of 'NX51_fmmu7_cfg_phys_startaddr': */
#define MSK_USED_BITS_NX51_fmmu7_cfg_phys_startaddr 0x03073fffU

enum {
	BFW_NX51_fmmu7_cfg_phys_startaddr_phys_startaddr = 14, /* [13:0] */
	BFW_NX51_fmmu7_cfg_phys_startaddr_reserved1      = 2,  /* [15:14] */
	BFW_NX51_fmmu7_cfg_phys_startaddr_phys_start_bit = 3,  /* [18:16] */
	BFW_NX51_fmmu7_cfg_phys_startaddr_reserved2      = 5,  /* [23:19] */
	BFW_NX51_fmmu7_cfg_phys_startaddr_proc_rd_enable = 1,  /* [24] */
	BFW_NX51_fmmu7_cfg_phys_startaddr_proc_wr_enable = 1,  /* [25] */
	BFW_NX51_fmmu7_cfg_phys_startaddr_reserved3      = 6   /* [31:26] */
};

typedef struct NX51_FMMU7_CFG_PHYS_STARTADDR_BIT_Ttag {
	unsigned int phys_startaddr : BFW_NX51_fmmu7_cfg_phys_startaddr_phys_startaddr; /* Physical byte address inside 8kByte xPEC data memory    */
	unsigned int reserved1      : BFW_NX51_fmmu7_cfg_phys_startaddr_reserved1;      /* reserved                                                */
	unsigned int phys_start_bit : BFW_NX51_fmmu7_cfg_phys_startaddr_phys_start_bit; /* Physical start bit, used for bitwise addressing.        */
	                                                                                /* Restricted at netX for use inside one byte.             */
	unsigned int reserved2      : BFW_NX51_fmmu7_cfg_phys_startaddr_reserved2;      /* reserved                                                */
	unsigned int proc_rd_enable : BFW_NX51_fmmu7_cfg_phys_startaddr_proc_rd_enable; /* Enable FMMU-mapping for read access of process channel. */
	unsigned int proc_wr_enable : BFW_NX51_fmmu7_cfg_phys_startaddr_proc_wr_enable; /* Enable FMMU-mapping for write access of process channel */
	unsigned int reserved3      : BFW_NX51_fmmu7_cfg_phys_startaddr_reserved3;      /* reserved                                                */
} NX51_FMMU7_CFG_PHYS_STARTADDR_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_FMMU7_CFG_PHYS_STARTADDR_BIT_T bf;
} NX51_FMMU7_CFG_PHYS_STARTADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmu7_cfg_enable */
/* => FMMU 7 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu7_cfg_enable    0x0000007CU
#define Adr_NX51_fmmusm_fmmu7_cfg_enable 0x1018BA7CU
#define Adr_NX51_fmmu7_cfg_enable        0x1018BA7CU
#define DFLT_VAL_NX51_fmmu7_cfg_enable   0x00000000U

#define MSK_NX51_fmmu7_cfg_enable_proc_enable         0x00000001U
#define SRT_NX51_fmmu7_cfg_enable_proc_enable         0
#define DFLT_VAL_NX51_fmmu7_cfg_enable_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_fmmu7_cfg_enable_proc_enable 0x00000000U

/* all used bits of 'NX51_fmmu7_cfg_enable': */
#define MSK_USED_BITS_NX51_fmmu7_cfg_enable 0x00000001U

enum {
	BFW_NX51_fmmu7_cfg_enable_proc_enable = 1,  /* [0] */
	BFW_NX51_fmmu7_cfg_enable_reserved1   = 31  /* [31:1] */
};

typedef struct NX51_FMMU7_CFG_ENABLE_BIT_Ttag {
	unsigned int proc_enable : BFW_NX51_fmmu7_cfg_enable_proc_enable; /* FMMU enable for process channel (1:active, 0: only forward) */
	unsigned int reserved1   : BFW_NX51_fmmu7_cfg_enable_reserved1;   /* reserved                                                    */
} NX51_FMMU7_CFG_ENABLE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_FMMU7_CFG_ENABLE_BIT_T bf;
} NX51_FMMU7_CFG_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register sm0_cfg_adr_len */
/* => SM 0 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm0_cfg_adr_len    0x00000080U
#define Adr_NX51_fmmusm_sm0_cfg_adr_len 0x1018BA80U
#define Adr_NX51_sm0_cfg_adr_len        0x1018BA80U
#define DFLT_VAL_NX51_sm0_cfg_adr_len   0x00000000U

#define MSK_NX51_sm0_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm0_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm0_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm0_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm0_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm0_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm0_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm0_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm0_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm0_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm0_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm0_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM0_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm0_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm0_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM0_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM0_CFG_ADR_LEN_BIT_T bf;
} NX51_SM0_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm0_cfg_mode */
/* => SM 0 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm0_cfg_mode    0x00000084U
#define Adr_NX51_fmmusm_sm0_cfg_mode 0x1018BA84U
#define Adr_NX51_sm0_cfg_mode        0x1018BA84U
#define DFLT_VAL_NX51_sm0_cfg_mode   0x00000000U

#define MSK_NX51_sm0_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm0_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm0_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm0_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm0_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm0_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm0_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm0_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm0_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm0_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm0_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm0_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm0_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm0_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm0_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm0_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm0_cfg_mode': */
#define MSK_USED_BITS_NX51_sm0_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm0_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm0_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm0_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm0_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm0_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm0_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm0_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm0_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM0_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm0_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm0_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm0_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm0_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm0_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm0_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm0_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm0_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM0_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM0_CFG_MODE_BIT_T bf;
} NX51_SM0_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sm1_cfg_adr_len */
/* => SM 1 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm1_cfg_adr_len    0x00000088U
#define Adr_NX51_fmmusm_sm1_cfg_adr_len 0x1018BA88U
#define Adr_NX51_sm1_cfg_adr_len        0x1018BA88U
#define DFLT_VAL_NX51_sm1_cfg_adr_len   0x00000000U

#define MSK_NX51_sm1_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm1_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm1_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm1_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm1_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm1_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm1_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm1_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm1_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm1_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm1_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm1_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM1_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm1_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm1_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM1_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM1_CFG_ADR_LEN_BIT_T bf;
} NX51_SM1_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm1_cfg_mode */
/* => SM 1 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm1_cfg_mode    0x0000008CU
#define Adr_NX51_fmmusm_sm1_cfg_mode 0x1018BA8CU
#define Adr_NX51_sm1_cfg_mode        0x1018BA8CU
#define DFLT_VAL_NX51_sm1_cfg_mode   0x00000000U

#define MSK_NX51_sm1_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm1_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm1_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm1_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm1_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm1_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm1_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm1_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm1_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm1_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm1_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm1_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm1_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm1_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm1_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm1_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm1_cfg_mode': */
#define MSK_USED_BITS_NX51_sm1_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm1_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm1_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm1_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm1_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm1_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm1_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm1_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm1_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM1_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm1_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm1_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm1_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm1_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm1_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm1_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm1_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm1_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM1_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM1_CFG_MODE_BIT_T bf;
} NX51_SM1_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sm2_cfg_adr_len */
/* => SM 2 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm2_cfg_adr_len    0x00000090U
#define Adr_NX51_fmmusm_sm2_cfg_adr_len 0x1018BA90U
#define Adr_NX51_sm2_cfg_adr_len        0x1018BA90U
#define DFLT_VAL_NX51_sm2_cfg_adr_len   0x00000000U

#define MSK_NX51_sm2_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm2_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm2_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm2_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm2_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm2_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm2_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm2_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm2_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm2_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm2_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm2_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM2_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm2_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm2_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM2_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM2_CFG_ADR_LEN_BIT_T bf;
} NX51_SM2_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm2_cfg_mode */
/* => SM 2 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm2_cfg_mode    0x00000094U
#define Adr_NX51_fmmusm_sm2_cfg_mode 0x1018BA94U
#define Adr_NX51_sm2_cfg_mode        0x1018BA94U
#define DFLT_VAL_NX51_sm2_cfg_mode   0x00000000U

#define MSK_NX51_sm2_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm2_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm2_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm2_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm2_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm2_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm2_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm2_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm2_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm2_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm2_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm2_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm2_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm2_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm2_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm2_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm2_cfg_mode': */
#define MSK_USED_BITS_NX51_sm2_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm2_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm2_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm2_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm2_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm2_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm2_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm2_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm2_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM2_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm2_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm2_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm2_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm2_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm2_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm2_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm2_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm2_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM2_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM2_CFG_MODE_BIT_T bf;
} NX51_SM2_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sm3_cfg_adr_len */
/* => SM 3 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm3_cfg_adr_len    0x00000098U
#define Adr_NX51_fmmusm_sm3_cfg_adr_len 0x1018BA98U
#define Adr_NX51_sm3_cfg_adr_len        0x1018BA98U
#define DFLT_VAL_NX51_sm3_cfg_adr_len   0x00000000U

#define MSK_NX51_sm3_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm3_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm3_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm3_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm3_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm3_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm3_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm3_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm3_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm3_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm3_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm3_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM3_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm3_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm3_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM3_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM3_CFG_ADR_LEN_BIT_T bf;
} NX51_SM3_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm3_cfg_mode */
/* => SM 3 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm3_cfg_mode    0x0000009CU
#define Adr_NX51_fmmusm_sm3_cfg_mode 0x1018BA9CU
#define Adr_NX51_sm3_cfg_mode        0x1018BA9CU
#define DFLT_VAL_NX51_sm3_cfg_mode   0x00000000U

#define MSK_NX51_sm3_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm3_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm3_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm3_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm3_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm3_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm3_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm3_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm3_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm3_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm3_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm3_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm3_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm3_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm3_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm3_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm3_cfg_mode': */
#define MSK_USED_BITS_NX51_sm3_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm3_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm3_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm3_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm3_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm3_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm3_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm3_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm3_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM3_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm3_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm3_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm3_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm3_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm3_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm3_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm3_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm3_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM3_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM3_CFG_MODE_BIT_T bf;
} NX51_SM3_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sm4_cfg_adr_len */
/* => SM 4 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm4_cfg_adr_len    0x000000A0U
#define Adr_NX51_fmmusm_sm4_cfg_adr_len 0x1018BAA0U
#define Adr_NX51_sm4_cfg_adr_len        0x1018BAA0U
#define DFLT_VAL_NX51_sm4_cfg_adr_len   0x00000000U

#define MSK_NX51_sm4_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm4_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm4_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm4_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm4_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm4_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm4_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm4_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm4_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm4_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm4_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm4_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM4_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm4_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm4_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM4_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM4_CFG_ADR_LEN_BIT_T bf;
} NX51_SM4_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm4_cfg_mode */
/* => SM 4 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm4_cfg_mode    0x000000A4U
#define Adr_NX51_fmmusm_sm4_cfg_mode 0x1018BAA4U
#define Adr_NX51_sm4_cfg_mode        0x1018BAA4U
#define DFLT_VAL_NX51_sm4_cfg_mode   0x00000000U

#define MSK_NX51_sm4_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm4_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm4_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm4_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm4_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm4_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm4_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm4_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm4_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm4_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm4_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm4_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm4_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm4_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm4_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm4_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm4_cfg_mode': */
#define MSK_USED_BITS_NX51_sm4_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm4_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm4_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm4_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm4_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm4_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm4_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm4_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm4_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM4_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm4_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm4_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm4_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm4_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm4_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm4_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm4_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm4_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM4_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM4_CFG_MODE_BIT_T bf;
} NX51_SM4_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sm5_cfg_adr_len */
/* => SM 5 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm5_cfg_adr_len    0x000000A8U
#define Adr_NX51_fmmusm_sm5_cfg_adr_len 0x1018BAA8U
#define Adr_NX51_sm5_cfg_adr_len        0x1018BAA8U
#define DFLT_VAL_NX51_sm5_cfg_adr_len   0x00000000U

#define MSK_NX51_sm5_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm5_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm5_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm5_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm5_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm5_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm5_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm5_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm5_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm5_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm5_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm5_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM5_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm5_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm5_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM5_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM5_CFG_ADR_LEN_BIT_T bf;
} NX51_SM5_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm5_cfg_mode */
/* => SM 5 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm5_cfg_mode    0x000000ACU
#define Adr_NX51_fmmusm_sm5_cfg_mode 0x1018BAACU
#define Adr_NX51_sm5_cfg_mode        0x1018BAACU
#define DFLT_VAL_NX51_sm5_cfg_mode   0x00000000U

#define MSK_NX51_sm5_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm5_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm5_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm5_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm5_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm5_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm5_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm5_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm5_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm5_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm5_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm5_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm5_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm5_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm5_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm5_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm5_cfg_mode': */
#define MSK_USED_BITS_NX51_sm5_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm5_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm5_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm5_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm5_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm5_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm5_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm5_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm5_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM5_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm5_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm5_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm5_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm5_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm5_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm5_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm5_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm5_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM5_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM5_CFG_MODE_BIT_T bf;
} NX51_SM5_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sm6_cfg_adr_len */
/* => SM 6 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm6_cfg_adr_len    0x000000B0U
#define Adr_NX51_fmmusm_sm6_cfg_adr_len 0x1018BAB0U
#define Adr_NX51_sm6_cfg_adr_len        0x1018BAB0U
#define DFLT_VAL_NX51_sm6_cfg_adr_len   0x00000000U

#define MSK_NX51_sm6_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm6_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm6_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm6_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm6_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm6_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm6_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm6_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm6_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm6_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm6_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm6_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM6_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm6_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm6_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM6_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM6_CFG_ADR_LEN_BIT_T bf;
} NX51_SM6_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm6_cfg_mode */
/* => SM 6 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm6_cfg_mode    0x000000B4U
#define Adr_NX51_fmmusm_sm6_cfg_mode 0x1018BAB4U
#define Adr_NX51_sm6_cfg_mode        0x1018BAB4U
#define DFLT_VAL_NX51_sm6_cfg_mode   0x00000000U

#define MSK_NX51_sm6_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm6_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm6_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm6_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm6_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm6_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm6_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm6_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm6_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm6_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm6_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm6_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm6_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm6_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm6_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm6_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm6_cfg_mode': */
#define MSK_USED_BITS_NX51_sm6_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm6_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm6_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm6_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm6_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm6_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm6_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm6_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm6_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM6_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm6_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm6_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm6_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm6_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm6_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm6_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm6_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm6_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM6_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM6_CFG_MODE_BIT_T bf;
} NX51_SM6_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sm7_cfg_adr_len */
/* => SM 7 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm7_cfg_adr_len    0x000000B8U
#define Adr_NX51_fmmusm_sm7_cfg_adr_len 0x1018BAB8U
#define Adr_NX51_sm7_cfg_adr_len        0x1018BAB8U
#define DFLT_VAL_NX51_sm7_cfg_adr_len   0x00000000U

#define MSK_NX51_sm7_cfg_adr_len_startaddr         0x0000ffffU
#define SRT_NX51_sm7_cfg_adr_len_startaddr         0
#define DFLT_VAL_NX51_sm7_cfg_adr_len_startaddr    0x00000000U
#define DFLT_BF_VAL_NX51_sm7_cfg_adr_len_startaddr 0x00000000U
#define MSK_NX51_sm7_cfg_adr_len_length            0xffff0000U
#define SRT_NX51_sm7_cfg_adr_len_length            16
#define DFLT_VAL_NX51_sm7_cfg_adr_len_length       0x00000000U
#define DFLT_BF_VAL_NX51_sm7_cfg_adr_len_length    0x00000000U

/* all used bits of 'NX51_sm7_cfg_adr_len': */
#define MSK_USED_BITS_NX51_sm7_cfg_adr_len 0xffffffffU

enum {
	BFW_NX51_sm7_cfg_adr_len_startaddr = 16, /* [15:0] */
	BFW_NX51_sm7_cfg_adr_len_length    = 16  /* [31:16] */
};

typedef struct NX51_SM7_CFG_ADR_LEN_BIT_Ttag {
	unsigned int startaddr : BFW_NX51_sm7_cfg_adr_len_startaddr; /* Physical start address of SM-area  */
	unsigned int length    : BFW_NX51_sm7_cfg_adr_len_length;    /* Length of SM-area in bytes,        */
	                                                             /* tripled in case of 3-buffer method */
} NX51_SM7_CFG_ADR_LEN_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SM7_CFG_ADR_LEN_BIT_T bf;
} NX51_SM7_CFG_ADR_LEN_T;

/* --------------------------------------------------------------------- */
/* Register sm7_cfg_mode */
/* => SM 7 config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm7_cfg_mode    0x000000BCU
#define Adr_NX51_fmmusm_sm7_cfg_mode 0x1018BABCU
#define Adr_NX51_sm7_cfg_mode        0x1018BABCU
#define DFLT_VAL_NX51_sm7_cfg_mode   0x00000000U

#define MSK_NX51_sm7_cfg_mode_buf_method          0x00000002U
#define SRT_NX51_sm7_cfg_mode_buf_method          1
#define DFLT_VAL_NX51_sm7_cfg_mode_buf_method     0x00000000U
#define DFLT_BF_VAL_NX51_sm7_cfg_mode_buf_method  0x00000000U
#define MSK_NX51_sm7_cfg_mode_write_read          0x00000004U
#define SRT_NX51_sm7_cfg_mode_write_read          2
#define DFLT_VAL_NX51_sm7_cfg_mode_write_read     0x00000000U
#define DFLT_BF_VAL_NX51_sm7_cfg_mode_write_read  0x00000000U
#define MSK_NX51_sm7_cfg_mode_proc_enable         0x00010000U
#define SRT_NX51_sm7_cfg_mode_proc_enable         16
#define DFLT_VAL_NX51_sm7_cfg_mode_proc_enable    0x00000000U
#define DFLT_BF_VAL_NX51_sm7_cfg_mode_proc_enable 0x00000000U
#define MSK_NX51_sm7_cfg_mode_dis_by_arm          0x01000000U
#define SRT_NX51_sm7_cfg_mode_dis_by_arm          24
#define DFLT_VAL_NX51_sm7_cfg_mode_dis_by_arm     0x00000000U
#define DFLT_BF_VAL_NX51_sm7_cfg_mode_dis_by_arm  0x00000000U

/* all used bits of 'NX51_sm7_cfg_mode': */
#define MSK_USED_BITS_NX51_sm7_cfg_mode 0x01010006U

enum {
	BFW_NX51_sm7_cfg_mode_reserved1   = 1,  /* [0] */
	BFW_NX51_sm7_cfg_mode_buf_method  = 1,  /* [1] */
	BFW_NX51_sm7_cfg_mode_write_read  = 1,  /* [2] */
	BFW_NX51_sm7_cfg_mode_reserved2   = 13, /* [15:3] */
	BFW_NX51_sm7_cfg_mode_proc_enable = 1,  /* [16] */
	BFW_NX51_sm7_cfg_mode_reserved3   = 7,  /* [23:17] */
	BFW_NX51_sm7_cfg_mode_dis_by_arm  = 1,  /* [24] */
	BFW_NX51_sm7_cfg_mode_reserved4   = 7   /* [31:25] */
};

typedef struct NX51_SM7_CFG_MODE_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_sm7_cfg_mode_reserved1;   /* reserved                                        */
	unsigned int buf_method  : BFW_NX51_sm7_cfg_mode_buf_method;  /* Buffer method:                                  */
	                                                              /* 0: 3 buffer method                              */
	                                                              /* 1: 1 buffer method                              */
	unsigned int write_read  : BFW_NX51_sm7_cfg_mode_write_read;  /* Write/Read:                                     */
	                                                              /* 0: read:  EtherCAT read,  ARM write             */
	                                                              /* 1: write: EtherCAT write, ARM read              */
	unsigned int reserved2   : BFW_NX51_sm7_cfg_mode_reserved2;   /* reserved                                        */
	unsigned int proc_enable : BFW_NX51_sm7_cfg_mode_proc_enable; /* Enable for process channel                      */
	                                                              /* 0: Sync-manager is disabled for process channel */
	                                                              /* 1: Sync-manager is enabled for process channel  */
	unsigned int reserved3   : BFW_NX51_sm7_cfg_mode_reserved3;   /* reserved                                        */
	unsigned int dis_by_arm  : BFW_NX51_sm7_cfg_mode_dis_by_arm;  /* Sync-manager locked by ARM                      */
	                                                              /* 0: Sync-manager is operable                     */
	                                                              /* 1: Sync-manager is locked by ARM                */
	unsigned int reserved4   : BFW_NX51_sm7_cfg_mode_reserved4;   /* reserved                                        */
} NX51_SM7_CFG_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SM7_CFG_MODE_BIT_T bf;
} NX51_SM7_CFG_MODE_T;

/* --------------------------------------------------------------------- */
/* Register phys_addr_offset */
/* => Physical offset of phys. ECAT address and xPEC data ram address */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_phys_addr_offset    0x000000D0U
#define Adr_NX51_fmmusm_phys_addr_offset 0x1018BAD0U
#define Adr_NX51_phys_addr_offset        0x1018BAD0U
#define DFLT_VAL_NX51_phys_addr_offset   0x00000000U

#define MSK_NX51_phys_addr_offset_phys_addr_offset                       0x0000ffffU
#define SRT_NX51_phys_addr_offset_phys_addr_offset                       0
#define DFLT_VAL_NX51_phys_addr_offset_phys_addr_offset                  0x00000000U
#define DFLT_BF_VAL_NX51_phys_addr_offset_phys_addr_offset               0x00000000U
#define MSK_NX51_phys_addr_offset_phys_addr_offset_register_area         0xffff0000U
#define SRT_NX51_phys_addr_offset_phys_addr_offset_register_area         16
#define DFLT_VAL_NX51_phys_addr_offset_phys_addr_offset_register_area    0x00000000U
#define DFLT_BF_VAL_NX51_phys_addr_offset_phys_addr_offset_register_area 0x00000000U

/* all used bits of 'NX51_phys_addr_offset': */
#define MSK_USED_BITS_NX51_phys_addr_offset 0xffffffffU

enum {
	BFW_NX51_phys_addr_offset_phys_addr_offset               = 16, /* [15:0] */
	BFW_NX51_phys_addr_offset_phys_addr_offset_register_area = 16  /* [31:16] */
};

typedef struct NX51_PHYS_ADDR_OFFSET_BIT_Ttag {
	unsigned int phys_addr_offset               : BFW_NX51_phys_addr_offset_phys_addr_offset;               /* Physical offset of phys. ECAT address and xPEC data ram address for phys_ECAT_addr>=0x1000 */
	                                                                                                        /* sm_write_addr_out = physical write address to access + phys_addr_offset                    */
	                                                                                                        /* sm_read_addr_out  = physical read address to access  + phys_addr_offset                    */
	unsigned int phys_addr_offset_register_area : BFW_NX51_phys_addr_offset_phys_addr_offset_register_area; /* Physical offset of phys. ECAT address and xPEC data ram address for phys_ECAT_addr<0x1000  */
	                                                                                                        /* sm_write_addr_out = physical write address to access + phys_addr_offset_register_area      */
	                                                                                                        /* sm_read_addr_out  = physical read address to access  + phys_addr_offset_register_area      */
} NX51_PHYS_ADDR_OFFSET_BIT_T;

typedef union {
	unsigned int                val;
	NX51_PHYS_ADDR_OFFSET_BIT_T bf;
} NX51_PHYS_ADDR_OFFSET_T;

/* --------------------------------------------------------------------- */
/* Register phys_last_addr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_phys_last_addr    0x000000D4U
#define Adr_NX51_fmmusm_phys_last_addr 0x1018BAD4U
#define Adr_NX51_phys_last_addr        0x1018BAD4U
#define DFLT_VAL_NX51_phys_last_addr   0x00001fffU

#define MSK_NX51_phys_last_addr_phys_last_addr         0x0000ffffU
#define SRT_NX51_phys_last_addr_phys_last_addr         0
#define DFLT_VAL_NX51_phys_last_addr_phys_last_addr    0x00001fffU
#define DFLT_BF_VAL_NX51_phys_last_addr_phys_last_addr 0x00001fffU
#define MSK_NX51_phys_last_addr_sm0_cfg_add            0x00030000U
#define SRT_NX51_phys_last_addr_sm0_cfg_add            16
#define DFLT_VAL_NX51_phys_last_addr_sm0_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm0_cfg_add    0x00000000U
#define MSK_NX51_phys_last_addr_sm1_cfg_add            0x000c0000U
#define SRT_NX51_phys_last_addr_sm1_cfg_add            18
#define DFLT_VAL_NX51_phys_last_addr_sm1_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm1_cfg_add    0x00000000U
#define MSK_NX51_phys_last_addr_sm2_cfg_add            0x00300000U
#define SRT_NX51_phys_last_addr_sm2_cfg_add            20
#define DFLT_VAL_NX51_phys_last_addr_sm2_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm2_cfg_add    0x00000000U
#define MSK_NX51_phys_last_addr_sm3_cfg_add            0x00c00000U
#define SRT_NX51_phys_last_addr_sm3_cfg_add            22
#define DFLT_VAL_NX51_phys_last_addr_sm3_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm3_cfg_add    0x00000000U
#define MSK_NX51_phys_last_addr_sm4_cfg_add            0x03000000U
#define SRT_NX51_phys_last_addr_sm4_cfg_add            24
#define DFLT_VAL_NX51_phys_last_addr_sm4_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm4_cfg_add    0x00000000U
#define MSK_NX51_phys_last_addr_sm5_cfg_add            0x0c000000U
#define SRT_NX51_phys_last_addr_sm5_cfg_add            26
#define DFLT_VAL_NX51_phys_last_addr_sm5_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm5_cfg_add    0x00000000U
#define MSK_NX51_phys_last_addr_sm6_cfg_add            0x30000000U
#define SRT_NX51_phys_last_addr_sm6_cfg_add            28
#define DFLT_VAL_NX51_phys_last_addr_sm6_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm6_cfg_add    0x00000000U
#define MSK_NX51_phys_last_addr_sm7_cfg_add            0xc0000000U
#define SRT_NX51_phys_last_addr_sm7_cfg_add            30
#define DFLT_VAL_NX51_phys_last_addr_sm7_cfg_add       0x00000000U
#define DFLT_BF_VAL_NX51_phys_last_addr_sm7_cfg_add    0x00000000U

/* all used bits of 'NX51_phys_last_addr': */
#define MSK_USED_BITS_NX51_phys_last_addr 0xffffffffU

enum {
	BFW_NX51_phys_last_addr_phys_last_addr = 16, /* [15:0] */
	BFW_NX51_phys_last_addr_sm0_cfg_add    = 2,  /* [17:16] */
	BFW_NX51_phys_last_addr_sm1_cfg_add    = 2,  /* [19:18] */
	BFW_NX51_phys_last_addr_sm2_cfg_add    = 2,  /* [21:20] */
	BFW_NX51_phys_last_addr_sm3_cfg_add    = 2,  /* [23:22] */
	BFW_NX51_phys_last_addr_sm4_cfg_add    = 2,  /* [25:24] */
	BFW_NX51_phys_last_addr_sm5_cfg_add    = 2,  /* [27:26] */
	BFW_NX51_phys_last_addr_sm6_cfg_add    = 2,  /* [29:28] */
	BFW_NX51_phys_last_addr_sm7_cfg_add    = 2   /* [31:30] */
};

typedef struct NX51_PHYS_LAST_ADDR_BIT_Ttag {
	unsigned int phys_last_addr : BFW_NX51_phys_last_addr_phys_last_addr; /* last accessible ecat data memory address within xPEC memory, (0x1000-phys_offset_data_ram_start+ecat data size-1)        */
	                                                                      /* IF (sm_read_addr_out  > phys_last_addr) THEN { read to ecat data memory is locked (read_allowed=0) }                     */
	                                                                      /* IF (sm_write_addr_out > phys_last_addr) THEN { write to ecat data memory is locked (write_allowed=0) }                   */
	unsigned int sm0_cfg_add    : BFW_NX51_phys_last_addr_sm0_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm0_cfg_len + sm0_cfg_add) * buf_nr */
	unsigned int sm1_cfg_add    : BFW_NX51_phys_last_addr_sm1_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm1_cfg_len + sm1_cfg_add) * buf_nr */
	unsigned int sm2_cfg_add    : BFW_NX51_phys_last_addr_sm2_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm2_cfg_len + sm2_cfg_add) * buf_nr */
	unsigned int sm3_cfg_add    : BFW_NX51_phys_last_addr_sm3_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm3_cfg_len + sm3_cfg_add) * buf_nr */
	unsigned int sm4_cfg_add    : BFW_NX51_phys_last_addr_sm4_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm4_cfg_len + sm4_cfg_add) * buf_nr */
	unsigned int sm5_cfg_add    : BFW_NX51_phys_last_addr_sm5_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm5_cfg_len + sm5_cfg_add) * buf_nr */
	unsigned int sm6_cfg_add    : BFW_NX51_phys_last_addr_sm6_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm6_cfg_len + sm6_cfg_add) * buf_nr */
	unsigned int sm7_cfg_add    : BFW_NX51_phys_last_addr_sm7_cfg_add;    /* add value to get DW-aligned triple buffer addresses: sm_phys_addr = fmmu_addr_out + (sm7_cfg_len + sm7_cfg_add) * buf_nr */
} NX51_PHYS_LAST_ADDR_BIT_T;

typedef union {
	unsigned int              val;
	NX51_PHYS_LAST_ADDR_BIT_T bf;
} NX51_PHYS_LAST_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register fmmusm_xpec_nr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmusm_xpec_nr    0x000000D8U
#define Adr_NX51_fmmusm_fmmusm_xpec_nr 0x1018BAD8U
#define Adr_NX51_fmmusm_xpec_nr        0x1018BAD8U
#define DFLT_VAL_NX51_fmmusm_xpec_nr   0x00000000U

#define MSK_NX51_fmmusm_xpec_nr_xpec_nr         0x00000001U
#define SRT_NX51_fmmusm_xpec_nr_xpec_nr         0
#define DFLT_VAL_NX51_fmmusm_xpec_nr_xpec_nr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmusm_xpec_nr_xpec_nr 0x00000000U

/* all used bits of 'NX51_fmmusm_xpec_nr': */
#define MSK_USED_BITS_NX51_fmmusm_xpec_nr 0x00000001U

enum {
	BFW_NX51_fmmusm_xpec_nr_xpec_nr   = 1,  /* [0] */
	BFW_NX51_fmmusm_xpec_nr_reserved1 = 31  /* [31:1] */
};

typedef struct NX51_FMMUSM_XPEC_NR_BIT_Ttag {
	unsigned int xpec_nr   : BFW_NX51_fmmusm_xpec_nr_xpec_nr;   /* number of xPEC using FMMUSM (utx_count is read from this xPEC) */
	unsigned int reserved1 : BFW_NX51_fmmusm_xpec_nr_reserved1; /* reserved                                                       */
} NX51_FMMUSM_XPEC_NR_BIT_T;

typedef union {
	unsigned int              val;
	NX51_FMMUSM_XPEC_NR_BIT_T bf;
} NX51_FMMUSM_XPEC_NR_T;

/* --------------------------------------------------------------------- */
/* Register fmmusm_read_addr_in */
/* => Read address from EtherCAT telegram */
/*    Write access by xPEC at adr_xpec_r6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmusm_read_addr_in    0x00000100U
#define Adr_NX51_fmmusm_fmmusm_read_addr_in 0x1018BB00U
#define Adr_NX51_fmmusm_read_addr_in        0x1018BB00U
#define DFLT_VAL_NX51_fmmusm_read_addr_in   0x00000000U

#define MSK_NX51_fmmusm_read_addr_in_read_adr         0xffffffffU
#define SRT_NX51_fmmusm_read_addr_in_read_adr         0
#define DFLT_VAL_NX51_fmmusm_read_addr_in_read_adr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmusm_read_addr_in_read_adr 0x00000000U

/* all used bits of 'NX51_fmmusm_read_addr_in': */
#define MSK_USED_BITS_NX51_fmmusm_read_addr_in 0xffffffffU

enum {
	BFW_NX51_fmmusm_read_addr_in_read_adr = 32  /* [31:0] */
};

typedef struct NX51_FMMUSM_READ_ADDR_IN_BIT_Ttag {
	unsigned int read_adr : BFW_NX51_fmmusm_read_addr_in_read_adr; /* Read address from EtherCAT telegram */
} NX51_FMMUSM_READ_ADDR_IN_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_FMMUSM_READ_ADDR_IN_BIT_T bf;
} NX51_FMMUSM_READ_ADDR_IN_T;

/* --------------------------------------------------------------------- */
/* Register fmmusm_write_addr_in */
/* => Write address from EtherCAT telegram */
/*    Write access by xPEC at adr_xpec_r7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmusm_write_addr_in    0x00000104U
#define Adr_NX51_fmmusm_fmmusm_write_addr_in 0x1018BB04U
#define Adr_NX51_fmmusm_write_addr_in        0x1018BB04U
#define DFLT_VAL_NX51_fmmusm_write_addr_in   0x00000000U

#define MSK_NX51_fmmusm_write_addr_in_write_adr         0xffffffffU
#define SRT_NX51_fmmusm_write_addr_in_write_adr         0
#define DFLT_VAL_NX51_fmmusm_write_addr_in_write_adr    0x00000000U
#define DFLT_BF_VAL_NX51_fmmusm_write_addr_in_write_adr 0x00000000U

/* all used bits of 'NX51_fmmusm_write_addr_in': */
#define MSK_USED_BITS_NX51_fmmusm_write_addr_in 0xffffffffU

enum {
	BFW_NX51_fmmusm_write_addr_in_write_adr = 32  /* [31:0] */
};

typedef struct NX51_FMMUSM_WRITE_ADDR_IN_BIT_Ttag {
	unsigned int write_adr : BFW_NX51_fmmusm_write_addr_in_write_adr; /* Write address from EtherCAT telegram */
} NX51_FMMUSM_WRITE_ADDR_IN_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_FMMUSM_WRITE_ADDR_IN_BIT_T bf;
} NX51_FMMUSM_WRITE_ADDR_IN_T;

/* --------------------------------------------------------------------- */
/* Register sm_read_addr_out */
/* => Physical read address in xPEC RAM */
/*    Read access by xPEC at adr_xpec_r6 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_read_addr_out    0x00000108U
#define Adr_NX51_fmmusm_sm_read_addr_out 0x1018BB08U
#define Adr_NX51_sm_read_addr_out        0x1018BB08U

#define MSK_NX51_sm_read_addr_out_sm_read_adr_out 0x00001fffU
#define SRT_NX51_sm_read_addr_out_sm_read_adr_out 0

/* all used bits of 'NX51_sm_read_addr_out': */
#define MSK_USED_BITS_NX51_sm_read_addr_out 0x00001fffU

enum {
	BFW_NX51_sm_read_addr_out_sm_read_adr_out = 13, /* [12:0] */
	BFW_NX51_sm_read_addr_out_reserved1       = 19  /* [31:13] */
};

typedef struct NX51_SM_READ_ADDR_OUT_BIT_Ttag {
	unsigned int sm_read_adr_out : BFW_NX51_sm_read_addr_out_sm_read_adr_out; /* Physical read address in xPEC RAM */
	                                                                          /* process by FMMU and SM            */
	unsigned int reserved1       : BFW_NX51_sm_read_addr_out_reserved1;       /* reserved                          */
} NX51_SM_READ_ADDR_OUT_BIT_T;

typedef union {
	unsigned int                val;
	NX51_SM_READ_ADDR_OUT_BIT_T bf;
} NX51_SM_READ_ADDR_OUT_T;

/* --------------------------------------------------------------------- */
/* Register sm_write_addr_out */
/* => Physical write address in xPEC RAM */
/*    Read access by xPEC at adr_xpec_r7 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_write_addr_out    0x0000010CU
#define Adr_NX51_fmmusm_sm_write_addr_out 0x1018BB0CU
#define Adr_NX51_sm_write_addr_out        0x1018BB0CU

#define MSK_NX51_sm_write_addr_out_sm_write_adr_out 0x00001fffU
#define SRT_NX51_sm_write_addr_out_sm_write_adr_out 0

/* all used bits of 'NX51_sm_write_addr_out': */
#define MSK_USED_BITS_NX51_sm_write_addr_out 0x00001fffU

enum {
	BFW_NX51_sm_write_addr_out_sm_write_adr_out = 13, /* [12:0] */
	BFW_NX51_sm_write_addr_out_reserved1        = 19  /* [31:13] */
};

typedef struct NX51_SM_WRITE_ADDR_OUT_BIT_Ttag {
	unsigned int sm_write_adr_out : BFW_NX51_sm_write_addr_out_sm_write_adr_out; /* Physical write address in xPEC RAM */
	                                                                             /* process by FMMU and SM             */
	unsigned int reserved1        : BFW_NX51_sm_write_addr_out_reserved1;        /* reserved                           */
} NX51_SM_WRITE_ADDR_OUT_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_SM_WRITE_ADDR_OUT_BIT_T bf;
} NX51_SM_WRITE_ADDR_OUT_T;

/* --------------------------------------------------------------------- */
/* Register fmmu_read_bit_rol_pos */
/* => Shift and mask value for bitwise read access */
/*    For direct use with combined rol-and command. */
/*    Read access by xPEC at adr_statcfg2 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu_read_bit_rol_pos    0x00000110U
#define Adr_NX51_fmmusm_fmmu_read_bit_rol_pos 0x1018BB10U
#define Adr_NX51_fmmu_read_bit_rol_pos        0x1018BB10U

#define MSK_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_rol      0x0000001fU
#define SRT_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_rol      0
#define MSK_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_maskmode 0x000000e0U
#define SRT_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_maskmode 5
#define MSK_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_mask     0x0000ff00U
#define SRT_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_mask     8
#define MSK_NX51_fmmu_read_bit_rol_pos_zero                   0xffff0000U
#define SRT_NX51_fmmu_read_bit_rol_pos_zero                   16

/* all used bits of 'NX51_fmmu_read_bit_rol_pos': */
#define MSK_USED_BITS_NX51_fmmu_read_bit_rol_pos 0xffffffffU

enum {
	BFW_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_rol      = 5,  /* [4:0] */
	BFW_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_maskmode = 3,  /* [7:5] */
	BFW_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_mask     = 8,  /* [15:8] */
	BFW_NX51_fmmu_read_bit_rol_pos_zero                   = 16  /* [31:16] */
};

typedef struct NX51_FMMU_READ_BIT_ROL_POS_BIT_Ttag {
	unsigned int fmmu_read_bit_rol      : BFW_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_rol;      /* rotate left value for bitwise read from RAM to bitstream.                             */
	                                                                                             /* Rotates byte from RAM to correct position for insertion into stream,                  */
	                                                                                             /*  num of pos to rotate left = neg. number of pos if rotate right,                      */
	                                                                                             /*  values in range (-7..7).                                                             */
	                                                                                             /* For bitwise read from RAM to UTX perform:                                             */
	                                                                                             /*  rol   R3,       [RAMrd]b, fmmu_read_bit_rol_pos  // shift and AND-mask bits from RAM */
	                                                                                             /*  nimp  R4,       URX,      fmmu_read_bit_mask     // delete to be changed bits        */
	                                                                                             /*  or    UTX,      R3,       R4                     // insert bits                      */
	                                                                                             /*  wait                                                                                 */
	unsigned int fmmu_read_bit_maskmode : BFW_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_maskmode; /* always 3'b010: and-mask-mode with upper mask-bits=0                                   */
	unsigned int fmmu_read_bit_mask     : BFW_NX51_fmmu_read_bit_rol_pos_fmmu_read_bit_mask;     /* mask for combined rol-and command,                                                    */
	                                                                                             /* same as at adr_fmmu_read_bit_mask                                                     */
	unsigned int zero                   : BFW_NX51_fmmu_read_bit_rol_pos_zero;                   /* upper mask bits, always zero                                                          */
} NX51_FMMU_READ_BIT_ROL_POS_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_FMMU_READ_BIT_ROL_POS_BIT_T bf;
} NX51_FMMU_READ_BIT_ROL_POS_T;

/* --------------------------------------------------------------------- */
/* Register fmmu_read_bit_mask */
/* => AND-mask for bitwise read access */
/*    In case of read_allowed==0, mask is set to 0. */
/*    Read access by xPEC at adr_statcfg3 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu_read_bit_mask    0x00000114U
#define Adr_NX51_fmmusm_fmmu_read_bit_mask 0x1018BB14U
#define Adr_NX51_fmmu_read_bit_mask        0x1018BB14U

#define MSK_NX51_fmmu_read_bit_mask_fmmu_read_bit_mask 0x000000ffU
#define SRT_NX51_fmmu_read_bit_mask_fmmu_read_bit_mask 0

/* all used bits of 'NX51_fmmu_read_bit_mask': */
#define MSK_USED_BITS_NX51_fmmu_read_bit_mask 0x000000ffU

enum {
	BFW_NX51_fmmu_read_bit_mask_fmmu_read_bit_mask = 8,  /* [7:0] */
	BFW_NX51_fmmu_read_bit_mask_reserved1          = 24  /* [31:8] */
};

typedef struct NX51_FMMU_READ_BIT_MASK_BIT_Ttag {
	unsigned int fmmu_read_bit_mask : BFW_NX51_fmmu_read_bit_mask_fmmu_read_bit_mask; /* AND mask for bitwise read from RAM to bitstream        */
	                                                                                  /* 1: Bit of UTX-Byte is read from RAM                    */
	                                                                                  /* 0: Bit of UTX-Byte is read from stream (URX)           */
	                                                                                  /* Used in combination with fmmu_read_bit_rol_pos (s.a.). */
	unsigned int reserved1          : BFW_NX51_fmmu_read_bit_mask_reserved1;          /* reserved                                               */
} NX51_FMMU_READ_BIT_MASK_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_FMMU_READ_BIT_MASK_BIT_T bf;
} NX51_FMMU_READ_BIT_MASK_T;

/* --------------------------------------------------------------------- */
/* Register fmmu_write_bit_rol_pos */
/* => Shift and mask value for bitwise write access. */
/*    For direct use with combined rol-and command. */
/*    Read access by xPEC at adr_urtx2 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu_write_bit_rol_pos    0x00000118U
#define Adr_NX51_fmmusm_fmmu_write_bit_rol_pos 0x1018BB18U
#define Adr_NX51_fmmu_write_bit_rol_pos        0x1018BB18U

#define MSK_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_rol      0x0000001fU
#define SRT_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_rol      0
#define MSK_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_maskmode 0x000000e0U
#define SRT_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_maskmode 5
#define MSK_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_mask     0x0000ff00U
#define SRT_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_mask     8
#define MSK_NX51_fmmu_write_bit_rol_pos_zero                    0xffff0000U
#define SRT_NX51_fmmu_write_bit_rol_pos_zero                    16

/* all used bits of 'NX51_fmmu_write_bit_rol_pos': */
#define MSK_USED_BITS_NX51_fmmu_write_bit_rol_pos 0xffffffffU

enum {
	BFW_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_rol      = 5,  /* [4:0] */
	BFW_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_maskmode = 3,  /* [7:5] */
	BFW_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_mask     = 8,  /* [15:8] */
	BFW_NX51_fmmu_write_bit_rol_pos_zero                    = 16  /* [31:16] */
};

typedef struct NX51_FMMU_WRITE_BIT_ROL_POS_BIT_Ttag {
	unsigned int fmmu_write_bit_rol      : BFW_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_rol;      /*   rotate left value for bitwise write from bitstream to RAM.                                                       */
	                                                                                                /*   Rotates byte from URX to correct position for insertion into RAM,                                                */
	                                                                                                /*    num of pos to rotate left = neg. number of pos if rotate right,                                                 */
	                                                                                                /*    values in range (-7..7).                                                                                        */
	                                                                                                /*   For bitwise write from URX to RAM perform:                                                                       */
	                                                                                                /*    rol   R1,       URX.snif, fmmu_write_bit_rol_pos // shift and AND-mask bits from URX-FIFO, dont change URX-FIFO */
	                                                                                                /*    nimp  R2,       [RAMwr]b, fmmu_write_bit_mask    // delete to be changed bits from RAM                          */
	                                                                                                /*    or    R1,       R1,       R2                     // insert bits                                                 */
	                                                                                                /*    mv    UTX,      URX                              // also forward to stream                                      */
	                                                                                                /*    storewait [RAMwr]b, R1                           // write modified val to RAM and wait                          */
	                                                                                                /*                                                                                                                    */
	                                                                                                /*   For bitwise read/write from URX and RAMrd to UTX and RAMwr perform:                                              */
	                                                                                                /*    rol   R1,       URX.snif, fmmu_write_bit_rol_pos // shift and AND-mask bits from URX-FIFO, dont change URX-FIFO */
	                                                                                                /*    nimp  R2,       [RAMwr]b, fmmu_write_bit_mask    // delete to be changed bits from RAM                          */
	                                                                                                /*    rol   R3,       [RAMrd]b, fmmu_read_bit_rol_pos  // shift and AND-mask bits from RAM                            */
	                                                                                                /*    nimp  R4,       URX,      fmmu_read_bit_mask     // delete to be changed bits                                   */
	                                                                                                /*    or    UTX,      R3,       R4                     // insert bits                                                 */
	                                                                                                /*    or    R1,       R1,       R2                     // insert bits                                                 */
	                                                                                                /*    storewait [RAMwr]b, R1                           // write modified val to RAM and wait                          */
	unsigned int fmmu_write_bit_maskmode : BFW_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_maskmode; /* always 3'b010: and-mask-mode with upper mask-bits=0                                                                */
	unsigned int fmmu_write_bit_mask     : BFW_NX51_fmmu_write_bit_rol_pos_fmmu_write_bit_mask;     /* mask for combined rol-and command,                                                                                 */
	                                                                                                /* same as at adr_fmmu_write_bit_mask                                                                                 */
	unsigned int zero                    : BFW_NX51_fmmu_write_bit_rol_pos_zero;                    /* upper mask bits, always zero                                                                                       */
} NX51_FMMU_WRITE_BIT_ROL_POS_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_FMMU_WRITE_BIT_ROL_POS_BIT_T bf;
} NX51_FMMU_WRITE_BIT_ROL_POS_T;

/* --------------------------------------------------------------------- */
/* Register fmmu_write_bit_mask */
/* => AND-mask for bitwise write access */
/*    In case of write_allowed==0, mask is set to 0. */
/*    Read access by xPEC at adr_urtx3 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmu_write_bit_mask    0x0000011CU
#define Adr_NX51_fmmusm_fmmu_write_bit_mask 0x1018BB1CU
#define Adr_NX51_fmmu_write_bit_mask        0x1018BB1CU

#define MSK_NX51_fmmu_write_bit_mask_fmmu_write_bit_mask 0x000000ffU
#define SRT_NX51_fmmu_write_bit_mask_fmmu_write_bit_mask 0

/* all used bits of 'NX51_fmmu_write_bit_mask': */
#define MSK_USED_BITS_NX51_fmmu_write_bit_mask 0x000000ffU

enum {
	BFW_NX51_fmmu_write_bit_mask_fmmu_write_bit_mask = 8,  /* [7:0] */
	BFW_NX51_fmmu_write_bit_mask_reserved1           = 24  /* [31:8] */
};

typedef struct NX51_FMMU_WRITE_BIT_MASK_BIT_Ttag {
	unsigned int fmmu_write_bit_mask : BFW_NX51_fmmu_write_bit_mask_fmmu_write_bit_mask; /* AND mask for bitwise write from bitstream to RAM        */
	                                                                                     /* 1: Bit of RAM Byte is written from stream (URX)         */
	                                                                                     /* 0: Bit of RAM Byte is unchanged                         */
	                                                                                     /* Used in combination with fmmu_write_bit_rol_pos (s.a.). */
	unsigned int reserved1           : BFW_NX51_fmmu_write_bit_mask_reserved1;           /* reserved                                                */
} NX51_FMMU_WRITE_BIT_MASK_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_FMMU_WRITE_BIT_MASK_BIT_T bf;
} NX51_FMMU_WRITE_BIT_MASK_T;

/* --------------------------------------------------------------------- */
/* Register fmmusm_len_en */
/* => Logical address enable from EtherCAT command */
/*    Read/Write access by xPEC at adr_xpec_sr8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmusm_len_en    0x00000120U
#define Adr_NX51_fmmusm_fmmusm_len_en 0x1018BB20U
#define Adr_NX51_fmmusm_len_en        0x1018BB20U
#define DFLT_VAL_NX51_fmmusm_len_en   0x00000000U

#define MSK_NX51_fmmusm_len_en_ecat_len            0x0000ffffU
#define SRT_NX51_fmmusm_len_en_ecat_len            0
#define DFLT_VAL_NX51_fmmusm_len_en_ecat_len       0x00000000U
#define DFLT_BF_VAL_NX51_fmmusm_len_en_ecat_len    0x00000000U
#define MSK_NX51_fmmusm_len_en_log_addr_en         0x00010000U
#define SRT_NX51_fmmusm_len_en_log_addr_en         16
#define DFLT_VAL_NX51_fmmusm_len_en_log_addr_en    0x00000000U
#define DFLT_BF_VAL_NX51_fmmusm_len_en_log_addr_en 0x00000000U
#define MSK_NX51_fmmusm_len_en_rd_en               0x00020000U
#define SRT_NX51_fmmusm_len_en_rd_en               17
#define DFLT_VAL_NX51_fmmusm_len_en_rd_en          0x00000000U
#define DFLT_BF_VAL_NX51_fmmusm_len_en_rd_en       0x00000000U
#define MSK_NX51_fmmusm_len_en_wr_en               0x00040000U
#define SRT_NX51_fmmusm_len_en_wr_en               18
#define DFLT_VAL_NX51_fmmusm_len_en_wr_en          0x00000000U
#define DFLT_BF_VAL_NX51_fmmusm_len_en_wr_en       0x00000000U

/* all used bits of 'NX51_fmmusm_len_en': */
#define MSK_USED_BITS_NX51_fmmusm_len_en 0x0007ffffU

enum {
	BFW_NX51_fmmusm_len_en_ecat_len    = 16, /* [15:0] */
	BFW_NX51_fmmusm_len_en_log_addr_en = 1,  /* [16] */
	BFW_NX51_fmmusm_len_en_rd_en       = 1,  /* [17] */
	BFW_NX51_fmmusm_len_en_wr_en       = 1,  /* [18] */
	BFW_NX51_fmmusm_len_en_reserved1   = 13  /* [31:19] */
};

typedef struct NX51_FMMUSM_LEN_EN_BIT_Ttag {
	unsigned int ecat_len    : BFW_NX51_fmmusm_len_en_ecat_len;    /* Length of EtherCAT telegram:                                                         */
	                                                               /* If UTX_COUNT == ecat_len                                                             */
	                                                               /* an event is generated (ecat_fin),                                                    */
	                                                               /* and furthermore calculations are blocked (allowed=0).                                */
	unsigned int log_addr_en : BFW_NX51_fmmusm_len_en_log_addr_en; /* Logical address enable                                                               */
	                                                               /* 1: fmmusm_read_addr_in and fmmusm_write_addr_in are logical addresses                */
	                                                               /* 0: fmmusm_read_addr_in and fmmusm_write_addr_in are physical addresses (bypass fmmu) */
	unsigned int rd_en       : BFW_NX51_fmmusm_len_en_rd_en;       /* 1/0: check/no_check for read direction                                               */
	unsigned int wr_en       : BFW_NX51_fmmusm_len_en_wr_en;       /* 1/0: check/no_check for write direction                                              */
	unsigned int reserved1   : BFW_NX51_fmmusm_len_en_reserved1;   /* reserved                                                                             */
} NX51_FMMUSM_LEN_EN_BIT_T;

typedef union {
	unsigned int             val;
	NX51_FMMUSM_LEN_EN_BIT_T bf;
} NX51_FMMUSM_LEN_EN_T;

/* --------------------------------------------------------------------- */
/* Register fmmusm_status_out */
/* => FMMU and SM match status: */
/*    Flags [31,30] are connected to event controller. */
/*    Read access by xPEC at adr_xpec_sr9 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fmmusm_status_out    0x00000124U
#define Adr_NX51_fmmusm_fmmusm_status_out 0x1018BB24U
#define Adr_NX51_fmmusm_status_out        0x1018BB24U

#define MSK_NX51_fmmusm_status_out_read_sm_nr               0x00000007U
#define SRT_NX51_fmmusm_status_out_read_sm_nr               0
#define MSK_NX51_fmmusm_status_out_read_sm_no_match         0x00000008U
#define SRT_NX51_fmmusm_status_out_read_sm_no_match         3
#define MSK_NX51_fmmusm_status_out_read_sm_fba              0x00000010U
#define SRT_NX51_fmmusm_status_out_read_sm_fba              4
#define MSK_NX51_fmmusm_status_out_read_sm_lba              0x00000020U
#define SRT_NX51_fmmusm_status_out_read_sm_lba              5
#define MSK_NX51_fmmusm_status_out_read_allowed             0x00000040U
#define SRT_NX51_fmmusm_status_out_read_allowed             6
#define MSK_NX51_fmmusm_status_out_read_allowed_bitwise     0x00000080U
#define SRT_NX51_fmmusm_status_out_read_allowed_bitwise     7
#define MSK_NX51_fmmusm_status_out_write_sm_nr              0x00000700U
#define SRT_NX51_fmmusm_status_out_write_sm_nr              8
#define MSK_NX51_fmmusm_status_out_write_sm_no_match        0x00000800U
#define SRT_NX51_fmmusm_status_out_write_sm_no_match        11
#define MSK_NX51_fmmusm_status_out_write_sm_fba             0x00001000U
#define SRT_NX51_fmmusm_status_out_write_sm_fba             12
#define MSK_NX51_fmmusm_status_out_write_sm_lba             0x00002000U
#define SRT_NX51_fmmusm_status_out_write_sm_lba             13
#define MSK_NX51_fmmusm_status_out_write_allowed            0x00004000U
#define SRT_NX51_fmmusm_status_out_write_allowed            14
#define MSK_NX51_fmmusm_status_out_write_allowed_bitwise    0x00008000U
#define SRT_NX51_fmmusm_status_out_write_allowed_bitwise    15
#define MSK_NX51_fmmusm_status_out_read_fmmu_match_nr       0x00070000U
#define SRT_NX51_fmmusm_status_out_read_fmmu_match_nr       16
#define MSK_NX51_fmmusm_status_out_read_fmmu_no_match       0x00080000U
#define SRT_NX51_fmmusm_status_out_read_fmmu_no_match       19
#define MSK_NX51_fmmusm_status_out_write_fmmu_match_nr      0x00700000U
#define SRT_NX51_fmmusm_status_out_write_fmmu_match_nr      20
#define MSK_NX51_fmmusm_status_out_write_fmmu_no_match      0x00800000U
#define SRT_NX51_fmmusm_status_out_write_fmmu_no_match      23
#define MSK_NX51_fmmusm_status_out_read_fmmu_match_bitwise  0x01000000U
#define SRT_NX51_fmmusm_status_out_read_fmmu_match_bitwise  24
#define MSK_NX51_fmmusm_status_out_write_fmmu_match_bitwise 0x02000000U
#define SRT_NX51_fmmusm_status_out_write_fmmu_match_bitwise 25
#define MSK_NX51_fmmusm_status_out_allowed_bitwise          0x20000000U
#define SRT_NX51_fmmusm_status_out_allowed_bitwise          29
#define MSK_NX51_fmmusm_status_out_allowed                  0x40000000U
#define SRT_NX51_fmmusm_status_out_allowed                  30
#define MSK_NX51_fmmusm_status_out_ecat_fin                 0x80000000U
#define SRT_NX51_fmmusm_status_out_ecat_fin                 31

/* all used bits of 'NX51_fmmusm_status_out': */
#define MSK_USED_BITS_NX51_fmmusm_status_out 0xe3ffffffU

enum {
	BFW_NX51_fmmusm_status_out_read_sm_nr               = 3, /* [2:0] */
	BFW_NX51_fmmusm_status_out_read_sm_no_match         = 1, /* [3] */
	BFW_NX51_fmmusm_status_out_read_sm_fba              = 1, /* [4] */
	BFW_NX51_fmmusm_status_out_read_sm_lba              = 1, /* [5] */
	BFW_NX51_fmmusm_status_out_read_allowed             = 1, /* [6] */
	BFW_NX51_fmmusm_status_out_read_allowed_bitwise     = 1, /* [7] */
	BFW_NX51_fmmusm_status_out_write_sm_nr              = 3, /* [10:8] */
	BFW_NX51_fmmusm_status_out_write_sm_no_match        = 1, /* [11] */
	BFW_NX51_fmmusm_status_out_write_sm_fba             = 1, /* [12] */
	BFW_NX51_fmmusm_status_out_write_sm_lba             = 1, /* [13] */
	BFW_NX51_fmmusm_status_out_write_allowed            = 1, /* [14] */
	BFW_NX51_fmmusm_status_out_write_allowed_bitwise    = 1, /* [15] */
	BFW_NX51_fmmusm_status_out_read_fmmu_match_nr       = 3, /* [18:16] */
	BFW_NX51_fmmusm_status_out_read_fmmu_no_match       = 1, /* [19] */
	BFW_NX51_fmmusm_status_out_write_fmmu_match_nr      = 3, /* [22:20] */
	BFW_NX51_fmmusm_status_out_write_fmmu_no_match      = 1, /* [23] */
	BFW_NX51_fmmusm_status_out_read_fmmu_match_bitwise  = 1, /* [24] */
	BFW_NX51_fmmusm_status_out_write_fmmu_match_bitwise = 1, /* [25] */
	BFW_NX51_fmmusm_status_out_reserved1                = 3, /* [28:26] */
	BFW_NX51_fmmusm_status_out_allowed_bitwise          = 1, /* [29] */
	BFW_NX51_fmmusm_status_out_allowed                  = 1, /* [30] */
	BFW_NX51_fmmusm_status_out_ecat_fin                 = 1  /* [31] */
};

typedef struct NX51_FMMUSM_STATUS_OUT_BIT_Ttag {
	unsigned int read_sm_nr               : BFW_NX51_fmmusm_status_out_read_sm_nr;               /* Number of actual matching sync manager for read access (0..7), independent on %read_allowed%      */
	unsigned int read_sm_no_match         : BFW_NX51_fmmusm_status_out_read_sm_no_match;         /* 1: No sync manager matches for reading -> direct access into xPEC Memory (register or data area). */
	                                                                                             /*    Read access is allowed, if last_phys_data_addr is not exceeded.                                */
	                                                                                             /* 0: Any sync manager matches for reading:                                                          */
	                                                                                             /*    Read access is allowed, depending on diversse enables, buf_method, fba, lba,...                */
	unsigned int read_sm_fba              : BFW_NX51_fmmusm_status_out_read_sm_fba;              /* Actual Sync Manager (read_sm_nr) matches on first byte, only valid if read_allowed==1             */
	unsigned int read_sm_lba              : BFW_NX51_fmmusm_status_out_read_sm_lba;              /* Actual Sync Manager (read_sm_nr) matches on last byte, only valid if read_allowed==1              */
	unsigned int read_allowed             : BFW_NX51_fmmusm_status_out_read_allowed;             /* 1/0: xPEC memory address %sm_read_addr_out% is released/ locked for reading                       */
	unsigned int read_allowed_bitwise     : BFW_NX51_fmmusm_status_out_read_allowed_bitwise;     /* 1/0: read access type is bitwise/bytewise, only valid if %read_allowed%==1                        */
	unsigned int write_sm_nr              : BFW_NX51_fmmusm_status_out_write_sm_nr;              /* Number of actual matching sync manager for write access (0..7), independent on %write_allowed%    */
	unsigned int write_sm_no_match        : BFW_NX51_fmmusm_status_out_write_sm_no_match;        /* 1: No sync manager matches for writing -> direct access into xPEC Memory (register or data area). */
	                                                                                             /*    Write access is allowed, if last_phys_data_addr is not exceeded.                               */
	                                                                                             /* 0: Any sync manager matches for Writing:                                                          */
	                                                                                             /*    Write access is allowed, depending on diversse enables, buf_method, fba, lba,...               */
	unsigned int write_sm_fba             : BFW_NX51_fmmusm_status_out_write_sm_fba;             /* Actual Sync Manager (write_sm_nr) matches on first byte, only valid if write_allowed==1           */
	unsigned int write_sm_lba             : BFW_NX51_fmmusm_status_out_write_sm_lba;             /* Actual Sync Manager (write_sm_nr) matches on last byte, only valid if write_allowed==1            */
	unsigned int write_allowed            : BFW_NX51_fmmusm_status_out_write_allowed;            /* 1/0: xPEC memory address %sm_write_addr_out% is released/ locked for writing                      */
	unsigned int write_allowed_bitwise    : BFW_NX51_fmmusm_status_out_write_allowed_bitwise;    /* 1/0: write access type is bitwise/bytewise, only valid if %write_allowed%==1                      */
	unsigned int read_fmmu_match_nr       : BFW_NX51_fmmusm_status_out_read_fmmu_match_nr;       /* Number of actual matching fmmu manager for read access (0..7)                                     */
	                                                                                             /* ----------------------------------------------------------------------                            */
	unsigned int read_fmmu_no_match       : BFW_NX51_fmmusm_status_out_read_fmmu_no_match;       /* 1: no fmmu read match, read address translation failed, read_fmmu_match_nr is invalid             */
	unsigned int write_fmmu_match_nr      : BFW_NX51_fmmusm_status_out_write_fmmu_match_nr;      /* Number of actual matching fmmu manager for write access (0..7), write_fmmu_match_nr is invalid    */
	unsigned int write_fmmu_no_match      : BFW_NX51_fmmusm_status_out_write_fmmu_no_match;      /* 1: no fmmu write match, write address translation failed, write_fmmu_match_nr is invalid          */
	unsigned int read_fmmu_match_bitwise  : BFW_NX51_fmmusm_status_out_read_fmmu_match_bitwise;  /* 1: fmmu bitwise read match, read address translation successful, read access is bitwise           */
	unsigned int write_fmmu_match_bitwise : BFW_NX51_fmmusm_status_out_write_fmmu_match_bitwise; /* 1: fmmu bitwise write match, write address translation successful, write access is bitwise        */
	unsigned int reserved1                : BFW_NX51_fmmusm_status_out_reserved1;                /* reserved                                                                                          */
	unsigned int allowed_bitwise          : BFW_NX51_fmmusm_status_out_allowed_bitwise;          /* Read or write bitwise allowed                                                                     */
	                                                                                             /* ----------------------------------------------------------------------                            */
	unsigned int allowed                  : BFW_NX51_fmmusm_status_out_allowed;                  /* Read or write allowed, bitwise or bytewise                                                        */
	unsigned int ecat_fin                 : BFW_NX51_fmmusm_status_out_ecat_fin;                 /* EtherCAT telegram is finished (utx_count == fmmusm_len_en.ecat_len)                               */
} NX51_FMMUSM_STATUS_OUT_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_FMMUSM_STATUS_OUT_BIT_T bf;
} NX51_FMMUSM_STATUS_OUT_T;

/* --------------------------------------------------------------------- */
/* Register sm_buf_statcfg */
/* => Config bits set by xPEC, if any 3-buffer-SM gets new buffer. */
/*    Writable in parallel with mask by all xPECs, ARM and BUF_MAN. */
/*    Read/Write access by xPEC at adr_xpec_sr10 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_buf_statcfg    0x00000128U
#define Adr_NX51_fmmusm_sm_buf_statcfg 0x1018BB28U
#define Adr_NX51_sm_buf_statcfg        0x1018BB28U
#define DFLT_VAL_NX51_sm_buf_statcfg   0x00ffff00U

#define MSK_NX51_sm_buf_statcfg_buf_full_0         0x00000001U
#define SRT_NX51_sm_buf_statcfg_buf_full_0         0
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_0    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_0 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_full_1         0x00000002U
#define SRT_NX51_sm_buf_statcfg_buf_full_1         1
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_1    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_1 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_full_2         0x00000004U
#define SRT_NX51_sm_buf_statcfg_buf_full_2         2
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_2    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_2 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_full_3         0x00000008U
#define SRT_NX51_sm_buf_statcfg_buf_full_3         3
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_3    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_3 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_full_4         0x00000010U
#define SRT_NX51_sm_buf_statcfg_buf_full_4         4
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_4    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_4 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_full_5         0x00000020U
#define SRT_NX51_sm_buf_statcfg_buf_full_5         5
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_5    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_5 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_full_6         0x00000040U
#define SRT_NX51_sm_buf_statcfg_buf_full_6         6
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_6    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_6 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_full_7         0x00000080U
#define SRT_NX51_sm_buf_statcfg_buf_full_7         7
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_full_7    0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_full_7 0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_nr_0           0x00000300U
#define SRT_NX51_sm_buf_statcfg_buf_nr_0           8
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_0      0x00000300U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_0   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_nr_1           0x00000c00U
#define SRT_NX51_sm_buf_statcfg_buf_nr_1           10
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_1      0x00000c00U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_1   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_nr_2           0x00003000U
#define SRT_NX51_sm_buf_statcfg_buf_nr_2           12
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_2      0x00003000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_2   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_nr_3           0x0000c000U
#define SRT_NX51_sm_buf_statcfg_buf_nr_3           14
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_3      0x0000c000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_3   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_nr_4           0x00030000U
#define SRT_NX51_sm_buf_statcfg_buf_nr_4           16
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_4      0x00030000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_4   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_nr_5           0x000c0000U
#define SRT_NX51_sm_buf_statcfg_buf_nr_5           18
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_5      0x000c0000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_5   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_nr_6           0x00300000U
#define SRT_NX51_sm_buf_statcfg_buf_nr_6           20
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_6      0x00300000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_6   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_nr_7           0x00c00000U
#define SRT_NX51_sm_buf_statcfg_buf_nr_7           22
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_nr_7      0x00c00000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_nr_7   0x00000003U
#define MSK_NX51_sm_buf_statcfg_buf_mask0          0x01000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask0          24
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask0     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask0  0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_mask1          0x02000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask1          25
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask1     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask1  0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_mask2          0x04000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask2          26
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask2     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask2  0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_mask3          0x08000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask3          27
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask3     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask3  0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_mask4          0x10000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask4          28
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask4     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask4  0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_mask5          0x20000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask5          29
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask5     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask5  0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_mask6          0x40000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask6          30
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask6     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask6  0x00000000U
#define MSK_NX51_sm_buf_statcfg_buf_mask7          0x80000000U
#define SRT_NX51_sm_buf_statcfg_buf_mask7          31
#define DFLT_VAL_NX51_sm_buf_statcfg_buf_mask7     0x00000000U
#define DFLT_BF_VAL_NX51_sm_buf_statcfg_buf_mask7  0x00000000U

/* all used bits of 'NX51_sm_buf_statcfg': */
#define MSK_USED_BITS_NX51_sm_buf_statcfg 0xffffffffU

enum {
	BFW_NX51_sm_buf_statcfg_buf_full_0 = 1, /* [0] */
	BFW_NX51_sm_buf_statcfg_buf_full_1 = 1, /* [1] */
	BFW_NX51_sm_buf_statcfg_buf_full_2 = 1, /* [2] */
	BFW_NX51_sm_buf_statcfg_buf_full_3 = 1, /* [3] */
	BFW_NX51_sm_buf_statcfg_buf_full_4 = 1, /* [4] */
	BFW_NX51_sm_buf_statcfg_buf_full_5 = 1, /* [5] */
	BFW_NX51_sm_buf_statcfg_buf_full_6 = 1, /* [6] */
	BFW_NX51_sm_buf_statcfg_buf_full_7 = 1, /* [7] */
	BFW_NX51_sm_buf_statcfg_buf_nr_0   = 2, /* [9:8] */
	BFW_NX51_sm_buf_statcfg_buf_nr_1   = 2, /* [11:10] */
	BFW_NX51_sm_buf_statcfg_buf_nr_2   = 2, /* [13:12] */
	BFW_NX51_sm_buf_statcfg_buf_nr_3   = 2, /* [15:14] */
	BFW_NX51_sm_buf_statcfg_buf_nr_4   = 2, /* [17:16] */
	BFW_NX51_sm_buf_statcfg_buf_nr_5   = 2, /* [19:18] */
	BFW_NX51_sm_buf_statcfg_buf_nr_6   = 2, /* [21:20] */
	BFW_NX51_sm_buf_statcfg_buf_nr_7   = 2, /* [23:22] */
	BFW_NX51_sm_buf_statcfg_buf_mask0  = 1, /* [24] */
	BFW_NX51_sm_buf_statcfg_buf_mask1  = 1, /* [25] */
	BFW_NX51_sm_buf_statcfg_buf_mask2  = 1, /* [26] */
	BFW_NX51_sm_buf_statcfg_buf_mask3  = 1, /* [27] */
	BFW_NX51_sm_buf_statcfg_buf_mask4  = 1, /* [28] */
	BFW_NX51_sm_buf_statcfg_buf_mask5  = 1, /* [29] */
	BFW_NX51_sm_buf_statcfg_buf_mask6  = 1, /* [30] */
	BFW_NX51_sm_buf_statcfg_buf_mask7  = 1  /* [31] */
};

typedef struct NX51_SM_BUF_STATCFG_BIT_Ttag {
	unsigned int buf_full_0 : BFW_NX51_sm_buf_statcfg_buf_full_0; /* Buffer of SM0 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_full_1 : BFW_NX51_sm_buf_statcfg_buf_full_1; /* Buffer of SM1 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_full_2 : BFW_NX51_sm_buf_statcfg_buf_full_2; /* Buffer of SM2 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_full_3 : BFW_NX51_sm_buf_statcfg_buf_full_3; /* Buffer of SM3 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_full_4 : BFW_NX51_sm_buf_statcfg_buf_full_4; /* Buffer of SM4 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_full_5 : BFW_NX51_sm_buf_statcfg_buf_full_5; /* Buffer of SM5 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_full_6 : BFW_NX51_sm_buf_statcfg_buf_full_6; /* Buffer of SM6 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_full_7 : BFW_NX51_sm_buf_statcfg_buf_full_7; /* Buffer of SM7 in use by xPEC is full, if 1 buffer method is activated.     */
	unsigned int buf_nr_0   : BFW_NX51_sm_buf_statcfg_buf_nr_0;   /* Buffer number in use by xPEC of SM0, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_nr_1   : BFW_NX51_sm_buf_statcfg_buf_nr_1;   /* Buffer number in use by xPEC of SM1, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_nr_2   : BFW_NX51_sm_buf_statcfg_buf_nr_2;   /* Buffer number in use by xPEC of SM2, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_nr_3   : BFW_NX51_sm_buf_statcfg_buf_nr_3;   /* Buffer number in use by xPEC of SM3, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_nr_4   : BFW_NX51_sm_buf_statcfg_buf_nr_4;   /* Buffer number in use by xPEC of SM4, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_nr_5   : BFW_NX51_sm_buf_statcfg_buf_nr_5;   /* Buffer number in use by xPEC of SM5, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_nr_6   : BFW_NX51_sm_buf_statcfg_buf_nr_6;   /* Buffer number in use by xPEC of SM6, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_nr_7   : BFW_NX51_sm_buf_statcfg_buf_nr_7;   /* Buffer number in use by xPEC of SM7, if 3 buffer method is activated.      */
	                                                              /* Usually set by BUF_MAN (not by software).                                  */
	unsigned int buf_mask0  : BFW_NX51_sm_buf_statcfg_buf_mask0;  /* Write mask: change only bits of SM0:                                       */
	                                                              /* Depending on sm0_cfg_mode.buf_method, mask acts on buf_nr_0 or buf_full_0. */
	unsigned int buf_mask1  : BFW_NX51_sm_buf_statcfg_buf_mask1;  /* Write mask: change only bits of SM1:                                       */
	                                                              /* Depending on sm1_cfg_mode.buf_method, mask acts on buf_nr_1 or buf_full_1. */
	unsigned int buf_mask2  : BFW_NX51_sm_buf_statcfg_buf_mask2;  /* Write mask: change only bits of SM2:                                       */
	                                                              /* Depending on sm2_cfg_mode.buf_method, mask acts on buf_nr_2 or buf_full_2. */
	unsigned int buf_mask3  : BFW_NX51_sm_buf_statcfg_buf_mask3;  /* Write mask: change only bits of SM3:                                       */
	                                                              /* Depending on sm3_cfg_mode.buf_method, mask acts on buf_nr_3 or buf_full_3. */
	unsigned int buf_mask4  : BFW_NX51_sm_buf_statcfg_buf_mask4;  /* Write mask: change only bits of SM4:                                       */
	                                                              /* Depending on sm4_cfg_mode.buf_method, mask acts on buf_nr_4 or buf_full_4. */
	unsigned int buf_mask5  : BFW_NX51_sm_buf_statcfg_buf_mask5;  /* Write mask: change only bits of SM5:                                       */
	                                                              /* Depending on sm5_cfg_mode.buf_method, mask acts on buf_nr_5 or buf_full_5. */
	unsigned int buf_mask6  : BFW_NX51_sm_buf_statcfg_buf_mask6;  /* Write mask: change only bits of SM6:                                       */
	                                                              /* Depending on sm6_cfg_mode.buf_method, mask acts on buf_nr_6 or buf_full_6. */
	unsigned int buf_mask7  : BFW_NX51_sm_buf_statcfg_buf_mask7;  /* Write mask: change only bits of SM7:                                       */
	                                                              /* Depending on sm7_cfg_mode.buf_method, mask acts on buf_nr_7 or buf_full_7. */
} NX51_SM_BUF_STATCFG_BIT_T;

typedef union {
	unsigned int              val;
	NX51_SM_BUF_STATCFG_BIT_T bf;
} NX51_SM_BUF_STATCFG_T;

/* --------------------------------------------------------------------- */
/* Register sm_read_event */
/* => Read Event status bits of all SM, process channel: */
/*    Writable in parallel with mask by all xPECs and ARM. */
/*    Reset by FMMUSM at first_byte_addressed and write_allowed. */
/*    Read/Write access by xPEC at adr_xpec_sr11 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_read_event    0x0000012CU
#define Adr_NX51_fmmusm_sm_read_event 0x1018BB2CU
#define Adr_NX51_sm_read_event        0x1018BB2CU
#define DFLT_VAL_NX51_sm_read_event   0x00000000U

#define MSK_NX51_sm_read_event_read_event_0             0x00000001U
#define SRT_NX51_sm_read_event_read_event_0             0
#define DFLT_VAL_NX51_sm_read_event_read_event_0        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_0     0x00000000U
#define MSK_NX51_sm_read_event_read_event_1             0x00000002U
#define SRT_NX51_sm_read_event_read_event_1             1
#define DFLT_VAL_NX51_sm_read_event_read_event_1        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_1     0x00000000U
#define MSK_NX51_sm_read_event_read_event_2             0x00000004U
#define SRT_NX51_sm_read_event_read_event_2             2
#define DFLT_VAL_NX51_sm_read_event_read_event_2        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_2     0x00000000U
#define MSK_NX51_sm_read_event_read_event_3             0x00000008U
#define SRT_NX51_sm_read_event_read_event_3             3
#define DFLT_VAL_NX51_sm_read_event_read_event_3        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_3     0x00000000U
#define MSK_NX51_sm_read_event_read_event_4             0x00000010U
#define SRT_NX51_sm_read_event_read_event_4             4
#define DFLT_VAL_NX51_sm_read_event_read_event_4        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_4     0x00000000U
#define MSK_NX51_sm_read_event_read_event_5             0x00000020U
#define SRT_NX51_sm_read_event_read_event_5             5
#define DFLT_VAL_NX51_sm_read_event_read_event_5        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_5     0x00000000U
#define MSK_NX51_sm_read_event_read_event_6             0x00000040U
#define SRT_NX51_sm_read_event_read_event_6             6
#define DFLT_VAL_NX51_sm_read_event_read_event_6        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_6     0x00000000U
#define MSK_NX51_sm_read_event_read_event_7             0x00000080U
#define SRT_NX51_sm_read_event_read_event_7             7
#define DFLT_VAL_NX51_sm_read_event_read_event_7        0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_7     0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask0         0x00010000U
#define SRT_NX51_sm_read_event_read_event_mask0         16
#define DFLT_VAL_NX51_sm_read_event_read_event_mask0    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask0 0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask1         0x00020000U
#define SRT_NX51_sm_read_event_read_event_mask1         17
#define DFLT_VAL_NX51_sm_read_event_read_event_mask1    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask1 0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask2         0x00040000U
#define SRT_NX51_sm_read_event_read_event_mask2         18
#define DFLT_VAL_NX51_sm_read_event_read_event_mask2    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask2 0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask3         0x00080000U
#define SRT_NX51_sm_read_event_read_event_mask3         19
#define DFLT_VAL_NX51_sm_read_event_read_event_mask3    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask3 0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask4         0x00100000U
#define SRT_NX51_sm_read_event_read_event_mask4         20
#define DFLT_VAL_NX51_sm_read_event_read_event_mask4    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask4 0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask5         0x00200000U
#define SRT_NX51_sm_read_event_read_event_mask5         21
#define DFLT_VAL_NX51_sm_read_event_read_event_mask5    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask5 0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask6         0x00400000U
#define SRT_NX51_sm_read_event_read_event_mask6         22
#define DFLT_VAL_NX51_sm_read_event_read_event_mask6    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask6 0x00000000U
#define MSK_NX51_sm_read_event_read_event_mask7         0x00800000U
#define SRT_NX51_sm_read_event_read_event_mask7         23
#define DFLT_VAL_NX51_sm_read_event_read_event_mask7    0x00000000U
#define DFLT_BF_VAL_NX51_sm_read_event_read_event_mask7 0x00000000U

/* all used bits of 'NX51_sm_read_event': */
#define MSK_USED_BITS_NX51_sm_read_event 0x00ff00ffU

enum {
	BFW_NX51_sm_read_event_read_event_0     = 1, /* [0] */
	BFW_NX51_sm_read_event_read_event_1     = 1, /* [1] */
	BFW_NX51_sm_read_event_read_event_2     = 1, /* [2] */
	BFW_NX51_sm_read_event_read_event_3     = 1, /* [3] */
	BFW_NX51_sm_read_event_read_event_4     = 1, /* [4] */
	BFW_NX51_sm_read_event_read_event_5     = 1, /* [5] */
	BFW_NX51_sm_read_event_read_event_6     = 1, /* [6] */
	BFW_NX51_sm_read_event_read_event_7     = 1, /* [7] */
	BFW_NX51_sm_read_event_reserved1        = 8, /* [15:8] */
	BFW_NX51_sm_read_event_read_event_mask0 = 1, /* [16] */
	BFW_NX51_sm_read_event_read_event_mask1 = 1, /* [17] */
	BFW_NX51_sm_read_event_read_event_mask2 = 1, /* [18] */
	BFW_NX51_sm_read_event_read_event_mask3 = 1, /* [19] */
	BFW_NX51_sm_read_event_read_event_mask4 = 1, /* [20] */
	BFW_NX51_sm_read_event_read_event_mask5 = 1, /* [21] */
	BFW_NX51_sm_read_event_read_event_mask6 = 1, /* [22] */
	BFW_NX51_sm_read_event_read_event_mask7 = 1, /* [23] */
	BFW_NX51_sm_read_event_reserved2        = 8  /* [31:24] */
};

typedef struct NX51_SM_READ_EVENT_BIT_Ttag {
	unsigned int read_event_0     : BFW_NX51_sm_read_event_read_event_0;     /* SM0 read event                     */
	unsigned int read_event_1     : BFW_NX51_sm_read_event_read_event_1;     /* SM1 read event                     */
	unsigned int read_event_2     : BFW_NX51_sm_read_event_read_event_2;     /* SM2 read event                     */
	unsigned int read_event_3     : BFW_NX51_sm_read_event_read_event_3;     /* SM3 read event                     */
	unsigned int read_event_4     : BFW_NX51_sm_read_event_read_event_4;     /* SM4 read event                     */
	unsigned int read_event_5     : BFW_NX51_sm_read_event_read_event_5;     /* SM5 read event                     */
	unsigned int read_event_6     : BFW_NX51_sm_read_event_read_event_6;     /* SM6 read event                     */
	unsigned int read_event_7     : BFW_NX51_sm_read_event_read_event_7;     /* SM7 read event                     */
	unsigned int reserved1        : BFW_NX51_sm_read_event_reserved1;        /* reserved                           */
	unsigned int read_event_mask0 : BFW_NX51_sm_read_event_read_event_mask0; /* write mask: change only bit of SM0 */
	unsigned int read_event_mask1 : BFW_NX51_sm_read_event_read_event_mask1; /* write mask: change only bit of SM1 */
	unsigned int read_event_mask2 : BFW_NX51_sm_read_event_read_event_mask2; /* write mask: change only bit of SM2 */
	unsigned int read_event_mask3 : BFW_NX51_sm_read_event_read_event_mask3; /* write mask: change only bit of SM3 */
	unsigned int read_event_mask4 : BFW_NX51_sm_read_event_read_event_mask4; /* write mask: change only bit of SM4 */
	unsigned int read_event_mask5 : BFW_NX51_sm_read_event_read_event_mask5; /* write mask: change only bit of SM5 */
	unsigned int read_event_mask6 : BFW_NX51_sm_read_event_read_event_mask6; /* write mask: change only bit of SM6 */
	unsigned int read_event_mask7 : BFW_NX51_sm_read_event_read_event_mask7; /* write mask: change only bit of SM7 */
	unsigned int reserved2        : BFW_NX51_sm_read_event_reserved2;        /* reserved                           */
} NX51_SM_READ_EVENT_BIT_T;

typedef union {
	unsigned int             val;
	NX51_SM_READ_EVENT_BIT_T bf;
} NX51_SM_READ_EVENT_T;

/* --------------------------------------------------------------------- */
/* Register sm_write_event */
/* => Write Event status bits of all SM, process channel */
/*    Writable in parallel with mask by all xPECs and ARM. */
/*    Reset by FMMUSM at first_byte_addressed and read_allowed. */
/*    Read/Write access by xPEC at adr_xpec_sr12 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_write_event    0x00000130U
#define Adr_NX51_fmmusm_sm_write_event 0x1018BB30U
#define Adr_NX51_sm_write_event        0x1018BB30U
#define DFLT_VAL_NX51_sm_write_event   0x00000000U

#define MSK_NX51_sm_write_event_write_event_0             0x00000001U
#define SRT_NX51_sm_write_event_write_event_0             0
#define DFLT_VAL_NX51_sm_write_event_write_event_0        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_0     0x00000000U
#define MSK_NX51_sm_write_event_write_event_1             0x00000002U
#define SRT_NX51_sm_write_event_write_event_1             1
#define DFLT_VAL_NX51_sm_write_event_write_event_1        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_1     0x00000000U
#define MSK_NX51_sm_write_event_write_event_2             0x00000004U
#define SRT_NX51_sm_write_event_write_event_2             2
#define DFLT_VAL_NX51_sm_write_event_write_event_2        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_2     0x00000000U
#define MSK_NX51_sm_write_event_write_event_3             0x00000008U
#define SRT_NX51_sm_write_event_write_event_3             3
#define DFLT_VAL_NX51_sm_write_event_write_event_3        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_3     0x00000000U
#define MSK_NX51_sm_write_event_write_event_4             0x00000010U
#define SRT_NX51_sm_write_event_write_event_4             4
#define DFLT_VAL_NX51_sm_write_event_write_event_4        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_4     0x00000000U
#define MSK_NX51_sm_write_event_write_event_5             0x00000020U
#define SRT_NX51_sm_write_event_write_event_5             5
#define DFLT_VAL_NX51_sm_write_event_write_event_5        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_5     0x00000000U
#define MSK_NX51_sm_write_event_write_event_6             0x00000040U
#define SRT_NX51_sm_write_event_write_event_6             6
#define DFLT_VAL_NX51_sm_write_event_write_event_6        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_6     0x00000000U
#define MSK_NX51_sm_write_event_write_event_7             0x00000080U
#define SRT_NX51_sm_write_event_write_event_7             7
#define DFLT_VAL_NX51_sm_write_event_write_event_7        0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_7     0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask0         0x00010000U
#define SRT_NX51_sm_write_event_write_event_mask0         16
#define DFLT_VAL_NX51_sm_write_event_write_event_mask0    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask0 0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask1         0x00020000U
#define SRT_NX51_sm_write_event_write_event_mask1         17
#define DFLT_VAL_NX51_sm_write_event_write_event_mask1    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask1 0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask2         0x00040000U
#define SRT_NX51_sm_write_event_write_event_mask2         18
#define DFLT_VAL_NX51_sm_write_event_write_event_mask2    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask2 0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask3         0x00080000U
#define SRT_NX51_sm_write_event_write_event_mask3         19
#define DFLT_VAL_NX51_sm_write_event_write_event_mask3    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask3 0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask4         0x00100000U
#define SRT_NX51_sm_write_event_write_event_mask4         20
#define DFLT_VAL_NX51_sm_write_event_write_event_mask4    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask4 0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask5         0x00200000U
#define SRT_NX51_sm_write_event_write_event_mask5         21
#define DFLT_VAL_NX51_sm_write_event_write_event_mask5    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask5 0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask6         0x00400000U
#define SRT_NX51_sm_write_event_write_event_mask6         22
#define DFLT_VAL_NX51_sm_write_event_write_event_mask6    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask6 0x00000000U
#define MSK_NX51_sm_write_event_write_event_mask7         0x00800000U
#define SRT_NX51_sm_write_event_write_event_mask7         23
#define DFLT_VAL_NX51_sm_write_event_write_event_mask7    0x00000000U
#define DFLT_BF_VAL_NX51_sm_write_event_write_event_mask7 0x00000000U

/* all used bits of 'NX51_sm_write_event': */
#define MSK_USED_BITS_NX51_sm_write_event 0x00ff00ffU

enum {
	BFW_NX51_sm_write_event_write_event_0     = 1, /* [0] */
	BFW_NX51_sm_write_event_write_event_1     = 1, /* [1] */
	BFW_NX51_sm_write_event_write_event_2     = 1, /* [2] */
	BFW_NX51_sm_write_event_write_event_3     = 1, /* [3] */
	BFW_NX51_sm_write_event_write_event_4     = 1, /* [4] */
	BFW_NX51_sm_write_event_write_event_5     = 1, /* [5] */
	BFW_NX51_sm_write_event_write_event_6     = 1, /* [6] */
	BFW_NX51_sm_write_event_write_event_7     = 1, /* [7] */
	BFW_NX51_sm_write_event_reserved1         = 8, /* [15:8] */
	BFW_NX51_sm_write_event_write_event_mask0 = 1, /* [16] */
	BFW_NX51_sm_write_event_write_event_mask1 = 1, /* [17] */
	BFW_NX51_sm_write_event_write_event_mask2 = 1, /* [18] */
	BFW_NX51_sm_write_event_write_event_mask3 = 1, /* [19] */
	BFW_NX51_sm_write_event_write_event_mask4 = 1, /* [20] */
	BFW_NX51_sm_write_event_write_event_mask5 = 1, /* [21] */
	BFW_NX51_sm_write_event_write_event_mask6 = 1, /* [22] */
	BFW_NX51_sm_write_event_write_event_mask7 = 1, /* [23] */
	BFW_NX51_sm_write_event_reserved2         = 8  /* [31:24] */
};

typedef struct NX51_SM_WRITE_EVENT_BIT_Ttag {
	unsigned int write_event_0     : BFW_NX51_sm_write_event_write_event_0;     /* SM0 write event                    */
	unsigned int write_event_1     : BFW_NX51_sm_write_event_write_event_1;     /* SM1 write event                    */
	unsigned int write_event_2     : BFW_NX51_sm_write_event_write_event_2;     /* SM2 write event                    */
	unsigned int write_event_3     : BFW_NX51_sm_write_event_write_event_3;     /* SM3 write event                    */
	unsigned int write_event_4     : BFW_NX51_sm_write_event_write_event_4;     /* SM4 write event                    */
	unsigned int write_event_5     : BFW_NX51_sm_write_event_write_event_5;     /* SM5 write event                    */
	unsigned int write_event_6     : BFW_NX51_sm_write_event_write_event_6;     /* SM6 write event                    */
	unsigned int write_event_7     : BFW_NX51_sm_write_event_write_event_7;     /* SM7 write event                    */
	unsigned int reserved1         : BFW_NX51_sm_write_event_reserved1;         /* reserved                           */
	unsigned int write_event_mask0 : BFW_NX51_sm_write_event_write_event_mask0; /* write mask: change only bit of SM0 */
	unsigned int write_event_mask1 : BFW_NX51_sm_write_event_write_event_mask1; /* write mask: change only bit of SM1 */
	unsigned int write_event_mask2 : BFW_NX51_sm_write_event_write_event_mask2; /* write mask: change only bit of SM2 */
	unsigned int write_event_mask3 : BFW_NX51_sm_write_event_write_event_mask3; /* write mask: change only bit of SM3 */
	unsigned int write_event_mask4 : BFW_NX51_sm_write_event_write_event_mask4; /* write mask: change only bit of SM4 */
	unsigned int write_event_mask5 : BFW_NX51_sm_write_event_write_event_mask5; /* write mask: change only bit of SM5 */
	unsigned int write_event_mask6 : BFW_NX51_sm_write_event_write_event_mask6; /* write mask: change only bit of SM6 */
	unsigned int write_event_mask7 : BFW_NX51_sm_write_event_write_event_mask7; /* write mask: change only bit of SM7 */
	unsigned int reserved2         : BFW_NX51_sm_write_event_reserved2;         /* reserved                           */
} NX51_SM_WRITE_EVENT_BIT_T;

typedef union {
	unsigned int              val;
	NX51_SM_WRITE_EVENT_BIT_T bf;
} NX51_SM_WRITE_EVENT_T;

/* --------------------------------------------------------------------- */
/* Register sm_first_byte_addressed */
/* => First byte addressed status bits of all SM, process channel: */
/*    Set by HW, if first byte was addressed. */
/*    Reset by SW (xPEC or ARM), by writing 1 on appropriate bit (usually after FCSok/fail). */
/*    Resetable in parallel by all xPECs and ARM. */
/*    Bits 31:8 are read only versions of other registers for faster update of register area. */
/*    Read/Write access by xPEC at adr_xpec_sr13 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_first_byte_addressed    0x00000134U
#define Adr_NX51_fmmusm_sm_first_byte_addressed 0x1018BB34U
#define Adr_NX51_sm_first_byte_addressed        0x1018BB34U
#define DFLT_VAL_NX51_sm_first_byte_addressed   0x00000000U

#define MSK_NX51_sm_first_byte_addressed_fba_0                 0x00000001U
#define SRT_NX51_sm_first_byte_addressed_fba_0                 0
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_0            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_0         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_fba_1                 0x00000002U
#define SRT_NX51_sm_first_byte_addressed_fba_1                 1
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_1            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_1         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_fba_2                 0x00000004U
#define SRT_NX51_sm_first_byte_addressed_fba_2                 2
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_2            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_2         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_fba_3                 0x00000008U
#define SRT_NX51_sm_first_byte_addressed_fba_3                 3
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_3            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_3         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_fba_4                 0x00000010U
#define SRT_NX51_sm_first_byte_addressed_fba_4                 4
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_4            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_4         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_fba_5                 0x00000020U
#define SRT_NX51_sm_first_byte_addressed_fba_5                 5
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_5            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_5         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_fba_6                 0x00000040U
#define SRT_NX51_sm_first_byte_addressed_fba_6                 6
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_6            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_6         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_fba_7                 0x00000080U
#define SRT_NX51_sm_first_byte_addressed_fba_7                 7
#define DFLT_VAL_NX51_sm_first_byte_addressed_fba_7            0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_fba_7         0x00000000U
#define MSK_NX51_sm_first_byte_addressed_write_event_0         0x00000100U
#define SRT_NX51_sm_first_byte_addressed_write_event_0         8
#define DFLT_VAL_NX51_sm_first_byte_addressed_write_event_0    0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_write_event_0 0x00000000U
#define MSK_NX51_sm_first_byte_addressed_read_event_0          0x00000200U
#define SRT_NX51_sm_first_byte_addressed_read_event_0          9
#define DFLT_VAL_NX51_sm_first_byte_addressed_read_event_0     0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_read_event_0  0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_full_0            0x00000800U
#define SRT_NX51_sm_first_byte_addressed_buf_full_0            11
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_full_0       0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_full_0    0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_nr_0              0x00003000U
#define SRT_NX51_sm_first_byte_addressed_buf_nr_0              12
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_nr_0         0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_nr_0      0x00000000U
#define MSK_NX51_sm_first_byte_addressed_write_event_1         0x00004000U
#define SRT_NX51_sm_first_byte_addressed_write_event_1         14
#define DFLT_VAL_NX51_sm_first_byte_addressed_write_event_1    0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_write_event_1 0x00000000U
#define MSK_NX51_sm_first_byte_addressed_read_event_1          0x00008000U
#define SRT_NX51_sm_first_byte_addressed_read_event_1          15
#define DFLT_VAL_NX51_sm_first_byte_addressed_read_event_1     0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_read_event_1  0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_full_1            0x00020000U
#define SRT_NX51_sm_first_byte_addressed_buf_full_1            17
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_full_1       0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_full_1    0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_nr_1              0x000c0000U
#define SRT_NX51_sm_first_byte_addressed_buf_nr_1              18
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_nr_1         0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_nr_1      0x00000000U
#define MSK_NX51_sm_first_byte_addressed_write_event_2         0x00100000U
#define SRT_NX51_sm_first_byte_addressed_write_event_2         20
#define DFLT_VAL_NX51_sm_first_byte_addressed_write_event_2    0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_write_event_2 0x00000000U
#define MSK_NX51_sm_first_byte_addressed_read_event_2          0x00200000U
#define SRT_NX51_sm_first_byte_addressed_read_event_2          21
#define DFLT_VAL_NX51_sm_first_byte_addressed_read_event_2     0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_read_event_2  0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_full_2            0x00800000U
#define SRT_NX51_sm_first_byte_addressed_buf_full_2            23
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_full_2       0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_full_2    0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_nr_2              0x03000000U
#define SRT_NX51_sm_first_byte_addressed_buf_nr_2              24
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_nr_2         0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_nr_2      0x00000000U
#define MSK_NX51_sm_first_byte_addressed_write_event_3         0x04000000U
#define SRT_NX51_sm_first_byte_addressed_write_event_3         26
#define DFLT_VAL_NX51_sm_first_byte_addressed_write_event_3    0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_write_event_3 0x00000000U
#define MSK_NX51_sm_first_byte_addressed_read_event_3          0x08000000U
#define SRT_NX51_sm_first_byte_addressed_read_event_3          27
#define DFLT_VAL_NX51_sm_first_byte_addressed_read_event_3     0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_read_event_3  0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_full_3            0x20000000U
#define SRT_NX51_sm_first_byte_addressed_buf_full_3            29
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_full_3       0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_full_3    0x00000000U
#define MSK_NX51_sm_first_byte_addressed_buf_nr_3              0xc0000000U
#define SRT_NX51_sm_first_byte_addressed_buf_nr_3              30
#define DFLT_VAL_NX51_sm_first_byte_addressed_buf_nr_3         0x00000000U
#define DFLT_BF_VAL_NX51_sm_first_byte_addressed_buf_nr_3      0x00000000U

/* all used bits of 'NX51_sm_first_byte_addressed': */
#define MSK_USED_BITS_NX51_sm_first_byte_addressed 0xefbefbffU

enum {
	BFW_NX51_sm_first_byte_addressed_fba_0         = 1, /* [0] */
	BFW_NX51_sm_first_byte_addressed_fba_1         = 1, /* [1] */
	BFW_NX51_sm_first_byte_addressed_fba_2         = 1, /* [2] */
	BFW_NX51_sm_first_byte_addressed_fba_3         = 1, /* [3] */
	BFW_NX51_sm_first_byte_addressed_fba_4         = 1, /* [4] */
	BFW_NX51_sm_first_byte_addressed_fba_5         = 1, /* [5] */
	BFW_NX51_sm_first_byte_addressed_fba_6         = 1, /* [6] */
	BFW_NX51_sm_first_byte_addressed_fba_7         = 1, /* [7] */
	BFW_NX51_sm_first_byte_addressed_write_event_0 = 1, /* [8] */
	BFW_NX51_sm_first_byte_addressed_read_event_0  = 1, /* [9] */
	BFW_NX51_sm_first_byte_addressed_reserved1     = 1, /* [10] */
	BFW_NX51_sm_first_byte_addressed_buf_full_0    = 1, /* [11] */
	BFW_NX51_sm_first_byte_addressed_buf_nr_0      = 2, /* [13:12] */
	BFW_NX51_sm_first_byte_addressed_write_event_1 = 1, /* [14] */
	BFW_NX51_sm_first_byte_addressed_read_event_1  = 1, /* [15] */
	BFW_NX51_sm_first_byte_addressed_reserved2     = 1, /* [16] */
	BFW_NX51_sm_first_byte_addressed_buf_full_1    = 1, /* [17] */
	BFW_NX51_sm_first_byte_addressed_buf_nr_1      = 2, /* [19:18] */
	BFW_NX51_sm_first_byte_addressed_write_event_2 = 1, /* [20] */
	BFW_NX51_sm_first_byte_addressed_read_event_2  = 1, /* [21] */
	BFW_NX51_sm_first_byte_addressed_reserved3     = 1, /* [22] */
	BFW_NX51_sm_first_byte_addressed_buf_full_2    = 1, /* [23] */
	BFW_NX51_sm_first_byte_addressed_buf_nr_2      = 2, /* [25:24] */
	BFW_NX51_sm_first_byte_addressed_write_event_3 = 1, /* [26] */
	BFW_NX51_sm_first_byte_addressed_read_event_3  = 1, /* [27] */
	BFW_NX51_sm_first_byte_addressed_reserved4     = 1, /* [28] */
	BFW_NX51_sm_first_byte_addressed_buf_full_3    = 1, /* [29] */
	BFW_NX51_sm_first_byte_addressed_buf_nr_3      = 2  /* [31:30] */
};

typedef struct NX51_SM_FIRST_BYTE_ADDRESSED_BIT_Ttag {
	unsigned int fba_0         : BFW_NX51_sm_first_byte_addressed_fba_0;         /* SM0 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int fba_1         : BFW_NX51_sm_first_byte_addressed_fba_1;         /* SM1 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int fba_2         : BFW_NX51_sm_first_byte_addressed_fba_2;         /* SM2 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int fba_3         : BFW_NX51_sm_first_byte_addressed_fba_3;         /* SM3 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int fba_4         : BFW_NX51_sm_first_byte_addressed_fba_4;         /* SM4 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int fba_5         : BFW_NX51_sm_first_byte_addressed_fba_5;         /* SM5 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int fba_6         : BFW_NX51_sm_first_byte_addressed_fba_6;         /* SM6 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int fba_7         : BFW_NX51_sm_first_byte_addressed_fba_7;         /* SM7 matches first byte of its address area                        */
	                                                                             /* 0: match only for first address (byte) of SM-address-area (len=1) */
	                                                                             /* 1: match on whole SM-address-area                                 */
	unsigned int write_event_0 : BFW_NX51_sm_first_byte_addressed_write_event_0; /* read only version of sm_write_event.write_event_0                 */
	unsigned int read_event_0  : BFW_NX51_sm_first_byte_addressed_read_event_0;  /* read only version of sm_read_event.read_event_0                   */
	unsigned int reserved1     : BFW_NX51_sm_first_byte_addressed_reserved1;     /* reserved                                                          */
	unsigned int buf_full_0    : BFW_NX51_sm_first_byte_addressed_buf_full_0;    /* read only version of sm_buf_statcfg.buf_full_0                    */
	unsigned int buf_nr_0      : BFW_NX51_sm_first_byte_addressed_buf_nr_0;      /* read only version of sm_buf_statcfg.buf_nr_0                      */
	unsigned int write_event_1 : BFW_NX51_sm_first_byte_addressed_write_event_1; /* read only version of sm_write_event.write_event_1                 */
	unsigned int read_event_1  : BFW_NX51_sm_first_byte_addressed_read_event_1;  /* read only version of sm_read_event.read_event_1                   */
	unsigned int reserved2     : BFW_NX51_sm_first_byte_addressed_reserved2;     /* reserved                                                          */
	unsigned int buf_full_1    : BFW_NX51_sm_first_byte_addressed_buf_full_1;    /* read only version of sm_buf_statcfg.buf_full_1                    */
	unsigned int buf_nr_1      : BFW_NX51_sm_first_byte_addressed_buf_nr_1;      /* read only version of sm_buf_statcfg.buf_nr_1                      */
	unsigned int write_event_2 : BFW_NX51_sm_first_byte_addressed_write_event_2; /* read only version of sm_write_event.write_event_2                 */
	unsigned int read_event_2  : BFW_NX51_sm_first_byte_addressed_read_event_2;  /* read only version of sm_read_event.read_event_2                   */
	unsigned int reserved3     : BFW_NX51_sm_first_byte_addressed_reserved3;     /* reserved                                                          */
	unsigned int buf_full_2    : BFW_NX51_sm_first_byte_addressed_buf_full_2;    /* read only version of sm_buf_statcfg.buf_full_2                    */
	unsigned int buf_nr_2      : BFW_NX51_sm_first_byte_addressed_buf_nr_2;      /* read only version of sm_buf_statcfg.buf_nr_2                      */
	unsigned int write_event_3 : BFW_NX51_sm_first_byte_addressed_write_event_3; /* read only version of sm_write_event.write_event_3                 */
	unsigned int read_event_3  : BFW_NX51_sm_first_byte_addressed_read_event_3;  /* read only version of sm_read_event.read_event_3                   */
	unsigned int reserved4     : BFW_NX51_sm_first_byte_addressed_reserved4;     /* reserved                                                          */
	unsigned int buf_full_3    : BFW_NX51_sm_first_byte_addressed_buf_full_3;    /* read only version of sm_buf_statcfg.buf_full_3                    */
	unsigned int buf_nr_3      : BFW_NX51_sm_first_byte_addressed_buf_nr_3;      /* read only version of sm_buf_statcfg.buf_nr_3                      */
} NX51_SM_FIRST_BYTE_ADDRESSED_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_SM_FIRST_BYTE_ADDRESSED_BIT_T bf;
} NX51_SM_FIRST_BYTE_ADDRESSED_T;

/* --------------------------------------------------------------------- */
/* Register sm_last_byte_addressed */
/* => Last byte addressed status bits of all SM, process channel: */
/*    Set by HW, if last byte was addressed. */
/*    Reset by SW (xPEC or ARM), by writing 1 on appropriate bit (usually after FCSok/fail). */
/*    Resetable in parallel by all xPECs and ARM. */
/*    Bits 31:8 are read only versions of other registers for faster update of register area. */
/*    Read/Write access by xPEC at adr_xpec_sr14 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_last_byte_addressed    0x00000138U
#define Adr_NX51_fmmusm_sm_last_byte_addressed 0x1018BB38U
#define Adr_NX51_sm_last_byte_addressed        0x1018BB38U
#define DFLT_VAL_NX51_sm_last_byte_addressed   0x00000000U

#define MSK_NX51_sm_last_byte_addressed_lba_0                 0x00000001U
#define SRT_NX51_sm_last_byte_addressed_lba_0                 0
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_0            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_0         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_lba_1                 0x00000002U
#define SRT_NX51_sm_last_byte_addressed_lba_1                 1
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_1            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_1         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_lba_2                 0x00000004U
#define SRT_NX51_sm_last_byte_addressed_lba_2                 2
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_2            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_2         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_lba_3                 0x00000008U
#define SRT_NX51_sm_last_byte_addressed_lba_3                 3
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_3            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_3         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_lba_4                 0x00000010U
#define SRT_NX51_sm_last_byte_addressed_lba_4                 4
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_4            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_4         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_lba_5                 0x00000020U
#define SRT_NX51_sm_last_byte_addressed_lba_5                 5
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_5            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_5         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_lba_6                 0x00000040U
#define SRT_NX51_sm_last_byte_addressed_lba_6                 6
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_6            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_6         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_lba_7                 0x00000080U
#define SRT_NX51_sm_last_byte_addressed_lba_7                 7
#define DFLT_VAL_NX51_sm_last_byte_addressed_lba_7            0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_lba_7         0x00000000U
#define MSK_NX51_sm_last_byte_addressed_write_event_4         0x00000100U
#define SRT_NX51_sm_last_byte_addressed_write_event_4         8
#define DFLT_VAL_NX51_sm_last_byte_addressed_write_event_4    0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_write_event_4 0x00000000U
#define MSK_NX51_sm_last_byte_addressed_read_event_4          0x00000200U
#define SRT_NX51_sm_last_byte_addressed_read_event_4          9
#define DFLT_VAL_NX51_sm_last_byte_addressed_read_event_4     0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_read_event_4  0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_full_4            0x00000800U
#define SRT_NX51_sm_last_byte_addressed_buf_full_4            11
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_full_4       0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_full_4    0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_nr_4              0x00003000U
#define SRT_NX51_sm_last_byte_addressed_buf_nr_4              12
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_nr_4         0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_nr_4      0x00000000U
#define MSK_NX51_sm_last_byte_addressed_write_event_5         0x00004000U
#define SRT_NX51_sm_last_byte_addressed_write_event_5         14
#define DFLT_VAL_NX51_sm_last_byte_addressed_write_event_5    0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_write_event_5 0x00000000U
#define MSK_NX51_sm_last_byte_addressed_read_event_5          0x00008000U
#define SRT_NX51_sm_last_byte_addressed_read_event_5          15
#define DFLT_VAL_NX51_sm_last_byte_addressed_read_event_5     0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_read_event_5  0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_full_5            0x00020000U
#define SRT_NX51_sm_last_byte_addressed_buf_full_5            17
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_full_5       0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_full_5    0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_nr_5              0x000c0000U
#define SRT_NX51_sm_last_byte_addressed_buf_nr_5              18
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_nr_5         0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_nr_5      0x00000000U
#define MSK_NX51_sm_last_byte_addressed_write_event_6         0x00100000U
#define SRT_NX51_sm_last_byte_addressed_write_event_6         20
#define DFLT_VAL_NX51_sm_last_byte_addressed_write_event_6    0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_write_event_6 0x00000000U
#define MSK_NX51_sm_last_byte_addressed_read_event_6          0x00200000U
#define SRT_NX51_sm_last_byte_addressed_read_event_6          21
#define DFLT_VAL_NX51_sm_last_byte_addressed_read_event_6     0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_read_event_6  0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_full_6            0x00800000U
#define SRT_NX51_sm_last_byte_addressed_buf_full_6            23
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_full_6       0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_full_6    0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_nr_6              0x03000000U
#define SRT_NX51_sm_last_byte_addressed_buf_nr_6              24
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_nr_6         0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_nr_6      0x00000000U
#define MSK_NX51_sm_last_byte_addressed_write_event_7         0x04000000U
#define SRT_NX51_sm_last_byte_addressed_write_event_7         26
#define DFLT_VAL_NX51_sm_last_byte_addressed_write_event_7    0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_write_event_7 0x00000000U
#define MSK_NX51_sm_last_byte_addressed_read_event_7          0x08000000U
#define SRT_NX51_sm_last_byte_addressed_read_event_7          27
#define DFLT_VAL_NX51_sm_last_byte_addressed_read_event_7     0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_read_event_7  0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_full_7            0x20000000U
#define SRT_NX51_sm_last_byte_addressed_buf_full_7            29
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_full_7       0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_full_7    0x00000000U
#define MSK_NX51_sm_last_byte_addressed_buf_nr_7              0xc0000000U
#define SRT_NX51_sm_last_byte_addressed_buf_nr_7              30
#define DFLT_VAL_NX51_sm_last_byte_addressed_buf_nr_7         0x00000000U
#define DFLT_BF_VAL_NX51_sm_last_byte_addressed_buf_nr_7      0x00000000U

/* all used bits of 'NX51_sm_last_byte_addressed': */
#define MSK_USED_BITS_NX51_sm_last_byte_addressed 0xefbefbffU

enum {
	BFW_NX51_sm_last_byte_addressed_lba_0         = 1, /* [0] */
	BFW_NX51_sm_last_byte_addressed_lba_1         = 1, /* [1] */
	BFW_NX51_sm_last_byte_addressed_lba_2         = 1, /* [2] */
	BFW_NX51_sm_last_byte_addressed_lba_3         = 1, /* [3] */
	BFW_NX51_sm_last_byte_addressed_lba_4         = 1, /* [4] */
	BFW_NX51_sm_last_byte_addressed_lba_5         = 1, /* [5] */
	BFW_NX51_sm_last_byte_addressed_lba_6         = 1, /* [6] */
	BFW_NX51_sm_last_byte_addressed_lba_7         = 1, /* [7] */
	BFW_NX51_sm_last_byte_addressed_write_event_4 = 1, /* [8] */
	BFW_NX51_sm_last_byte_addressed_read_event_4  = 1, /* [9] */
	BFW_NX51_sm_last_byte_addressed_reserved1     = 1, /* [10] */
	BFW_NX51_sm_last_byte_addressed_buf_full_4    = 1, /* [11] */
	BFW_NX51_sm_last_byte_addressed_buf_nr_4      = 2, /* [13:12] */
	BFW_NX51_sm_last_byte_addressed_write_event_5 = 1, /* [14] */
	BFW_NX51_sm_last_byte_addressed_read_event_5  = 1, /* [15] */
	BFW_NX51_sm_last_byte_addressed_reserved2     = 1, /* [16] */
	BFW_NX51_sm_last_byte_addressed_buf_full_5    = 1, /* [17] */
	BFW_NX51_sm_last_byte_addressed_buf_nr_5      = 2, /* [19:18] */
	BFW_NX51_sm_last_byte_addressed_write_event_6 = 1, /* [20] */
	BFW_NX51_sm_last_byte_addressed_read_event_6  = 1, /* [21] */
	BFW_NX51_sm_last_byte_addressed_reserved3     = 1, /* [22] */
	BFW_NX51_sm_last_byte_addressed_buf_full_6    = 1, /* [23] */
	BFW_NX51_sm_last_byte_addressed_buf_nr_6      = 2, /* [25:24] */
	BFW_NX51_sm_last_byte_addressed_write_event_7 = 1, /* [26] */
	BFW_NX51_sm_last_byte_addressed_read_event_7  = 1, /* [27] */
	BFW_NX51_sm_last_byte_addressed_reserved4     = 1, /* [28] */
	BFW_NX51_sm_last_byte_addressed_buf_full_7    = 1, /* [29] */
	BFW_NX51_sm_last_byte_addressed_buf_nr_7      = 2  /* [31:30] */
};

typedef struct NX51_SM_LAST_BYTE_ADDRESSED_BIT_Ttag {
	unsigned int lba_0         : BFW_NX51_sm_last_byte_addressed_lba_0;         /* SM0 matches last byte of its address area         */
	unsigned int lba_1         : BFW_NX51_sm_last_byte_addressed_lba_1;         /* SM1 matches last byte of its address area         */
	unsigned int lba_2         : BFW_NX51_sm_last_byte_addressed_lba_2;         /* SM2 matches last byte of its address area         */
	unsigned int lba_3         : BFW_NX51_sm_last_byte_addressed_lba_3;         /* SM3 matches last byte of its address area         */
	unsigned int lba_4         : BFW_NX51_sm_last_byte_addressed_lba_4;         /* SM4 matches last byte of its address area         */
	unsigned int lba_5         : BFW_NX51_sm_last_byte_addressed_lba_5;         /* SM5 matches last byte of its address area         */
	unsigned int lba_6         : BFW_NX51_sm_last_byte_addressed_lba_6;         /* SM6 matches last byte of its address area         */
	unsigned int lba_7         : BFW_NX51_sm_last_byte_addressed_lba_7;         /* SM7 matches last byte of its address area         */
	unsigned int write_event_4 : BFW_NX51_sm_last_byte_addressed_write_event_4; /* read only version of sm_write_event.write_event_4 */
	unsigned int read_event_4  : BFW_NX51_sm_last_byte_addressed_read_event_4;  /* read only version of sm_read_event.read_event_4   */
	unsigned int reserved1     : BFW_NX51_sm_last_byte_addressed_reserved1;     /* reserved                                          */
	unsigned int buf_full_4    : BFW_NX51_sm_last_byte_addressed_buf_full_4;    /* read only version of sm_buf_statcfg.buf_full_4    */
	unsigned int buf_nr_4      : BFW_NX51_sm_last_byte_addressed_buf_nr_4;      /* read only version of sm_buf_statcfg.buf_nr_4      */
	unsigned int write_event_5 : BFW_NX51_sm_last_byte_addressed_write_event_5; /* read only version of sm_write_event.write_event_5 */
	unsigned int read_event_5  : BFW_NX51_sm_last_byte_addressed_read_event_5;  /* read only version of sm_read_event.read_event_5   */
	unsigned int reserved2     : BFW_NX51_sm_last_byte_addressed_reserved2;     /* reserved                                          */
	unsigned int buf_full_5    : BFW_NX51_sm_last_byte_addressed_buf_full_5;    /* read only version of sm_buf_statcfg.buf_full_5    */
	unsigned int buf_nr_5      : BFW_NX51_sm_last_byte_addressed_buf_nr_5;      /* read only version of sm_buf_statcfg.buf_nr_5      */
	unsigned int write_event_6 : BFW_NX51_sm_last_byte_addressed_write_event_6; /* read only version of sm_write_event.write_event_6 */
	unsigned int read_event_6  : BFW_NX51_sm_last_byte_addressed_read_event_6;  /* read only version of sm_read_event.read_event_6   */
	unsigned int reserved3     : BFW_NX51_sm_last_byte_addressed_reserved3;     /* reserved                                          */
	unsigned int buf_full_6    : BFW_NX51_sm_last_byte_addressed_buf_full_6;    /* read only version of sm_buf_statcfg.buf_full_6    */
	unsigned int buf_nr_6      : BFW_NX51_sm_last_byte_addressed_buf_nr_6;      /* read only version of sm_buf_statcfg.buf_nr_6      */
	unsigned int write_event_7 : BFW_NX51_sm_last_byte_addressed_write_event_7; /* read only version of sm_write_event.write_event_7 */
	unsigned int read_event_7  : BFW_NX51_sm_last_byte_addressed_read_event_7;  /* read only version of sm_read_event.read_event_7   */
	unsigned int reserved4     : BFW_NX51_sm_last_byte_addressed_reserved4;     /* reserved                                          */
	unsigned int buf_full_7    : BFW_NX51_sm_last_byte_addressed_buf_full_7;    /* read only version of sm_buf_statcfg.buf_full_7    */
	unsigned int buf_nr_7      : BFW_NX51_sm_last_byte_addressed_buf_nr_7;      /* read only version of sm_buf_statcfg.buf_nr_7      */
} NX51_SM_LAST_BYTE_ADDRESSED_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_SM_LAST_BYTE_ADDRESSED_BIT_T bf;
} NX51_SM_LAST_BYTE_ADDRESSED_T;

/* --------------------------------------------------------------------- */
/* Register sm_served */
/* => Served status bits of all SM, process channel: */
/*    Set by HW, if SM gives write_allowed or read_allowed. */
/*    Reset by SW (xPEC or ARM), by writing 1 on appropriate bit (usually after FCSok/fail). */
/*    Read/Write access by xPEC at adr_xpec_sr15 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sm_served    0x0000013CU
#define Adr_NX51_fmmusm_sm_served 0x1018BB3CU
#define Adr_NX51_sm_served        0x1018BB3CU
#define DFLT_VAL_NX51_sm_served   0x00000000U

#define MSK_NX51_sm_served_srvd_0                       0x00000001U
#define SRT_NX51_sm_served_srvd_0                       0
#define DFLT_VAL_NX51_sm_served_srvd_0                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_0               0x00000000U
#define MSK_NX51_sm_served_srvd_1                       0x00000002U
#define SRT_NX51_sm_served_srvd_1                       1
#define DFLT_VAL_NX51_sm_served_srvd_1                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_1               0x00000000U
#define MSK_NX51_sm_served_srvd_2                       0x00000004U
#define SRT_NX51_sm_served_srvd_2                       2
#define DFLT_VAL_NX51_sm_served_srvd_2                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_2               0x00000000U
#define MSK_NX51_sm_served_srvd_3                       0x00000008U
#define SRT_NX51_sm_served_srvd_3                       3
#define DFLT_VAL_NX51_sm_served_srvd_3                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_3               0x00000000U
#define MSK_NX51_sm_served_srvd_4                       0x00000010U
#define SRT_NX51_sm_served_srvd_4                       4
#define DFLT_VAL_NX51_sm_served_srvd_4                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_4               0x00000000U
#define MSK_NX51_sm_served_srvd_5                       0x00000020U
#define SRT_NX51_sm_served_srvd_5                       5
#define DFLT_VAL_NX51_sm_served_srvd_5                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_5               0x00000000U
#define MSK_NX51_sm_served_srvd_6                       0x00000040U
#define SRT_NX51_sm_served_srvd_6                       6
#define DFLT_VAL_NX51_sm_served_srvd_6                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_6               0x00000000U
#define MSK_NX51_sm_served_srvd_7                       0x00000080U
#define SRT_NX51_sm_served_srvd_7                       7
#define DFLT_VAL_NX51_sm_served_srvd_7                  0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_srvd_7               0x00000000U
#define MSK_NX51_sm_served_any_proc_read_match          0x00000100U
#define SRT_NX51_sm_served_any_proc_read_match          8
#define DFLT_VAL_NX51_sm_served_any_proc_read_match     0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_any_proc_read_match  0x00000000U
#define MSK_NX51_sm_served_any_proc_write_match         0x00000200U
#define SRT_NX51_sm_served_any_proc_write_match         9
#define DFLT_VAL_NX51_sm_served_any_proc_write_match    0x00000000U
#define DFLT_BF_VAL_NX51_sm_served_any_proc_write_match 0x00000000U

/* all used bits of 'NX51_sm_served': */
#define MSK_USED_BITS_NX51_sm_served 0x000003ffU

enum {
	BFW_NX51_sm_served_srvd_0               = 1,  /* [0] */
	BFW_NX51_sm_served_srvd_1               = 1,  /* [1] */
	BFW_NX51_sm_served_srvd_2               = 1,  /* [2] */
	BFW_NX51_sm_served_srvd_3               = 1,  /* [3] */
	BFW_NX51_sm_served_srvd_4               = 1,  /* [4] */
	BFW_NX51_sm_served_srvd_5               = 1,  /* [5] */
	BFW_NX51_sm_served_srvd_6               = 1,  /* [6] */
	BFW_NX51_sm_served_srvd_7               = 1,  /* [7] */
	BFW_NX51_sm_served_any_proc_read_match  = 1,  /* [8] */
	BFW_NX51_sm_served_any_proc_write_match = 1,  /* [9] */
	BFW_NX51_sm_served_reserved1            = 22  /* [31:10] */
};

typedef struct NX51_SM_SERVED_BIT_Ttag {
	unsigned int srvd_0               : BFW_NX51_sm_served_srvd_0;               /* SM0 address area was read or write accessed by xPEC                                */
	unsigned int srvd_1               : BFW_NX51_sm_served_srvd_1;               /* SM1 address area was read or write accessed by xPEC                                */
	unsigned int srvd_2               : BFW_NX51_sm_served_srvd_2;               /* SM2 address area was read or write accessed by xPEC                                */
	unsigned int srvd_3               : BFW_NX51_sm_served_srvd_3;               /* SM3 address area was read or write accessed by xPEC                                */
	unsigned int srvd_4               : BFW_NX51_sm_served_srvd_4;               /* SM4 address area was read or write accessed by xPEC                                */
	unsigned int srvd_5               : BFW_NX51_sm_served_srvd_5;               /* SM5 address area was read or write accessed by xPEC                                */
	unsigned int srvd_6               : BFW_NX51_sm_served_srvd_6;               /* SM6 address area was read or write accessed by xPEC                                */
	unsigned int srvd_7               : BFW_NX51_sm_served_srvd_7;               /* SM7 address area was read or write accessed by xPEC                                */
	unsigned int any_proc_read_match  : BFW_NX51_sm_served_any_proc_read_match;  /* Any read access was allowed, i.e. any SM matched for read or direct read access    */
	unsigned int any_proc_write_match : BFW_NX51_sm_served_any_proc_write_match; /* Any write access was allowed, i.e. any SM matched for write or direct write access */
	unsigned int reserved1            : BFW_NX51_sm_served_reserved1;            /* reserved                                                                           */
} NX51_SM_SERVED_BIT_T;

typedef union {
	unsigned int         val;
	NX51_SM_SERVED_BIT_T bf;
} NX51_SM_SERVED_T;


/* ===================================================================== */

/* Area of trigger_sample_unit */

/* ===================================================================== */

#define Addr_NX51_trigger_sample_unit 0x1018BD00U

/* --------------------------------------------------------------------- */
/* Register trigger_sample_config */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_sample_config                 0x00000000U
#define Adr_NX51_trigger_sample_unit_trigger_sample_config 0x1018BD00U
#define Adr_NX51_trigger_sample_config                     0x1018BD00U
#define DFLT_VAL_NX51_trigger_sample_config                0x00000000U

#define MSK_NX51_trigger_sample_config_sync0_output_driver           0x00000001U
#define SRT_NX51_trigger_sample_config_sync0_output_driver           0
#define DFLT_VAL_NX51_trigger_sample_config_sync0_output_driver      0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync0_output_driver   0x00000000U
#define MSK_NX51_trigger_sample_config_sync0_polarity                0x00000002U
#define SRT_NX51_trigger_sample_config_sync0_polarity                1
#define DFLT_VAL_NX51_trigger_sample_config_sync0_polarity           0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync0_polarity        0x00000000U
#define MSK_NX51_trigger_sample_config_sync0_oe                      0x00000004U
#define SRT_NX51_trigger_sample_config_sync0_oe                      2
#define DFLT_VAL_NX51_trigger_sample_config_sync0_oe                 0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync0_oe              0x00000000U
#define MSK_NX51_trigger_sample_config_sync0_irq_en                  0x00000008U
#define SRT_NX51_trigger_sample_config_sync0_irq_en                  3
#define DFLT_VAL_NX51_trigger_sample_config_sync0_irq_en             0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync0_irq_en          0x00000000U
#define MSK_NX51_trigger_sample_config_sync1_output_driver           0x00000010U
#define SRT_NX51_trigger_sample_config_sync1_output_driver           4
#define DFLT_VAL_NX51_trigger_sample_config_sync1_output_driver      0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync1_output_driver   0x00000000U
#define MSK_NX51_trigger_sample_config_sync1_polarity                0x00000020U
#define SRT_NX51_trigger_sample_config_sync1_polarity                5
#define DFLT_VAL_NX51_trigger_sample_config_sync1_polarity           0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync1_polarity        0x00000000U
#define MSK_NX51_trigger_sample_config_sync1_oe                      0x00000040U
#define SRT_NX51_trigger_sample_config_sync1_oe                      6
#define DFLT_VAL_NX51_trigger_sample_config_sync1_oe                 0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync1_oe              0x00000000U
#define MSK_NX51_trigger_sample_config_sync1_irq_en                  0x00000080U
#define SRT_NX51_trigger_sample_config_sync1_irq_en                  7
#define DFLT_VAL_NX51_trigger_sample_config_sync1_irq_en             0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_sync1_irq_en          0x00000000U
#define MSK_NX51_trigger_sample_config_trigger_mode                  0x00000300U
#define SRT_NX51_trigger_sample_config_trigger_mode                  8
#define DFLT_VAL_NX51_trigger_sample_config_trigger_mode             0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_trigger_mode          0x00000000U
#define MSK_NX51_trigger_sample_config_cyc1_count                    0x0000f000U
#define SRT_NX51_trigger_sample_config_cyc1_count                    12
#define DFLT_VAL_NX51_trigger_sample_config_cyc1_count               0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_cyc1_count            0x00000000U
#define MSK_NX51_trigger_sample_config_latch_unit_activate           0x00010000U
#define SRT_NX51_trigger_sample_config_latch_unit_activate           16
#define DFLT_VAL_NX51_trigger_sample_config_latch_unit_activate      0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_latch_unit_activate   0x00000000U
#define MSK_NX51_trigger_sample_config_latch0_posedge_irq_en         0x01000000U
#define SRT_NX51_trigger_sample_config_latch0_posedge_irq_en         24
#define DFLT_VAL_NX51_trigger_sample_config_latch0_posedge_irq_en    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_latch0_posedge_irq_en 0x00000000U
#define MSK_NX51_trigger_sample_config_latch0_negedge_irq_en         0x02000000U
#define SRT_NX51_trigger_sample_config_latch0_negedge_irq_en         25
#define DFLT_VAL_NX51_trigger_sample_config_latch0_negedge_irq_en    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_latch0_negedge_irq_en 0x00000000U
#define MSK_NX51_trigger_sample_config_latch1_posedge_irq_en         0x04000000U
#define SRT_NX51_trigger_sample_config_latch1_posedge_irq_en         26
#define DFLT_VAL_NX51_trigger_sample_config_latch1_posedge_irq_en    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_latch1_posedge_irq_en 0x00000000U
#define MSK_NX51_trigger_sample_config_latch1_negedge_irq_en         0x08000000U
#define SRT_NX51_trigger_sample_config_latch1_negedge_irq_en         27
#define DFLT_VAL_NX51_trigger_sample_config_latch1_negedge_irq_en    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_config_latch1_negedge_irq_en 0x00000000U

/* all used bits of 'NX51_trigger_sample_config': */
#define MSK_USED_BITS_NX51_trigger_sample_config 0x0f01f3ffU

enum {
	BFW_NX51_trigger_sample_config_sync0_output_driver   = 1, /* [0] */
	BFW_NX51_trigger_sample_config_sync0_polarity        = 1, /* [1] */
	BFW_NX51_trigger_sample_config_sync0_oe              = 1, /* [2] */
	BFW_NX51_trigger_sample_config_sync0_irq_en          = 1, /* [3] */
	BFW_NX51_trigger_sample_config_sync1_output_driver   = 1, /* [4] */
	BFW_NX51_trigger_sample_config_sync1_polarity        = 1, /* [5] */
	BFW_NX51_trigger_sample_config_sync1_oe              = 1, /* [6] */
	BFW_NX51_trigger_sample_config_sync1_irq_en          = 1, /* [7] */
	BFW_NX51_trigger_sample_config_trigger_mode          = 2, /* [9:8] */
	BFW_NX51_trigger_sample_config_reserved1             = 2, /* [11:10] */
	BFW_NX51_trigger_sample_config_cyc1_count            = 4, /* [15:12] */
	BFW_NX51_trigger_sample_config_latch_unit_activate   = 1, /* [16] */
	BFW_NX51_trigger_sample_config_reserved2             = 7, /* [23:17] */
	BFW_NX51_trigger_sample_config_latch0_posedge_irq_en = 1, /* [24] */
	BFW_NX51_trigger_sample_config_latch0_negedge_irq_en = 1, /* [25] */
	BFW_NX51_trigger_sample_config_latch1_posedge_irq_en = 1, /* [26] */
	BFW_NX51_trigger_sample_config_latch1_negedge_irq_en = 1, /* [27] */
	BFW_NX51_trigger_sample_config_reserved3             = 4  /* [31:28] */
};

typedef struct NX51_TRIGGER_SAMPLE_CONFIG_BIT_Ttag {
	unsigned int sync0_output_driver   : BFW_NX51_trigger_sample_config_sync0_output_driver;   /* 1/0: sync0 (ethercat) open-drain                                                                                   */
	unsigned int sync0_polarity        : BFW_NX51_trigger_sample_config_sync0_polarity;        /* 1/0: sync0 (ethercat) high/low active                                                                              */
	unsigned int sync0_oe              : BFW_NX51_trigger_sample_config_sync0_oe;              /* 1/0: sync0 (ethercat) output enabled/disabled                                                                      */
	unsigned int sync0_irq_en          : BFW_NX51_trigger_sample_config_sync0_irq_en;          /* 1/0: sync0 (ethercat) interrupt enabled/disabled                                                                   */
	unsigned int sync1_output_driver   : BFW_NX51_trigger_sample_config_sync1_output_driver;   /* 1/0: sync1 (ethercat) open-drain/ push-pull                                                                        */
	unsigned int sync1_polarity        : BFW_NX51_trigger_sample_config_sync1_polarity;        /* 1/0: sync1 (ethercat) high/low active                                                                              */
	unsigned int sync1_oe              : BFW_NX51_trigger_sample_config_sync1_oe;              /* 1/0: sync1 (ethercat) output enabled/disabled                                                                      */
	unsigned int sync1_irq_en          : BFW_NX51_trigger_sample_config_sync1_irq_en;          /* 1/0: sync1 (ethercat) interrupt enabled/disabled                                                                   */
	unsigned int trigger_mode          : BFW_NX51_trigger_sample_config_trigger_mode;          /* trigger unit mode:                                                                                                 */
	                                                                                           /* 2'b00: normal (sync0 and sync1 are independent, damit sollte PROFINET spielen)                                     */
	                                                                                           /* 2'b01: ecat (sync1 depends on sync0 s. EtherCat Spec.)                                                             */
	                                                                                           /* 2'b10: reserved                                                                                                    */
	                                                                                           /* 2'b11: reserved                                                                                                    */
	unsigned int reserved1             : BFW_NX51_trigger_sample_config_reserved1;             /* reserved                                                                                                           */
	unsigned int cyc1_count            : BFW_NX51_trigger_sample_config_cyc1_count;            /* cycle counter for sync 1 for sercos3, 0..16 (0=endless, 1..16 times) (normal/PN mode only)                         */
	                                                                                           /* write cycle counter befor trigger_1_starttime_ns                                                                   */
	                                                                                           /* writing trigger_1_starttime_ns restarts cycle counter/timer                                                        */
	                                                                                           /* number of added pulses after Sync1 event, 0/1: no added pulses, 2..15 lead to 1..14 added pulses after sync1 event */
	unsigned int latch_unit_activate   : BFW_NX51_trigger_sample_config_latch_unit_activate;   /* 0->1 (posedge)/ 1->0 (negedge): latching enabled/disabled (reset internal statemachine ethercat)                   */
	unsigned int reserved2             : BFW_NX51_trigger_sample_config_reserved2;             /* reserved                                                                                                           */
	unsigned int latch0_posedge_irq_en : BFW_NX51_trigger_sample_config_latch0_posedge_irq_en; /* 1/0: latch0 posedge interrupt enabled(ethercat mode)                                                               */
	unsigned int latch0_negedge_irq_en : BFW_NX51_trigger_sample_config_latch0_negedge_irq_en; /* 1/0: latch0 negedge interrupt enabled(ethercat mode)                                                               */
	unsigned int latch1_posedge_irq_en : BFW_NX51_trigger_sample_config_latch1_posedge_irq_en; /* 1/0: latch1 posedge interrupt enabled(ethercat mode)                                                               */
	unsigned int latch1_negedge_irq_en : BFW_NX51_trigger_sample_config_latch1_negedge_irq_en; /* 1/0: latch1 negedge interrupt enabled(ethercat mode)                                                               */
	unsigned int reserved3             : BFW_NX51_trigger_sample_config_reserved3;             /* reserved                                                                                                           */
} NX51_TRIGGER_SAMPLE_CONFIG_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_TRIGGER_SAMPLE_CONFIG_BIT_T bf;
} NX51_TRIGGER_SAMPLE_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register trigger_sample_status */
/* => r/w access by xPEC and ARM, set by trigger_sample_unit, write access (1'b1) clears the events, all status signals are connected to the xPEC event controller of each xPEC */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_sample_status                 0x00000004U
#define Adr_NX51_trigger_sample_unit_trigger_sample_status 0x1018BD04U
#define Adr_NX51_trigger_sample_status                     0x1018BD04U
#define DFLT_VAL_NX51_trigger_sample_status                0x00000000U

#define MSK_NX51_trigger_sample_status_sync0_status                    0x00000001U
#define SRT_NX51_trigger_sample_status_sync0_status                    0
#define DFLT_VAL_NX51_trigger_sample_status_sync0_status               0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sync0_status            0x00000000U
#define MSK_NX51_trigger_sample_status_sync1_status                    0x00000100U
#define SRT_NX51_trigger_sample_status_sync1_status                    8
#define DFLT_VAL_NX51_trigger_sample_status_sync1_status               0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sync1_status            0x00000000U
#define MSK_NX51_trigger_sample_status_sample_0_posedge_status         0x00010000U
#define SRT_NX51_trigger_sample_status_sample_0_posedge_status         16
#define DFLT_VAL_NX51_trigger_sample_status_sample_0_posedge_status    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sample_0_posedge_status 0x00000000U
#define MSK_NX51_trigger_sample_status_sample_0_negedge_status         0x00020000U
#define SRT_NX51_trigger_sample_status_sample_0_negedge_status         17
#define DFLT_VAL_NX51_trigger_sample_status_sample_0_negedge_status    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sample_0_negedge_status 0x00000000U
#define MSK_NX51_trigger_sample_status_sample_0_in                     0x00040000U
#define SRT_NX51_trigger_sample_status_sample_0_in                     18
#define DFLT_VAL_NX51_trigger_sample_status_sample_0_in                0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sample_0_in             0x00000000U
#define MSK_NX51_trigger_sample_status_sample_1_posedge_status         0x01000000U
#define SRT_NX51_trigger_sample_status_sample_1_posedge_status         24
#define DFLT_VAL_NX51_trigger_sample_status_sample_1_posedge_status    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sample_1_posedge_status 0x00000000U
#define MSK_NX51_trigger_sample_status_sample_1_negedge_status         0x02000000U
#define SRT_NX51_trigger_sample_status_sample_1_negedge_status         25
#define DFLT_VAL_NX51_trigger_sample_status_sample_1_negedge_status    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sample_1_negedge_status 0x00000000U
#define MSK_NX51_trigger_sample_status_sample_1_in                     0x04000000U
#define SRT_NX51_trigger_sample_status_sample_1_in                     26
#define DFLT_VAL_NX51_trigger_sample_status_sample_1_in                0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_status_sample_1_in             0x00000000U

/* all used bits of 'NX51_trigger_sample_status': */
#define MSK_USED_BITS_NX51_trigger_sample_status 0x07070101U

enum {
	BFW_NX51_trigger_sample_status_sync0_status            = 1, /* [0] */
	BFW_NX51_trigger_sample_status_reserved1               = 7, /* [7:1] */
	BFW_NX51_trigger_sample_status_sync1_status            = 1, /* [8] */
	BFW_NX51_trigger_sample_status_reserved2               = 7, /* [15:9] */
	BFW_NX51_trigger_sample_status_sample_0_posedge_status = 1, /* [16] */
	BFW_NX51_trigger_sample_status_sample_0_negedge_status = 1, /* [17] */
	BFW_NX51_trigger_sample_status_sample_0_in             = 1, /* [18] */
	BFW_NX51_trigger_sample_status_reserved3               = 5, /* [23:19] */
	BFW_NX51_trigger_sample_status_sample_1_posedge_status = 1, /* [24] */
	BFW_NX51_trigger_sample_status_sample_1_negedge_status = 1, /* [25] */
	BFW_NX51_trigger_sample_status_sample_1_in             = 1, /* [26] */
	BFW_NX51_trigger_sample_status_reserved4               = 5  /* [31:27] */
};

typedef struct NX51_TRIGGER_SAMPLE_STATUS_BIT_Ttag {
	unsigned int sync0_status            : BFW_NX51_trigger_sample_status_sync0_status;            /* status of sync0                                     */
	unsigned int reserved1               : BFW_NX51_trigger_sample_status_reserved1;               /* reserved                                            */
	unsigned int sync1_status            : BFW_NX51_trigger_sample_status_sync1_status;            /* status of sync1                                     */
	unsigned int reserved2               : BFW_NX51_trigger_sample_status_reserved2;               /* reserved                                            */
	unsigned int sample_0_posedge_status : BFW_NX51_trigger_sample_status_sample_0_posedge_status; /* 1/0: positive edge detected/not detected at latch 0 */
	unsigned int sample_0_negedge_status : BFW_NX51_trigger_sample_status_sample_0_negedge_status; /* 1/0: negative edge detected/not detected at latch 0 */
	unsigned int sample_0_in             : BFW_NX51_trigger_sample_status_sample_0_in;             /* current value at latch0                             */
	unsigned int reserved3               : BFW_NX51_trigger_sample_status_reserved3;               /* reserved                                            */
	unsigned int sample_1_posedge_status : BFW_NX51_trigger_sample_status_sample_1_posedge_status; /* 1/0: positive edge detected/not detected at latch 1 */
	unsigned int sample_1_negedge_status : BFW_NX51_trigger_sample_status_sample_1_negedge_status; /* 1/0: negative edge detected/not detected at latch 1 */
	unsigned int sample_1_in             : BFW_NX51_trigger_sample_status_sample_1_in;             /* current value at latch1                             */
	unsigned int reserved4               : BFW_NX51_trigger_sample_status_reserved4;               /* reserved                                            */
} NX51_TRIGGER_SAMPLE_STATUS_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_TRIGGER_SAMPLE_STATUS_BIT_T bf;
} NX51_TRIGGER_SAMPLE_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register trigger_sample_irq */
/* => r/w by xPEC and ARM, one global irq register for trigger_sample unit (must be also visible for HIF); irq set by xPEC, reset by arm (always with writing a 1 at appropriate bit position) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_sample_irq                 0x00000008U
#define Adr_NX51_trigger_sample_unit_trigger_sample_irq 0x1018BD08U
#define Adr_NX51_trigger_sample_irq                     0x1018BD08U
#define DFLT_VAL_NX51_trigger_sample_irq                0x00000000U

#define MSK_NX51_trigger_sample_irq_sync0_irq                  0x00000001U
#define SRT_NX51_trigger_sample_irq_sync0_irq                  0
#define DFLT_VAL_NX51_trigger_sample_irq_sync0_irq             0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_irq_sync0_irq          0x00000000U
#define MSK_NX51_trigger_sample_irq_sync1_irq                  0x00000002U
#define SRT_NX51_trigger_sample_irq_sync1_irq                  1
#define DFLT_VAL_NX51_trigger_sample_irq_sync1_irq             0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_irq_sync1_irq          0x00000000U
#define MSK_NX51_trigger_sample_irq_latch0_posedge_irq         0x00000100U
#define SRT_NX51_trigger_sample_irq_latch0_posedge_irq         8
#define DFLT_VAL_NX51_trigger_sample_irq_latch0_posedge_irq    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_irq_latch0_posedge_irq 0x00000000U
#define MSK_NX51_trigger_sample_irq_latch0_negedge_irq         0x00000200U
#define SRT_NX51_trigger_sample_irq_latch0_negedge_irq         9
#define DFLT_VAL_NX51_trigger_sample_irq_latch0_negedge_irq    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_irq_latch0_negedge_irq 0x00000000U
#define MSK_NX51_trigger_sample_irq_latch1_posedge_irq         0x00000400U
#define SRT_NX51_trigger_sample_irq_latch1_posedge_irq         10
#define DFLT_VAL_NX51_trigger_sample_irq_latch1_posedge_irq    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_irq_latch1_posedge_irq 0x00000000U
#define MSK_NX51_trigger_sample_irq_latch1_negedge_irq         0x00000800U
#define SRT_NX51_trigger_sample_irq_latch1_negedge_irq         11
#define DFLT_VAL_NX51_trigger_sample_irq_latch1_negedge_irq    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_sample_irq_latch1_negedge_irq 0x00000000U

/* all used bits of 'NX51_trigger_sample_irq': */
#define MSK_USED_BITS_NX51_trigger_sample_irq 0x00000f03U

enum {
	BFW_NX51_trigger_sample_irq_sync0_irq          = 1,  /* [0] */
	BFW_NX51_trigger_sample_irq_sync1_irq          = 1,  /* [1] */
	BFW_NX51_trigger_sample_irq_reserved1          = 6,  /* [7:2] */
	BFW_NX51_trigger_sample_irq_latch0_posedge_irq = 1,  /* [8] */
	BFW_NX51_trigger_sample_irq_latch0_negedge_irq = 1,  /* [9] */
	BFW_NX51_trigger_sample_irq_latch1_posedge_irq = 1,  /* [10] */
	BFW_NX51_trigger_sample_irq_latch1_negedge_irq = 1,  /* [11] */
	BFW_NX51_trigger_sample_irq_reserved2          = 20  /* [31:12] */
};

typedef struct NX51_TRIGGER_SAMPLE_IRQ_BIT_Ttag {
	unsigned int sync0_irq          : BFW_NX51_trigger_sample_irq_sync0_irq;          /* sync0 interrupt # default 0              */
	unsigned int sync1_irq          : BFW_NX51_trigger_sample_irq_sync1_irq;          /* sync1 interrupt # default 0              */
	unsigned int reserved1          : BFW_NX51_trigger_sample_irq_reserved1;          /* reserved                                 */
	unsigned int latch0_posedge_irq : BFW_NX51_trigger_sample_irq_latch0_posedge_irq; /* latch0 posedge interrupt (ethercat mode) */
	unsigned int latch0_negedge_irq : BFW_NX51_trigger_sample_irq_latch0_negedge_irq; /* latch0 negedge interrupt (ethercat mode) */
	unsigned int latch1_posedge_irq : BFW_NX51_trigger_sample_irq_latch1_posedge_irq; /* latch1 posedge interrupt (ethercat mode) */
	unsigned int latch1_negedge_irq : BFW_NX51_trigger_sample_irq_latch1_negedge_irq; /* latch1 negedge interrupt (ethercat mode) */
	unsigned int reserved2          : BFW_NX51_trigger_sample_irq_reserved2;          /* reserved                                 */
} NX51_TRIGGER_SAMPLE_IRQ_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_TRIGGER_SAMPLE_IRQ_BIT_T bf;
} NX51_TRIGGER_SAMPLE_IRQ_T;

/* --------------------------------------------------------------------- */
/* Register trigger_activate */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_activate                 0x0000000CU
#define Adr_NX51_trigger_sample_unit_trigger_activate 0x1018BD0CU
#define Adr_NX51_trigger_activate                     0x1018BD0CU
#define DFLT_VAL_NX51_trigger_activate                0x00000000U

#define MSK_NX51_trigger_activate_trigger_unit_activate         0x00000100U
#define SRT_NX51_trigger_activate_trigger_unit_activate         8
#define DFLT_VAL_NX51_trigger_activate_trigger_unit_activate    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_activate_trigger_unit_activate 0x00000000U
#define MSK_NX51_trigger_activate_sync0_activate                0x00000200U
#define SRT_NX51_trigger_activate_sync0_activate                9
#define DFLT_VAL_NX51_trigger_activate_sync0_activate           0x00000000U
#define DFLT_BF_VAL_NX51_trigger_activate_sync0_activate        0x00000000U
#define MSK_NX51_trigger_activate_sync1_activate                0x00000400U
#define SRT_NX51_trigger_activate_sync1_activate                10
#define DFLT_VAL_NX51_trigger_activate_sync1_activate           0x00000000U
#define DFLT_BF_VAL_NX51_trigger_activate_sync1_activate        0x00000000U

/* all used bits of 'NX51_trigger_activate': */
#define MSK_USED_BITS_NX51_trigger_activate 0x00000700U

enum {
	BFW_NX51_trigger_activate_reserved1             = 8,  /* [7:0] */
	BFW_NX51_trigger_activate_trigger_unit_activate = 1,  /* [8] */
	BFW_NX51_trigger_activate_sync0_activate        = 1,  /* [9] */
	BFW_NX51_trigger_activate_sync1_activate        = 1,  /* [10] */
	BFW_NX51_trigger_activate_reserved2             = 21  /* [31:11] */
};

typedef struct NX51_TRIGGER_ACTIVATE_BIT_Ttag {
	unsigned int reserved1             : BFW_NX51_trigger_activate_reserved1;             /* reserved                                                                              */
	unsigned int trigger_unit_activate : BFW_NX51_trigger_activate_trigger_unit_activate; /* 0->1 (posedge): activates trigger unit cyclic functions                               */
	                                                                                      /* normal mode: unit waits for trigger_0_starttime and trigger_1_starttime independently */
	                                                                                      /* ecat mode: unit waits for trigger_0_starttime                                         */
	                                                                                      /* 1->0 (negedge): reset trigger unit state machine (internal signals)                   */
	unsigned int sync0_activate        : BFW_NX51_trigger_activate_sync0_activate;        /* 1/0: sync0 activated/deactivated                                                      */
	unsigned int sync1_activate        : BFW_NX51_trigger_activate_sync1_activate;        /* 1/0: sync1 activated/deactivated                                                      */
	unsigned int reserved2             : BFW_NX51_trigger_activate_reserved2;             /* reserved                                                                              */
} NX51_TRIGGER_ACTIVATE_BIT_T;

typedef union {
	unsigned int                val;
	NX51_TRIGGER_ACTIVATE_BIT_T bf;
} NX51_TRIGGER_ACTIVATE_T;

/* --------------------------------------------------------------------- */
/* Register trigger_impulse_length */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_impulse_length                 0x00000010U
#define Adr_NX51_trigger_sample_unit_trigger_impulse_length 0x1018BD10U
#define Adr_NX51_trigger_impulse_length                     0x1018BD10U
#define DFLT_VAL_NX51_trigger_impulse_length                0x00000000U

#define MSK_NX51_trigger_impulse_length_sync0_impulse_length         0x0000ffffU
#define SRT_NX51_trigger_impulse_length_sync0_impulse_length         0
#define DFLT_VAL_NX51_trigger_impulse_length_sync0_impulse_length    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_impulse_length_sync0_impulse_length 0x00000000U
#define MSK_NX51_trigger_impulse_length_sync1_impulse_length         0xffff0000U
#define SRT_NX51_trigger_impulse_length_sync1_impulse_length         16
#define DFLT_VAL_NX51_trigger_impulse_length_sync1_impulse_length    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_impulse_length_sync1_impulse_length 0x00000000U

/* all used bits of 'NX51_trigger_impulse_length': */
#define MSK_USED_BITS_NX51_trigger_impulse_length 0xffffffffU

enum {
	BFW_NX51_trigger_impulse_length_sync0_impulse_length = 16, /* [15:0] */
	BFW_NX51_trigger_impulse_length_sync1_impulse_length = 16  /* [31:16] */
};

typedef struct NX51_TRIGGER_IMPULSE_LENGTH_BIT_Ttag {
	unsigned int sync0_impulse_length : BFW_NX51_trigger_impulse_length_sync0_impulse_length; /* impulse length Sync0 signal (in Units of 10ns), 0x0000: activates acknowledge mode */
	                                                                                          /* ImpulseLength+1 [cc], to configure 2..2^16 * 10 ns pulse width use values 1..2^15  */
	unsigned int sync1_impulse_length : BFW_NX51_trigger_impulse_length_sync1_impulse_length; /* impulse length Sync1 signal (in Units of 10ns), 0x0000: activates acknowledge mode */
	                                                                                          /* ImpulseLength+1 [cc], to configure 2..2^16 * 10 ns pulse width use values 1..2^15  */
} NX51_TRIGGER_IMPULSE_LENGTH_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_TRIGGER_IMPULSE_LENGTH_BIT_T bf;
} NX51_TRIGGER_IMPULSE_LENGTH_T;

/* --------------------------------------------------------------------- */
/* Register trigger_0_starttime_ns */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_0_starttime_ns                 0x00000014U
#define Adr_NX51_trigger_sample_unit_trigger_0_starttime_ns 0x1018BD14U
#define Adr_NX51_trigger_0_starttime_ns                     0x1018BD14U
#define DFLT_VAL_NX51_trigger_0_starttime_ns                0x00000000U

#define MSK_NX51_trigger_0_starttime_ns_systime_ns         0xffffffffU
#define SRT_NX51_trigger_0_starttime_ns_systime_ns         0
#define DFLT_VAL_NX51_trigger_0_starttime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_0_starttime_ns_systime_ns 0x00000000U

/* all used bits of 'NX51_trigger_0_starttime_ns': */
#define MSK_USED_BITS_NX51_trigger_0_starttime_ns 0xffffffffU

enum {
	BFW_NX51_trigger_0_starttime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_TRIGGER_0_STARTTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_trigger_0_starttime_ns_systime_ns; /* write: system time ns when 1st sync0 event shall occur */
	                                                                      /* read: systime_ns value of next sync0 event             */
} NX51_TRIGGER_0_STARTTIME_NS_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_TRIGGER_0_STARTTIME_NS_BIT_T bf;
} NX51_TRIGGER_0_STARTTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register trigger_1_starttime_ns */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_1_starttime_ns                 0x00000018U
#define Adr_NX51_trigger_sample_unit_trigger_1_starttime_ns 0x1018BD18U
#define Adr_NX51_trigger_1_starttime_ns                     0x1018BD18U
#define DFLT_VAL_NX51_trigger_1_starttime_ns                0x00000000U

#define MSK_NX51_trigger_1_starttime_ns_systime_ns         0xffffffffU
#define SRT_NX51_trigger_1_starttime_ns_systime_ns         0
#define DFLT_VAL_NX51_trigger_1_starttime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_1_starttime_ns_systime_ns 0x00000000U

/* all used bits of 'NX51_trigger_1_starttime_ns': */
#define MSK_USED_BITS_NX51_trigger_1_starttime_ns 0xffffffffU

enum {
	BFW_NX51_trigger_1_starttime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_TRIGGER_1_STARTTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_trigger_1_starttime_ns_systime_ns; /* write: systime_ns when 1st sync1 event shall occur                                                                   */
	                                                                      /* read: systime_ns value of next sync1 event                                                                           */
	                                                                      /* In EtherCAT mode the starttime1 must be configured manuelly with StartTime0+CycleTime1 before activation of the unit */
} NX51_TRIGGER_1_STARTTIME_NS_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_TRIGGER_1_STARTTIME_NS_BIT_T bf;
} NX51_TRIGGER_1_STARTTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register trigger_0_cyc_time */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_0_cyc_time                 0x0000001CU
#define Adr_NX51_trigger_sample_unit_trigger_0_cyc_time 0x1018BD1CU
#define Adr_NX51_trigger_0_cyc_time                     0x1018BD1CU
#define DFLT_VAL_NX51_trigger_0_cyc_time                0x00000000U

#define MSK_NX51_trigger_0_cyc_time_systime_ns         0xffffffffU
#define SRT_NX51_trigger_0_cyc_time_systime_ns         0
#define DFLT_VAL_NX51_trigger_0_cyc_time_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_0_cyc_time_systime_ns 0x00000000U

/* all used bits of 'NX51_trigger_0_cyc_time': */
#define MSK_USED_BITS_NX51_trigger_0_cyc_time 0xffffffffU

enum {
	BFW_NX51_trigger_0_cyc_time_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_TRIGGER_0_CYC_TIME_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_trigger_0_cyc_time_systime_ns; /* Time between two consecutive SYNC0 Signals                          */
	                                                                  /* cyclic functions are disabled if CYC_TIME0==0 -> single event usage */
	                                                                  /* if cycle time not zero then cyletime > 40 ns and < systime_border   */
} NX51_TRIGGER_0_CYC_TIME_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_TRIGGER_0_CYC_TIME_BIT_T bf;
} NX51_TRIGGER_0_CYC_TIME_T;

/* --------------------------------------------------------------------- */
/* Register trigger_1_cyc_time */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_1_cyc_time                 0x00000020U
#define Adr_NX51_trigger_sample_unit_trigger_1_cyc_time 0x1018BD20U
#define Adr_NX51_trigger_1_cyc_time                     0x1018BD20U
#define DFLT_VAL_NX51_trigger_1_cyc_time                0x00000000U

#define MSK_NX51_trigger_1_cyc_time_systime_ns         0xffffffffU
#define SRT_NX51_trigger_1_cyc_time_systime_ns         0
#define DFLT_VAL_NX51_trigger_1_cyc_time_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_1_cyc_time_systime_ns 0x00000000U

/* all used bits of 'NX51_trigger_1_cyc_time': */
#define MSK_USED_BITS_NX51_trigger_1_cyc_time 0xffffffffU

enum {
	BFW_NX51_trigger_1_cyc_time_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_TRIGGER_1_CYC_TIME_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_trigger_1_cyc_time_systime_ns; /* normal mode: Time between two consecutive SYNC1 Signal            */
	                                                                  /* ecat mode: Time between SYNC1 Signal and SYNC0 Signal             */
	                                                                  /* if cycle time not zero then cyletime > 40 ns and < systime_border */
} NX51_TRIGGER_1_CYC_TIME_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_TRIGGER_1_CYC_TIME_BIT_T bf;
} NX51_TRIGGER_1_CYC_TIME_T;

/* --------------------------------------------------------------------- */
/* Register sample_mode */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sample_mode                 0x00000024U
#define Adr_NX51_trigger_sample_unit_sample_mode 0x1018BD24U
#define Adr_NX51_sample_mode                     0x1018BD24U
#define DFLT_VAL_NX51_sample_mode                0x00000000U

#define MSK_NX51_sample_mode_sample_0_posedge_mode         0x00000001U
#define SRT_NX51_sample_mode_sample_0_posedge_mode         0
#define DFLT_VAL_NX51_sample_mode_sample_0_posedge_mode    0x00000000U
#define DFLT_BF_VAL_NX51_sample_mode_sample_0_posedge_mode 0x00000000U
#define MSK_NX51_sample_mode_sample_0_negedge_mode         0x00000002U
#define SRT_NX51_sample_mode_sample_0_negedge_mode         1
#define DFLT_VAL_NX51_sample_mode_sample_0_negedge_mode    0x00000000U
#define DFLT_BF_VAL_NX51_sample_mode_sample_0_negedge_mode 0x00000000U
#define MSK_NX51_sample_mode_sample_1_posedge_mode         0x00000100U
#define SRT_NX51_sample_mode_sample_1_posedge_mode         8
#define DFLT_VAL_NX51_sample_mode_sample_1_posedge_mode    0x00000000U
#define DFLT_BF_VAL_NX51_sample_mode_sample_1_posedge_mode 0x00000000U
#define MSK_NX51_sample_mode_sample_1_negedge_mode         0x00000200U
#define SRT_NX51_sample_mode_sample_1_negedge_mode         9
#define DFLT_VAL_NX51_sample_mode_sample_1_negedge_mode    0x00000000U
#define DFLT_BF_VAL_NX51_sample_mode_sample_1_negedge_mode 0x00000000U

/* all used bits of 'NX51_sample_mode': */
#define MSK_USED_BITS_NX51_sample_mode 0x00000303U

enum {
	BFW_NX51_sample_mode_sample_0_posedge_mode = 1,  /* [0] */
	BFW_NX51_sample_mode_sample_0_negedge_mode = 1,  /* [1] */
	BFW_NX51_sample_mode_reserved1             = 6,  /* [7:2] */
	BFW_NX51_sample_mode_sample_1_posedge_mode = 1,  /* [8] */
	BFW_NX51_sample_mode_sample_1_negedge_mode = 1,  /* [9] */
	BFW_NX51_sample_mode_reserved2             = 22  /* [31:10] */
};

typedef struct NX51_SAMPLE_MODE_BIT_Ttag {
	unsigned int sample_0_posedge_mode : BFW_NX51_sample_mode_sample_0_posedge_mode; /* latch0 positive edge mode                                                                            */
	                                                                                 /* 0: continuous sampling 1: single sampling (latch status must be reset before latching enabled again) */
	unsigned int sample_0_negedge_mode : BFW_NX51_sample_mode_sample_0_negedge_mode; /* latch0 negative edge mode                                                                            */
	                                                                                 /* 0: continuous sampling 1: single sampling (latch status must be reset before latching enabled again) */
	unsigned int reserved1             : BFW_NX51_sample_mode_reserved1;             /* reserved                                                                                             */
	unsigned int sample_1_posedge_mode : BFW_NX51_sample_mode_sample_1_posedge_mode; /* latch1 positive edge mode                                                                            */
	                                                                                 /* 0: continuous sampling 1: single sampling (latch status must be reset before latching enabled again) */
	unsigned int sample_1_negedge_mode : BFW_NX51_sample_mode_sample_1_negedge_mode; /* latch1 negative edge mode                                                                            */
	                                                                                 /* 0: continuous sampling 1: single sampling (latch status must be reset before latching enabled again) */
	unsigned int reserved2             : BFW_NX51_sample_mode_reserved2;             /* reserved                                                                                             */
} NX51_SAMPLE_MODE_BIT_T;

typedef union {
	unsigned int           val;
	NX51_SAMPLE_MODE_BIT_T bf;
} NX51_SAMPLE_MODE_T;

/* --------------------------------------------------------------------- */
/* Register sample_0_pos_systime_ns */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sample_0_pos_systime_ns                 0x00000028U
#define Adr_NX51_trigger_sample_unit_sample_0_pos_systime_ns 0x1018BD28U
#define Adr_NX51_sample_0_pos_systime_ns                     0x1018BD28U
#define DFLT_VAL_NX51_sample_0_pos_systime_ns                0x00000000U

#define MSK_NX51_sample_0_pos_systime_ns_systime_ns         0xffffffffU
#define SRT_NX51_sample_0_pos_systime_ns_systime_ns         0
#define DFLT_VAL_NX51_sample_0_pos_systime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_sample_0_pos_systime_ns_systime_ns 0x00000000U

/* all used bits of 'NX51_sample_0_pos_systime_ns': */
#define MSK_USED_BITS_NX51_sample_0_pos_systime_ns 0xffffffffU

enum {
	BFW_NX51_sample_0_pos_systime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_SAMPLE_0_POS_SYSTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_sample_0_pos_systime_ns_systime_ns; /* systime_ns when posedge at latch 0 occurred */
} NX51_SAMPLE_0_POS_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_SAMPLE_0_POS_SYSTIME_NS_BIT_T bf;
} NX51_SAMPLE_0_POS_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register sample_0_neg_systime_ns */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sample_0_neg_systime_ns                 0x0000002CU
#define Adr_NX51_trigger_sample_unit_sample_0_neg_systime_ns 0x1018BD2CU
#define Adr_NX51_sample_0_neg_systime_ns                     0x1018BD2CU
#define DFLT_VAL_NX51_sample_0_neg_systime_ns                0x00000000U

#define MSK_NX51_sample_0_neg_systime_ns_systime_ns         0xffffffffU
#define SRT_NX51_sample_0_neg_systime_ns_systime_ns         0
#define DFLT_VAL_NX51_sample_0_neg_systime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_sample_0_neg_systime_ns_systime_ns 0x00000000U

/* all used bits of 'NX51_sample_0_neg_systime_ns': */
#define MSK_USED_BITS_NX51_sample_0_neg_systime_ns 0xffffffffU

enum {
	BFW_NX51_sample_0_neg_systime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_SAMPLE_0_NEG_SYSTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_sample_0_neg_systime_ns_systime_ns; /* systime_ns when posedge at latch 0 occurred */
} NX51_SAMPLE_0_NEG_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_SAMPLE_0_NEG_SYSTIME_NS_BIT_T bf;
} NX51_SAMPLE_0_NEG_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register sample_1_pos_systime_ns */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sample_1_pos_systime_ns                 0x00000030U
#define Adr_NX51_trigger_sample_unit_sample_1_pos_systime_ns 0x1018BD30U
#define Adr_NX51_sample_1_pos_systime_ns                     0x1018BD30U
#define DFLT_VAL_NX51_sample_1_pos_systime_ns                0x00000000U

#define MSK_NX51_sample_1_pos_systime_ns_systime_ns         0xffffffffU
#define SRT_NX51_sample_1_pos_systime_ns_systime_ns         0
#define DFLT_VAL_NX51_sample_1_pos_systime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_sample_1_pos_systime_ns_systime_ns 0x00000000U

/* all used bits of 'NX51_sample_1_pos_systime_ns': */
#define MSK_USED_BITS_NX51_sample_1_pos_systime_ns 0xffffffffU

enum {
	BFW_NX51_sample_1_pos_systime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_SAMPLE_1_POS_SYSTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_sample_1_pos_systime_ns_systime_ns; /* systime_ns when posedge at latch 1 occurred */
} NX51_SAMPLE_1_POS_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_SAMPLE_1_POS_SYSTIME_NS_BIT_T bf;
} NX51_SAMPLE_1_POS_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register sample_1_neg_systime_ns */
/* => r/w access by xPEC and ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sample_1_neg_systime_ns                 0x00000034U
#define Adr_NX51_trigger_sample_unit_sample_1_neg_systime_ns 0x1018BD34U
#define Adr_NX51_sample_1_neg_systime_ns                     0x1018BD34U
#define DFLT_VAL_NX51_sample_1_neg_systime_ns                0x00000000U

#define MSK_NX51_sample_1_neg_systime_ns_systime_ns         0xffffffffU
#define SRT_NX51_sample_1_neg_systime_ns_systime_ns         0
#define DFLT_VAL_NX51_sample_1_neg_systime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_sample_1_neg_systime_ns_systime_ns 0x00000000U

/* all used bits of 'NX51_sample_1_neg_systime_ns': */
#define MSK_USED_BITS_NX51_sample_1_neg_systime_ns 0xffffffffU

enum {
	BFW_NX51_sample_1_neg_systime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_SAMPLE_1_NEG_SYSTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_sample_1_neg_systime_ns_systime_ns; /* systime_ns when negedge at latch 1 occurred */
} NX51_SAMPLE_1_NEG_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_SAMPLE_1_NEG_SYSTIME_NS_BIT_T bf;
} NX51_SAMPLE_1_NEG_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register trigger_offset */
/* => r/w access by ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_trigger_offset                 0x00000038U
#define Adr_NX51_trigger_sample_unit_trigger_offset 0x1018BD38U
#define Adr_NX51_trigger_offset                     0x1018BD38U
#define DFLT_VAL_NX51_trigger_offset                0x00000000U

#define MSK_NX51_trigger_offset_trigger_offset         0xffffffffU
#define SRT_NX51_trigger_offset_trigger_offset         0
#define DFLT_VAL_NX51_trigger_offset_trigger_offset    0x00000000U
#define DFLT_BF_VAL_NX51_trigger_offset_trigger_offset 0x00000000U

/* all used bits of 'NX51_trigger_offset': */
#define MSK_USED_BITS_NX51_trigger_offset 0xffffffffU

enum {
	BFW_NX51_trigger_offset_trigger_offset = 32  /* [31:0] */
};

typedef struct NX51_TRIGGER_OFFSET_BIT_Ttag {
	unsigned int trigger_offset : BFW_NX51_trigger_offset_trigger_offset; /* trigger_offset offset register for NextSync0SysTime and NextSync1SysTime */
	                                                                      /* may only be != 0 when systime_border=0xffffffff                          */
} NX51_TRIGGER_OFFSET_BIT_T;

typedef union {
	unsigned int              val;
	NX51_TRIGGER_OFFSET_BIT_T bf;
} NX51_TRIGGER_OFFSET_T;

/* --------------------------------------------------------------------- */
/* Register sync1_interval */
/* => r/w access by ARM */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sync1_interval                 0x0000003CU
#define Adr_NX51_trigger_sample_unit_sync1_interval 0x1018BD3CU
#define Adr_NX51_sync1_interval                     0x1018BD3CU
#define DFLT_VAL_NX51_sync1_interval                0x00000000U

#define MSK_NX51_sync1_interval_sync1_interval         0x03ffffffU
#define SRT_NX51_sync1_interval_sync1_interval         0
#define DFLT_VAL_NX51_sync1_interval_sync1_interval    0x00000000U
#define DFLT_BF_VAL_NX51_sync1_interval_sync1_interval 0x00000000U

/* all used bits of 'NX51_sync1_interval': */
#define MSK_USED_BITS_NX51_sync1_interval 0x03ffffffU

enum {
	BFW_NX51_sync1_interval_sync1_interval = 26, /* [25:0] */
	BFW_NX51_sync1_interval_reserved1      = 6   /* [31:26] */
};

typedef struct NX51_SYNC1_INTERVAL_BIT_Ttag {
	unsigned int sync1_interval : BFW_NX51_sync1_interval_sync1_interval; /* sync1 intervall                     */
	                                                                      /* important: use multiple of 0xa (10) */
	unsigned int reserved1      : BFW_NX51_sync1_interval_reserved1;      /* reserved                            */
} NX51_SYNC1_INTERVAL_BIT_T;

typedef union {
	unsigned int              val;
	NX51_SYNC1_INTERVAL_BIT_T bf;
} NX51_SYNC1_INTERVAL_T;


/* ===================================================================== */

/* AREA buf_man */
/* Area of buf_man, buf_man_motion */

/* ===================================================================== */

#define Addr_NX51_buf_man        0x1018BE00U
#define Addr_NX51_buf_man_motion 0x10100600U

/* --------------------------------------------------------------------- */
/* Register buf_man_rpec0 */
/* => BMU port of 1st master (xPEC0): */
/*    This register address allows to access 16 buffer controllers, where each one handles buffer numbers (0..4) between up */
/*    to four processors. Due to the complex functionality in one register address, bits have different meaning depending on */
/*    request type and mode. */
/*    Getting a new buffer always happens with two command accesses: */
/*    1st: Write access: Tell the buf_manager the channel(s) (0..15) and whether you request read or write buffer. */
/*         Wait for two clock cycles, until new buffer number is calculated after any write access. */
/*    2nd: Read access: Read the buffer number (0..4). */
/*    This register is also accessible directly by xPEC0 with higher priority. Do not use this address, if xPEC0 uses the buffer manager. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_buf_man_rpec0            0x00000000U
#define Adr_NX51_buf_man_buf_man_rpec0        0x1018BE00U
#define Adr_NX51_buf_man_motion_buf_man_rpec0 0x10100600U
#define DFLT_VAL_NX51_buf_man_rpec0           0x00000007U

#define MSK_NX51_buf_man_rpec0_buf_nr                 0x0000000fU
#define SRT_NX51_buf_man_rpec0_buf_nr                 0
#define DFLT_VAL_NX51_buf_man_rpec0_buf_nr            0x00000007U
#define DFLT_BF_VAL_NX51_buf_man_rpec0_buf_nr         0x00000007U
#define MSK_NX51_buf_man_rpec0_req_type               0x00000060U
#define SRT_NX51_buf_man_rpec0_req_type               5
#define DFLT_VAL_NX51_buf_man_rpec0_req_type          0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec0_req_type       0x00000000U
#define MSK_NX51_buf_man_rpec0_semaphore_mode         0x00000080U
#define SRT_NX51_buf_man_rpec0_semaphore_mode         7
#define DFLT_VAL_NX51_buf_man_rpec0_semaphore_mode    0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec0_semaphore_mode 0x00000000U
#define MSK_NX51_buf_man_rpec0_parallel_mode          0x00000100U
#define SRT_NX51_buf_man_rpec0_parallel_mode          8
#define DFLT_VAL_NX51_buf_man_rpec0_parallel_mode     0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec0_parallel_mode  0x00000000U
#define MSK_NX51_buf_man_rpec0_reset                  0x00000200U
#define SRT_NX51_buf_man_rpec0_reset                  9
#define DFLT_VAL_NX51_buf_man_rpec0_reset             0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec0_reset          0x00000000U
#define MSK_NX51_buf_man_rpec0_sm_update_en           0x00000400U
#define SRT_NX51_buf_man_rpec0_sm_update_en           10
#define DFLT_VAL_NX51_buf_man_rpec0_sm_update_en      0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec0_sm_update_en   0x00000000U
#define MSK_NX51_buf_man_rpec0_sm_update_dis          0x00000800U
#define SRT_NX51_buf_man_rpec0_sm_update_dis          11
#define DFLT_VAL_NX51_buf_man_rpec0_sm_update_dis     0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec0_sm_update_dis  0x00000000U

/* all used bits of 'NX51_buf_man_rpec0': */
#define MSK_USED_BITS_NX51_buf_man_rpec0 0x00000fefU

enum {
	BFW_NX51_buf_man_rpec0_buf_nr         = 4,  /* [3:0] */
	BFW_NX51_buf_man_rpec0_reserved1      = 1,  /* [4] */
	BFW_NX51_buf_man_rpec0_req_type       = 2,  /* [6:5] */
	BFW_NX51_buf_man_rpec0_semaphore_mode = 1,  /* [7] */
	BFW_NX51_buf_man_rpec0_parallel_mode  = 1,  /* [8] */
	BFW_NX51_buf_man_rpec0_reset          = 1,  /* [9] */
	BFW_NX51_buf_man_rpec0_sm_update_en   = 1,  /* [10] */
	BFW_NX51_buf_man_rpec0_sm_update_dis  = 1,  /* [11] */
	BFW_NX51_buf_man_rpec0_reserved2      = 20  /* [31:12] */
};

typedef struct NX51_BUF_MAN_RPEC0_BIT_Ttag {
	unsigned int buf_nr         : BFW_NX51_buf_man_rpec0_buf_nr;         /* Write access: number of buf_manager controller (0..15)                                           */
	                                                                     /* Read access:  number of buffer (0..m+1), where m is the number of masters using this buf_manager */
	unsigned int reserved1      : BFW_NX51_buf_man_rpec0_reserved1;      /* reserved                                                                                         */
	unsigned int req_type       : BFW_NX51_buf_man_rpec0_req_type;       /* Request type bits are write-only:                                                                */
	                                                                     /* 00: request read buffer (or semaphore)                                                           */
	                                                                     /* 01: request write buffer (or release semaphore)                                                  */
	                                                                     /* 10: release write buffer (or release semaphore)                                                  */
	                                                                     /* 11: do not request new buffer or semaphore (used to only change channel)                         */
	unsigned int semaphore_mode : BFW_NX51_buf_man_rpec0_semaphore_mode; /* Activate 'semaphore mode' for this buf_nr by writing 1 to this bit.                              */
	                                                                     /* To return from semaphore-mode reset this channel.                                                */
	                                                                     /* In semaphore mode only buf_nr=0 (this master gets the semaphore) or                              */
	                                                                     /* buf_nr=7 (master does not get semaphore) are returned.                                           */
	                                                                     /* Requesting or releasing a semaphore (by req_type) is allowed while switching to semaphore mode.  */
	unsigned int parallel_mode  : BFW_NX51_buf_man_rpec0_parallel_mode;  /* Activate parallel mode by writing 1 to this bit (other bits are ignored).                        */
	                                                                     /* To return to normal mode, write 0xffff0000 to this register.                                     */
	                                                                     /* In parallel mode, the behaviour of all bits of this register changes completely.                 */
	                                                                     /* Parallel mode write access:                                                                      */
	                                                                     /* {       |                                                                                        */
	                                                                     /*  15.. 0: Request bits of all 16 channels:                                                        */
	                                                                     /*          1: request new buffer or semaphore.                                                     */
	                                                                     /*          0: don't request buffer or semaphore.                                                   */
	                                                                     /*  31..16: wr bits of all 16 channels:                                                             */
	                                                                     /*          1: request write buffer or semaphore.                                                   */
	                                                                     /*          0: request read buffer or semaphore.}                                                   */
	                                                                     /* Parallel mode read access:                                                                       */
	                                                                     /* {      |                                                                                         */
	                                                                     /*  1,0:   Actual buffer number of channel 0.                                                       */
	                                                                     /*   ...                                                                                            */
	                                                                     /*  31,30: Actual buffer number of channel 15.}                                                     */
	                                                                     /* In parallel mode, the number of masters is limited to 2, resulting in 3 buffers per channel.     */
	                                                                     /* In parallel mode, buffers cannot be released without requesting new buffer numbers.              */
	unsigned int reset          : BFW_NX51_buf_man_rpec0_reset;          /* Reset buf_manager controller of selected  channel (buf_nr).                                      */
	                                                                     /* This bit will automatically be reset.                                                            */
	unsigned int sm_update_en   : BFW_NX51_buf_man_rpec0_sm_update_en;   /* Activate SM_auto_update mode by writing 1 to this bit:                                           */
	                                                                     /* In SM_auto_update mode the requested buffer numbers of buffer managers 0..7 will automatically   */
	                                                                     /* be programmed to the FMMU_SM unit.                                                               */
	unsigned int sm_update_dis  : BFW_NX51_buf_man_rpec0_sm_update_dis;  /* De-activate SM_auto_update mode by writing 1 to this bit.                                        */
	unsigned int reserved2      : BFW_NX51_buf_man_rpec0_reserved2;      /* reserved                                                                                         */
} NX51_BUF_MAN_RPEC0_BIT_T;

typedef union {
	unsigned int             val;
	NX51_BUF_MAN_RPEC0_BIT_T bf;
} NX51_BUF_MAN_RPEC0_T;

/* --------------------------------------------------------------------- */
/* Register buf_man_rpec1 */
/* => BMU port of 2nd master (xPEC1): */
/*    This register address allows to access 16 buffer controllers, where each one handles buffer numbers (0..4) between up */
/*    to four processors. Due to the complex functionality in one register address, bits have different meaning depending on */
/*    request type and mode. */
/*    Getting a new buffer always happens with two command accesses: */
/*    1st: Write access: Tell the buf_manager the channel(s) (0..15) and whether you request read or write buffer. */
/*         Wait for two clock cycles, until new buffer number is calculated after any write access. */
/*    2nd: Read access: Read the buffer number (0..4). */
/*    This register is also accessible directly by xPEC1 with higher priority. Do not use this address, if xPEC1 uses the buffer manager. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_buf_man_rpec1            0x00000004U
#define Adr_NX51_buf_man_buf_man_rpec1        0x1018BE04U
#define Adr_NX51_buf_man_motion_buf_man_rpec1 0x10100604U
#define DFLT_VAL_NX51_buf_man_rpec1           0x00000007U

#define MSK_NX51_buf_man_rpec1_buf_nr                 0x0000000fU
#define SRT_NX51_buf_man_rpec1_buf_nr                 0
#define DFLT_VAL_NX51_buf_man_rpec1_buf_nr            0x00000007U
#define DFLT_BF_VAL_NX51_buf_man_rpec1_buf_nr         0x00000007U
#define MSK_NX51_buf_man_rpec1_req_type               0x00000060U
#define SRT_NX51_buf_man_rpec1_req_type               5
#define DFLT_VAL_NX51_buf_man_rpec1_req_type          0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec1_req_type       0x00000000U
#define MSK_NX51_buf_man_rpec1_semaphore_mode         0x00000080U
#define SRT_NX51_buf_man_rpec1_semaphore_mode         7
#define DFLT_VAL_NX51_buf_man_rpec1_semaphore_mode    0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec1_semaphore_mode 0x00000000U
#define MSK_NX51_buf_man_rpec1_parallel_mode          0x00000100U
#define SRT_NX51_buf_man_rpec1_parallel_mode          8
#define DFLT_VAL_NX51_buf_man_rpec1_parallel_mode     0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec1_parallel_mode  0x00000000U
#define MSK_NX51_buf_man_rpec1_reset                  0x00000200U
#define SRT_NX51_buf_man_rpec1_reset                  9
#define DFLT_VAL_NX51_buf_man_rpec1_reset             0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec1_reset          0x00000000U
#define MSK_NX51_buf_man_rpec1_sm_update_en           0x00000400U
#define SRT_NX51_buf_man_rpec1_sm_update_en           10
#define DFLT_VAL_NX51_buf_man_rpec1_sm_update_en      0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec1_sm_update_en   0x00000000U
#define MSK_NX51_buf_man_rpec1_sm_update_dis          0x00000800U
#define SRT_NX51_buf_man_rpec1_sm_update_dis          11
#define DFLT_VAL_NX51_buf_man_rpec1_sm_update_dis     0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_rpec1_sm_update_dis  0x00000000U

/* all used bits of 'NX51_buf_man_rpec1': */
#define MSK_USED_BITS_NX51_buf_man_rpec1 0x00000fefU

enum {
	BFW_NX51_buf_man_rpec1_buf_nr         = 4,  /* [3:0] */
	BFW_NX51_buf_man_rpec1_reserved1      = 1,  /* [4] */
	BFW_NX51_buf_man_rpec1_req_type       = 2,  /* [6:5] */
	BFW_NX51_buf_man_rpec1_semaphore_mode = 1,  /* [7] */
	BFW_NX51_buf_man_rpec1_parallel_mode  = 1,  /* [8] */
	BFW_NX51_buf_man_rpec1_reset          = 1,  /* [9] */
	BFW_NX51_buf_man_rpec1_sm_update_en   = 1,  /* [10] */
	BFW_NX51_buf_man_rpec1_sm_update_dis  = 1,  /* [11] */
	BFW_NX51_buf_man_rpec1_reserved2      = 20  /* [31:12] */
};

typedef struct NX51_BUF_MAN_RPEC1_BIT_Ttag {
	unsigned int buf_nr         : BFW_NX51_buf_man_rpec1_buf_nr;         /* Write access: number of buf_manager controller (0..15)                                           */
	                                                                     /* Read access:  number of buffer (0..m+1), where m is the number of masters using this buf_manager */
	unsigned int reserved1      : BFW_NX51_buf_man_rpec1_reserved1;      /* reserved                                                                                         */
	unsigned int req_type       : BFW_NX51_buf_man_rpec1_req_type;       /* Request type bits are write-only:                                                                */
	                                                                     /* 00: request read buffer (or semaphore)                                                           */
	                                                                     /* 01: request write buffer (or release semaphore)                                                  */
	                                                                     /* 10: release write buffer (or release semaphore)                                                  */
	                                                                     /* 11: do not request new buffer or semaphore (used to only change channel)                         */
	unsigned int semaphore_mode : BFW_NX51_buf_man_rpec1_semaphore_mode; /* Activate 'semaphore mode' for this buf_nr by writing 1 to this bit.                              */
	                                                                     /* To return from semaphore-mode reset this channel.                                                */
	                                                                     /* In semaphore mode only buf_nr=0 (this master gets the semaphore) or                              */
	                                                                     /* buf_nr=7 (master does not get semaphore) are returned.                                           */
	                                                                     /* Requesting or releasing a semaphore (by req_type) is allowed while switching to semaphore mode.  */
	unsigned int parallel_mode  : BFW_NX51_buf_man_rpec1_parallel_mode;  /* Activate parallel mode by writing 1 to this bit (other bits are ignored).                        */
	                                                                     /* To return to normal mode, write 0xffff0000 to this register.                                     */
	                                                                     /* In parallel mode, the behaviour of all bits of this register changes completely.                 */
	                                                                     /* Parallel mode write access:                                                                      */
	                                                                     /* {       |                                                                                        */
	                                                                     /*  15.. 0: Request bits of all 16 channels:                                                        */
	                                                                     /*          1: request new buffer or semaphore.                                                     */
	                                                                     /*          0: don't request buffer or semaphore.                                                   */
	                                                                     /*  31..16: wr bits of all 16 channels:                                                             */
	                                                                     /*          1: request write buffer or semaphore.                                                   */
	                                                                     /*          0: request read buffer or semaphore.}                                                   */
	                                                                     /* Parallel mode read access:                                                                       */
	                                                                     /* {      |                                                                                         */
	                                                                     /*  1,0:   Actual buffer number of channel 0.                                                       */
	                                                                     /*   ...                                                                                            */
	                                                                     /*  31,30: Actual buffer number of channel 15.}                                                     */
	                                                                     /* In parallel mode, the number of masters is limited to 2, resulting in 3 buffers per channel.     */
	                                                                     /* In parallel mode, buffers cannot be released without requesting new buffer numbers.              */
	unsigned int reset          : BFW_NX51_buf_man_rpec1_reset;          /* Reset buf_manager controller of selected  channel (buf_nr).                                      */
	                                                                     /* This bit will automatically be reset.                                                            */
	unsigned int sm_update_en   : BFW_NX51_buf_man_rpec1_sm_update_en;   /* Activate SM_auto_update mode by writing 1 to this bit:                                           */
	                                                                     /* In SM_auto_update mode the requested buffer numbers of buffer managers 0..7 will automatically   */
	                                                                     /* be programmed to the FMMU_SM unit.                                                               */
	unsigned int sm_update_dis  : BFW_NX51_buf_man_rpec1_sm_update_dis;  /* De-activate SM_auto_update mode by writing 1 to this bit.                                        */
	unsigned int reserved2      : BFW_NX51_buf_man_rpec1_reserved2;      /* reserved                                                                                         */
} NX51_BUF_MAN_RPEC1_BIT_T;

typedef union {
	unsigned int             val;
	NX51_BUF_MAN_RPEC1_BIT_T bf;
} NX51_BUF_MAN_RPEC1_T;

/* --------------------------------------------------------------------- */
/* Register buf_man */
/* => BMU-port of 3rd master (intlogic address area) or 4th master (intlogic-motion address area): */
/*    This register address allows to access 16 buffer controllers, where each one handles buffer numbers (0..4) between up */
/*    to four processors. Due to the complex functionality in one register address, bits have different meaning depending on */
/*    request type and mode. */
/*    Getting a new buffer always happens with two command accesses: */
/*    1st: Write access: Tell the buf_manager the channel(s) (0..15) and whether you request read or write buffer. */
/*         Wait for two clock cycles, until new buffer number is calculated after any write access. */
/*    2nd: Read access: Read the buffer number (0..4). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_buf_man            0x00000008U
#define Adr_NX51_buf_man_buf_man        0x1018BE08U
#define Adr_NX51_buf_man_motion_buf_man 0x10100608U
#define DFLT_VAL_NX51_buf_man           0x00000007U

#define MSK_NX51_buf_man_buf_nr                 0x0000000fU
#define SRT_NX51_buf_man_buf_nr                 0
#define DFLT_VAL_NX51_buf_man_buf_nr            0x00000007U
#define DFLT_BF_VAL_NX51_buf_man_buf_nr         0x00000007U
#define MSK_NX51_buf_man_req_type               0x00000060U
#define SRT_NX51_buf_man_req_type               5
#define DFLT_VAL_NX51_buf_man_req_type          0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_req_type       0x00000000U
#define MSK_NX51_buf_man_semaphore_mode         0x00000080U
#define SRT_NX51_buf_man_semaphore_mode         7
#define DFLT_VAL_NX51_buf_man_semaphore_mode    0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_semaphore_mode 0x00000000U
#define MSK_NX51_buf_man_parallel_mode          0x00000100U
#define SRT_NX51_buf_man_parallel_mode          8
#define DFLT_VAL_NX51_buf_man_parallel_mode     0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_parallel_mode  0x00000000U
#define MSK_NX51_buf_man_reset                  0x00000200U
#define SRT_NX51_buf_man_reset                  9
#define DFLT_VAL_NX51_buf_man_reset             0x00000000U
#define DFLT_BF_VAL_NX51_buf_man_reset          0x00000000U

/* all used bits of 'NX51_buf_man': */
#define MSK_USED_BITS_NX51_buf_man 0x000003efU

enum {
	BFW_NX51_buf_man_buf_nr         = 4,  /* [3:0] */
	BFW_NX51_buf_man_reserved1      = 1,  /* [4] */
	BFW_NX51_buf_man_req_type       = 2,  /* [6:5] */
	BFW_NX51_buf_man_semaphore_mode = 1,  /* [7] */
	BFW_NX51_buf_man_parallel_mode  = 1,  /* [8] */
	BFW_NX51_buf_man_reset          = 1,  /* [9] */
	BFW_NX51_buf_man_reserved2      = 22  /* [31:10] */
};

typedef struct NX51_BUF_MAN_BIT_Ttag {
	unsigned int buf_nr         : BFW_NX51_buf_man_buf_nr;         /* Write access: number of buf_manager controller (0..15)                                           */
	                                                               /* Read access:  number of buffer (0..m+1), where m is the number of masters using this buf_manager */
	unsigned int reserved1      : BFW_NX51_buf_man_reserved1;      /* reserved                                                                                         */
	unsigned int req_type       : BFW_NX51_buf_man_req_type;       /* Request type bits are write-only:                                                                */
	                                                               /* 00: request read buffer (or semaphore)                                                           */
	                                                               /* 01: request write buffer (or release semaphore)                                                  */
	                                                               /* 10: release write buffer (or release semaphore)                                                  */
	                                                               /* 11: do not request new buffer or semaphore (used to only change channel)                         */
	unsigned int semaphore_mode : BFW_NX51_buf_man_semaphore_mode; /* Activate 'semaphore mode' for this buf_nr by writing 1 to this bit.                              */
	                                                               /* To return from semaphore-mode reset this channel.                                                */
	                                                               /* In semaphore mode only buf_nr=0 (this master gets the semaphore) or                              */
	                                                               /* buf_nr=7 (master does not get semaphore) are returned.                                           */
	                                                               /* Requesting or releasing a semaphore (by req_type) is allowed while switching to semaphore mode.  */
	unsigned int parallel_mode  : BFW_NX51_buf_man_parallel_mode;  /* Activate parallel mode by writing 1 to this bit (other bits are ignored).                        */
	                                                               /* To return to normal mode, write 0xffff0000 to this register.                                     */
	                                                               /* In parallel mode, the behaviour of all bits of this register changes completely.                 */
	                                                               /* Parallel mode write access:                                                                      */
	                                                               /* {       |                                                                                        */
	                                                               /*  15.. 0: Request bits of all 16 channels:                                                        */
	                                                               /*          1: request new buffer or semaphore.                                                     */
	                                                               /*          0: don't request buffer or semaphore.                                                   */
	                                                               /*  31..16: wr bits of all 16 channels:                                                             */
	                                                               /*          1: request write buffer or semaphore.                                                   */
	                                                               /*          0: request read buffer or semaphore.}                                                   */
	                                                               /* Parallel mode read access:                                                                       */
	                                                               /* {      |                                                                                         */
	                                                               /*  1,0:   Actual buffer number of channel 0.                                                       */
	                                                               /*   ...                                                                                            */
	                                                               /*  31,30: Actual buffer number of channel 15.}                                                     */
	                                                               /* In parallel mode, the number of masters is limited to 2, resulting in 3 buffers per channel.     */
	                                                               /* In parallel mode, buffers cannot be released without requesting new buffer numbers.              */
	unsigned int reset          : BFW_NX51_buf_man_reset;          /* Reset buf_manager controller of selected  channel (buf_nr).                                      */
	                                                               /* This bit will automatically be reset.                                                            */
	unsigned int reserved2      : BFW_NX51_buf_man_reserved2;      /* reserved                                                                                         */
} NX51_BUF_MAN_BIT_T;

typedef union {
	unsigned int       val;
	NX51_BUF_MAN_BIT_T bf;
} NX51_BUF_MAN_T;


/* ===================================================================== */

/* Area of xpec_irq_registers */

/* ===================================================================== */

#define Addr_NX51_xpec_irq_registers 0x1018BE20U

/* --------------------------------------------------------------------- */
/* Register irq_xpec0 */
/* => IRQ_RPEC 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_irq_xpec0                0x00000000U
#define Adr_NX51_xpec_irq_registers_irq_xpec0 0x1018BE20U
#define Adr_NX51_irq_xpec0                    0x1018BE20U
#define DFLT_VAL_NX51_irq_xpec0               0x00000000U

#define MSK_NX51_irq_xpec0_rtpec0_irq         0x0000ffffU
#define SRT_NX51_irq_xpec0_rtpec0_irq         0
#define DFLT_VAL_NX51_irq_xpec0_rtpec0_irq    0x00000000U
#define DFLT_BF_VAL_NX51_irq_xpec0_rtpec0_irq 0x00000000U
#define MSK_NX51_irq_xpec0_arm_irq            0xffff0000U
#define SRT_NX51_irq_xpec0_arm_irq            16
#define DFLT_VAL_NX51_irq_xpec0_arm_irq       0x00000000U
#define DFLT_BF_VAL_NX51_irq_xpec0_arm_irq    0x00000000U

/* all used bits of 'NX51_irq_xpec0': */
#define MSK_USED_BITS_NX51_irq_xpec0 0xffffffffU

enum {
	BFW_NX51_irq_xpec0_rtpec0_irq = 16, /* [15:0] */
	BFW_NX51_irq_xpec0_arm_irq    = 16  /* [31:16] */
};

typedef struct NX51_IRQ_XPEC0_BIT_Ttag {
	unsigned int rtpec0_irq : BFW_NX51_irq_xpec0_rtpec0_irq; /* set by xpec ; reset by arm */
	unsigned int arm_irq    : BFW_NX51_irq_xpec0_arm_irq;    /* set by arm  ; reset by xec */
} NX51_IRQ_XPEC0_BIT_T;

typedef union {
	unsigned int         val;
	NX51_IRQ_XPEC0_BIT_T bf;
} NX51_IRQ_XPEC0_T;

/* --------------------------------------------------------------------- */
/* Register irq_xpec1 */
/* => IRQ_TPEC 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_irq_xpec1                0x00000004U
#define Adr_NX51_xpec_irq_registers_irq_xpec1 0x1018BE24U
#define Adr_NX51_irq_xpec1                    0x1018BE24U
#define DFLT_VAL_NX51_irq_xpec1               0x00000000U

#define MSK_NX51_irq_xpec1_rtpec1_irq         0x0000ffffU
#define SRT_NX51_irq_xpec1_rtpec1_irq         0
#define DFLT_VAL_NX51_irq_xpec1_rtpec1_irq    0x00000000U
#define DFLT_BF_VAL_NX51_irq_xpec1_rtpec1_irq 0x00000000U
#define MSK_NX51_irq_xpec1_arm_irq            0xffff0000U
#define SRT_NX51_irq_xpec1_arm_irq            16
#define DFLT_VAL_NX51_irq_xpec1_arm_irq       0x00000000U
#define DFLT_BF_VAL_NX51_irq_xpec1_arm_irq    0x00000000U

/* all used bits of 'NX51_irq_xpec1': */
#define MSK_USED_BITS_NX51_irq_xpec1 0xffffffffU

enum {
	BFW_NX51_irq_xpec1_rtpec1_irq = 16, /* [15:0] */
	BFW_NX51_irq_xpec1_arm_irq    = 16  /* [31:16] */
};

typedef struct NX51_IRQ_XPEC1_BIT_Ttag {
	unsigned int rtpec1_irq : BFW_NX51_irq_xpec1_rtpec1_irq; /* set by xpec ; reset by arm  */
	unsigned int arm_irq    : BFW_NX51_irq_xpec1_arm_irq;    /* set by arm  ; reset by xpec */
} NX51_IRQ_XPEC1_BIT_T;

typedef union {
	unsigned int         val;
	NX51_IRQ_XPEC1_BIT_T bf;
} NX51_IRQ_XPEC1_T;


/* ===================================================================== */

/* Area of xc_debug */

/* ===================================================================== */

#define Addr_NX51_xc_debug 0x1018BE30U

/* --------------------------------------------------------------------- */
/* Register xc_debug_config */
/* => config XC debug module */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xc_debug_config      0x00000000U
#define Adr_NX51_xc_debug_xc_debug_config 0x1018BE30U
#define Adr_NX51_xc_debug_config          0x1018BE30U
#define DFLT_VAL_NX51_xc_debug_config     0x00000000U

#define MSK_NX51_xc_debug_config_select_xpec          0x00000003U
#define SRT_NX51_xc_debug_config_select_xpec          0
#define DFLT_VAL_NX51_xc_debug_config_select_xpec     0x00000000U
#define DFLT_BF_VAL_NX51_xc_debug_config_select_xpec  0x00000000U
#define MSK_NX51_xc_debug_config_debug_enable         0x80000000U
#define SRT_NX51_xc_debug_config_debug_enable         31
#define DFLT_VAL_NX51_xc_debug_config_debug_enable    0x00000000U
#define DFLT_BF_VAL_NX51_xc_debug_config_debug_enable 0x00000000U

/* all used bits of 'NX51_xc_debug_config': */
#define MSK_USED_BITS_NX51_xc_debug_config 0x80000003U

enum {
	BFW_NX51_xc_debug_config_select_xpec  = 2,  /* [1:0] */
	BFW_NX51_xc_debug_config_reserved1    = 29, /* [30:2] */
	BFW_NX51_xc_debug_config_debug_enable = 1   /* [31] */
};

typedef struct NX51_XC_DEBUG_CONFIG_BIT_Ttag {
	unsigned int select_xpec  : BFW_NX51_xc_debug_config_select_xpec;  /*  (00 = rpec0, 01 = tpec0, 10 = rpec1, 11 = tpec1) default 0x0 */
	unsigned int reserved1    : BFW_NX51_xc_debug_config_reserved1;    /* reserved                                                      */
	unsigned int debug_enable : BFW_NX51_xc_debug_config_debug_enable; /* default 0x0                                                   */
} NX51_XC_DEBUG_CONFIG_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XC_DEBUG_CONFIG_BIT_T bf;
} NX51_XC_DEBUG_CONFIG_T;


/* ===================================================================== */

/* Area of xc_start_stop */

/* ===================================================================== */

#define Addr_NX51_xc_start_stop 0x1018BE40U

/* --------------------------------------------------------------------- */
/* Register xc_start_stop_ctrl */
/* => Start / Stop Register for XC CPUs (rPECs / tPECs / xMACs) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xc_start_stop_ctrl           0x00000000U
#define Adr_NX51_xc_start_stop_xc_start_stop_ctrl 0x1018BE40U
#define Adr_NX51_xc_start_stop_ctrl               0x1018BE40U
#define DFLT_VAL_NX51_xc_start_stop_ctrl          0x00000000U

#define MSK_NX51_xc_start_stop_ctrl_start_rpec0         0x00000001U
#define SRT_NX51_xc_start_stop_ctrl_start_rpec0         0
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_rpec0    0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_rpec0 0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_start_tpec0         0x00000002U
#define SRT_NX51_xc_start_stop_ctrl_start_tpec0         1
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_tpec0    0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_tpec0 0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_start_rpu0          0x00000004U
#define SRT_NX51_xc_start_stop_ctrl_start_rpu0          2
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_rpu0     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_rpu0  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_start_tpu0          0x00000008U
#define SRT_NX51_xc_start_stop_ctrl_start_tpu0          3
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_tpu0     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_tpu0  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_start_rpec1         0x00000010U
#define SRT_NX51_xc_start_stop_ctrl_start_rpec1         4
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_rpec1    0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_rpec1 0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_start_tpec1         0x00000020U
#define SRT_NX51_xc_start_stop_ctrl_start_tpec1         5
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_tpec1    0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_tpec1 0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_start_rpu1          0x00000040U
#define SRT_NX51_xc_start_stop_ctrl_start_rpu1          6
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_rpu1     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_rpu1  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_start_tpu1          0x00000080U
#define SRT_NX51_xc_start_stop_ctrl_start_tpu1          7
#define DFLT_VAL_NX51_xc_start_stop_ctrl_start_tpu1     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_start_tpu1  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_rpec0          0x00010000U
#define SRT_NX51_xc_start_stop_ctrl_stop_rpec0          16
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_rpec0     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_rpec0  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_tpec0          0x00020000U
#define SRT_NX51_xc_start_stop_ctrl_stop_tpec0          17
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_tpec0     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_tpec0  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_rpu0           0x00040000U
#define SRT_NX51_xc_start_stop_ctrl_stop_rpu0           18
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_rpu0      0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_rpu0   0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_tpu0           0x00080000U
#define SRT_NX51_xc_start_stop_ctrl_stop_tpu0           19
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_tpu0      0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_tpu0   0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_rpec1          0x00100000U
#define SRT_NX51_xc_start_stop_ctrl_stop_rpec1          20
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_rpec1     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_rpec1  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_tpec1          0x00200000U
#define SRT_NX51_xc_start_stop_ctrl_stop_tpec1          21
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_tpec1     0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_tpec1  0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_rpu1           0x00400000U
#define SRT_NX51_xc_start_stop_ctrl_stop_rpu1           22
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_rpu1      0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_rpu1   0x00000000U
#define MSK_NX51_xc_start_stop_ctrl_stop_tpu1           0x00800000U
#define SRT_NX51_xc_start_stop_ctrl_stop_tpu1           23
#define DFLT_VAL_NX51_xc_start_stop_ctrl_stop_tpu1      0x00000000U
#define DFLT_BF_VAL_NX51_xc_start_stop_ctrl_stop_tpu1   0x00000000U

/* all used bits of 'NX51_xc_start_stop_ctrl': */
#define MSK_USED_BITS_NX51_xc_start_stop_ctrl 0x00ff00ffU

enum {
	BFW_NX51_xc_start_stop_ctrl_start_rpec0 = 1, /* [0] */
	BFW_NX51_xc_start_stop_ctrl_start_tpec0 = 1, /* [1] */
	BFW_NX51_xc_start_stop_ctrl_start_rpu0  = 1, /* [2] */
	BFW_NX51_xc_start_stop_ctrl_start_tpu0  = 1, /* [3] */
	BFW_NX51_xc_start_stop_ctrl_start_rpec1 = 1, /* [4] */
	BFW_NX51_xc_start_stop_ctrl_start_tpec1 = 1, /* [5] */
	BFW_NX51_xc_start_stop_ctrl_start_rpu1  = 1, /* [6] */
	BFW_NX51_xc_start_stop_ctrl_start_tpu1  = 1, /* [7] */
	BFW_NX51_xc_start_stop_ctrl_reserved1   = 8, /* [15:8] */
	BFW_NX51_xc_start_stop_ctrl_stop_rpec0  = 1, /* [16] */
	BFW_NX51_xc_start_stop_ctrl_stop_tpec0  = 1, /* [17] */
	BFW_NX51_xc_start_stop_ctrl_stop_rpu0   = 1, /* [18] */
	BFW_NX51_xc_start_stop_ctrl_stop_tpu0   = 1, /* [19] */
	BFW_NX51_xc_start_stop_ctrl_stop_rpec1  = 1, /* [20] */
	BFW_NX51_xc_start_stop_ctrl_stop_tpec1  = 1, /* [21] */
	BFW_NX51_xc_start_stop_ctrl_stop_rpu1   = 1, /* [22] */
	BFW_NX51_xc_start_stop_ctrl_stop_tpu1   = 1, /* [23] */
	BFW_NX51_xc_start_stop_ctrl_reserved2   = 8  /* [31:24] */
};

typedef struct NX51_XC_START_STOP_CTRL_BIT_Ttag {
	unsigned int start_rpec0 : BFW_NX51_xc_start_stop_ctrl_start_rpec0; /* write '1' to start */
	unsigned int start_tpec0 : BFW_NX51_xc_start_stop_ctrl_start_tpec0; /* write '1' to start */
	unsigned int start_rpu0  : BFW_NX51_xc_start_stop_ctrl_start_rpu0;  /* write '1' to start */
	unsigned int start_tpu0  : BFW_NX51_xc_start_stop_ctrl_start_tpu0;  /* write '1' to start */
	unsigned int start_rpec1 : BFW_NX51_xc_start_stop_ctrl_start_rpec1; /* write '1' to start */
	unsigned int start_tpec1 : BFW_NX51_xc_start_stop_ctrl_start_tpec1; /* write '1' to start */
	unsigned int start_rpu1  : BFW_NX51_xc_start_stop_ctrl_start_rpu1;  /* write '1' to start */
	unsigned int start_tpu1  : BFW_NX51_xc_start_stop_ctrl_start_tpu1;  /* write '1' to start */
	unsigned int reserved1   : BFW_NX51_xc_start_stop_ctrl_reserved1;   /* reserved           */
	unsigned int stop_rpec0  : BFW_NX51_xc_start_stop_ctrl_stop_rpec0;  /* write '1' to stop  */
	unsigned int stop_tpec0  : BFW_NX51_xc_start_stop_ctrl_stop_tpec0;  /* write '1' to stop  */
	unsigned int stop_rpu0   : BFW_NX51_xc_start_stop_ctrl_stop_rpu0;   /* write '1' to stop  */
	unsigned int stop_tpu0   : BFW_NX51_xc_start_stop_ctrl_stop_tpu0;   /* write '1' to stop  */
	unsigned int stop_rpec1  : BFW_NX51_xc_start_stop_ctrl_stop_rpec1;  /* write '1' to stop  */
	unsigned int stop_tpec1  : BFW_NX51_xc_start_stop_ctrl_stop_tpec1;  /* write '1' to stop  */
	unsigned int stop_rpu1   : BFW_NX51_xc_start_stop_ctrl_stop_rpu1;   /* write '1' to stop  */
	unsigned int stop_tpu1   : BFW_NX51_xc_start_stop_ctrl_stop_tpu1;   /* write '1' to stop  */
	unsigned int reserved2   : BFW_NX51_xc_start_stop_ctrl_reserved2;   /* reserved           */
} NX51_XC_START_STOP_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XC_START_STOP_CTRL_BIT_T bf;
} NX51_XC_START_STOP_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register xc_hold_status */
/* => Hold Status Register for XC CPUs (rPECs / tPECs / xMACs) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xc_hold_status           0x00000004U
#define Adr_NX51_xc_start_stop_xc_hold_status 0x1018BE44U
#define Adr_NX51_xc_hold_status               0x1018BE44U

#define MSK_NX51_xc_hold_status_hold_rpec0 0x00000001U
#define SRT_NX51_xc_hold_status_hold_rpec0 0
#define MSK_NX51_xc_hold_status_hold_tpec0 0x00000002U
#define SRT_NX51_xc_hold_status_hold_tpec0 1
#define MSK_NX51_xc_hold_status_hold_rpu0  0x00000004U
#define SRT_NX51_xc_hold_status_hold_rpu0  2
#define MSK_NX51_xc_hold_status_hold_tpu0  0x00000008U
#define SRT_NX51_xc_hold_status_hold_tpu0  3
#define MSK_NX51_xc_hold_status_hold_rpec1 0x00000010U
#define SRT_NX51_xc_hold_status_hold_rpec1 4
#define MSK_NX51_xc_hold_status_hold_tpec1 0x00000020U
#define SRT_NX51_xc_hold_status_hold_tpec1 5
#define MSK_NX51_xc_hold_status_hold_rpu1  0x00000040U
#define SRT_NX51_xc_hold_status_hold_rpu1  6
#define MSK_NX51_xc_hold_status_hold_tpu1  0x00000080U
#define SRT_NX51_xc_hold_status_hold_tpu1  7

/* all used bits of 'NX51_xc_hold_status': */
#define MSK_USED_BITS_NX51_xc_hold_status 0x000000ffU

enum {
	BFW_NX51_xc_hold_status_hold_rpec0 = 1,  /* [0] */
	BFW_NX51_xc_hold_status_hold_tpec0 = 1,  /* [1] */
	BFW_NX51_xc_hold_status_hold_rpu0  = 1,  /* [2] */
	BFW_NX51_xc_hold_status_hold_tpu0  = 1,  /* [3] */
	BFW_NX51_xc_hold_status_hold_rpec1 = 1,  /* [4] */
	BFW_NX51_xc_hold_status_hold_tpec1 = 1,  /* [5] */
	BFW_NX51_xc_hold_status_hold_rpu1  = 1,  /* [6] */
	BFW_NX51_xc_hold_status_hold_tpu1  = 1,  /* [7] */
	BFW_NX51_xc_hold_status_reserved1  = 24  /* [31:8] */
};

typedef struct NX51_XC_HOLD_STATUS_BIT_Ttag {
	unsigned int hold_rpec0 : BFW_NX51_xc_hold_status_hold_rpec0; /* '1' cpu is in hold */
	unsigned int hold_tpec0 : BFW_NX51_xc_hold_status_hold_tpec0; /* '1' cpu is in hold */
	unsigned int hold_rpu0  : BFW_NX51_xc_hold_status_hold_rpu0;  /* '1' cpu is in hold */
	unsigned int hold_tpu0  : BFW_NX51_xc_hold_status_hold_tpu0;  /* '1' cpu is in hold */
	unsigned int hold_rpec1 : BFW_NX51_xc_hold_status_hold_rpec1; /* '1' cpu is in hold */
	unsigned int hold_tpec1 : BFW_NX51_xc_hold_status_hold_tpec1; /* '1' cpu is in hold */
	unsigned int hold_rpu1  : BFW_NX51_xc_hold_status_hold_rpu1;  /* '1' cpu is in hold */
	unsigned int hold_tpu1  : BFW_NX51_xc_hold_status_hold_tpu1;  /* '1' cpu is in hold */
	unsigned int reserved1  : BFW_NX51_xc_hold_status_reserved1;  /* reserved           */
} NX51_XC_HOLD_STATUS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_XC_HOLD_STATUS_BIT_T bf;
} NX51_XC_HOLD_STATUS_T;


/* ===================================================================== */

/* Area of dpm */

/* ===================================================================== */

#define Addr_NX51_dpm 0x1018C000U

/* --------------------------------------------------------------------- */
/* Register dpm_cfg0x0 */
/* => DPM IO Control Register 0. */
/*    This register is accessible in any DPM-mode (8, 16, 32 bit, SRAM, Intel, Motorola, little endian, big endian) by access to DPM address 0. */
/*    Basic DPM settings are configurable here to make higher addresses accessible. */
/*    To avoid instable system configurations, global changes of important configuration registers must be confirmed */
/*    (re)writing 'mode' bit field of this register. View 'mode' description for details. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_cfg0x0  0x00000000U
#define Adr_NX51_dpm_dpm_cfg0x0  0x1018C000U
#define Adr_NX51_dpm_cfg0x0      0x1018C000U
#define DFLT_VAL_NX51_dpm_cfg0x0 0x00000000U

#define MSK_NX51_dpm_cfg0x0_mode           0x0000000fU
#define SRT_NX51_dpm_cfg0x0_mode           0
#define DFLT_VAL_NX51_dpm_cfg0x0_mode      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_cfg0x0_mode   0x00000000U
#define MSK_NX51_dpm_cfg0x0_endian         0x00000030U
#define SRT_NX51_dpm_cfg0x0_endian         4
#define DFLT_VAL_NX51_dpm_cfg0x0_endian    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_cfg0x0_endian 0x00000000U

/* all used bits of 'NX51_dpm_cfg0x0': */
#define MSK_USED_BITS_NX51_dpm_cfg0x0 0x0000003fU

enum {
	BFW_NX51_dpm_cfg0x0_mode      = 4,  /* [3:0] */
	BFW_NX51_dpm_cfg0x0_endian    = 2,  /* [5:4] */
	BFW_NX51_dpm_cfg0x0_reserved1 = 26  /* [31:6] */
};

typedef struct NX51_DPM_CFG0X0_BIT_Ttag {
	unsigned int mode      : BFW_NX51_dpm_cfg0x0_mode;      /* Basic DPM interface mode:                                                                               */
	                                                        /* Additionally writing to this bit field will confirm global interface configuration changes:             */
	                                                        /* Interface configuration can not always be written one single access (e.g. in 8 bit data mode            */
	                                                        /* changing of 'dpm_if_cfg' is not possible in one single access as there are more than 8 bits             */
	                                                        /* for congifuration). However changing interface configuration by more than one single access could       */
	                                                        /* lead to instable interfaces. This is avoided by following procedure:                                    */
	                                                        /* For proper interface configuration, values of important interface configuration                         */
	                                                        /* registers are buffered in temporary registers first. Interface configuration is changed                 */
	                                                        /* finaly by (re)writing 'mode' bits. There is no need to realy change a prior programmed 'mode'           */
	                                                        /* setting, interface change is done when low byte of this registers is target of a write acceess.         */
	                                                        /* Temporary registers which must be confirmed by this are:                                                */
	                                                        /* - All bits of 'dpm_if_cfg' register.                                                                    */
	                                                        /* - Address compartor configuration: All 'addr_cmp_a*' bit fields in 'dpm_addr_cfg' register.             */
	                                                        /* Note:                                                                                                   */
	                                                        /*    Interface configuration confirm must be done regardless wether programmed by host via                */
	                                                        /*    external interfaces or by internal ARM via internal INTLOGIC configuration channel.                  */
	                                                        /* DPM interface mode must be further configured in 'dpm_if_cfg' register. Data width and                  */
	                                                        /* address multiplexing mode must be configure here.                                                       */
	                                                        /* Supported basic DPM modes are:                                                                          */
	                                                        /* {     |                                                                                                 */
	                                                        /*  0000  8 bit data non multiplexed mode.                                                                 */
	                                                        /*        DPM_D7..0 are used as data lines, DPM_D31..8 can be used as PIOs (+24 PIOs).                     */
	                                                        /*        DPM_D17 can be used as Address-Enable DPM_AEN/DPM_ALE.                                           */
	                                                        /*  0001  reserved.                                                                                        */
	                                                        /*  0010  8 bit data multiplexed mode.                                                                     */
	                                                        /*        DPM_D7..0 are used as address and data lines, DPM_D17 as ALE.                                    */
	                                                        /*        DPM_A7..0 and DPM_D31..8 can be used as PIOs (+31 PIOs).                                         */
	                                                        /*        DPM_A10..8 will used as address lines.                                                           */
	                                                        /*        DPM_A19..11 can used as address lines (depending on selectde 'addr_range'.                       */
	                                                        /*        High address lines will be sampled at the same time when lower address bits are                  */
	                                                        /*        latched from DPM_D7..0.                                                                          */
	                                                        /*  0011  reserved.                                                                                        */
	                                                        /*  0100  16 bit data non multiplexed mode.                                                                */
	                                                        /*        DPM_D15..0 are used as data lines, DPM_D31..16 can be used as PIOs (+16 PIOs).                   */
	                                                        /*        DPM_D17 can be used as Address-Enable DPM_AEN/DPM_ALE.                                           */
	                                                        /*  0101  reserved.                                                                                        */
	                                                        /*  0110  16 bit data multiplexed mode with 2 byte-enables on separated lines.                             */
	                                                        /*        DPM_D15..0 are used as address and data lines, DPM_D17 as ALE.                                   */
	                                                        /*        DPM_A15..0 and DPM_D31..16 can be used as PIOs (+31 PIOs).                                       */
	                                                        /*        Two byte-enable signals can be used additionally. View register 'dpm_if_cfg' 'be_sel'.           */
	                                                        /*        DPM_A19..16 can used as address lines (depending on selectde 'addr_range'.                       */
	                                                        /*        High address lines will be sampled at the same time when lower address bits are                  */
	                                                        /*        latched from DPM_D15..0.                                                                         */
	                                                        /*  0111  reserved                                                                                         */
	                                                        /*  1000  32 bit data non multiplexed mode.                                                                */
	                                                        /*        DPM_D0..32 are used as data lines.                                                               */
	                                                        /*        DPM_A15 or DPM_AH1 can be used as Address-Enable DPM_AEN/DPM_ALE.                                */
	                                                        /*  1001  reserved.                                                                                        */
	                                                        /*  1010  32 bit data multiplexed mode with 4 byte-enables on separated lines.                             */
	                                                        /*        DPM_D31..0 are used as address and data lines, DPM_A15 or DPM_AH1 as ALE.                        */
	                                                        /*        Four byte-enable signals can be used additionally. View register 'dpm_if_cfg' 'be_sel'.          */
	                                                        /*    :   reserved.                                                                                        */
	                                                        /*  1111  reserved.}                                                                                       */
	                                                        /* Note:                                                                                                   */
	                                                        /*    For DPM modes with less than 32 bit data, write data could not written immediate to netX memory or   */
	                                                        /*    registers ('byte_area' and 'dis_rd_latch' of 'dpm_win1_map' register).                               */
	unsigned int endian    : BFW_NX51_dpm_cfg0x0_endian;    /* Endianess of 32 bit (DWord) address alignment (B0: least significant byte, B3: most significant byte):  */
	                                                        /* {      |                     |      |      |      |                                                     */
	                                                        /*  coding   Address               A+3    A+2    A+1    A+0                                                */
	                                                        /*    00     little endian         B3     B2     B1     B0                                                 */
	                                                        /*    01     16 bit big endian     B2     B3     B0     B1                                                 */
	                                                        /*    10     32 bit big endian     B0     B1     B2     B3                                                 */
	                                                        /*    11     reserved                                        }                                             */
	                                                        /* Little endian is used netX inside. If big endian host device is used, set to this 01 or 10 according to */
	                                                        /* host device data width.                                                                                 */
	unsigned int reserved1 : BFW_NX51_dpm_cfg0x0_reserved1; /* reserved                                                                                                */
} NX51_DPM_CFG0X0_BIT_T;

typedef union {
	unsigned int          val;
	NX51_DPM_CFG0X0_BIT_T bf;
} NX51_DPM_CFG0X0_T;

/* --------------------------------------------------------------------- */
/* Register dpm_if_cfg */
/* => DPM interface configuration register. */
/*    DPM interface mode must be basically configured in 'dpm_cfg0x0' register. Interface configuration is */
/*    split up into two registers to support setup from external host CPU when DPM is in 8 bit non-multiplexed default mode after reset. */
/*    However this does not work for all interfaces. E.g. for modes where DPM_WRN is not write trigger this is not */
/*    possible. Interface setup must be done by netX internal CPU then. */
/*    To avoid instable system configurations, changes of this registers must be confirmed */
/*    (re)writing 'mode' bit field of dpm_cfg0x0 register. View 'mode' description there for details. */
/*    {                                      |         |         |         |         |         |           |       |        |        |          | */
/*      Host connection                       isa_bhe3   cs_ctrl   addr_sh   aen_pol   aen_sel   be_wr       be_rd   be_pol   be_sel   dir_ctrl   cfg_0x0.mode */
/*                                            memcs16n                                           _dis        _dis */
/*      Intel, 8bit (SRAM)                          0         0         x         x        0       x           x       x         0         0         0x0 */
/*      Intel, 16bit,byte-write                     0         0         0         x        0       0           1       0         1         1         0x4 */
/*      Intel, 16bit,byte-enable (SRAM)             0         0         0         x        0       0           0       0         0         0         0x4 */
/*      Intel, 32bit,byte-write                     0         0         0         x        0       0           1       0         0         1         0x8 */
/*      Intel, 32bit,byte-enable (SRAM)             0         0         0         x        0       0           0       0         0         0         0x8 */
/*      Intel, 8bit multiplexed                     0         0         x         1        1       x           x       x         0         0         0x2 */
/*      Intel, 16bit mul. netx50: no BEs            0         0         0         1        1       1           1       x         0         0         0x6 */
/*      Intel, 16bit mul. byte-write                0         0         1         1        1       0           1       0         1         1         0x6 */
/*      Intel, 16bit mul. 2BEs, byte-addr           0         0         0         1        1       0           0       0         0         0         0x6 */
/*      Intel, 16bit mul. 2BEs, word-addr           0         0         1         1        1       0           0       0         0         0         0x6 */
/*      Intel, 32bit mul. netx50: byte-addr         0         0         0         1        1       0           1       0         0         1         0xa */
/*      Intel, 32bit mul. byte-write DWord-addr     0         0         1         1        1       0           1       0         0         1         0xa */
/*      Intel, 32bit mul. 4BEs, byte-addr           0         0         0         1        1       0           0       0         0         0         0xa */
/*      Intel, 32bit mul. 4BEs, DWord-addr          0         0         1         1        1       0           0       0         0         0         0xa */
/*      TI OMAP, 16bit non-multiplexed              0         0         0         x        0       0           0       0         0         0         0x4 */
/*      TI OMAP, 16bit multiplexed                  0         0         1         0        1       0           0       0         0         0         0x6 */
/*      Motorola, 8bit (6800)                       0         0         x         x        0       0           0       1         1         2         0x0 */
/*      Motorola, 16bit                             0         0         0         x        0       0           0       0         0         2         0x4 */
/*      Motorola, 16bit (68000)                     0         0         0         0        1       0           0       0         0         2         0x4 */
/*      Motorola, 32bit                             0         0         0         x        0       0           0       0         0         2         0x8 */
/*      Motorola, 8bit multiplexed                  0         0         x         x        0       0           0       1         1         2         0x2 */
/*      Motorola, 16bit mul.netx50: byte-addr       0         0         0         1        1       0           0       0         0         2         0x6 */
/*      Motorola, 16bit mul.word-addr               0         0         1         1        1       0           0       0         0         2         0x6 */
/*      Motorola, 32bit mul.netx50: byte-addr       0         0         0         1        1       0           0       0         0         2         0xa */
/*      Motorola, 32bit mul.DWord-addr              0         0         1         1        1       0           0       0         0         2         0xa */
/*      ISA, 8bit                                   0         4         x         0        1       0           0       0         0         0         0x0 */
/*      ISA, 16bit                                  1         4         0         0        1       0           0       0         0         0         0x4} */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_if_cfg  0x00000004U
#define Adr_NX51_dpm_dpm_if_cfg  0x1018C004U
#define Adr_NX51_dpm_if_cfg      0x1018C004U
#define DFLT_VAL_NX51_dpm_if_cfg 0x00000000U

#define MSK_NX51_dpm_if_cfg_dir_ctrl                     0x00000003U
#define SRT_NX51_dpm_if_cfg_dir_ctrl                     0
#define DFLT_VAL_NX51_dpm_if_cfg_dir_ctrl                0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_dir_ctrl             0x00000000U
#define MSK_NX51_dpm_if_cfg_be_sel                       0x00000010U
#define SRT_NX51_dpm_if_cfg_be_sel                       4
#define DFLT_VAL_NX51_dpm_if_cfg_be_sel                  0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_be_sel               0x00000000U
#define MSK_NX51_dpm_if_cfg_be_rd_dis                    0x00000040U
#define SRT_NX51_dpm_if_cfg_be_rd_dis                    6
#define DFLT_VAL_NX51_dpm_if_cfg_be_rd_dis               0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_be_rd_dis            0x00000000U
#define MSK_NX51_dpm_if_cfg_be_wr_dis                    0x00000080U
#define SRT_NX51_dpm_if_cfg_be_wr_dis                    7
#define DFLT_VAL_NX51_dpm_if_cfg_be_wr_dis               0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_be_wr_dis            0x00000000U
#define MSK_NX51_dpm_if_cfg_be_pol                       0x00000f00U
#define SRT_NX51_dpm_if_cfg_be_pol                       8
#define DFLT_VAL_NX51_dpm_if_cfg_be_pol                  0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_be_pol               0x00000000U
#define MSK_NX51_dpm_if_cfg_aen_sel                      0x00003000U
#define SRT_NX51_dpm_if_cfg_aen_sel                      12
#define DFLT_VAL_NX51_dpm_if_cfg_aen_sel                 0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_aen_sel              0x00000000U
#define MSK_NX51_dpm_if_cfg_aen_pol                      0x00004000U
#define SRT_NX51_dpm_if_cfg_aen_pol                      14
#define DFLT_VAL_NX51_dpm_if_cfg_aen_pol                 0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_aen_pol              0x00000000U
#define MSK_NX51_dpm_if_cfg_addr_sh                      0x00008000U
#define SRT_NX51_dpm_if_cfg_addr_sh                      15
#define DFLT_VAL_NX51_dpm_if_cfg_addr_sh                 0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_addr_sh              0x00000000U
#define MSK_NX51_dpm_if_cfg_cs_ctrl                      0x00070000U
#define SRT_NX51_dpm_if_cfg_cs_ctrl                      16
#define DFLT_VAL_NX51_dpm_if_cfg_cs_ctrl                 0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_cs_ctrl              0x00000000U
#define MSK_NX51_dpm_if_cfg_isa_bhe3_is_memcs16n         0x01000000U
#define SRT_NX51_dpm_if_cfg_isa_bhe3_is_memcs16n         24
#define DFLT_VAL_NX51_dpm_if_cfg_isa_bhe3_is_memcs16n    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_if_cfg_isa_bhe3_is_memcs16n 0x00000000U

/* all used bits of 'NX51_dpm_if_cfg': */
#define MSK_USED_BITS_NX51_dpm_if_cfg 0x0107ffd3U

enum {
	BFW_NX51_dpm_if_cfg_dir_ctrl             = 2, /* [1:0] */
	BFW_NX51_dpm_if_cfg_reserved1            = 2, /* [3:2] */
	BFW_NX51_dpm_if_cfg_be_sel               = 1, /* [4] */
	BFW_NX51_dpm_if_cfg_reserved2            = 1, /* [5] */
	BFW_NX51_dpm_if_cfg_be_rd_dis            = 1, /* [6] */
	BFW_NX51_dpm_if_cfg_be_wr_dis            = 1, /* [7] */
	BFW_NX51_dpm_if_cfg_be_pol               = 4, /* [11:8] */
	BFW_NX51_dpm_if_cfg_aen_sel              = 2, /* [13:12] */
	BFW_NX51_dpm_if_cfg_aen_pol              = 1, /* [14] */
	BFW_NX51_dpm_if_cfg_addr_sh              = 1, /* [15] */
	BFW_NX51_dpm_if_cfg_cs_ctrl              = 3, /* [18:16] */
	BFW_NX51_dpm_if_cfg_reserved3            = 5, /* [23:19] */
	BFW_NX51_dpm_if_cfg_isa_bhe3_is_memcs16n = 1, /* [24] */
	BFW_NX51_dpm_if_cfg_reserved4            = 7  /* [31:25] */
};

typedef struct NX51_DPM_IF_CFG_BIT_Ttag {
	unsigned int dir_ctrl             : BFW_NX51_dpm_if_cfg_dir_ctrl;             /* DPM access direction control.                                                                                      */
	                                                                              /*  00: dedicated low active read- and write control signals (RDn + WRn) with optional byte-enables.                  */
	                                                                              /*      byte-enables have address character i.e. they must be stable while read- or write-control                     */
	                                                                              /*      signal is active. byte-enables are not used as Strobe signals.                                                */
	                                                                              /*      A read-access is started when RDn signal becomes active low at access start. Address, Chip-Select and         */
	                                                                              /*      byte-enable signals must be stable then.                                                                      */
	                                                                              /*      A write-access is done when WRn becomes inactive high at access end. Address, Chip-Select, data and           */
	                                                                              /*      byte-enable signals must be stable then.                                                                      */
	                                                                              /*      Ready/Busy signal is asserted when RDn or WRn is active.                                                      */
	                                                                              /*      This setting can be used for standard SRAM interfaces.                                                        */
	                                                                              /*  01: RDn is direction signal nRW (signal high: write, low: read).                                                  */
	                                                                              /*      For read byte-enables have address character i.e. they must be stable when RDn becomes low.                   */
	                                                                              /*      For write byte-enables have strobe character i.e. Address, Data and RDn must be stable when they              */
	                                                                              /*      become inactive at access end..                                                                               */
	                                                                              /*      A read-access is started when RDn signal becomes low at access start. Address, Chip-Select and                */
	                                                                              /*      byte-enable signals must be stable then.                                                                      */
	                                                                              /*      A write-access is done when byte-enables becomes inactive at access end. Address, Chip-Select, data and       */
	                                                                              /*      RDn signals must be stable then.                                                                              */
	                                                                              /*      Ready/Busy signal is asserted when RDn is low or byte-enables are active.                                     */
	                                                                              /*      This setting is typically used for Intel-like interfaces with Byte-Write-Strope signals..                     */
	                                                                              /*  10: RDn is direction signal nWR (signal low: write, high: read).                                                  */
	                                                                              /*      byte-enables have strobe character for both read and write i.e. Address, and RDn must be stable when they     */
	                                                                              /*      become active at access start. These signals must remain stable until byte-enables become inactive            */
	                                                                              /*      at access end. For write data must be stable then.                                                            */
	                                                                              /*      Ready/Busy signal is asserted when at least one byte-enables is active.                                       */
	                                                                              /*      This setting is typically used for Motorola-like interfaces with Byte-Write-Strope signals.                   */
	unsigned int reserved1            : BFW_NX51_dpm_if_cfg_reserved1;            /* reserved                                                                                                           */
	unsigned int be_sel               : BFW_NX51_dpm_if_cfg_be_sel;               /* DPM access byte-enable signal selection.                                                                           */
	                                                                              /* byte-enables can located on different netX IOs - netx50 compatibility.                                             */
	                                                                              /* Basically BE signals depend on selected data width (cfg0x0).                                                       */
	                                                                              /* {        |            |          |          |         |                                                            */
	                                                                              /*  setting   data width   D[31:24]   D[23:16]   D[15:8]   D[7:0]                                                     */
	                                                                              /*        0     8bit                                            -                                                     */
	                                                                              /*        0    16bit                               BHE1n       A0                                                     */
	                                                                              /*        0    32bit         BHE3n          A1     BHE1n       A0                                                     */
	                                                                              /*  --------------------------------------------------------------                                                    */
	                                                                              /*        1     8bit                                        BHE1n                                                     */
	                                                                              /*        1    16bit                               BHE3n      WRn                                                     */
	                                                                              /*        1    32bit         BHE3n          A1     BHE1n       A0}                                                    */
	                                                                              /* For 32 bit data interfaces only following byte-enable combinatzions are valid - others                             */
	                                                                              /* will cause unpredictable behaviour (na: not active):                                                               */
	                                                                              /* {            |           |          |          |                                                                   */
	                                                                              /*       BE3         BE2        BE1        BE0      netX internal write access width                                  */
	                                                                              /*     active      active     active     active     32 bit access to 32 bit word address                              */
	                                                                              /*     active      active       na         na       16 bit access to 32 bit word address + 2                          */
	                                                                              /*       na          na       active     active     16 bit access to 32 bit word address                              */
	                                                                              /*     active        na         na         na       8 bit access to 32 bit word address + 3                           */
	                                                                              /*       na         active      na         na       8 bit access to 32 bit word address + 2                           */
	                                                                              /*       na          na       active       na       8 bit access to 32 bit word address + 1                           */
	                                                                              /*       na          na         na       active     8 bit access to 32 bit word address                               */
	                                                                              /*       na          na         na         na       access ignored}                                                   */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    Target address in table above is related to little endianess. Offsets inside a 32 bit                           */
	                                                                              /*    data word will be different for other endianess settings (view 'dpm_cfg0x0' register).                          */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    For 8 bit data modes this bit must only be set when an additional                                               */
	                                                                              /*    byte-enable Signal is required (e.g. Motorola 6800). Do not set 'be_sel' and ignore                             */
	                                                                              /*    for read and write (be_wr_dis, be_rd_dis) - DPM Ready geneartion will care                                      */
	                                                                              /*    for BHE1n anyhow.                                                                                               */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    This bit is irrelevant for 32 bit data modes.                                                                   */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    Internal read access data width is always 32 bit.                                                               */
	unsigned int reserved2            : BFW_NX51_dpm_if_cfg_reserved2;            /* reserved                                                                                                           */
	unsigned int be_rd_dis            : BFW_NX51_dpm_if_cfg_be_rd_dis;            /* DPM read access byte-enable configuration.                                                                         */
	                                                                              /*   0: byte-enables will be used on read access, only data lines of enabled bytes will be driven.                    */
	                                                                              /*   1: byte-enables will be ignored on read access, all used data lines will be driven.                              */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    Do not set this bit when 'dir_ctrl' is set to nRW-mode ('10'). Byte-Write-Strobes are essentially in this case. */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    This bit is ignored for 8 bit data modes when 'be_sel' bit is not set.                                          */
	unsigned int be_wr_dis            : BFW_NX51_dpm_if_cfg_be_wr_dis;            /* DPM write access byte-enable configuration.                                                                        */
	                                                                              /*   0: byte-enables will be used on write access, only data lines of enabled bytes will be written.                  */
	                                                                              /*   1: byte-enables will be ignored on write access, all used data lines will be written.                            */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    Do not set this bit when 'dir_ctrl' is set to nWR-mode ('01'). Byte-Write-Strobes are essentially in this case. */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    This bit is ignored for 8 bit data modes when 'be_sel' bit is not set.                                          */
	unsigned int be_pol               : BFW_NX51_dpm_if_cfg_be_pol;               /* DPM access byte-enable active level polarity.                                                                      */
	                                                                              /* byte-enable active polarity can be set for each data byte separately. byte-enable signals                          */
	                                                                              /* can be selected by 'be_sel'.                                                                                       */
	                                                                              /* Bits inside this bit field are associated as follows:                                                              */
	                                                                              /* {            |                                                                                                     */
	                                                                              /*   Bit         data lines                                                                                           */
	                                                                              /*   be_pol[0]       D[7:0]                                                                                           */
	                                                                              /*   be_pol[1]      D[15:8]                                                                                           */
	                                                                              /*   be_pol[2]     D[23:16]                                                                                           */
	                                                                              /*   be_pol[3]     D[31:24]}                                                                                          */
	                                                                              /* Function:                                                                                                          */
	                                                                              /*   0: BE signals are low active byte-enables.                                                                       */
	                                                                              /*   1: BE signals are high active byte-enables (e.g. 8 bit Motorola 6800).                                           */
	unsigned int aen_sel              : BFW_NX51_dpm_if_cfg_aen_sel;              /* Address-Enable (AEN-modes) or Address-Latch-Enable (multiplexed modes) Control.                                    */
	                                                                              /*  00: No additional Address controlling function.                                                                   */
	                                                                              /*  01: netx50 compatibe Address controlling signal selection:                                                        */
	                                                                              /*      For 8 or 16 bit data modes: AEN on DPM_D17.                                                                   */
	                                                                              /*      For 32 bit data modes: AEN on HIF_A15 (up to 32kB address space for non-multiplexed modes).                   */
	                                                                              /*  10: Not netx50 compatibe Address controlling signal selection for 32 bit data modes:                              */
	                                                                              /*      For 8 or 16 bit data modes identically to setting '01': AEN on DPM_D17.                                       */
	                                                                              /*      For 32 bit data modes: AEN on HIF_AHI1 (up to 128kB address space for non-multiplexed modes).                 */
	                                                                              /*  11: reserved.                                                                                                     */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    In multiplexed modes read or write access will not be started netX internally while address-phase               */
	                                                                              /*    is active. ALE signal must return to idle state first.                                                          */
	unsigned int aen_pol              : BFW_NX51_dpm_if_cfg_aen_pol;              /* Address-Enable active level polarity.                                                                              */
	                                                                              /*   0: Address is latched while ALE-signal is low (i.e. low active ALE/AEN).                                         */
	                                                                              /*   1: Address is latched while ALE-signal is high (i.e. high active ALE/AEN).                                       */
	                                                                              /* In non-multiplexed modes, address is only latched when chip-select is additionally active (as programmed           */
	                                                                              /* in 'cs_ctrl').                                                                                                     */
	                                                                              /* In multiplexed modes, address latching is not controlled by chip-select. Address is latched all time               */
	                                                                              /* when ALE is active then.                                                                                           */
	unsigned int addr_sh              : BFW_NX51_dpm_if_cfg_addr_sh;              /* Address is Byte address or shifted according to selected data size.                                                */
	                                                                              /* This bit is irrelevant in 8 bit data modes. Address comparator logic works always with unshifted                   */
	                                                                              /* address.                                                                                                           */
	                                                                              /* {  |                                                                                                               */
	                                                                              /*   0 Address is always Byte address (not shifted).                                                                  */
	                                                                              /*     In 16 bit data modes: Address bit 0 can be used as low byte-enable or can be ignored.                          */
	                                                                              /*     In 32 bit data modes: Address bits 1,0 can be used as byte-enables or can be ignored.                          */
	                                                                              /*     Use 'be_sel' to select byte-enables and 'be_wr_dis' or 'be_rd_dis' to ignore them.                             */
	                                                                              /*   1 Address is shifted according to programmed data width.                                                         */
	                                                                              /*     In 16 bit data modes: Address from host starting at A0 (or AD0 when multiplexed ) is 16 bit word address.      */
	                                                                              /*     In 32 bit data modes: Address from host starting at A0 (or AD0 when multiplexed ) is 32 bit word address.}     */
	unsigned int cs_ctrl              : BFW_NX51_dpm_if_cfg_cs_ctrl;              /* Chip-Select controlling.                                                                                           */
	                                                                              /* Chip access can be additionally controlled for all settings by address comparator. View                            */
	                                                                              /* 'addr_cmp_a*' bit fields of 'dpm_addr_cfg' register.                                                               */
	                                                                              /*  000:     Use 1 low active Chip-Select signal (DPM_CSN).                                                           */
	                                                                              /*  001:     Use 2 low active Chip-Select signals (DPM_CSN or DPM_BHE1n must be low).                                 */
	                                                                              /*  010:     Use high active Chip-Select signal (DPM_CSN).                                                            */
	                                                                              /*  011:     Use 2 low active Chip-Select signals (DPM_CSN or DPM_BHE1n must be high).                                */
	                                                                              /*  100:     No Chip-Select signal. Behaves like DPM_CSN is permanent active.                                         */
	                                                                              /*  111:     Chip access is disabled. Address comparator is ignored.                                                  */
	                                                                              /*  others:  reserved                                                                                                 */
	                                                                              /* Note:                                                                                                              */
	                                                                              /*    Internal address-comparator is part of netX DPM Chip-Select decoding logic. View 'addr_cmp_a*' bit fields       */
	                                                                              /*    of 'dpm_addr_cfg' register. Set address comparator mask to '0' to disable.                                      */
	unsigned int reserved3            : BFW_NX51_dpm_if_cfg_reserved3;            /* reserved                                                                                                           */
	unsigned int isa_bhe3_is_memcs16n : BFW_NX51_dpm_if_cfg_isa_bhe3_is_memcs16n; /* ISA usage of BHE3 signal.                                                                                          */
	                                                                              /* Warning:                                                                                                           */
	                                                                              /*    ISA memcs16n signal is an ISA slave output signal. I.e. it is drive by netX when this bit                       */
	                                                                              /*    is enabled. This could cause permanent damage to netX or host when interface is not ISA.                        */
	                                                                              /* Settings:                                                                                                          */
	                                                                              /*   0: BHE3 is used as byte-enable or PIO and input by default.                                                      */
	                                                                              /*   1: BHE3 is used as ISA memcs16n signal and driven by netX.                                                       */
	                                                                              /*      Signal is driven low when DPM is selected by Chip-Select decoding logic (cs_ctrl) and                         */
	                                                                              /*      16 bit data mode is selected. Signal is never driven active high. High level is reached                       */
	                                                                              /*      by external pull up resistor.                                                                                 */
	unsigned int reserved4            : BFW_NX51_dpm_if_cfg_reserved4;            /* reserved                                                                                                           */
} NX51_DPM_IF_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_DPM_IF_CFG_BIT_T bf;
} NX51_DPM_IF_CFG_T;

/* --------------------------------------------------------------------- */
/* Register dpm_pio_cfg0 */
/* => DPM PIO Configuration Register0. */
/*    Signals to be used as PIOs when netX DPM is active must be selected here or in 'dpm_pio_cfg1' register. Since netx51 */
/*    PIO function will not be automatically activated depending on other settings. E.g. DPM_D31..8 can not be used */
/*    automatically when 8 bit data mode is selected. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_pio_cfg0  0x00000008U
#define Adr_NX51_dpm_dpm_pio_cfg0  0x1018C008U
#define Adr_NX51_dpm_pio_cfg0      0x1018C008U
#define DFLT_VAL_NX51_dpm_pio_cfg0 0x00000000U

#define MSK_NX51_dpm_pio_cfg0_sel_d_pio         0xffffffffU
#define SRT_NX51_dpm_pio_cfg0_sel_d_pio         0
#define DFLT_VAL_NX51_dpm_pio_cfg0_sel_d_pio    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg0_sel_d_pio 0x00000000U

/* all used bits of 'NX51_dpm_pio_cfg0': */
#define MSK_USED_BITS_NX51_dpm_pio_cfg0 0xffffffffU

enum {
	BFW_NX51_dpm_pio_cfg0_sel_d_pio = 32  /* [31:0] */
};

typedef struct NX51_DPM_PIO_CFG0_BIT_Ttag {
	unsigned int sel_d_pio : BFW_NX51_dpm_pio_cfg0_sel_d_pio; /* Use related DPM_D-pin as PIO pin. */
} NX51_DPM_PIO_CFG0_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_PIO_CFG0_BIT_T bf;
} NX51_DPM_PIO_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register dpm_pio_cfg1 */
/* => DPM PIO Configuration Register1. */
/*    PIO usage of DPM_SIRQ, DPM_DIRQ and DPM_RDY has moved from 'dpm_io_cfg_misc' to this register since netx51. */
/*    Signals to be used as PIOs when netX DPM is active must be selected here or in 'dpm_pio_cfg0' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_pio_cfg1  0x0000000CU
#define Adr_NX51_dpm_dpm_pio_cfg1  0x1018C00CU
#define Adr_NX51_dpm_pio_cfg1      0x1018C00CU
#define DFLT_VAL_NX51_dpm_pio_cfg1 0xe0000000U

#define MSK_NX51_dpm_pio_cfg1_sel_a_pio            0x000fffffU
#define SRT_NX51_dpm_pio_cfg1_sel_a_pio            0
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_a_pio       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_a_pio    0x00000000U
#define MSK_NX51_dpm_pio_cfg1_sel_bhe1_pio         0x01000000U
#define SRT_NX51_dpm_pio_cfg1_sel_bhe1_pio         24
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_bhe1_pio    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_bhe1_pio 0x00000000U
#define MSK_NX51_dpm_pio_cfg1_sel_bhe3_pio         0x02000000U
#define SRT_NX51_dpm_pio_cfg1_sel_bhe3_pio         25
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_bhe3_pio    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_bhe3_pio 0x00000000U
#define MSK_NX51_dpm_pio_cfg1_sel_csn_pio          0x04000000U
#define SRT_NX51_dpm_pio_cfg1_sel_csn_pio          26
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_csn_pio     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_csn_pio  0x00000000U
#define MSK_NX51_dpm_pio_cfg1_sel_rdn_pio          0x08000000U
#define SRT_NX51_dpm_pio_cfg1_sel_rdn_pio          27
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_rdn_pio     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_rdn_pio  0x00000000U
#define MSK_NX51_dpm_pio_cfg1_sel_wrn_pio          0x10000000U
#define SRT_NX51_dpm_pio_cfg1_sel_wrn_pio          28
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_wrn_pio     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_wrn_pio  0x00000000U
#define MSK_NX51_dpm_pio_cfg1_sel_rdy_pio          0x20000000U
#define SRT_NX51_dpm_pio_cfg1_sel_rdy_pio          29
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_rdy_pio     0x20000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_rdy_pio  0x00000001U
#define MSK_NX51_dpm_pio_cfg1_sel_dirq_pio         0x40000000U
#define SRT_NX51_dpm_pio_cfg1_sel_dirq_pio         30
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_dirq_pio    0x40000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_dirq_pio 0x00000001U
#define MSK_NX51_dpm_pio_cfg1_sel_sirq_pio         0x80000000U
#define SRT_NX51_dpm_pio_cfg1_sel_sirq_pio         31
#define DFLT_VAL_NX51_dpm_pio_cfg1_sel_sirq_pio    0x80000000U
#define DFLT_BF_VAL_NX51_dpm_pio_cfg1_sel_sirq_pio 0x00000001U

/* all used bits of 'NX51_dpm_pio_cfg1': */
#define MSK_USED_BITS_NX51_dpm_pio_cfg1 0xff0fffffU

enum {
	BFW_NX51_dpm_pio_cfg1_sel_a_pio    = 20, /* [19:0] */
	BFW_NX51_dpm_pio_cfg1_reserved1    = 4,  /* [23:20] */
	BFW_NX51_dpm_pio_cfg1_sel_bhe1_pio = 1,  /* [24] */
	BFW_NX51_dpm_pio_cfg1_sel_bhe3_pio = 1,  /* [25] */
	BFW_NX51_dpm_pio_cfg1_sel_csn_pio  = 1,  /* [26] */
	BFW_NX51_dpm_pio_cfg1_sel_rdn_pio  = 1,  /* [27] */
	BFW_NX51_dpm_pio_cfg1_sel_wrn_pio  = 1,  /* [28] */
	BFW_NX51_dpm_pio_cfg1_sel_rdy_pio  = 1,  /* [29] */
	BFW_NX51_dpm_pio_cfg1_sel_dirq_pio = 1,  /* [30] */
	BFW_NX51_dpm_pio_cfg1_sel_sirq_pio = 1   /* [31] */
};

typedef struct NX51_DPM_PIO_CFG1_BIT_Ttag {
	unsigned int sel_a_pio    : BFW_NX51_dpm_pio_cfg1_sel_a_pio;    /* Use related DPM_A-pin as PIO pin.                                                            */
	                                                                /* Note:                                                                                        */
	                                                                /*    PIO selects for DPM_A19..18 are only used for test purpose here. To select PIO function   */
	                                                                /*    of high DPM_A lines which are multiplexed on DPM_D23..22 use related bits of 'sel_d_pio'  */
	                                                                /*    Bit field in 'dpm_pio_cfg0' register. DPM_A17..16 are treated in the same way in netx50   */
	                                                                /*    compatibility mode (located on DPM_D21..20 then). However they are located on HIF_AHI1..0 */
	                                                                /*    when netx50 compatibility is globally disabled (ASIC_CTRL-area).                          */
	unsigned int reserved1    : BFW_NX51_dpm_pio_cfg1_reserved1;    /* reserved                                                                                     */
	unsigned int sel_bhe1_pio : BFW_NX51_dpm_pio_cfg1_sel_bhe1_pio; /* Use DPM_BHE1-pin as PIO pin.                                                                 */
	unsigned int sel_bhe3_pio : BFW_NX51_dpm_pio_cfg1_sel_bhe3_pio; /* Use DPM_BHE3-pin as PIO pin.                                                                 */
	unsigned int sel_csn_pio  : BFW_NX51_dpm_pio_cfg1_sel_csn_pio;  /* Use DPM_CSN-pin as PIO pin.                                                                  */
	unsigned int sel_rdn_pio  : BFW_NX51_dpm_pio_cfg1_sel_rdn_pio;  /* Use DPM_RDN-pin as PIO pin.                                                                  */
	unsigned int sel_wrn_pio  : BFW_NX51_dpm_pio_cfg1_sel_wrn_pio;  /* Use DPM_WRN-pin as PIO pin.                                                                  */
	unsigned int sel_rdy_pio  : BFW_NX51_dpm_pio_cfg1_sel_rdy_pio;  /* Use DPM_RDY-pin as PIO pin. RDY is by default PIO to avoid RDY-conflicts during reset.       */
	unsigned int sel_dirq_pio : BFW_NX51_dpm_pio_cfg1_sel_dirq_pio; /* Use DPM_DIRQ-pin as PIO pin.                                                                 */
	                                                                /* Note:                                                                                        */
	                                                                /*    For serial DPM this bit is related to netX51 IO HIF_D12. Setting of for HIF_D12           */
	                                                                /*    inside 'dpm_pio_cfg0 register is ignored then. I.e. this bit must be programmed           */
	                                                                /*    to '0' for DPM_DIRQ/IRQ usage regardless whether serial or parallel DPM is used.          */
	unsigned int sel_sirq_pio : BFW_NX51_dpm_pio_cfg1_sel_sirq_pio; /* Use DPM_SIRQ-pin as PIO pin.                                                                 */
	                                                                /* Note:                                                                                        */
	                                                                /*    For serial DPM this bit is related to netX51 IO HIF_D13. Setting of for HIF_D13           */
	                                                                /*    inside 'dpm_pio_cfg0 register is ignored then. I.e. this bit must be programmed           */
	                                                                /*    to '0' for DPM_SIRQ/FIQ usage regardless whether serial or parallel DPM is used.          */
} NX51_DPM_PIO_CFG1_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_PIO_CFG1_BIT_T bf;
} NX51_DPM_PIO_CFG1_T;

/* --------------------------------------------------------------------- */
/* Register dpm_addr_cfg */
/* => DPM External Address Configuration Register. */
/*    Note: */
/*       Address compare logic as part of netX DPM Chip-Select decoding logic is a new netx51 feature. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_addr_cfg  0x00000010U
#define Adr_NX51_dpm_dpm_addr_cfg  0x1018C010U
#define Adr_NX51_dpm_addr_cfg      0x1018C010U
#define DFLT_VAL_NX51_dpm_addr_cfg 0x00000002U

#define MSK_NX51_dpm_addr_cfg_addr_range               0x0000000fU
#define SRT_NX51_dpm_addr_cfg_addr_range               0
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_range          0x00000002U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_range       0x00000002U
#define MSK_NX51_dpm_addr_cfg_cfg_win_addr_cfg         0x00000030U
#define SRT_NX51_dpm_addr_cfg_cfg_win_addr_cfg         4
#define DFLT_VAL_NX51_dpm_addr_cfg_cfg_win_addr_cfg    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_cfg_win_addr_cfg 0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a11             0x0000c000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a11             14
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a11        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a11     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a12             0x00030000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a12             16
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a12        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a12     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a13             0x000c0000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a13             18
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a13        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a13     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a14             0x00300000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a14             20
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a14        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a14     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a15             0x00c00000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a15             22
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a15        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a15     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a16             0x03000000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a16             24
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a16        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a16     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a17             0x0c000000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a17             26
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a17        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a17     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a18             0x30000000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a18             28
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a18        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a18     0x00000000U
#define MSK_NX51_dpm_addr_cfg_addr_cmp_a19             0xc0000000U
#define SRT_NX51_dpm_addr_cfg_addr_cmp_a19             30
#define DFLT_VAL_NX51_dpm_addr_cfg_addr_cmp_a19        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_addr_cfg_addr_cmp_a19     0x00000000U

/* all used bits of 'NX51_dpm_addr_cfg': */
#define MSK_USED_BITS_NX51_dpm_addr_cfg 0xffffc03fU

enum {
	BFW_NX51_dpm_addr_cfg_addr_range       = 4, /* [3:0] */
	BFW_NX51_dpm_addr_cfg_cfg_win_addr_cfg = 2, /* [5:4] */
	BFW_NX51_dpm_addr_cfg_reserved1        = 8, /* [13:6] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a11     = 2, /* [15:14] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a12     = 2, /* [17:16] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a13     = 2, /* [19:18] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a14     = 2, /* [21:20] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a15     = 2, /* [23:22] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a16     = 2, /* [25:24] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a17     = 2, /* [27:26] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a18     = 2, /* [29:28] */
	BFW_NX51_dpm_addr_cfg_addr_cmp_a19     = 2  /* [31:30] */
};

typedef struct NX51_DPM_ADDR_CFG_BIT_Ttag {
	unsigned int addr_range       : BFW_NX51_dpm_addr_cfg_addr_range;       /*   DPM external address range.                                                                               */
	                                                                        /*   {        |                                  |                                                             */
	                                                                        /*    coding   Byte Address range                 address used signals                                         */
	                                                                        /*     0000    reserved                                                                                        */
	                                                                        /*     0001    reserved                                                                                        */
	                                                                        /*     0010    2KB address range                  DPM_A[10:0]                                                  */
	                                                                        /*     0011    4KB address range                  DPM_A[11:0]                                                  */
	                                                                        /*     0100    8KB address range                  DPM_A[12:0]                                                  */
	                                                                        /*     0101    16KB address range                 DPM_A[13:0]                                                  */
	                                                                        /*     0110    32KB address range                 DPM_A[14:0]                                                  */
	                                                                        /*     0111    64KB address range                 DPM_A[15:0]                                                  */
	                                                                        /*     1000    128KB address range                DPM_A[16:0]                                                  */
	                                                                        /*     1001    256KB address range                DPM_A[17:0]                                                  */
	                                                                        /*     1010    512KB address range                DPM_A[18:0]                                                  */
	                                                                        /*     1011    1024KB address range               DPM_A[19:0]                                                  */
	                                                                        /*      :      reserved                                                                                        */
	                                                                        /*     1111    reserved }                                                                                      */
	                                                                        /*   This setting is related to Byte address. I.e. it is not possible to expand address rage                   */
	                                                                        /*   by setting the 'addr_sh' bit inside the 'dpm_if_cfg' register. However required address lines             */
	                                                                        /*   will decrease by 1 (16 bit data modes) or 2 (32 bit data modes) when the 'addr_sh' bit is set.            */
	                                                                        /*                                                                                                             */
	                                                                        /*   For chip-select generation by internal address compare logic:                                             */
	                                                                        /*   Address lines used for chip-select decoding ('addr_cmp' bit fields) must not be regarded                  */
	                                                                        /*   for this setting.                                                                                         */
	                                                                        /*   Example:                                                                                                  */
	                                                                        /*   16kB (A[13:0]) DPM, A[17:14] for chip-select generation, A[19:18] unused:                                 */
	                                                                        /*   Set 'addr_range' to 5, 'addr_cmp_a17' to 'addr_cmp_a14' to '10' or '11' (depending on your compare value) */
	                                                                        /*   and all other 'addr_cmp_a*' bit fields to '00'.                                                           */
	                                                                        /*                                                                                                             */
	                                                                        /*   For multiplexed modes:                                                                                    */
	                                                                        /*   If programmed address range exceeds number of data lines, high address bits will be sampled               */
	                                                                        /*   from DPM_A lines starting above last used data line. High address will be sampled at the same moment      */
	                                                                        /*   when low address bits are sampled from data lines.                                                        */
	                                                                        /*   Example 1:                                                                                                */
	                                                                        /*   8 bit data multiplexed mode, 1024KB address range programmed and 'aen_pol' is set to 0:                   */
	                                                                        /*   Address bits A7..0 are sampled from DPM_D7..0 before DPM_ALE is released to 1. Address bits A19..8        */
	                                                                        /*   are sampled from DPM_A19..8 also before DPM_ALE is released to 1.                                         */
	                                                                        /*   Example 2:                                                                                                */
	                                                                        /*   16 bit data multiplexed mode, 1024KB address range programmed, 'aen_pol' is set                           */
	                                                                        /*   to 0 and 'addr_sh' is set to 1:                                                                           */
	                                                                        /*   Address bits A16..1 are sampled from DPM_D15..0 before DPM_ALE is released to 1. Address bits A19..17     */
	                                                                        /*   are sampled from DPM_A18..16 also before DPM_ALE is released to 1. I.e. a 19 bit word address is          */
	                                                                        /*   carried on DPM_D15..0 and DPM_A18..16 and is left-shifted internally by 1 to resolve a byte address.      */
	unsigned int cfg_win_addr_cfg : BFW_NX51_dpm_addr_cfg_cfg_win_addr_cfg; /* Configuration of External DPM Configuration Window 0.                                                       */
	                                                                        /* Supported settings are:                                                                                     */
	                                                                        /*  00: Configuration Window is located in the first 256 bytes of external DPM address                         */
	                                                                        /*      range (0x0 to 0xff). It is located before the next enabled Window (1 to 4).                            */
	                                                                        /*  01: Configuration Window is located in the last 256 bytes of external DPM address                          */
	                                                                        /*      range. It is located after the last enabled Window (1 to 4).                                           */
	                                                                        /*      Example: 'addr_range' is 8kB: Configuration Window is located in 0x1F00..0x1FFF.                       */
	                                                                        /*  10: reserved.                                                                                              */
	                                                                        /*  11: Configuration Window is disabled for external DPM access. Full DPM address                             */
	                                                                        /*      range can be used for Windows 1 to 4.                                                                  */
	                                                                        /* Note:                                                                                                       */
	                                                                        /*   Configuration Window 0 access detection has higher priority than normal DPM Window                        */
	                                                                        /*   detection but lower priority than Access Tunnel access detection.                                         */
	unsigned int reserved1        : BFW_NX51_dpm_addr_cfg_reserved1;        /* reserved                                                                                                    */
	unsigned int addr_cmp_a11     : BFW_NX51_dpm_addr_cfg_addr_cmp_a11;     /* Address comparator controlling for DPM_A11.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A11 is DPM_SEL_A11 (located on HIF_D31).                                          */
	                                                                        /* Note:                                                                                                       */
	                                                                        /*    A11 is not part of netx50 address compare logic.                                                         */
	unsigned int addr_cmp_a12     : BFW_NX51_dpm_addr_cfg_addr_cmp_a12;     /* Address comparator controlling for DPM_A12.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A12 is DPM_SEL_A12 (located on HIF_D24).                                          */
	unsigned int addr_cmp_a13     : BFW_NX51_dpm_addr_cfg_addr_cmp_a13;     /* Address comparator controlling for DPM_A13.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A13 is DPM_SEL_A13 (located on HIF_D25).                                          */
	unsigned int addr_cmp_a14     : BFW_NX51_dpm_addr_cfg_addr_cmp_a14;     /* Address comparator controlling for DPM_A14.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A14 is DPM_SEL_A14 (located on HIF_D26).                                          */
	unsigned int addr_cmp_a15     : BFW_NX51_dpm_addr_cfg_addr_cmp_a15;     /* Address comparator controlling for DPM_A15.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A15 is DPM_SEL_A15 (located on HIF_D27).                                          */
	unsigned int addr_cmp_a16     : BFW_NX51_dpm_addr_cfg_addr_cmp_a16;     /* Address comparator controlling for DPM_A16.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A16 is DPM_SEL_A16 (located on HIF_D28).                                          */
	unsigned int addr_cmp_a17     : BFW_NX51_dpm_addr_cfg_addr_cmp_a17;     /* Address comparator controlling for DPM_A17.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A17 is DPM_SEL_A17 (located on HIF_D29).                                          */
	unsigned int addr_cmp_a18     : BFW_NX51_dpm_addr_cfg_addr_cmp_a18;     /* Address comparator controlling for DPM_A18.                                                                 */
	                                                                        /* Programming is done like described for 'addr_cmp_a19' bit field.                                            */
	                                                                        /* Related compare input for A18 is DPM_SEL_A18 (located on HIF_D30).                                          */
	unsigned int addr_cmp_a19     : BFW_NX51_dpm_addr_cfg_addr_cmp_a19;     /* Address comparator controlling for DPM_A19.                                                                 */
	                                                                        /* Like netx50 an internal address comparator is provided by netx51 DPM.                                       */
	                                                                        /* Address compare logic is compatible to netx50 address comparator; however programming differs:              */
	                                                                        /* Programming for each address line must be done by a 2-bit field. Additionally A11 is included               */
	                                                                        /* now. Related input DPM_SEL_A11 is located on HIF_D31 for netX51.                                            */
	                                                                        /* -----------------------------------------------------------------------                                     */
	                                                                        /* To avoid instable system configurations, changes of 'addr_cmp_a*' bit fields                                */
	                                                                        /* of this registers must be confirmed by (re)writing 'mode' bit field of dpm_cfg0x0                           */
	                                                                        /* register. View 'mode' description there for details.                                                        */
	                                                                        /* -----------------------------------------------------------------------                                     */
	                                                                        /* Supported settings for each address line of address compare are:                                            */
	                                                                        /* {       |         |              |                                                                          */
	                                                                        /*  coding  compare   compare with   comment                                                                   */
	                                                                        /*     00   disabled  -                                                                                        */
	                                                                        /*     01   enabled   netX input     input state of DPM_SEL_A19 (HIF_D18)                                      */
	                                                                        /*     10   enabled   logic 0                                                                                  */
	                                                                        /*     11   enabled   logic 1    }                                                                             */
	                                                                        /* Set all 'addr_cmp_a*' bit fields to '00' to disable address comparator for Chip-Select decoding logic.      */
	                                                                        /* Whole address comparator result will be always true then.                                                   */
	                                                                        /* Note:                                                                                                       */
	                                                                        /*    Address comparator is not affected by programmed 'addr_range'. Address bits exceeding                    */
	                                                                        /*    selected address range 'addr_range' will also be compared when mask bits are set here.                   */
	                                                                        /* Note:                                                                                                       */
	                                                                        /*    This is a new netx51 feature.                                                                            */
} NX51_DPM_ADDR_CFG_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_ADDR_CFG_BIT_T bf;
} NX51_DPM_ADDR_CFG_T;

/* --------------------------------------------------------------------- */
/* Register dpm_timing_cfg */
/* => DPM timing and access configuration register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_timing_cfg  0x00000014U
#define Adr_NX51_dpm_dpm_timing_cfg  0x1018C014U
#define Adr_NX51_dpm_timing_cfg      0x1018C014U
#define DFLT_VAL_NX51_dpm_timing_cfg 0x00000027U

#define MSK_NX51_dpm_timing_cfg_t_osa                     0x00000003U
#define SRT_NX51_dpm_timing_cfg_t_osa                     0
#define DFLT_VAL_NX51_dpm_timing_cfg_t_osa                0x00000003U
#define DFLT_BF_VAL_NX51_dpm_timing_cfg_t_osa             0x00000003U
#define MSK_NX51_dpm_timing_cfg_filter                    0x00000004U
#define SRT_NX51_dpm_timing_cfg_filter                    2
#define DFLT_VAL_NX51_dpm_timing_cfg_filter               0x00000004U
#define DFLT_BF_VAL_NX51_dpm_timing_cfg_filter            0x00000001U
#define MSK_NX51_dpm_timing_cfg_t_rds                     0x00000070U
#define SRT_NX51_dpm_timing_cfg_t_rds                     4
#define DFLT_VAL_NX51_dpm_timing_cfg_t_rds                0x00000020U
#define DFLT_BF_VAL_NX51_dpm_timing_cfg_t_rds             0x00000002U
#define MSK_NX51_dpm_timing_cfg_rd_burst_en               0x00000080U
#define SRT_NX51_dpm_timing_cfg_rd_burst_en               7
#define DFLT_VAL_NX51_dpm_timing_cfg_rd_burst_en          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_timing_cfg_rd_burst_en       0x00000000U
#define MSK_NX51_dpm_timing_cfg_en_dpm_serial_sqi         0x40000000U
#define SRT_NX51_dpm_timing_cfg_en_dpm_serial_sqi         30
#define DFLT_VAL_NX51_dpm_timing_cfg_en_dpm_serial_sqi    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_timing_cfg_en_dpm_serial_sqi 0x00000000U
#define MSK_NX51_dpm_timing_cfg_sdpm_miso_early           0x80000000U
#define SRT_NX51_dpm_timing_cfg_sdpm_miso_early           31
#define DFLT_VAL_NX51_dpm_timing_cfg_sdpm_miso_early      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_timing_cfg_sdpm_miso_early   0x00000000U

/* all used bits of 'NX51_dpm_timing_cfg': */
#define MSK_USED_BITS_NX51_dpm_timing_cfg 0xc00000f7U

enum {
	BFW_NX51_dpm_timing_cfg_t_osa             = 2,  /* [1:0] */
	BFW_NX51_dpm_timing_cfg_filter            = 1,  /* [2] */
	BFW_NX51_dpm_timing_cfg_reserved1         = 1,  /* [3] */
	BFW_NX51_dpm_timing_cfg_t_rds             = 3,  /* [6:4] */
	BFW_NX51_dpm_timing_cfg_rd_burst_en       = 1,  /* [7] */
	BFW_NX51_dpm_timing_cfg_reserved2         = 22, /* [29:8] */
	BFW_NX51_dpm_timing_cfg_en_dpm_serial_sqi = 1,  /* [30] */
	BFW_NX51_dpm_timing_cfg_sdpm_miso_early   = 1   /* [31] */
};

typedef struct NX51_DPM_TIMING_CFG_BIT_Ttag {
	unsigned int t_osa             : BFW_NX51_dpm_timing_cfg_t_osa;             /* Address Setup Time (t_osa * 10ns).                                                                                 */
	                                                                            /* Address sampling can be delayed for read and write accesses by this parameter.                                     */
	                                                                            /* E.g. host device asserts Chip-Select, Read-Enable and address lines simultaneously but                             */
	                                                                            /* some address lines are not stable while Chip-Select and Read-Enable are both low, set t_osa                        */
	                                                                            /* to delay address sampling by t_osa * 10ns.                                                                         */
	                                                                            /* When data direction is controlled by RDn line ('if_cfg.dir_ctrl' not '00') and byte-enables are used               */
	                                                                            /* for read ('if_cfg.be_rd_dis' not set), a read access is initiated when active byte-enable signals                  */
	                                                                            /* are detected stable for t_osa netX clock periods.                                                                  */
	                                                                            /* Valid settings are: 0..3.                                                                                          */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    Read data access time will increased by t_osa * 10ns if t_osa is not 0.                                         */
	unsigned int filter            : BFW_NX51_dpm_timing_cfg_filter;            /* Filter DPM Control Signals.                                                                                        */
	                                                                            /* If this bit is set, DPM signals Chip-Select, Read-Enable and Write-Enable (and Address latch enable if multiplexed */
	                                                                            /* Parallel DPM modes are used) are filtered for spike suppression.                                                   */
	                                                                            /*  0: no spike suppression.                                                                                          */
	                                                                            /*  1: Spikes < 10ns are suppressed, read data access time increased by 10ns.                                         */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    Data, address and byte-enable inputs are not filtered and must be stable when sampled. I.e. during              */
	                                                                            /*    the last 20ns of a write access and at the first 10ns of read access start.                                     */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    Read data access time is increased by 10ns if this bit is set.                                                  */
	unsigned int reserved1         : BFW_NX51_dpm_timing_cfg_reserved1;         /* reserved                                                                                                           */
	unsigned int t_rds             : BFW_NX51_dpm_timing_cfg_t_rds;             /* Read data setup time (in steps of 10ns).                                                                           */
	                                                                            /* If DPM_RDY is used (rdy_mode != 0), DPM_RDY is generated t_rds*10ns after read data is stored on data bus.         */
	                                                                            /* Without DPM_RDY use (rdy_mode == 0) read access error is detected if access terminates before t_rds*10ns           */
	                                                                            /* passed after read data generation.                                                                                 */
	                                                                            /* Valid settings are: 0..7.                                                                                          */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    Read data access time will increased by t_rds * 10ns if t_rds is not 0.                                         */
	unsigned int rd_burst_en       : BFW_NX51_dpm_timing_cfg_rd_burst_en;       /* Read burst enable.                                                                                                 */
	                                                                            /* Read bursts are subsequent read accesses without toggeling chip-select or read-enable in between.                  */
	                                                                            /* They are supported for non-multiplexed modes only.                                                                 */
	unsigned int reserved2         : BFW_NX51_dpm_timing_cfg_reserved2;         /* reserved                                                                                                           */
	unsigned int en_dpm_serial_sqi : BFW_NX51_dpm_timing_cfg_en_dpm_serial_sqi; /* When DPM ist in serial mode ('dpm_status.sel_dpm_serial' active), serial DPM                                       */
	                                                                            /* can be switched to SQI-compatible 4-bit mode.                                                                      */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    Netx DPM changes serial configuration immediately when this bit is changed. Hence                               */
	                                                                            /*    do not change this bit by a longer serial sequence from host.                                                   */
	                                                                            /*    E.g.: Change from SPI to SQI from host-side when host:                                                          */
	                                                                            /*    1.: Set this bit by SPI write sequence from host.                                                               */
	                                                                            /*    2.: Terminate sequence after the byte containing this bit was written.                                          */
	                                                                            /*    3.: Ensure that host has completed writing this byte serially (host transfer could last                         */
	                                                                            /*        even when related commands are already finished, e.g. due to FIFOs inside host SPI module).                 */
	                                                                            /*    4.: Change host to SQI.                                                                                         */
	                                                                            /*    5.: Continue acessing netX DPM in SQI mode.                                                                     */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    This bit has no effect when DPM is in parallel mode.                                                            */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    This is a new netx51 feature.                                                                                   */
	unsigned int sdpm_miso_early   : BFW_NX51_dpm_timing_cfg_sdpm_miso_early;   /* Serial DPM early MISO (read-data) generation.                                                                      */
	                                                                            /* Serial DPM based on standard SPI changes read data on the edge following the sampling clock edge, i.e.             */
	                                                                            /* works on both serial clock edges. That avoids hold timing errors on MISO-data but decreases                        */
	                                                                            /* maximum serial data rate on the other hand. Hence, for fast serial data rates this bit must be set.                */
	                                                                            /* MISO hold times will always be positive but could get very short then. For details view netX                       */
	                                                                            /* timing characteristics.                                                                                            */
	                                                                            /*  0: Change MISO on the clock edge following the sampling edge.                                                     */
	                                                                            /*  1: Change MISO on the sampling edge.                                                                              */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    Sampling and generating clock edges are determined by serial DPM mode (clock phase and polarity).               */
	                                                                            /*    Related configuration must be done outside DPM module.                                                          */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    Hold timings can be relaxed by decreasing serial clock rate when this bit is not set. When this                 */
	                                                                            /*    bit is set, MISO hold timing does not depend on serial clock rate.                                              */
	                                                                            /* Note:                                                                                                              */
	                                                                            /*    This is a new netx51 feature.                                                                                   */
} NX51_DPM_TIMING_CFG_BIT_T;

typedef union {
	unsigned int              val;
	NX51_DPM_TIMING_CFG_BIT_T bf;
} NX51_DPM_TIMING_CFG_T;

/* --------------------------------------------------------------------- */
/* Register dpm_rdy_cfg */
/* => DPM Ready (DPM_RDY) Signal Configuration Register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_rdy_cfg  0x00000018U
#define Adr_NX51_dpm_dpm_rdy_cfg  0x1018C018U
#define Adr_NX51_dpm_rdy_cfg      0x1018C018U
#define DFLT_VAL_NX51_dpm_rdy_cfg 0x00000001U

#define MSK_NX51_dpm_rdy_cfg_rdy_pol              0x00000001U
#define SRT_NX51_dpm_rdy_cfg_rdy_pol              0
#define DFLT_VAL_NX51_dpm_rdy_cfg_rdy_pol         0x00000001U
#define DFLT_BF_VAL_NX51_dpm_rdy_cfg_rdy_pol      0x00000001U
#define MSK_NX51_dpm_rdy_cfg_rdy_drv_mode         0x00000006U
#define SRT_NX51_dpm_rdy_cfg_rdy_drv_mode         1
#define DFLT_VAL_NX51_dpm_rdy_cfg_rdy_drv_mode    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_rdy_cfg_rdy_drv_mode 0x00000000U
#define MSK_NX51_dpm_rdy_cfg_rdy_sig_mode         0x00000008U
#define SRT_NX51_dpm_rdy_cfg_rdy_sig_mode         3
#define DFLT_VAL_NX51_dpm_rdy_cfg_rdy_sig_mode    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_rdy_cfg_rdy_sig_mode 0x00000000U
#define MSK_NX51_dpm_rdy_cfg_rdy_to_cfg           0x00000030U
#define SRT_NX51_dpm_rdy_cfg_rdy_to_cfg           4
#define DFLT_VAL_NX51_dpm_rdy_cfg_rdy_to_cfg      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_rdy_cfg_rdy_to_cfg   0x00000000U

/* all used bits of 'NX51_dpm_rdy_cfg': */
#define MSK_USED_BITS_NX51_dpm_rdy_cfg 0x0000003fU

enum {
	BFW_NX51_dpm_rdy_cfg_rdy_pol      = 1,  /* [0] */
	BFW_NX51_dpm_rdy_cfg_rdy_drv_mode = 2,  /* [2:1] */
	BFW_NX51_dpm_rdy_cfg_rdy_sig_mode = 1,  /* [3] */
	BFW_NX51_dpm_rdy_cfg_rdy_to_cfg   = 2,  /* [5:4] */
	BFW_NX51_dpm_rdy_cfg_reserved1    = 26  /* [31:6] */
};

typedef struct NX51_DPM_RDY_CFG_BIT_Ttag {
	unsigned int rdy_pol      : BFW_NX51_dpm_rdy_cfg_rdy_pol;      /* Ready signal ready-state polarity.                                                                                            */
	                                                               /* 1: DPM is ready when external RDY-signal is high.                                                                             */
	                                                               /* 0: DPM is busy when external RDY-signal is high.                                                                              */
	unsigned int rdy_drv_mode : BFW_NX51_dpm_rdy_cfg_rdy_drv_mode; /* Ready generation mode.                                                                                                        */
	                                                               /* 00: ready signal generation is disabled (High-Impedance mode).                                                                */
	                                                               /* 01: ready is driven when active and inactive. Never highZ. (Push-Pull mode)                                                   */
	                                                               /* 10: ready is driven when active and for a short time when inactive-phase starts for fast                                      */
	                                                               /*     busy to ready signal state change (Sustain-Tristate mode).                                                                */
	                                                               /*     Inactive-phase ready driving time (tRPm02, tRPm12) depends on rdy_sig_mode:                                               */
	                                                               /*     For rdy_sig_mode=0 this time (tRPm02) is 10ns.                                                                            */
	                                                               /*     For rdy_sig_mode=1 this time (tRPm12) depends on programmed input signal                                                  */
	                                                               /*     filtering (register dpm_timing_cfg bit filter): If filtering is disabled tRPm12 is 20ns to 30ns,                          */
	                                                               /*     if input filtering is enabled,  tRPm12 is 30ns to 40ns.                                                                   */
	                                                               /* 11: ready is only driven when cycle active (Open-Drain/Open-Source mode).                                                     */
	                                                               /* Note:                                                                                                                         */
	                                                               /*       Mode 2 and 3 are reordered in comparison to netX100/500/50.                                                             */
	unsigned int rdy_sig_mode : BFW_NX51_dpm_rdy_cfg_rdy_sig_mode; /* Ready signal mode.                                                                                                            */
	                                                               /* 1: DPM_RDY is generated as ready/acknowledge pulse.                                                                           */
	                                                               /*    In this mode, DPM_RDY is only in active state at access end to sign that host device is allowed to finish the              */
	                                                               /*    current access. If no access to DPM is done or if host device runs DPM access but is not allowed to finish it yet,         */
	                                                               /*    DPM_RDY will remain in inactive state.                                                                                     */
	                                                               /* 0: DPM_RDY is generated as wait/busy state signal.                                                                            */
	                                                               /*    In this mode, DPM_RDY becomes active at access start and will remain active while host device is not allowed to finish the */
	                                                               /*    current access. If no access to DPM is done or if host device runs DPM access and allowed to finish it and continue        */
	                                                               /*    access generation, DPM_RDY will be in inactive state.                                                                      */
	unsigned int rdy_to_cfg   : BFW_NX51_dpm_rdy_cfg_rdy_to_cfg;   /* Ready Timeout Configuration.                                                                                                  */
	                                                               /* Ready Timeout detection can controlled this bit. For further information                                                      */
	                                                               /* see descrition of rdy_to_err bit of dpm_status register.                                                                      */
	                                                               /* 00: Ready Timeout after 2048 netx system clock cycles (i.e. 20.48us, not netx50 compatible)                                   */
	                                                               /* 01: Ready Timeout after 256 netx system clock cycles (i.e. 2.56us, netx50 compatible)                                         */
	                                                               /* 10: reserved                                                                                                                  */
	                                                               /* 11: Ready Timeout disabled.                                                                                                   */
	                                                               /* The value programmed here is ignored for serial DPM with stream-type 'ready-polling'. In this mode                            */
	                                                               /* no ready-timeout will be generated to avoid additional status checking. A ready-polling timeout                               */
	                                                               /* counter should be implemented in serial DPM host application.                                                                 */
	                                                               /* Note:                                                                                                                         */
	                                                               /*    This is a new netx51 feature.                                                                                              */
	unsigned int reserved1    : BFW_NX51_dpm_rdy_cfg_reserved1;    /* reserved                                                                                                                      */
} NX51_DPM_RDY_CFG_BIT_T;

typedef union {
	unsigned int           val;
	NX51_DPM_RDY_CFG_BIT_T bf;
} NX51_DPM_RDY_CFG_T;

/* --------------------------------------------------------------------- */
/* Register dpm_status */
/* => DPM Status Register. */
/*    DPM access errors can generate IRQ for host device (view DPM IRQ registers further down). For */
/*    error handling, the address an error occurred with is logged in dpm_status_err_addr register. Error bits can be cleared by */
/*    access to dpm_status_err_reset register. */
/*    Note for 'bus_conflict_rd_addr_err', 'bus_conflict_rd_err' and 'bus_conflict_wr_err': */
/*       Bus-conflict error detection is basically implemented as debug feature. Detected errors could be result of hazardous */
/*       signals, incorrect configured DPM mode or not supported host interfaces. However there could some be some applications */
/*       where error detection is too strict (see description of 'dis_bus_conflict_err_detect' of 'dpm_misc_cfg'). For that reason */
/*       bus-conflict error behaviour can be controlled by 'dis_bus_conflict_err_detect' of 'dpm_misc_cfg' */
/*       register. However, status bits inside this register (and inside 'dpm_status_err_reset') will always be set when an */
/*       error was detected. */
/*       When error detection is enabled ('dis_bus_conflict_err_detect' is not set), an error-access will be aborted (ready-signal will */
/*       be set to ready state when used) and DPM will wait for idle bus (dir_mode==0: deselected or read and write control signal */
/*       inactive, dir_mode!=0: deselected or all byte-enables inactive). The error IRQ ('dpm_err') will be asserted. Read data */
/*       of related access will be unvalid and write data will be junked. */
/*       When error detection is disabled ('dis_bus_conflict_err_detect' is set) bus-conflict errors do not assert the 'dpm_err' */
/*       IRQ, erroneous access will not be aborted and DPM will not wait for bus idle state. I.e. the erroneous access will be */
/*       finished as read or write. However consequences of an error access are not predictable: Read or write data or address */
/*       could be invalid. */
/*       Error detection is disabled by default after power on and must be enabled before usage. */
/*    Note for 'rdy_to_err', 'wr_err' and 'rd_err': */
/*       These errors are basically set when an host access is too fast to be handled by netX internally. NetX internal access */
/*       times depend on target address area. However there are some address areas where other netX modules have higher access */
/*       priority than DPM (especially local memories of netX internal CPUs like xPEC or xPIC). Fore these address areas */
/*       access times could become unpredictable (depending on application running netX inside). Especially when using host */
/*       devices without ready-signal handshaking (i.e. also serial DPM) where netX access times could not be met under all */
/*       conditions error detection handling becomes mandatory. It is recommended to check for errors after each access. In */
/*       error-case the last access must be repeated. If an error occurs permanently the host must stretch external DPM access */
/*       by inserting wait states. For all other DPM connections this error detection should only be a debug feature. */
/*       Behaviour of 'wr_err' and 'rd_err' can be additionally controlled by 'dis_access_err_halt' of 'dpm_misc_cfg' register: */
/*       When error detection is enabled ('dis_access_err_halt' is not set), all read-access after occurrence of a read-error */
/*       and all write-access after occurrence of a write-error will be ignored. Error states must be reset first before new */
/*       accesses are performed internally. This is implemented to protect netX from unpredictable results of access errors. */
/*       However some applications always require access to netX internal address area (e.g. as DPM configuration window 0 */
/*       for error handling was disabled). For this purpose error-detection could be disabled. */
/*       DPM error IRQ ('dpm_err') and error-staus flags will always be set in error case independent of 'dis_access_err_halt'. */
/*       Error detection is disabled by default after power on and must be enabled before usage. */
/*    Note: */
/*      Errors could be avoided by programming input filtering, burst support or timing. */
/*      That can be configured by dpm_timing_cfg register. */
/*    Note: */
/*      Serial DPM status send on the first byte of a serial access by netX is reordered and bus_conflict-errors */
/*      are omitted (as they are related to parallel DPM only). Serial DPM status byte is transferred MSB first */
/*      and contains following information (serial DPM protokol was completely revised for netx51 and this is a new netx51 feature): */
/*    {                          | */
/*      bit of first serial byte   status information */
/*                 7 (MSB)                          0 */
/*                 6                                0 */
/*                 5                                0 */
/*                 4                   sel_dpm_serial */
/*                 3                       rdy_to_err */
/*                 2                           wr_err */
/*                 1                           rd_err */
/*                 0 (LSB)                   unlocked} */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_status 0x0000001CU
#define Adr_NX51_dpm_dpm_status 0x1018C01CU
#define Adr_NX51_dpm_status     0x1018C01CU

#define MSK_NX51_dpm_status_unlocked                 0x00000001U
#define SRT_NX51_dpm_status_unlocked                 0
#define MSK_NX51_dpm_status_rd_err                   0x00000002U
#define SRT_NX51_dpm_status_rd_err                   1
#define MSK_NX51_dpm_status_wr_err                   0x00000004U
#define SRT_NX51_dpm_status_wr_err                   2
#define MSK_NX51_dpm_status_rdy_to_err               0x00000008U
#define SRT_NX51_dpm_status_rdy_to_err               3
#define MSK_NX51_dpm_status_bus_conflict_wr_err      0x00000010U
#define SRT_NX51_dpm_status_bus_conflict_wr_err      4
#define MSK_NX51_dpm_status_bus_conflict_rd_err      0x00000020U
#define SRT_NX51_dpm_status_bus_conflict_rd_err      5
#define MSK_NX51_dpm_status_bus_conflict_rd_addr_err 0x00000040U
#define SRT_NX51_dpm_status_bus_conflict_rd_addr_err 6
#define MSK_NX51_dpm_status_sel_dpm_serial           0x00000080U
#define SRT_NX51_dpm_status_sel_dpm_serial           7

/* all used bits of 'NX51_dpm_status': */
#define MSK_USED_BITS_NX51_dpm_status 0x000000ffU

enum {
	BFW_NX51_dpm_status_unlocked                 = 1,  /* [0] */
	BFW_NX51_dpm_status_rd_err                   = 1,  /* [1] */
	BFW_NX51_dpm_status_wr_err                   = 1,  /* [2] */
	BFW_NX51_dpm_status_rdy_to_err               = 1,  /* [3] */
	BFW_NX51_dpm_status_bus_conflict_wr_err      = 1,  /* [4] */
	BFW_NX51_dpm_status_bus_conflict_rd_err      = 1,  /* [5] */
	BFW_NX51_dpm_status_bus_conflict_rd_addr_err = 1,  /* [6] */
	BFW_NX51_dpm_status_sel_dpm_serial           = 1,  /* [7] */
	BFW_NX51_dpm_status_reserved1                = 24  /* [31:8] */
};

typedef struct NX51_DPM_STATUS_BIT_Ttag {
	unsigned int unlocked                 : BFW_NX51_dpm_status_unlocked;                 /* DPM is locked during netX power up and boot phase.                                                            */
	                                                                                      /* DPM access to other addresses than these DPM control address area cannot be done before this bit is set to 1. */
	                                                                                      /* Poll for 1 after power up or reset.                                                                           */
	unsigned int rd_err                   : BFW_NX51_dpm_status_rd_err;                   /* DPM Read Error Status Flag.                                                                                   */
	                                                                                      /* Read errors occur if ready signal (DPM_RDY) is not respected by host device and                               */
	                                                                                      /* external DPM read access terminated before read data could be asserted on the external DPM data               */
	                                                                                      /* bus (view also t_rds in dpm_timing_cfg register).                                                             */
	                                                                                      /* In case of read error this bit is set immediately after the appropriate read access. Repeat the               */
	                                                                                      /* read access until no error occurs.                                                                            */
	                                                                                      /* 1: The external DPM read access was too fast. Repeat the read access.                                         */
	                                                                                      /* 0: Read data OK.                                                                                              */
	                                                                                      /* Note:                                                                                                         */
	                                                                                      /*    For additional information view note in register description header.                                       */
	unsigned int wr_err                   : BFW_NX51_dpm_status_wr_err;                   /* DPM Write Error Status Flag.                                                                                  */
	                                                                                      /* Write errors occur if ready signal (DPM_RDY) is not respected by host device and                              */
	                                                                                      /* external DPM write access terminated before data could be stored.                                             */
	                                                                                      /* In some cases certain netX address areas could be busy for not predictable time. If DPM_RDY is                */
	                                                                                      /* not used, check for write error after write access to these areas.                                            */
	                                                                                      /* In case of write error this bit is set immediately after the appropriate write access. Repeat                 */
	                                                                                      /* the write access until no error occurs.                                                                       */
	                                                                                      /* 1: The external DPM write access was too fast to store write data. Repeat the write access.                   */
	                                                                                      /* 0: Write access terminated without error.                                                                     */
	                                                                                      /* Note:                                                                                                         */
	                                                                                      /*    For additional information view note in register description header.                                       */
	unsigned int rdy_to_err               : BFW_NX51_dpm_status_rdy_to_err;               /* DPM_RDY Timeout Error Status Flag.                                                                            */
	                                                                                      /* This error could occur if host device tries to access permanently busy netX address area (e.g. netX           */
	                                                                                      /* xPEC program RAM while xPEC is running). To avoid host device stalling DPM_RDY signal is released             */
	                                                                                      /* to ready state after 2048 or 256 system clock cycles (i.e. 20.48us or 2.56us) at least.                       */
	                                                                                      /* 1: Last access went to netX busy address and was broken to avoid host device stalling.                        */
	                                                                                      /* 0: Access was finished successfully by DPM_RDY assertion to ready state.                                      */
	                                                                                      /* Note:                                                                                                         */
	                                                                                      /*    For additional information view note in register description header.                                       */
	                                                                                      /* Note:                                                                                                         */
	                                                                                      /*    This flag is not affected by 'dpm_firmware_irq' registers.                                                 */
	unsigned int bus_conflict_wr_err      : BFW_NX51_dpm_status_bus_conflict_wr_err;      /* Parallel DPM write access bus error detected.                                                                 */
	                                                                                      /* This bit is set if a write access was started and signals change to read access states.                       */
	                                                                                      /* I.e. for dir_mode 0: Read-control (nRD) signal becomes active (low, after filtering if enabled)               */
	                                                                                      /* during a write access.                                                                                        */
	                                                                                      /* I.e. for dir_mode 2: Direction line (nRD) signal changes to read (low, after filtering if enabled)            */
	                                                                                      /* during a write access.                                                                                        */
	                                                                                      /* Note:                                                                                                         */
	                                                                                      /*    For additional information view note in register description header.                                       */
	unsigned int bus_conflict_rd_err      : BFW_NX51_dpm_status_bus_conflict_rd_err;      /* Parallel DPM read access bus error detected.                                                                  */
	                                                                                      /* This bit is set if a read access was started and signals change to write access states.                       */
	                                                                                      /* I.e. for dir_mode 0: Write-control (nWR) signal becomes active (low, after filtering if enabled)              */
	                                                                                      /* during a read access.                                                                                         */
	                                                                                      /* I.e. for dir_mode 1: Direction line (nRD) signal changes to write (low, after filtering if enabled)           */
	                                                                                      /* during a read access.                                                                                         */
	                                                                                      /* Note:                                                                                                         */
	                                                                                      /*    For additional information view note in register description header.                                       */
	unsigned int bus_conflict_rd_addr_err : BFW_NX51_dpm_status_bus_conflict_rd_addr_err; /* Parallel DPM read access address change bus error detected.                                                   */
	                                                                                      /* This bit is set if address lines change (after filtering if enabled) during a read access while               */
	                                                                                      /* burst support is not enabled. byte-enables are not included in this error-detection.                          */
	                                                                                      /* Note:                                                                                                         */
	                                                                                      /*    For additional information view note in register description header.                                       */
	unsigned int sel_dpm_serial           : BFW_NX51_dpm_status_sel_dpm_serial;           /* DPM_MODE configuration input state.                                                                           */
	                                                                                      /* 0: DPM is in parallel mode (DPM_MODE configuration input is low).                                             */
	                                                                                      /* 1: DPM is in serial mode (DPM_MODE configuration input is high).                                              */
	unsigned int reserved1                : BFW_NX51_dpm_status_reserved1;                /* reserved                                                                                                      */
} NX51_DPM_STATUS_BIT_T;

typedef union {
	unsigned int          val;
	NX51_DPM_STATUS_BIT_T bf;
} NX51_DPM_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dpm_status_err_reset */
/* => DPM Error Status Reset Register. */
/*    Each flags can be reset by writing a '1' to it. For fast error detection for DPM interfaces without ready usage, */
/*    reset-on-read-function can be enabled for this register. */
/*    Note: */
/*       If reset-on-read-function is enabled, this register must be read with a single access as bits are cleared */
/*       immediately after the access. You should always use a byte access in this case. */
/*    Note: */
/*       View dpm_status register for detailed error description. */
/*    Note: */
/*       reset-on-read-function is controlled by enable_flag_reset_on_rd-bit in dpm_misc_cfg-register. */
/*    Note: */
/*       In cases where internal access time is not predictable and host provides no */
/*       ready function, it is recommended to enable reset-on-read-function. There is only one access */
/*       necessary for error detection and clearing this flag then. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_status_err_reset  0x00000020U
#define Adr_NX51_dpm_dpm_status_err_reset  0x1018C020U
#define Adr_NX51_dpm_status_err_reset      0x1018C020U
#define DFLT_VAL_NX51_dpm_status_err_reset 0x00000000U

#define MSK_NX51_dpm_status_err_reset_rd_err_rst                           0x00000002U
#define SRT_NX51_dpm_status_err_reset_rd_err_rst                           1
#define DFLT_VAL_NX51_dpm_status_err_reset_rd_err_rst                      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_status_err_reset_rd_err_rst                   0x00000000U
#define MSK_NX51_dpm_status_err_reset_wr_err_rst                           0x00000004U
#define SRT_NX51_dpm_status_err_reset_wr_err_rst                           2
#define DFLT_VAL_NX51_dpm_status_err_reset_wr_err_rst                      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_status_err_reset_wr_err_rst                   0x00000000U
#define MSK_NX51_dpm_status_err_reset_rdy_to_err_rst                       0x00000008U
#define SRT_NX51_dpm_status_err_reset_rdy_to_err_rst                       3
#define DFLT_VAL_NX51_dpm_status_err_reset_rdy_to_err_rst                  0x00000000U
#define DFLT_BF_VAL_NX51_dpm_status_err_reset_rdy_to_err_rst               0x00000000U
#define MSK_NX51_dpm_status_err_reset_bus_conflict_wr_err_rst              0x00000010U
#define SRT_NX51_dpm_status_err_reset_bus_conflict_wr_err_rst              4
#define DFLT_VAL_NX51_dpm_status_err_reset_bus_conflict_wr_err_rst         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_status_err_reset_bus_conflict_wr_err_rst      0x00000000U
#define MSK_NX51_dpm_status_err_reset_bus_conflict_rd_err_rst              0x00000020U
#define SRT_NX51_dpm_status_err_reset_bus_conflict_rd_err_rst              5
#define DFLT_VAL_NX51_dpm_status_err_reset_bus_conflict_rd_err_rst         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_status_err_reset_bus_conflict_rd_err_rst      0x00000000U
#define MSK_NX51_dpm_status_err_reset_bus_conflict_rd_addr_err_rst         0x00000040U
#define SRT_NX51_dpm_status_err_reset_bus_conflict_rd_addr_err_rst         6
#define DFLT_VAL_NX51_dpm_status_err_reset_bus_conflict_rd_addr_err_rst    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_status_err_reset_bus_conflict_rd_addr_err_rst 0x00000000U

/* all used bits of 'NX51_dpm_status_err_reset': */
#define MSK_USED_BITS_NX51_dpm_status_err_reset 0x0000007eU

enum {
	BFW_NX51_dpm_status_err_reset_reserved1                    = 1,  /* [0] */
	BFW_NX51_dpm_status_err_reset_rd_err_rst                   = 1,  /* [1] */
	BFW_NX51_dpm_status_err_reset_wr_err_rst                   = 1,  /* [2] */
	BFW_NX51_dpm_status_err_reset_rdy_to_err_rst               = 1,  /* [3] */
	BFW_NX51_dpm_status_err_reset_bus_conflict_wr_err_rst      = 1,  /* [4] */
	BFW_NX51_dpm_status_err_reset_bus_conflict_rd_err_rst      = 1,  /* [5] */
	BFW_NX51_dpm_status_err_reset_bus_conflict_rd_addr_err_rst = 1,  /* [6] */
	BFW_NX51_dpm_status_err_reset_reserved2                    = 25  /* [31:7] */
};

typedef struct NX51_DPM_STATUS_ERR_RESET_BIT_Ttag {
	unsigned int reserved1                    : BFW_NX51_dpm_status_err_reset_reserved1;                    /* reserved                                                                                                 */
	unsigned int rd_err_rst                   : BFW_NX51_dpm_status_err_reset_rd_err_rst;                   /* DPM read error detection bit with auto reset function.                                                   */
	                                                                                                        /* For fast write error detection this bit can be checked after each write access. If it was set, the write */
	                                                                                                        /* access must be repeated.                                                                                 */
	unsigned int wr_err_rst                   : BFW_NX51_dpm_status_err_reset_wr_err_rst;                   /* DPM write error detection bit with auto reset function.                                                  */
	                                                                                                        /* For fast read error detection this bit can be checked after each read access. If it was set, the read    */
	                                                                                                        /* access must be repeated.                                                                                 */
	unsigned int rdy_to_err_rst               : BFW_NX51_dpm_status_err_reset_rdy_to_err_rst;               /* DPM_RDY timeout error.                                                                                   */
	unsigned int bus_conflict_wr_err_rst      : BFW_NX51_dpm_status_err_reset_bus_conflict_wr_err_rst;      /* Parallel DPM write access bus error detected.                                                            */
	unsigned int bus_conflict_rd_err_rst      : BFW_NX51_dpm_status_err_reset_bus_conflict_rd_err_rst;      /* Parallel DPM read access bus error detected.                                                             */
	unsigned int bus_conflict_rd_addr_err_rst : BFW_NX51_dpm_status_err_reset_bus_conflict_rd_addr_err_rst; /* Parallel DPM read access address change bus error detected.                                              */
	unsigned int reserved2                    : BFW_NX51_dpm_status_err_reset_reserved2;                    /* reserved                                                                                                 */
} NX51_DPM_STATUS_ERR_RESET_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DPM_STATUS_ERR_RESET_BIT_T bf;
} NX51_DPM_STATUS_ERR_RESET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_status_err_addr */
/* => DPM Error Address Status Register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_status_err_addr 0x00000024U
#define Adr_NX51_dpm_dpm_status_err_addr 0x1018C024U
#define Adr_NX51_dpm_status_err_addr     0x1018C024U

#define MSK_NX51_dpm_status_err_addr_err_addr 0x000fffffU
#define SRT_NX51_dpm_status_err_addr_err_addr 0

/* all used bits of 'NX51_dpm_status_err_addr': */
#define MSK_USED_BITS_NX51_dpm_status_err_addr 0x000fffffU

enum {
	BFW_NX51_dpm_status_err_addr_err_addr  = 20, /* [19:0] */
	BFW_NX51_dpm_status_err_addr_reserved1 = 12  /* [31:20] */
};

typedef struct NX51_DPM_STATUS_ERR_ADDR_BIT_Ttag {
	unsigned int err_addr  : BFW_NX51_dpm_status_err_addr_err_addr;  /* Access error address.                                                                                                                 */
	                                                                 /* Address of first erroneous access. IRQ handler can use this value to repeat failed accesses after error                               */
	                                                                 /* bits are set in dpm_status or dpm_status_err_reset register. However, only DPM Read Error (rd_err),                                   */
	                                                                 /* DPM Write Error (wr_err) and DPM_RDY Timeout Error (rdy_to_err) are cared for address logging.                                        */
	                                                                 /* This register is only valid if one of the error bits is set and should be read before error bits are cleared. If no error bit is set, */
	                                                                 /* it is updated each access to the current address.                                                                                     */
	                                                                 /* Note:                                                                                                                                 */
	                                                                 /*    Address status during bus conflict errors will not be logged. Bus conflict error status information                                */
	                                                                 /*    is for debug purpose of unstable systems. Purpose of this register is primarily access error                                       */
	                                                                 /*    handling for systems without ready usage.                                                                                          */
	unsigned int reserved1 : BFW_NX51_dpm_status_err_addr_reserved1; /* reserved                                                                                                                              */
} NX51_DPM_STATUS_ERR_ADDR_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_DPM_STATUS_ERR_ADDR_BIT_T bf;
} NX51_DPM_STATUS_ERR_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register dpm_misc_cfg */
/* => DPM Configuration Register for some Special Functions. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_misc_cfg  0x00000028U
#define Adr_NX51_dpm_dpm_misc_cfg  0x1018C028U
#define Adr_NX51_dpm_misc_cfg      0x1018C028U
#define DFLT_VAL_NX51_dpm_misc_cfg 0x00000006U

#define MSK_NX51_dpm_misc_cfg_enable_flag_reset_on_rd             0x00000001U
#define SRT_NX51_dpm_misc_cfg_enable_flag_reset_on_rd             0
#define DFLT_VAL_NX51_dpm_misc_cfg_enable_flag_reset_on_rd        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_misc_cfg_enable_flag_reset_on_rd     0x00000000U
#define MSK_NX51_dpm_misc_cfg_dis_access_err_halt                 0x00000002U
#define SRT_NX51_dpm_misc_cfg_dis_access_err_halt                 1
#define DFLT_VAL_NX51_dpm_misc_cfg_dis_access_err_halt            0x00000002U
#define DFLT_BF_VAL_NX51_dpm_misc_cfg_dis_access_err_halt         0x00000001U
#define MSK_NX51_dpm_misc_cfg_dis_bus_conflict_err_detect         0x00000004U
#define SRT_NX51_dpm_misc_cfg_dis_bus_conflict_err_detect         2
#define DFLT_VAL_NX51_dpm_misc_cfg_dis_bus_conflict_err_detect    0x00000004U
#define DFLT_BF_VAL_NX51_dpm_misc_cfg_dis_bus_conflict_err_detect 0x00000001U

/* all used bits of 'NX51_dpm_misc_cfg': */
#define MSK_USED_BITS_NX51_dpm_misc_cfg 0x00000007U

enum {
	BFW_NX51_dpm_misc_cfg_enable_flag_reset_on_rd     = 1,  /* [0] */
	BFW_NX51_dpm_misc_cfg_dis_access_err_halt         = 1,  /* [1] */
	BFW_NX51_dpm_misc_cfg_dis_bus_conflict_err_detect = 1,  /* [2] */
	BFW_NX51_dpm_misc_cfg_reserved1                   = 29  /* [31:3] */
};

typedef struct NX51_DPM_MISC_CFG_BIT_Ttag {
	unsigned int enable_flag_reset_on_rd     : BFW_NX51_dpm_misc_cfg_enable_flag_reset_on_rd;     /* Enable Status Flag Reset by reading the 'dpm_status_err_reset' register.                                */
	                                                                                              /* When enable_flag_reset_on_rd-bit is set to '1', there is only one access necessary for                  */
	                                                                                              /* error detection and clearing the error status bits. In cases where internal access time is              */
	                                                                                              /* not predictable and host provides no ready function, it is recommended to enable reset-on-read-function */
	                                                                                              /* to minimize traffic.                                                                                    */
	unsigned int dis_access_err_halt         : BFW_NX51_dpm_misc_cfg_dis_access_err_halt;         /* Disable halt after access-errors where detected.                                                        */
	                                                                                              /* When this bit is set access-error-detection ('rd_err', 'wr_err' and 'rdy_to_err' status bits            */
	                                                                                              /* of 'dpm_status' register) will be set in error case but following accesses to netX internal             */
	                                                                                              /* address area will not be blocked. Error IRQs will be generated.                                         */
	                                                                                              /* Note:                                                                                                   */
	                                                                                              /*    This bit is set by default, but it is strongly recommended to clear it. However keeping              */
	                                                                                              /*    this bit set could be helpful for debugging, netx50 compatibility or when                            */
	                                                                                              /*    DPM configuration window 0 is disabled and not available for error handling.                         */
	                                                                                              /* Note:                                                                                                   */
	                                                                                              /*    IRQ 'dpm_err' is asserted in case of access-errors even when this bit is set.                        */
	                                                                                              /* Note:                                                                                                   */
	                                                                                              /*    This is a new netx51 feature.                                                                        */
	unsigned int dis_bus_conflict_err_detect : BFW_NX51_dpm_misc_cfg_dis_bus_conflict_err_detect; /* This bit controls bus-error-detection.                                                                  */
	                                                                                              /* When this bit is set, detected bus errors will only be flagged inside 'dpm_status' register             */
	                                                                                              /* without further action. When this bit is cleared, dpm-error IRQ will be asserted and erroneous          */
	                                                                                              /* accesses are terminated (or ignored) in error case additionally.                                        */
	                                                                                              /* View also 'bus_conflict' status bits and description of 'dpm_status' register for details.              */
	                                                                                              /* Note:                                                                                                   */
	                                                                                              /*    This bit is set by default, but it is strongly recommended to clear it. However keeping              */
	                                                                                              /*    this bit set could be helpful for debugging, netx50 compatibility or when                            */
	                                                                                              /*    DPM configuration window 0 is disabled and not available for error handling.                         */
	                                                                                              /* Note:                                                                                                   */
	                                                                                              /*    This bit could become necessary to be set for modes with direction signal                            */
	                                                                                              /*    where byte-enables change (nearly) simultanously to direction signal (e.g. old Motorola 8bit CPUs).  */
	                                                                                              /*    In this case DPM could detect an error at read access end when direction line is                     */
	                                                                                              /*    already sampled inactive while byte-enables are still sampled active.                                */
	                                                                                              /* Note:                                                                                                   */
	                                                                                              /*    This is a new netx51 feature.                                                                        */
	unsigned int reserved1                   : BFW_NX51_dpm_misc_cfg_reserved1;                   /* reserved                                                                                                */
} NX51_DPM_MISC_CFG_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_MISC_CFG_BIT_T bf;
} NX51_DPM_MISC_CFG_T;

/* --------------------------------------------------------------------- */
/* Register dpm_io_cfg_misc */
/* => DPM IO Configuration Register. */
/*    PIO usage of DPM_SIRQ, DPM_DIRQ and DPM_RDY has moved from this register to register'dpm_pio_cfg1' since netx51. */
/*    Signals which should be used as PIOs when netX DPM is active must be selected there. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_io_cfg_misc  0x0000002CU
#define Adr_NX51_dpm_dpm_io_cfg_misc  0x1018C02CU
#define Adr_NX51_dpm_io_cfg_misc      0x1018C02CU
#define DFLT_VAL_NX51_dpm_io_cfg_misc 0x000000a0U

#define MSK_NX51_dpm_io_cfg_misc_irq_pol         0x00000010U
#define SRT_NX51_dpm_io_cfg_misc_irq_pol         4
#define DFLT_VAL_NX51_dpm_io_cfg_misc_irq_pol    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_io_cfg_misc_irq_pol 0x00000000U
#define MSK_NX51_dpm_io_cfg_misc_irq_oec         0x00000020U
#define SRT_NX51_dpm_io_cfg_misc_irq_oec         5
#define DFLT_VAL_NX51_dpm_io_cfg_misc_irq_oec    0x00000020U
#define DFLT_BF_VAL_NX51_dpm_io_cfg_misc_irq_oec 0x00000001U
#define MSK_NX51_dpm_io_cfg_misc_fiq_pol         0x00000040U
#define SRT_NX51_dpm_io_cfg_misc_fiq_pol         6
#define DFLT_VAL_NX51_dpm_io_cfg_misc_fiq_pol    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_io_cfg_misc_fiq_pol 0x00000000U
#define MSK_NX51_dpm_io_cfg_misc_fiq_oec         0x00000080U
#define SRT_NX51_dpm_io_cfg_misc_fiq_oec         7
#define DFLT_VAL_NX51_dpm_io_cfg_misc_fiq_oec    0x00000080U
#define DFLT_BF_VAL_NX51_dpm_io_cfg_misc_fiq_oec 0x00000001U

/* all used bits of 'NX51_dpm_io_cfg_misc': */
#define MSK_USED_BITS_NX51_dpm_io_cfg_misc 0x000000f0U

enum {
	BFW_NX51_dpm_io_cfg_misc_reserved1 = 4,  /* [3:0] */
	BFW_NX51_dpm_io_cfg_misc_irq_pol   = 1,  /* [4] */
	BFW_NX51_dpm_io_cfg_misc_irq_oec   = 1,  /* [5] */
	BFW_NX51_dpm_io_cfg_misc_fiq_pol   = 1,  /* [6] */
	BFW_NX51_dpm_io_cfg_misc_fiq_oec   = 1,  /* [7] */
	BFW_NX51_dpm_io_cfg_misc_reserved2 = 24  /* [31:8] */
};

typedef struct NX51_DPM_IO_CFG_MISC_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_dpm_io_cfg_misc_reserved1; /* reserved                                                                                                                  */
	unsigned int irq_pol   : BFW_NX51_dpm_io_cfg_misc_irq_pol;   /* IRQ/DIRQ signal polarity.                                                                                                 */
	                                                             /* 0: IRQ/DIRQ is active low.                                                                                                */
	                                                             /* 1: IRQ/DIRQ is active high.                                                                                               */
	unsigned int irq_oec   : BFW_NX51_dpm_io_cfg_misc_irq_oec;   /* IRQ output enable controlled.                                                                                             */
	                                                             /* 0: IRQ/DIRQ signal is always driven.                                                                                      */
	                                                             /* 1: IRQ/DIRQ signal is only driven when active. Inactive level must be realized by external pull-up or pull-down resistor. */
	unsigned int fiq_pol   : BFW_NX51_dpm_io_cfg_misc_fiq_pol;   /* FIQ/SIRQ signal polarity.                                                                                                 */
	                                                             /* 0: FIQ/SIRQ is active low.                                                                                                */
	                                                             /* 1: FIQ/SIRQ is active high.                                                                                               */
	unsigned int fiq_oec   : BFW_NX51_dpm_io_cfg_misc_fiq_oec;   /* FIQ/SIRQ output enable controlled.                                                                                        */
	                                                             /* 0: FIQ/SIRQ signal is always driven.                                                                                      */
	                                                             /* 1: FIQ/SIRQ signal is only driven when active. Inactive level must be realized by external pull-up or pull-down resistor. */
	unsigned int reserved2 : BFW_NX51_dpm_io_cfg_misc_reserved2; /* reserved                                                                                                                  */
} NX51_DPM_IO_CFG_MISC_BIT_T;

typedef union {
	unsigned int               val;
	NX51_DPM_IO_CFG_MISC_BIT_T bf;
} NX51_DPM_IO_CFG_MISC_T;

/* --------------------------------------------------------------------- */
/* Register dpm_tunnel_cfg */
/* => DPM Access Tunnel Configuration Register. */
/*    DPM Access Tunnel (DATunnel) is a 64 byte (16DWord) address window which can be mapped on any 64 byte boundary of the external visible address space. */
/*    In the last DWord (15) of DATunnel a netX Internal 32 bit Target Base Address (ITBAddr) matching a 64 byte boundary can be programmed. */
/*    By DWords 0..14 netX data starting at ITBAddr can be accessed then (read-only functionality can be configured by 'wp_data' bit). */
/*    For access to netX data with ITBAddr DWord offset 15, bits 5 to 2 of programmed ITBAddr are interpreted as mapping value. This value */
/*    will be added to internal access address before tunnelling (wrapping around at the 64 byte boundary). Hence it is possible to access */
/*    always 15 of the 16 netX DWord while the missing one can be selected by an appropriate mapping value. */
/*    ITBAddr can also be programmed or read from netX using dpm_itbaddr register. Also ITBAddr can be write-protected from host */
/*    by a configuration bit (wp_itbaddr) of this register. */
/*    External to internal address mapping for DATunnel area can be calculated by following formula: */
/*       INAAdr = (ITBAddr & 0xffffffc0) + ((EDAAdr + ITBAddr) & 0x3C) */
/*    With: */
/*       INAAdr:  Internal netX Access Address */
/*       ITBAddr: Internal netX 32 bit Tunnel Target Base Address */
/*       EDAAdr:  External DPM Access Address */
/*    Condition for DATunnel access is: */
/*       EDAAdr>>6 equals value of bit field 'base' from this register. */
/*    To map netX internal DWord N to invisible last external DWord (15), use mapping value */
/*       map = (N - 15) & 0xf */
/*    on bits 5 to 2. */
/*    Internal to external address offset inside DATunnel area for internal DWord N can be calculated by following formula: */
/*       External offset = (N*4 - map*4) & 0x3C = (N*4 - ITBAddr) & 0x3C */
/*    Example 1: */
/*       Access to netX sys_time module by host via DATunnel on external DPM addresses are starting at 0x240. */
/*       - Set bit field 'base' of this register to 9 (0x240>>6), set enable bit (and write protection depending on application). */
/*         DATunnel now is enabled on external DPM addresses 0x240 to 0x27f. */
/*       - ITBAddr of netX10 sys_time module is 0x101c1000. */
/*         For direct DATunnel to this address, host must write 0x101c1000 to external DPM address 0x27c. This */
/*         can be done e.g. by four byte accesses to 0x27c, 0x27d, 0x27e and 0x27f or by two 16 bit accesses to 0x27c and 0x27e. */
/*         Now sys_time module registers 0 to 14 can be accessed on external DPM address 0x240 to 0x27b. */
/*    Example 2: */
/*       Register 15 of sys_time is hidden by ITBAddr configuration on 0x27c in example 1 but must also be accessed. However, sys_time */
/*       Register 6 is never kind of interest. */
/*       - Configure this register like described in example 1. */
/*       - To map Register 6 (Module offset 6*4) to external offset 0x3C (hidden data on DWord 15), */
/*         the following rule must be complied: */
/*            0x3C + map*4 = 6*4. */
/*         That leads to a mapping value of: */
/*            map*4 = (6*4 - 0x3C) & 0x3C = 1C */
/*         Hence, write 0x101c101C to DATunnel DWord 15 (external DPM address 0x27c) to map sys_time Register 6 to */
/*         hidden DWord 15. */
/*         INAAdr now will be derived from EDAAdr before tunneling as follows: */
/*            INAAdr = 0x101c1000 + ((EDAAdr + 0x1C) & 0x3C) */
/*         External offset of Module DWord N results from: */
/*            External offset = (N*4 - 0x1C) & 0x3C */
/*         Register 15 of sys_time unit now can be accessed by external DPM address 0x240+((0xf*4-0x1C) & 0x3C) = 0x260 (i.e. Tunnel DWord 8). */
/*         Register 0  of sys_time unit now can be accessed by external DPM address 0x240+((0x0*4-0x1C) & 0x3C) = 0x264 (i.e. Tunnel DWord 9). */
/*         Register 1  of sys_time unit now can be accessed by external DPM address 0x240+((0x1*4-0x1C) & 0x3C) = 0x268 (i.e. Tunnel DWord 10). */
/*         and so on. */
/*         Register 6  of sys_time unit can not be accessed as it is hidden by ITBAddr configuration on 0x27c (i.e. Tunnel DWord 15). */
/*         Register 7  of sys_time unit now can be accessed by external DPM address 0x240+((0x7*4-0x1C) & 0x3C) = 0x240 (i.e. Tunnel DWord 0). */
/*    Note: */
/*      Access to netX ITBAddr data is done without read ahead and with byte collecting (view adr_dpm_win1_map for details). */
/*    Note: */
/*      Configuration Window 0 access detection has higher priority than normal DPM Window */
/*      detection but lower priority than Access Tunnel access detection. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_tunnel_cfg  0x00000038U
#define Adr_NX51_dpm_dpm_tunnel_cfg  0x1018C038U
#define Adr_NX51_dpm_tunnel_cfg      0x1018C038U
#define DFLT_VAL_NX51_dpm_tunnel_cfg 0x00000101U

#define MSK_NX51_dpm_tunnel_cfg_wp_data              0x00000001U
#define SRT_NX51_dpm_tunnel_cfg_wp_data              0
#define DFLT_VAL_NX51_dpm_tunnel_cfg_wp_data         0x00000001U
#define DFLT_BF_VAL_NX51_dpm_tunnel_cfg_wp_data      0x00000001U
#define MSK_NX51_dpm_tunnel_cfg_wp_itbaddr           0x00000002U
#define SRT_NX51_dpm_tunnel_cfg_wp_itbaddr           1
#define DFLT_VAL_NX51_dpm_tunnel_cfg_wp_itbaddr      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_tunnel_cfg_wp_itbaddr   0x00000000U
#define MSK_NX51_dpm_tunnel_cfg_enable               0x00000004U
#define SRT_NX51_dpm_tunnel_cfg_enable               2
#define DFLT_VAL_NX51_dpm_tunnel_cfg_enable          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_tunnel_cfg_enable       0x00000000U
#define MSK_NX51_dpm_tunnel_cfg_tunnel_all           0x00000008U
#define SRT_NX51_dpm_tunnel_cfg_tunnel_all           3
#define DFLT_VAL_NX51_dpm_tunnel_cfg_tunnel_all      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_tunnel_cfg_tunnel_all   0x00000000U
#define MSK_NX51_dpm_tunnel_cfg_byte_area            0x00000010U
#define SRT_NX51_dpm_tunnel_cfg_byte_area            4
#define DFLT_VAL_NX51_dpm_tunnel_cfg_byte_area       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_tunnel_cfg_byte_area    0x00000000U
#define MSK_NX51_dpm_tunnel_cfg_dis_rd_latch         0x00000020U
#define SRT_NX51_dpm_tunnel_cfg_dis_rd_latch         5
#define DFLT_VAL_NX51_dpm_tunnel_cfg_dis_rd_latch    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_tunnel_cfg_dis_rd_latch 0x00000000U
#define MSK_NX51_dpm_tunnel_cfg_base                 0x000fffc0U
#define SRT_NX51_dpm_tunnel_cfg_base                 6
#define DFLT_VAL_NX51_dpm_tunnel_cfg_base            0x00000100U
#define DFLT_BF_VAL_NX51_dpm_tunnel_cfg_base         0x00000004U

/* all used bits of 'NX51_dpm_tunnel_cfg': */
#define MSK_USED_BITS_NX51_dpm_tunnel_cfg 0x000fffffU

enum {
	BFW_NX51_dpm_tunnel_cfg_wp_data      = 1,  /* [0] */
	BFW_NX51_dpm_tunnel_cfg_wp_itbaddr   = 1,  /* [1] */
	BFW_NX51_dpm_tunnel_cfg_enable       = 1,  /* [2] */
	BFW_NX51_dpm_tunnel_cfg_tunnel_all   = 1,  /* [3] */
	BFW_NX51_dpm_tunnel_cfg_byte_area    = 1,  /* [4] */
	BFW_NX51_dpm_tunnel_cfg_dis_rd_latch = 1,  /* [5] */
	BFW_NX51_dpm_tunnel_cfg_base         = 14, /* [19:6] */
	BFW_NX51_dpm_tunnel_cfg_reserved1    = 12  /* [31:20] */
};

typedef struct NX51_DPM_TUNNEL_CFG_BIT_Ttag {
	unsigned int wp_data      : BFW_NX51_dpm_tunnel_cfg_wp_data;      /* Access Tunnel function is write-protected from data access (DWords 0 to 14 of DATunnel).                      */
	                                                                  /* Write accesses to DWords 0 to 14 of DATunnel will be ignored.                                                 */
	                                                                  /* Data write protection for host is enabled by default and can be disabled by clearing this bit.                */
	unsigned int wp_itbaddr   : BFW_NX51_dpm_tunnel_cfg_wp_itbaddr;   /* ITBAddr is write-protected from host.                                                                         */
	                                                                  /* If this bit is set, ITBAddr (Internal netX 32 bit Tunnel Target Base Address)                                 */
	                                                                  /* can only be changed from netX side using dpm_itbaddr address.                                                 */
	                                                                  /* Write accesses to DWords 0 to 14 of DATunnel will be ignored.                                                 */
	unsigned int enable       : BFW_NX51_dpm_tunnel_cfg_enable;       /* Enable/disable Access Tunnel function.                                                                        */
	unsigned int tunnel_all   : BFW_NX51_dpm_tunnel_cfg_tunnel_all;   /* Enable/disable external access to Internal Target Base Address (ITBAddr) Configuration Register.              */
	                                                                  /* If this bit is set Internal Target Base Address (ITBAddr) configuration is not available at tunnel            */
	                                                                  /* offset 0x3C. All 64 tunnel target bytes can be accessed then (no hidden register). Target mapping and address */
	                                                                  /* (base and map) will not be changed when enable or disabled.                                                   */
	                                                                  /* Note:                                                                                                         */
	                                                                  /*    This is a new netx51 feature.                                                                              */
	unsigned int byte_area    : BFW_NX51_dpm_tunnel_cfg_byte_area;    /* Tunnel is byte area or not. View 'byte_area' of 'dpm_win1_map' register for details.                          */
	                                                                  /* Note:                                                                                                         */
	                                                                  /*    This is a new netx51 feature.                                                                              */
	unsigned int dis_rd_latch : BFW_NX51_dpm_tunnel_cfg_dis_rd_latch; /* Disabled read data latch for Tunnel. View 'dis_rd_latch' of 'dpm_win1_map' register for details.              */
	                                                                  /* Note:                                                                                                         */
	                                                                  /*    This is a new netx51 feature.                                                                              */
	unsigned int base         : BFW_NX51_dpm_tunnel_cfg_base;         /* DPM Access Tunnel (DATunnel) Base Address divided by 64 on external visible address space.                    */
	                                                                  /* Note:                                                                                                         */
	                                                                  /*    Default setting for tunnel base is starting on external address 0x100.                                     */
	unsigned int reserved1    : BFW_NX51_dpm_tunnel_cfg_reserved1;    /* reserved                                                                                                      */
} NX51_DPM_TUNNEL_CFG_BIT_T;

typedef union {
	unsigned int              val;
	NX51_DPM_TUNNEL_CFG_BIT_T bf;
} NX51_DPM_TUNNEL_CFG_T;

/* --------------------------------------------------------------------- */
/* Register dpm_itbaddr */
/* => DPM Access Tunnel (DATunnel) netX Internal Target Base Address (ITBAddr) Configuration Register. */
/*    For DPM Access Tunnel (DATunnel) function view description of dpm_tunnel_cfg register. */
/*    This register contains ITBAddr value that can also be changed by host on last offset 0x3c (last DWord) of */
/*    external DATunnel area (defined by bit field 'base' in 'dpm_tunnel_cfg' register). However this register can */
/*    also be write-protected from host if bit 'wp_itbaddr' in 'dpm_tunnel_cfg' register is set. */
/*    Write protection bits of DATunnel configured in 'dpm_tunnel_cfg' register can also be read from this register. Host */
/*    can read access rights from these bits on last DWord of external DATunnel address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_itbaddr  0x0000003CU
#define Adr_NX51_dpm_dpm_itbaddr  0x1018C03CU
#define Adr_NX51_dpm_itbaddr      0x1018C03CU
#define DFLT_VAL_NX51_dpm_itbaddr 0x00000001U

#define MSK_NX51_dpm_itbaddr_wp_data_ro            0x00000001U
#define SRT_NX51_dpm_itbaddr_wp_data_ro            0
#define DFLT_VAL_NX51_dpm_itbaddr_wp_data_ro       0x00000001U
#define DFLT_BF_VAL_NX51_dpm_itbaddr_wp_data_ro    0x00000001U
#define MSK_NX51_dpm_itbaddr_wp_itbaddr_ro         0x00000002U
#define SRT_NX51_dpm_itbaddr_wp_itbaddr_ro         1
#define DFLT_VAL_NX51_dpm_itbaddr_wp_itbaddr_ro    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_itbaddr_wp_itbaddr_ro 0x00000000U
#define MSK_NX51_dpm_itbaddr_map                   0x0000003cU
#define SRT_NX51_dpm_itbaddr_map                   2
#define DFLT_VAL_NX51_dpm_itbaddr_map              0x00000000U
#define DFLT_BF_VAL_NX51_dpm_itbaddr_map           0x00000000U
#define MSK_NX51_dpm_itbaddr_base                  0xffffffc0U
#define SRT_NX51_dpm_itbaddr_base                  6
#define DFLT_VAL_NX51_dpm_itbaddr_base             0x00000000U
#define DFLT_BF_VAL_NX51_dpm_itbaddr_base          0x00000000U

/* all used bits of 'NX51_dpm_itbaddr': */
#define MSK_USED_BITS_NX51_dpm_itbaddr 0xffffffffU

enum {
	BFW_NX51_dpm_itbaddr_wp_data_ro    = 1,  /* [0] */
	BFW_NX51_dpm_itbaddr_wp_itbaddr_ro = 1,  /* [1] */
	BFW_NX51_dpm_itbaddr_map           = 4,  /* [5:2] */
	BFW_NX51_dpm_itbaddr_base          = 26  /* [31:6] */
};

typedef struct NX51_DPM_ITBADDR_BIT_Ttag {
	unsigned int wp_data_ro    : BFW_NX51_dpm_itbaddr_wp_data_ro;    /* Access Tunnel function is write-protected from data access (DWords 0 to 14 of DATunnel). */
	                                                                 /* This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register.   */
	                                                                 /* View description of dpm_tunnel_cfg register.                                             */
	unsigned int wp_itbaddr_ro : BFW_NX51_dpm_itbaddr_wp_itbaddr_ro; /* ITBAddr is write-protected from host.                                                    */
	                                                                 /* This is a read-only bit here. Its setting can be changed in 'dpm_tunnel_cfg' register.   */
	                                                                 /* View description of dpm_tunnel_cfg register.                                             */
	unsigned int map           : BFW_NX51_dpm_itbaddr_map;           /* Mapping part of ITBAddr.                                                                 */
	                                                                 /* View description of dpm_tunnel_cfg register.                                             */
	unsigned int base          : BFW_NX51_dpm_itbaddr_base;          /* Internal netX Tunnel Target Base Address (ITBAddr) divided by 64.                        */
	                                                                 /* View description of dpm_tunnel_cfg register.                                             */
} NX51_DPM_ITBADDR_BIT_T;

typedef union {
	unsigned int           val;
	NX51_DPM_ITBADDR_BIT_T bf;
} NX51_DPM_ITBADDR_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win1_end */
/* => DPM Window 1 End Address Configuration Register. */
/*    Smallest DPM window configuration unit is 128 bytes (i.e. lowest 7 bits of address configuration are always 0). */
/*    At address 0x0 DPM configuration window is mapped after reset (length: 256 bytes, containing all DPM addresses defined here). Each window starts at */
/*    window end address of the preceding window. Hence external window 1 start address is 0x100, window 2 starts at value programmed in this register and so on. */
/*    Windows with programmed end addresses exceeding external address range (view dpm_addr_cfg) can not be accessed by host device. */
/*    Note: */
/*      Configuration Window 0 access detection has higher priority than normal DPM Window */
/*      detection but lower priority than Access Tunnel access detection. */
/*    Note: */
/*      Since netX10 window configuration can be done in steps of 128 bytes. In netx5 only steps of 256 bytes are possible. */
/*    Note: */
/*      Since netX10 there are 4 programmable DPM windows provided. Only for netX5 there are 5 windows. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win1_end  0x00000040U
#define Adr_NX51_dpm_dpm_win1_end  0x1018C040U
#define Adr_NX51_dpm_win1_end      0x1018C040U
#define DFLT_VAL_NX51_dpm_win1_end 0x00000000U

#define MSK_NX51_dpm_win1_end_win_end         0x001fff80U
#define SRT_NX51_dpm_win1_end_win_end         7
#define DFLT_VAL_NX51_dpm_win1_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win1_end_win_end 0x00000000U

/* all used bits of 'NX51_dpm_win1_end': */
#define MSK_USED_BITS_NX51_dpm_win1_end 0x001fff80U

enum {
	BFW_NX51_dpm_win1_end_reserved1 = 7,  /* [6:0] */
	BFW_NX51_dpm_win1_end_win_end   = 14, /* [20:7] */
	BFW_NX51_dpm_win1_end_reserved2 = 11  /* [31:21] */
};

typedef struct NX51_DPM_WIN1_END_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_dpm_win1_end_reserved1; /* reserved                                                                                      */
	unsigned int win_end   : BFW_NX51_dpm_win1_end_win_end;   /* Window 1 End Address divided by 128.                                                          */
	                                                          /* Last external address is win_end*128-1.                                                       */
	                                                          /* Setting win_end to 0 will disable this window.                                                */
	                                                          /* If programmed external address range (adr_dpm_addr_cfg) is smaller than maximum               */
	                                                          /* external address range, access addresses will be zero-expanded for upper unused address lines */
	                                                          /* before window match detection.                                                                */
	unsigned int reserved2 : BFW_NX51_dpm_win1_end_reserved2; /* reserved                                                                                      */
} NX51_DPM_WIN1_END_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN1_END_BIT_T bf;
} NX51_DPM_WIN1_END_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win1_map */
/* => DPM Window 1 Address Map Configuration Register. */
/*    Smallest DPM window configuration unit is 128 bytes (i.e. lowest 8 bits of address configuration are always 0). */
/*    For further information view description of 'dpm_win1_end' register. */
/*    Note: */
/*      Since netX10 window pages of 1MB is supported. For netX5 this was not necessary as all netX5 addresses are in bound of 1MB.. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win1_map  0x00000044U
#define Adr_NX51_dpm_dpm_win1_map  0x1018C044U
#define Adr_NX51_dpm_win1_map      0x1018C044U
#define DFLT_VAL_NX51_dpm_win1_map 0x01800000U

#define MSK_NX51_dpm_win1_map_byte_area            0x00000001U
#define SRT_NX51_dpm_win1_map_byte_area            0
#define DFLT_VAL_NX51_dpm_win1_map_byte_area       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win1_map_byte_area    0x00000000U
#define MSK_NX51_dpm_win1_map_read_ahead           0x00000002U
#define SRT_NX51_dpm_win1_map_read_ahead           1
#define DFLT_VAL_NX51_dpm_win1_map_read_ahead      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win1_map_read_ahead   0x00000000U
#define MSK_NX51_dpm_win1_map_win_map_alt          0x0000000cU
#define SRT_NX51_dpm_win1_map_win_map_alt          2
#define DFLT_VAL_NX51_dpm_win1_map_win_map_alt     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win1_map_win_map_alt  0x00000000U
#define MSK_NX51_dpm_win1_map_dis_rd_latch         0x00000010U
#define SRT_NX51_dpm_win1_map_dis_rd_latch         4
#define DFLT_VAL_NX51_dpm_win1_map_dis_rd_latch    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win1_map_dis_rd_latch 0x00000000U
#define MSK_NX51_dpm_win1_map_win_map              0x000fff80U
#define SRT_NX51_dpm_win1_map_win_map              7
#define DFLT_VAL_NX51_dpm_win1_map_win_map         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win1_map_win_map      0x00000000U
#define MSK_NX51_dpm_win1_map_win_page             0xfff00000U
#define SRT_NX51_dpm_win1_map_win_page             20
#define DFLT_VAL_NX51_dpm_win1_map_win_page        0x01800000U
#define DFLT_BF_VAL_NX51_dpm_win1_map_win_page     0x00000018U

/* all used bits of 'NX51_dpm_win1_map': */
#define MSK_USED_BITS_NX51_dpm_win1_map 0xffffff9fU

enum {
	BFW_NX51_dpm_win1_map_byte_area    = 1,  /* [0] */
	BFW_NX51_dpm_win1_map_read_ahead   = 1,  /* [1] */
	BFW_NX51_dpm_win1_map_win_map_alt  = 2,  /* [3:2] */
	BFW_NX51_dpm_win1_map_dis_rd_latch = 1,  /* [4] */
	BFW_NX51_dpm_win1_map_reserved1    = 2,  /* [6:5] */
	BFW_NX51_dpm_win1_map_win_map      = 13, /* [19:7] */
	BFW_NX51_dpm_win1_map_win_page     = 12  /* [31:20] */
};

typedef struct NX51_DPM_WIN1_MAP_BIT_Ttag {
	unsigned int byte_area    : BFW_NX51_dpm_win1_map_byte_area;    /* Window is byte-write area.                                                                                            */
	                                                                /* 1: Target area of this window is byte accessible. Any write access are done immediately internally.                   */
	                                                                /* 0: Target area of this window is 32 bit accessible. Single write accesses are collected until a 32 bit data           */
	                                                                /*    word (DWord) is received completely from host (write-byte-collecting). Data is written to netX target address when */
	                                                                /*    the 32bit data word is complete.                                                                                   */
	                                                                /* Note:                                                                                                                 */
	                                                                /*    Since netX51 write-byte-collecting buffer is cleared when host is leaving the current 4-byte-address-boundary      */
	                                                                /*    (e.g. changing address from 0x103 to 0x104). That means all sub-DWord access which should make up the whole DWord  */
	                                                                /*    must target the same 4-byte-boundary. In prior DPM versions only the last written data determined netX internal    */
	                                                                /*    access address and there was no check whether all prior written data was written to the same DWord. The            */
	                                                                /*    address-boundary check is implemented to avoid write-byte-collecting getting confused by single DPM access         */
	                                                                /*    errors (e.g. by a single missing byte-write).                                                                      */
	                                                                /* Note:                                                                                                                 */
	                                                                /*    The setting of this bit does not affect read functionality. For details see 'dis_rd_latch' bit description.        */
	unsigned int read_ahead   : BFW_NX51_dpm_win1_map_read_ahead;   /* Read ahead.                                                                                                           */
	                                                                /* If this bit is set, read ahead will be done. This will minimize read cycle time if ready generation is                */
	                                                                /* used but could cause problems with read sensitive logic (e.g. FIFOs).                                                 */
	                                                                /* Note:                                                                                                                 */
	                                                                /*    Read-ahead should not be enabled when 'dis_rd_latch' bit is set for the same window. Otherwise access              */
	                                                                /*    timing could decrease dramatically (does not apply to setting of another window).                                  */
	unsigned int win_map_alt  : BFW_NX51_dpm_win1_map_win_map_alt;  /* Window 1 Alternative Address Mapping Configuration.                                                                   */
	                                                                /* Alternative Address Mapping can be generated by Triple Buffer Managers inside HANDSHAKE_CTRL unit.                    */
	                                                                /* Coding:                                                                                                               */
	                                                                /*  00 : Alternative Address Mapping disabled.                                                                           */
	                                                                /*  01 : Alternative Address Mapping enabled: Use Triple Buffer Manager 0 from HANDSHAKE_CTRL unit.                      */
	                                                                /*  10 : Alternative Address Mapping enabled: Use Triple Buffer Manager 1 from HANDSHAKE_CTRL unit.                      */
	                                                                /*  11 : reserved                                                                                                        */
	                                                                /* If Alternative Address Mapping is enabled, mapping value is taken according to buffer status                          */
	                                                                /* of related HANDSHAKE_CTRL Triple Buffer Manager as follows.                                                           */
	                                                                /* {                    |                                                                                                */
	                                                                /*   buffer status        used mapping value                                                                             */
	                                                                /*   00 (buffer 0)        win_map entry of this register                                                                 */
	                                                                /*   01 (buffer 1)        Alternative win_map value 1 of related HANDSHAKE_CTRL Triple Buffer Manager.                   */
	                                                                /*   10 (buffer 2)        Alternative win_map value 2 of related HANDSHAKE_CTRL Triple Buffer Manager.                   */
	                                                                /*   11 (invalid buffer)  win_map entry of this register }                                                               */
	                                                                /* Note:                                                                                                                 */
	                                                                /*    Alternative Triple Buffer Manager win_map values can be programmed in HANDSHAKE_CTRL address area.                 */
	unsigned int dis_rd_latch : BFW_NX51_dpm_win1_map_dis_rd_latch; /* Window 1 read data latch disable.                                                                                     */
	                                                                /* By default all netX internal read access are done as 32 bit access and read data is latched                           */
	                                                                /* inside DPM interface. This is done to provide data consistence when host is connected by                              */
	                                                                /* an interface smaller than 32 bit. Read data latch is updated (new read form netX logic)                               */
	                                                                /* when host read address is changing to another 32 bit address or if host read access repeats                           */
	                                                                /* reading the same data within the 32 bit address boundary of prior accesses (e.g. polling).                            */
	                                                                /* Reading 32 bit status information from netX should be done with byte latching (Example 1).                            */
	                                                                /* Read data latch can be disabled by setting this bit to avoid special handling of byte (or                             */
	                                                                /* 16 bit) data streams (Example 2).                                                                                     */
	                                                                /* Example 1: Enabled read data latching (default, 'dis_rd_latch' bit ist not set):                                      */
	                                                                /*    Reading 32 bit systime from netX without data latching will fail when DPM                                          */
	                                                                /*    is not 32 bit wide. Considering an 8 bit DPM interface would lead to 4 single                                      */
	                                                                /*    host byte read accesses for complete systime. Without data latching systime will                                   */
	                                                                /*    be re-read for each byte requested by host. This will lead to invalid data as systime                              */
	                                                                /*    will change between single reads.                                                                                  */
	                                                                /*    When data latching is enabled, systime will be read from netX at the first host byte read                          */
	                                                                /*    access. Following 3 host byte reads will receive data from DPM data latch which contains                           */
	                                                                /*    complete 32 bit systime value read at the first access. Host will receive valid systime data.                      */
	                                                                /* Example 2 Disabled read data latching ('dis_rd_latch' bit is set):                                                    */
	                                                                /*    Reading a byte stream could fail when it is appended by an application running netX inside                         */
	                                                                /*    could fail. Considering an netX application providing 13 bytes starting at a 32 bit boundary                       */
	                                                                /*    for host and host is reading these bytes. After that netX application is appending new data                        */
	                                                                /*    bytes 14 to 20. When data read latch is enabled host will receive bytes 14 to 16 from data                         */
	                                                                /*    latch. However these bytes are not valid any longer as netX application changed them in                            */
	                                                                /*    background. In this case data latching must be disabled.                                                           */
	                                                                /*    However reading byte streams is also possible with enabled data latch. In this case                                */
	                                                                /*    host must always read full 32 bit data words (i.e. restart with byte 13 when reading the                           */
	                                                                /*    second part of the stream).                                                                                        */
	                                                                /* Note:                                                                                                                 */
	                                                                /*    When read data latch is disable 'read_ahead' bit should not be set for the same window. Otherwise access           */
	                                                                /*    timing could decrease dramatically (does not apply to setting of another window).                                  */
	                                                                /* Note:                                                                                                                 */
	                                                                /*    All netX internal read access are performed as 32 bit access.                                                      */
	                                                                /* Note:                                                                                                                 */
	                                                                /*    This is a new netx51 feature.                                                                                      */
	                                                                /*    Behaviour of older netX versions (e.g. netX10) is similar to default setting 0. No functional                      */
	                                                                /*    changes are done for default case.                                                                                 */
	unsigned int reserved1    : BFW_NX51_dpm_win1_map_reserved1;    /* reserved                                                                                                              */
	unsigned int win_map      : BFW_NX51_dpm_win1_map_win_map;      /* Window 1 Address Mapping.                                                                                             */
	                                                                /* Internal access address HADDR to netX logic is combined by DPM interface by:                                          */
	                                                                /* HADDR[31:20]: win_page                                                                                                */
	                                                                /* HADDR[19:0]:  mapped DPM address. This part of address is defined by programmed win_map value for each window.        */
	                                                                /* The value to be programmed is address bits 19 to 0 of netX internal window start address minus start address of the   */
	                                                                /* external window (i.e. end address of preceding window) .                                                              */
	                                                                /* Example:                                                                                                              */
	                                                                /*    Window n starts at 0x400 of external DPM address range (i.e. programmed win_end value of window (n-1) and targets  */
	                                                                /*    netX address 0x01808000.                                                                                           */
	                                                                /*    For address calculation only lower 20 bits of netX address are relevant, i.e. 0x08000.                             */
	                                                                /*    The complete 20 bit address map value is then:0x08000-0x400=0x07C00.                                               */
	                                                                /*    Hence the programmed 13 bit value must be 0x07C00>>7=0xf8.                                                         */
	unsigned int win_page     : BFW_NX51_dpm_win1_map_win_page;     /* Window 1 address page.                                                                                                */
	                                                                /* Internal address space of netX is divided in 1MB pages. Changing win_map allows addressing inside                     */
	                                                                /* the whole currently set page.                                                                                         */
	                                                                /* Example:                                                                                                              */
	                                                                /*    Window n starts at 0x400 of external DPM address range (i.e. programmed win_end value of window (n-1) and targets  */
	                                                                /*    netX address 0x01808000.                                                                                           */
	                                                                /*    The programmed value for the related page is 0x018.                                                                */
} NX51_DPM_WIN1_MAP_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN1_MAP_BIT_T bf;
} NX51_DPM_WIN1_MAP_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win2_end */
/* => DPM Window 2 End Address Configuration Register. */
/*    For detailed information view dpm_win1_end description. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win2_end  0x00000048U
#define Adr_NX51_dpm_dpm_win2_end  0x1018C048U
#define Adr_NX51_dpm_win2_end      0x1018C048U
#define DFLT_VAL_NX51_dpm_win2_end 0x00000000U

#define MSK_NX51_dpm_win2_end_win_end         0x001fff80U
#define SRT_NX51_dpm_win2_end_win_end         7
#define DFLT_VAL_NX51_dpm_win2_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win2_end_win_end 0x00000000U

/* all used bits of 'NX51_dpm_win2_end': */
#define MSK_USED_BITS_NX51_dpm_win2_end 0x001fff80U

enum {
	BFW_NX51_dpm_win2_end_reserved1 = 7,  /* [6:0] */
	BFW_NX51_dpm_win2_end_win_end   = 14, /* [20:7] */
	BFW_NX51_dpm_win2_end_reserved2 = 11  /* [31:21] */
};

typedef struct NX51_DPM_WIN2_END_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_dpm_win2_end_reserved1; /* reserved                                                                     */
	unsigned int win_end   : BFW_NX51_dpm_win2_end_win_end;   /* Window 2 End Address divided by 128. Last external address is win_end*128-1. */
	unsigned int reserved2 : BFW_NX51_dpm_win2_end_reserved2; /* reserved                                                                     */
} NX51_DPM_WIN2_END_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN2_END_BIT_T bf;
} NX51_DPM_WIN2_END_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win2_map */
/* => DPM Window 2 Address Map Configuration Register. */
/*    For detailed information view dpm_win1_map description. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win2_map  0x0000004CU
#define Adr_NX51_dpm_dpm_win2_map  0x1018C04CU
#define Adr_NX51_dpm_win2_map      0x1018C04CU
#define DFLT_VAL_NX51_dpm_win2_map 0x01800000U

#define MSK_NX51_dpm_win2_map_byte_area            0x00000001U
#define SRT_NX51_dpm_win2_map_byte_area            0
#define DFLT_VAL_NX51_dpm_win2_map_byte_area       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win2_map_byte_area    0x00000000U
#define MSK_NX51_dpm_win2_map_read_ahead           0x00000002U
#define SRT_NX51_dpm_win2_map_read_ahead           1
#define DFLT_VAL_NX51_dpm_win2_map_read_ahead      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win2_map_read_ahead   0x00000000U
#define MSK_NX51_dpm_win2_map_win_map_alt          0x0000000cU
#define SRT_NX51_dpm_win2_map_win_map_alt          2
#define DFLT_VAL_NX51_dpm_win2_map_win_map_alt     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win2_map_win_map_alt  0x00000000U
#define MSK_NX51_dpm_win2_map_dis_rd_latch         0x00000010U
#define SRT_NX51_dpm_win2_map_dis_rd_latch         4
#define DFLT_VAL_NX51_dpm_win2_map_dis_rd_latch    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win2_map_dis_rd_latch 0x00000000U
#define MSK_NX51_dpm_win2_map_win_map              0x000fff80U
#define SRT_NX51_dpm_win2_map_win_map              7
#define DFLT_VAL_NX51_dpm_win2_map_win_map         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win2_map_win_map      0x00000000U
#define MSK_NX51_dpm_win2_map_win_page             0xfff00000U
#define SRT_NX51_dpm_win2_map_win_page             20
#define DFLT_VAL_NX51_dpm_win2_map_win_page        0x01800000U
#define DFLT_BF_VAL_NX51_dpm_win2_map_win_page     0x00000018U

/* all used bits of 'NX51_dpm_win2_map': */
#define MSK_USED_BITS_NX51_dpm_win2_map 0xffffff9fU

enum {
	BFW_NX51_dpm_win2_map_byte_area    = 1,  /* [0] */
	BFW_NX51_dpm_win2_map_read_ahead   = 1,  /* [1] */
	BFW_NX51_dpm_win2_map_win_map_alt  = 2,  /* [3:2] */
	BFW_NX51_dpm_win2_map_dis_rd_latch = 1,  /* [4] */
	BFW_NX51_dpm_win2_map_reserved1    = 2,  /* [6:5] */
	BFW_NX51_dpm_win2_map_win_map      = 13, /* [19:7] */
	BFW_NX51_dpm_win2_map_win_page     = 12  /* [31:20] */
};

typedef struct NX51_DPM_WIN2_MAP_BIT_Ttag {
	unsigned int byte_area    : BFW_NX51_dpm_win2_map_byte_area;    /* Window is byte area.                              */
	unsigned int read_ahead   : BFW_NX51_dpm_win2_map_read_ahead;   /* Read ahead.                                       */
	unsigned int win_map_alt  : BFW_NX51_dpm_win2_map_win_map_alt;  /* Window Alternative Address Mapping Configuration. */
	unsigned int dis_rd_latch : BFW_NX51_dpm_win2_map_dis_rd_latch; /* Window read data latch disable.                   */
	unsigned int reserved1    : BFW_NX51_dpm_win2_map_reserved1;    /* reserved                                          */
	unsigned int win_map      : BFW_NX51_dpm_win2_map_win_map;      /* Window address mapping.                           */
	unsigned int win_page     : BFW_NX51_dpm_win2_map_win_page;     /* Window address page.                              */
} NX51_DPM_WIN2_MAP_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN2_MAP_BIT_T bf;
} NX51_DPM_WIN2_MAP_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win3_end */
/* => DPM Window 3 End Address Configuration Register. */
/*    For detailed information view dpm_win1_end description. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win3_end  0x00000050U
#define Adr_NX51_dpm_dpm_win3_end  0x1018C050U
#define Adr_NX51_dpm_win3_end      0x1018C050U
#define DFLT_VAL_NX51_dpm_win3_end 0x00000000U

#define MSK_NX51_dpm_win3_end_win_end         0x001fff80U
#define SRT_NX51_dpm_win3_end_win_end         7
#define DFLT_VAL_NX51_dpm_win3_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win3_end_win_end 0x00000000U

/* all used bits of 'NX51_dpm_win3_end': */
#define MSK_USED_BITS_NX51_dpm_win3_end 0x001fff80U

enum {
	BFW_NX51_dpm_win3_end_reserved1 = 7,  /* [6:0] */
	BFW_NX51_dpm_win3_end_win_end   = 14, /* [20:7] */
	BFW_NX51_dpm_win3_end_reserved2 = 11  /* [31:21] */
};

typedef struct NX51_DPM_WIN3_END_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_dpm_win3_end_reserved1; /* reserved                                                                     */
	unsigned int win_end   : BFW_NX51_dpm_win3_end_win_end;   /* Window 3 End Address divided by 128. Last external address is win_end*128-1. */
	unsigned int reserved2 : BFW_NX51_dpm_win3_end_reserved2; /* reserved                                                                     */
} NX51_DPM_WIN3_END_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN3_END_BIT_T bf;
} NX51_DPM_WIN3_END_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win3_map */
/* => DPM Window 3 Address Map Configuration Register. */
/*    For detailed information view dpm_win1_map description. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win3_map  0x00000054U
#define Adr_NX51_dpm_dpm_win3_map  0x1018C054U
#define Adr_NX51_dpm_win3_map      0x1018C054U
#define DFLT_VAL_NX51_dpm_win3_map 0x01800000U

#define MSK_NX51_dpm_win3_map_byte_area            0x00000001U
#define SRT_NX51_dpm_win3_map_byte_area            0
#define DFLT_VAL_NX51_dpm_win3_map_byte_area       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win3_map_byte_area    0x00000000U
#define MSK_NX51_dpm_win3_map_read_ahead           0x00000002U
#define SRT_NX51_dpm_win3_map_read_ahead           1
#define DFLT_VAL_NX51_dpm_win3_map_read_ahead      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win3_map_read_ahead   0x00000000U
#define MSK_NX51_dpm_win3_map_win_map_alt          0x0000000cU
#define SRT_NX51_dpm_win3_map_win_map_alt          2
#define DFLT_VAL_NX51_dpm_win3_map_win_map_alt     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win3_map_win_map_alt  0x00000000U
#define MSK_NX51_dpm_win3_map_dis_rd_latch         0x00000010U
#define SRT_NX51_dpm_win3_map_dis_rd_latch         4
#define DFLT_VAL_NX51_dpm_win3_map_dis_rd_latch    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win3_map_dis_rd_latch 0x00000000U
#define MSK_NX51_dpm_win3_map_win_map              0x000fff80U
#define SRT_NX51_dpm_win3_map_win_map              7
#define DFLT_VAL_NX51_dpm_win3_map_win_map         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win3_map_win_map      0x00000000U
#define MSK_NX51_dpm_win3_map_win_page             0xfff00000U
#define SRT_NX51_dpm_win3_map_win_page             20
#define DFLT_VAL_NX51_dpm_win3_map_win_page        0x01800000U
#define DFLT_BF_VAL_NX51_dpm_win3_map_win_page     0x00000018U

/* all used bits of 'NX51_dpm_win3_map': */
#define MSK_USED_BITS_NX51_dpm_win3_map 0xffffff9fU

enum {
	BFW_NX51_dpm_win3_map_byte_area    = 1,  /* [0] */
	BFW_NX51_dpm_win3_map_read_ahead   = 1,  /* [1] */
	BFW_NX51_dpm_win3_map_win_map_alt  = 2,  /* [3:2] */
	BFW_NX51_dpm_win3_map_dis_rd_latch = 1,  /* [4] */
	BFW_NX51_dpm_win3_map_reserved1    = 2,  /* [6:5] */
	BFW_NX51_dpm_win3_map_win_map      = 13, /* [19:7] */
	BFW_NX51_dpm_win3_map_win_page     = 12  /* [31:20] */
};

typedef struct NX51_DPM_WIN3_MAP_BIT_Ttag {
	unsigned int byte_area    : BFW_NX51_dpm_win3_map_byte_area;    /* Window is byte area.                              */
	unsigned int read_ahead   : BFW_NX51_dpm_win3_map_read_ahead;   /* Read ahead.                                       */
	unsigned int win_map_alt  : BFW_NX51_dpm_win3_map_win_map_alt;  /* Window Alternative Address Mapping Configuration. */
	unsigned int dis_rd_latch : BFW_NX51_dpm_win3_map_dis_rd_latch; /* Window read data latch disable.                   */
	unsigned int reserved1    : BFW_NX51_dpm_win3_map_reserved1;    /* reserved                                          */
	unsigned int win_map      : BFW_NX51_dpm_win3_map_win_map;      /* Window map address.                               */
	unsigned int win_page     : BFW_NX51_dpm_win3_map_win_page;     /* Window address page.                              */
} NX51_DPM_WIN3_MAP_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN3_MAP_BIT_T bf;
} NX51_DPM_WIN3_MAP_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win4_end */
/* => DPM Window 4 End Address Configuration Register. */
/*    For detailed information view dpm_win1_end description. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win4_end  0x00000058U
#define Adr_NX51_dpm_dpm_win4_end  0x1018C058U
#define Adr_NX51_dpm_win4_end      0x1018C058U
#define DFLT_VAL_NX51_dpm_win4_end 0x00000000U

#define MSK_NX51_dpm_win4_end_win_end         0x001fff80U
#define SRT_NX51_dpm_win4_end_win_end         7
#define DFLT_VAL_NX51_dpm_win4_end_win_end    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win4_end_win_end 0x00000000U

/* all used bits of 'NX51_dpm_win4_end': */
#define MSK_USED_BITS_NX51_dpm_win4_end 0x001fff80U

enum {
	BFW_NX51_dpm_win4_end_reserved1 = 7,  /* [6:0] */
	BFW_NX51_dpm_win4_end_win_end   = 14, /* [20:7] */
	BFW_NX51_dpm_win4_end_reserved2 = 11  /* [31:21] */
};

typedef struct NX51_DPM_WIN4_END_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_dpm_win4_end_reserved1; /* reserved                                                                     */
	unsigned int win_end   : BFW_NX51_dpm_win4_end_win_end;   /* Window 4 End Address divided by 128. Last external address is win_end*128-1. */
	unsigned int reserved2 : BFW_NX51_dpm_win4_end_reserved2; /* reserved                                                                     */
} NX51_DPM_WIN4_END_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN4_END_BIT_T bf;
} NX51_DPM_WIN4_END_T;

/* --------------------------------------------------------------------- */
/* Register dpm_win4_map */
/* => DPM Window 4 Address Map Configuration Register. */
/*    For detailed information view dpm_win1_map description. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_win4_map  0x0000005CU
#define Adr_NX51_dpm_dpm_win4_map  0x1018C05CU
#define Adr_NX51_dpm_win4_map      0x1018C05CU
#define DFLT_VAL_NX51_dpm_win4_map 0x01800000U

#define MSK_NX51_dpm_win4_map_byte_area            0x00000001U
#define SRT_NX51_dpm_win4_map_byte_area            0
#define DFLT_VAL_NX51_dpm_win4_map_byte_area       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win4_map_byte_area    0x00000000U
#define MSK_NX51_dpm_win4_map_read_ahead           0x00000002U
#define SRT_NX51_dpm_win4_map_read_ahead           1
#define DFLT_VAL_NX51_dpm_win4_map_read_ahead      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win4_map_read_ahead   0x00000000U
#define MSK_NX51_dpm_win4_map_win_map_alt          0x0000000cU
#define SRT_NX51_dpm_win4_map_win_map_alt          2
#define DFLT_VAL_NX51_dpm_win4_map_win_map_alt     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win4_map_win_map_alt  0x00000000U
#define MSK_NX51_dpm_win4_map_dis_rd_latch         0x00000010U
#define SRT_NX51_dpm_win4_map_dis_rd_latch         4
#define DFLT_VAL_NX51_dpm_win4_map_dis_rd_latch    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win4_map_dis_rd_latch 0x00000000U
#define MSK_NX51_dpm_win4_map_win_map              0x000fff80U
#define SRT_NX51_dpm_win4_map_win_map              7
#define DFLT_VAL_NX51_dpm_win4_map_win_map         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_win4_map_win_map      0x00000000U
#define MSK_NX51_dpm_win4_map_win_page             0xfff00000U
#define SRT_NX51_dpm_win4_map_win_page             20
#define DFLT_VAL_NX51_dpm_win4_map_win_page        0x01800000U
#define DFLT_BF_VAL_NX51_dpm_win4_map_win_page     0x00000018U

/* all used bits of 'NX51_dpm_win4_map': */
#define MSK_USED_BITS_NX51_dpm_win4_map 0xffffff9fU

enum {
	BFW_NX51_dpm_win4_map_byte_area    = 1,  /* [0] */
	BFW_NX51_dpm_win4_map_read_ahead   = 1,  /* [1] */
	BFW_NX51_dpm_win4_map_win_map_alt  = 2,  /* [3:2] */
	BFW_NX51_dpm_win4_map_dis_rd_latch = 1,  /* [4] */
	BFW_NX51_dpm_win4_map_reserved1    = 2,  /* [6:5] */
	BFW_NX51_dpm_win4_map_win_map      = 13, /* [19:7] */
	BFW_NX51_dpm_win4_map_win_page     = 12  /* [31:20] */
};

typedef struct NX51_DPM_WIN4_MAP_BIT_Ttag {
	unsigned int byte_area    : BFW_NX51_dpm_win4_map_byte_area;    /* Window is byte area.                              */
	unsigned int read_ahead   : BFW_NX51_dpm_win4_map_read_ahead;   /* Read ahead.                                       */
	unsigned int win_map_alt  : BFW_NX51_dpm_win4_map_win_map_alt;  /* Window Alternative Address Mapping Configuration. */
	unsigned int dis_rd_latch : BFW_NX51_dpm_win4_map_dis_rd_latch; /* Window read data latch disable.                   */
	unsigned int reserved1    : BFW_NX51_dpm_win4_map_reserved1;    /* reserved                                          */
	unsigned int win_map      : BFW_NX51_dpm_win4_map_win_map;      /* Window map address.                               */
	unsigned int win_page     : BFW_NX51_dpm_win4_map_win_page;     /* Window address page.                              */
} NX51_DPM_WIN4_MAP_BIT_T;

typedef union {
	unsigned int            val;
	NX51_DPM_WIN4_MAP_BIT_T bf;
} NX51_DPM_WIN4_MAP_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_raw */
/* => DPM Raw (before masking) IRQ Status Register. */
/*    If a bit is set, the related interrupt is asserted. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    Important: There are two completely independent sets of IRQ registers: */
/*       IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers). */
/*       IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). */
/*       Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs */
/*       can be found in both sets (e.g. com0). */
/*    Note: */
/*       The 'dpm_sw' IRQ can be controlled by the 'dpm_sw_irq' register for each */
/*       IRQ target differently, i.e. there are 4 different 'dpm_sw' IRQs internally, one */
/*       for each IRQ target. However, 'dpm_sw' will be set inside the 'dpm_irq_raw' register here */
/*       when the 'dpm_sw' is activated for at least one IRQ target. But each IRQ target */
/*       obtains only the 'dpm_sw' IRQ state programmed for this target inside the 'dpm_sw_irq' */
/*       register. For an example view description of 'dpm_sw_irq' register. */
/*    Note: */
/*        The 'test' function is obsolte since netX51, the 'dpm_sw' bit can be used instead of this. */
/*    Note: */
/*        The 'firmware' IRQ can be used to flag handshake and netX firmware system status events to the */
/*        host. Firmware IRQ generation can be controlled by dpm_firmware_irq_mask register. Detailed */
/*        firmware IRQ status can be read from dpm_firmware_irq_raw register. */
/*    Note: */
/*        For all netX modules which are capable generating IRQs for ARM and xPIC, ARM-IRQ is taken here. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_raw 0x00000080U
#define Adr_NX51_dpm_dpm_irq_raw 0x1018C080U
#define Adr_NX51_dpm_irq_raw     0x1018C080U

#define MSK_NX51_dpm_irq_raw_dpm_sw     0x00000001U
#define SRT_NX51_dpm_irq_raw_dpm_sw     0
#define MSK_NX51_dpm_irq_raw_dpm_err    0x00000002U
#define SRT_NX51_dpm_irq_raw_dpm_err    1
#define MSK_NX51_dpm_irq_raw_gpio_timer 0x00000008U
#define SRT_NX51_dpm_irq_raw_gpio_timer 3
#define MSK_NX51_dpm_irq_raw_systime_ns 0x00000010U
#define SRT_NX51_dpm_irq_raw_systime_ns 4
#define MSK_NX51_dpm_irq_raw_systime_s  0x00000020U
#define SRT_NX51_dpm_irq_raw_systime_s  5
#define MSK_NX51_dpm_irq_raw_gpio31     0x00000040U
#define SRT_NX51_dpm_irq_raw_gpio31     6
#define MSK_NX51_dpm_irq_raw_watchdog   0x00000080U
#define SRT_NX51_dpm_irq_raw_watchdog   7
#define MSK_NX51_dpm_irq_raw_uart0      0x00000100U
#define SRT_NX51_dpm_irq_raw_uart0      8
#define MSK_NX51_dpm_irq_raw_uart1      0x00000200U
#define SRT_NX51_dpm_irq_raw_uart1      9
#define MSK_NX51_dpm_irq_raw_uart2      0x00000400U
#define SRT_NX51_dpm_irq_raw_uart2      10
#define MSK_NX51_dpm_irq_raw_usb        0x00000800U
#define SRT_NX51_dpm_irq_raw_usb        11
#define MSK_NX51_dpm_irq_raw_spi        0x00001000U
#define SRT_NX51_dpm_irq_raw_spi        12
#define MSK_NX51_dpm_irq_raw_i2c        0x00002000U
#define SRT_NX51_dpm_irq_raw_i2c        13
#define MSK_NX51_dpm_irq_raw_firmware   0x00008000U
#define SRT_NX51_dpm_irq_raw_firmware   15
#define MSK_NX51_dpm_irq_raw_gpio       0x00010000U
#define SRT_NX51_dpm_irq_raw_gpio       16
#define MSK_NX51_dpm_irq_raw_com0       0x00020000U
#define SRT_NX51_dpm_irq_raw_com0       17
#define MSK_NX51_dpm_irq_raw_com1       0x00040000U
#define SRT_NX51_dpm_irq_raw_com1       18
#define MSK_NX51_dpm_irq_raw_xpic_debug 0x00100000U
#define SRT_NX51_dpm_irq_raw_xpic_debug 20
#define MSK_NX51_dpm_irq_raw_msync0     0x00200000U
#define SRT_NX51_dpm_irq_raw_msync0     21
#define MSK_NX51_dpm_irq_raw_msync1     0x00400000U
#define SRT_NX51_dpm_irq_raw_msync1     22
#define MSK_NX51_dpm_irq_raw_int_phy    0x02000000U
#define SRT_NX51_dpm_irq_raw_int_phy    25
#define MSK_NX51_dpm_irq_raw_sysstate   0x04000000U
#define SRT_NX51_dpm_irq_raw_sysstate   26
#define MSK_NX51_dpm_irq_raw_dmac       0x08000000U
#define SRT_NX51_dpm_irq_raw_dmac       27
#define MSK_NX51_dpm_irq_raw_trigger_lt 0x10000000U
#define SRT_NX51_dpm_irq_raw_trigger_lt 28
#define MSK_NX51_dpm_irq_raw_can        0x20000000U
#define SRT_NX51_dpm_irq_raw_can        29
#define MSK_NX51_dpm_irq_raw_osac       0x40000000U
#define SRT_NX51_dpm_irq_raw_osac       30

/* all used bits of 'NX51_dpm_irq_raw': */
#define MSK_USED_BITS_NX51_dpm_irq_raw 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_raw_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_raw_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_raw_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_raw_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_raw_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_raw_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_raw_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_raw_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_raw_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_raw_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_raw_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_raw_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_raw_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_raw_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_raw_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_raw_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_raw_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_raw_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_raw_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_raw_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_raw_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_raw_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_raw_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_raw_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_raw_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_raw_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_raw_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_raw_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_raw_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_raw_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_raw_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_RAW_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_raw_dpm_sw;     /* raw software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_raw_dpm_err;    /* raw DPM access error interrupt                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_raw_reserved1;  /* reserved                                                             */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_raw_gpio_timer; /* raw GPIO Timer 0..4 interrupt                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_raw_systime_ns; /* raw ARM_TIMER systime_ns/systime_uc_ns interrupt                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_raw_systime_s;  /* raw ARM_TIMER systime_s/systime_uc_s interrupt                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_raw_gpio31;     /* raw external GPIO 31 interrupt                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_raw_watchdog;   /* raw combined Watchdog from WDG_SYS and XPIC_WDG module interrupt     */
	unsigned int uart0      : BFW_NX51_dpm_irq_raw_uart0;      /* raw UART 0 interrupt                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_raw_uart1;      /* raw UART 1 interrupt                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_raw_uart2;      /* raw UART 2 interrupt                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_raw_usb;        /* raw USB interrupt                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_raw_spi;        /* raw combined SPI 0 / SQI, SPI 1 interrupt                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_raw_i2c;        /* raw combined I2C 0 and I2C 1 interrupt                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_raw_reserved2;  /* reserved                                                             */
	unsigned int firmware   : BFW_NX51_dpm_irq_raw_firmware;   /* raw combined handshake-cell and SYS_STA firmware interrupt           */
	unsigned int gpio       : BFW_NX51_dpm_irq_raw_gpio;       /* raw combined GPIO 0-30 / IOLINK interrupt                            */
	unsigned int com0       : BFW_NX51_dpm_irq_raw_com0;       /* raw communication channel 0 (= |xpec0_irq[11:0]) interrupt           */
	unsigned int com1       : BFW_NX51_dpm_irq_raw_com1;       /* raw communication channel 1 (= |xpec1_irq[11:0]) interrupt           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_raw_reserved3;  /* reserved                                                             */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_raw_xpic_debug; /* raw xPIC Debug interrupt                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_raw_msync0;     /* raw motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt */
	unsigned int msync1     : BFW_NX51_dpm_irq_raw_msync1;     /* raw motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt */
	unsigned int reserved4  : BFW_NX51_dpm_irq_raw_reserved4;  /* reserved                                                             */
	unsigned int int_phy    : BFW_NX51_dpm_irq_raw_int_phy;    /* raw combined internal PHY 0 / PHY 1 interrupt                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_raw_sysstate;   /* raw combined licence error and MI timeout interrupt                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_raw_dmac;       /* raw DMA-Controller interrupt                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_raw_trigger_lt; /* raw Trigger-Latch interrupt                                          */
	unsigned int can        : BFW_NX51_dpm_irq_raw_can;        /* raw CAN interrupt                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_raw_osac;       /* raw OSAC interrupt                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_raw_reserved5;  /* reserved                                                             */
} NX51_DPM_IRQ_RAW_BIT_T;

typedef union {
	unsigned int           val;
	NX51_DPM_IRQ_RAW_BIT_T bf;
} NX51_DPM_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_arm_mask_set */
/* => DPM Interrupt Mask Register for netX internal ARM-CPU. */
/*    Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for netX internal ARM-CPU. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for netX internal ARM-CPU without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_arm_mask_set  0x00000084U
#define Adr_NX51_dpm_dpm_irq_arm_mask_set  0x1018C084U
#define Adr_NX51_dpm_irq_arm_mask_set      0x1018C084U
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set 0x00000000U

#define MSK_NX51_dpm_irq_arm_mask_set_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_arm_mask_set_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_arm_mask_set_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_arm_mask_set_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_arm_mask_set_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_arm_mask_set_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_arm_mask_set_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_arm_mask_set_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_uart0              0x00000100U
#define SRT_NX51_dpm_irq_arm_mask_set_uart0              8
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_uart0      0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_uart1              0x00000200U
#define SRT_NX51_dpm_irq_arm_mask_set_uart1              9
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_uart1      0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_uart2              0x00000400U
#define SRT_NX51_dpm_irq_arm_mask_set_uart2              10
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_uart2      0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_usb                0x00000800U
#define SRT_NX51_dpm_irq_arm_mask_set_usb                11
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_usb        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_spi                0x00001000U
#define SRT_NX51_dpm_irq_arm_mask_set_spi                12
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_spi        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_i2c                0x00002000U
#define SRT_NX51_dpm_irq_arm_mask_set_i2c                13
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_i2c        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_firmware           0x00008000U
#define SRT_NX51_dpm_irq_arm_mask_set_firmware           15
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_firmware   0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_gpio               0x00010000U
#define SRT_NX51_dpm_irq_arm_mask_set_gpio               16
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_gpio       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_com0               0x00020000U
#define SRT_NX51_dpm_irq_arm_mask_set_com0               17
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_com0       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_com1               0x00040000U
#define SRT_NX51_dpm_irq_arm_mask_set_com1               18
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_com1       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_arm_mask_set_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_msync0             0x00200000U
#define SRT_NX51_dpm_irq_arm_mask_set_msync0             21
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_msync0     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_msync1             0x00400000U
#define SRT_NX51_dpm_irq_arm_mask_set_msync1             22
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_msync1     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_arm_mask_set_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_arm_mask_set_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_dmac               0x08000000U
#define SRT_NX51_dpm_irq_arm_mask_set_dmac               27
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_dmac       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_arm_mask_set_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_can                0x20000000U
#define SRT_NX51_dpm_irq_arm_mask_set_can                29
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_can        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_set_osac               0x40000000U
#define SRT_NX51_dpm_irq_arm_mask_set_osac               30
#define DFLT_VAL_NX51_dpm_irq_arm_mask_set_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_set_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_arm_mask_set': */
#define MSK_USED_BITS_NX51_dpm_irq_arm_mask_set 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_arm_mask_set_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_arm_mask_set_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_arm_mask_set_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_arm_mask_set_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_arm_mask_set_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_arm_mask_set_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_arm_mask_set_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_arm_mask_set_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_arm_mask_set_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_arm_mask_set_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_arm_mask_set_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_arm_mask_set_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_arm_mask_set_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_arm_mask_set_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_arm_mask_set_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_arm_mask_set_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_arm_mask_set_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_arm_mask_set_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_arm_mask_set_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_arm_mask_set_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_arm_mask_set_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_arm_mask_set_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_arm_mask_set_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_arm_mask_set_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_arm_mask_set_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_arm_mask_set_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_arm_mask_set_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_arm_mask_set_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_arm_mask_set_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_arm_mask_set_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_arm_mask_set_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_ARM_MASK_SET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_arm_mask_set_dpm_sw;     /* set software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for netX internal ARM-CPU     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_arm_mask_set_dpm_err;    /* set DPM access error interrupt mask for netX internal ARM-CPU                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_arm_mask_set_reserved1;  /* reserved                                                                                            */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_arm_mask_set_gpio_timer; /* set GPIO Timer 0..4 interrupt mask for netX internal ARM-CPU                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_arm_mask_set_systime_ns; /* set ARM_TIMER systime_ns/systime_uc_ns interrupt mask for netX internal ARM-CPU                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_arm_mask_set_systime_s;  /* set ARM_TIMER systime_s/systime_uc_s interrupt mask for netX internal ARM-CPU                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_arm_mask_set_gpio31;     /* set external GPIO 31 interrupt mask for netX internal ARM-CPU                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_arm_mask_set_watchdog;   /* set combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for netX internal ARM-CPU     */
	unsigned int uart0      : BFW_NX51_dpm_irq_arm_mask_set_uart0;      /* set UART 0 interrupt mask for netX internal ARM-CPU                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_arm_mask_set_uart1;      /* set UART 1 interrupt mask for netX internal ARM-CPU                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_arm_mask_set_uart2;      /* set UART 2 interrupt mask for netX internal ARM-CPU                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_arm_mask_set_usb;        /* set USB interrupt mask for netX internal ARM-CPU                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_arm_mask_set_spi;        /* set combined SPI 0 / SQI, SPI 1 interrupt mask for netX internal ARM-CPU                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_arm_mask_set_i2c;        /* set combined I2C 0 and I2C 1 interrupt mask for netX internal ARM-CPU                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_arm_mask_set_reserved2;  /* reserved                                                                                            */
	unsigned int firmware   : BFW_NX51_dpm_irq_arm_mask_set_firmware;   /* set combined handshake-cell and SYS_STA firmware interrupt mask for netX internal ARM-CPU           */
	unsigned int gpio       : BFW_NX51_dpm_irq_arm_mask_set_gpio;       /* set combined GPIO 0-30 / IOLINK interrupt mask for netX internal ARM-CPU                            */
	unsigned int com0       : BFW_NX51_dpm_irq_arm_mask_set_com0;       /* set communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for netX internal ARM-CPU           */
	unsigned int com1       : BFW_NX51_dpm_irq_arm_mask_set_com1;       /* set communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for netX internal ARM-CPU           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_arm_mask_set_reserved3;  /* reserved                                                                                            */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_arm_mask_set_xpic_debug; /* set xPIC Debug interrupt mask for netX internal ARM-CPU                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_arm_mask_set_msync0;     /* set motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for netX internal ARM-CPU */
	unsigned int msync1     : BFW_NX51_dpm_irq_arm_mask_set_msync1;     /* set motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for netX internal ARM-CPU */
	unsigned int reserved4  : BFW_NX51_dpm_irq_arm_mask_set_reserved4;  /* reserved                                                                                            */
	unsigned int int_phy    : BFW_NX51_dpm_irq_arm_mask_set_int_phy;    /* set combined internal PHY 0 / PHY 1 interrupt mask for netX internal ARM-CPU                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_arm_mask_set_sysstate;   /* set combined licence error and MI timeout interrupt mask for netX internal ARM-CPU                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_arm_mask_set_dmac;       /* set DMA-Controller interrupt mask for netX internal ARM-CPU                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_arm_mask_set_trigger_lt; /* set Trigger-Latch interrupt mask for netX internal ARM-CPU                                          */
	unsigned int can        : BFW_NX51_dpm_irq_arm_mask_set_can;        /* set CAN interrupt mask for netX internal ARM-CPU                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_arm_mask_set_osac;       /* set OSAC interrupt mask for netX internal ARM-CPU                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_arm_mask_set_reserved5;  /* reserved                                                                                            */
} NX51_DPM_IRQ_ARM_MASK_SET_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DPM_IRQ_ARM_MASK_SET_BIT_T bf;
} NX51_DPM_IRQ_ARM_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_arm_mask_reset */
/* => DPM Interrupt Mask Reset Register for netX internal ARM-CPU. */
/*    Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for netX internal ARM-CPU. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for netX internal ARM-CPU without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_arm_mask_reset  0x00000088U
#define Adr_NX51_dpm_dpm_irq_arm_mask_reset  0x1018C088U
#define Adr_NX51_dpm_irq_arm_mask_reset      0x1018C088U
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset 0x00000000U

#define MSK_NX51_dpm_irq_arm_mask_reset_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_arm_mask_reset_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_arm_mask_reset_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_arm_mask_reset_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_arm_mask_reset_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_arm_mask_reset_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_arm_mask_reset_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_arm_mask_reset_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_uart0              0x00000100U
#define SRT_NX51_dpm_irq_arm_mask_reset_uart0              8
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_uart0      0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_uart1              0x00000200U
#define SRT_NX51_dpm_irq_arm_mask_reset_uart1              9
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_uart1      0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_uart2              0x00000400U
#define SRT_NX51_dpm_irq_arm_mask_reset_uart2              10
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_uart2      0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_usb                0x00000800U
#define SRT_NX51_dpm_irq_arm_mask_reset_usb                11
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_usb        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_spi                0x00001000U
#define SRT_NX51_dpm_irq_arm_mask_reset_spi                12
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_spi        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_i2c                0x00002000U
#define SRT_NX51_dpm_irq_arm_mask_reset_i2c                13
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_i2c        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_firmware           0x00008000U
#define SRT_NX51_dpm_irq_arm_mask_reset_firmware           15
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_firmware   0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_gpio               0x00010000U
#define SRT_NX51_dpm_irq_arm_mask_reset_gpio               16
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_gpio       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_com0               0x00020000U
#define SRT_NX51_dpm_irq_arm_mask_reset_com0               17
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_com0       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_com1               0x00040000U
#define SRT_NX51_dpm_irq_arm_mask_reset_com1               18
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_com1       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_arm_mask_reset_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_msync0             0x00200000U
#define SRT_NX51_dpm_irq_arm_mask_reset_msync0             21
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_msync0     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_msync1             0x00400000U
#define SRT_NX51_dpm_irq_arm_mask_reset_msync1             22
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_msync1     0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_arm_mask_reset_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_arm_mask_reset_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_dmac               0x08000000U
#define SRT_NX51_dpm_irq_arm_mask_reset_dmac               27
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_dmac       0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_arm_mask_reset_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_can                0x20000000U
#define SRT_NX51_dpm_irq_arm_mask_reset_can                29
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_can        0x00000000U
#define MSK_NX51_dpm_irq_arm_mask_reset_osac               0x40000000U
#define SRT_NX51_dpm_irq_arm_mask_reset_osac               30
#define DFLT_VAL_NX51_dpm_irq_arm_mask_reset_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_arm_mask_reset_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_arm_mask_reset': */
#define MSK_USED_BITS_NX51_dpm_irq_arm_mask_reset 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_arm_mask_reset_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_arm_mask_reset_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_arm_mask_reset_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_arm_mask_reset_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_arm_mask_reset_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_arm_mask_reset_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_arm_mask_reset_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_arm_mask_reset_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_arm_mask_reset_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_arm_mask_reset_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_arm_mask_reset_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_arm_mask_reset_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_arm_mask_reset_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_arm_mask_reset_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_arm_mask_reset_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_arm_mask_reset_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_arm_mask_reset_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_arm_mask_reset_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_arm_mask_reset_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_arm_mask_reset_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_arm_mask_reset_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_arm_mask_reset_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_arm_mask_reset_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_arm_mask_reset_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_arm_mask_reset_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_arm_mask_reset_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_arm_mask_reset_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_arm_mask_reset_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_arm_mask_reset_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_arm_mask_reset_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_arm_mask_reset_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_ARM_MASK_RESET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_arm_mask_reset_dpm_sw;     /* reset software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for netX internal ARM-CPU     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_arm_mask_reset_dpm_err;    /* reset DPM access error interrupt mask for netX internal ARM-CPU                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_arm_mask_reset_reserved1;  /* reserved                                                                                              */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_arm_mask_reset_gpio_timer; /* reset GPIO Timer 0..4 interrupt mask for netX internal ARM-CPU                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_arm_mask_reset_systime_ns; /* reset ARM_TIMER systime_ns/systime_uc_ns interrupt mask for netX internal ARM-CPU                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_arm_mask_reset_systime_s;  /* reset ARM_TIMER systime_s/systime_uc_s interrupt mask for netX internal ARM-CPU                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_arm_mask_reset_gpio31;     /* reset external GPIO 31 interrupt mask for netX internal ARM-CPU                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_arm_mask_reset_watchdog;   /* reset combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for netX internal ARM-CPU     */
	unsigned int uart0      : BFW_NX51_dpm_irq_arm_mask_reset_uart0;      /* reset UART 0 interrupt mask for netX internal ARM-CPU                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_arm_mask_reset_uart1;      /* reset UART 1 interrupt mask for netX internal ARM-CPU                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_arm_mask_reset_uart2;      /* reset UART 2 interrupt mask for netX internal ARM-CPU                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_arm_mask_reset_usb;        /* reset USB interrupt mask for netX internal ARM-CPU                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_arm_mask_reset_spi;        /* reset combined SPI 0 / SQI, SPI 1 interrupt mask for netX internal ARM-CPU                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_arm_mask_reset_i2c;        /* reset combined I2C 0 and I2C 1 interrupt mask for netX internal ARM-CPU                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_arm_mask_reset_reserved2;  /* reserved                                                                                              */
	unsigned int firmware   : BFW_NX51_dpm_irq_arm_mask_reset_firmware;   /* reset combined handshake-cell and SYS_STA firmware interrupt mask for netX internal ARM-CPU           */
	unsigned int gpio       : BFW_NX51_dpm_irq_arm_mask_reset_gpio;       /* reset combined GPIO 0-30 / IOLINK interrupt mask for netX internal ARM-CPU                            */
	unsigned int com0       : BFW_NX51_dpm_irq_arm_mask_reset_com0;       /* reset communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for netX internal ARM-CPU           */
	unsigned int com1       : BFW_NX51_dpm_irq_arm_mask_reset_com1;       /* reset communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for netX internal ARM-CPU           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_arm_mask_reset_reserved3;  /* reserved                                                                                              */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_arm_mask_reset_xpic_debug; /* reset xPIC Debug interrupt mask for netX internal ARM-CPU                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_arm_mask_reset_msync0;     /* reset motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for netX internal ARM-CPU */
	unsigned int msync1     : BFW_NX51_dpm_irq_arm_mask_reset_msync1;     /* reset motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for netX internal ARM-CPU */
	unsigned int reserved4  : BFW_NX51_dpm_irq_arm_mask_reset_reserved4;  /* reserved                                                                                              */
	unsigned int int_phy    : BFW_NX51_dpm_irq_arm_mask_reset_int_phy;    /* reset combined internal PHY 0 / PHY 1 interrupt mask for netX internal ARM-CPU                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_arm_mask_reset_sysstate;   /* reset combined licence error and MI timeout interrupt mask for netX internal ARM-CPU                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_arm_mask_reset_dmac;       /* reset DMA-Controller interrupt mask for netX internal ARM-CPU                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_arm_mask_reset_trigger_lt; /* reset Trigger-Latch interrupt mask for netX internal ARM-CPU                                          */
	unsigned int can        : BFW_NX51_dpm_irq_arm_mask_reset_can;        /* reset CAN interrupt mask for netX internal ARM-CPU                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_arm_mask_reset_osac;       /* reset OSAC interrupt mask for netX internal ARM-CPU                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_arm_mask_reset_reserved5;  /* reserved                                                                                              */
} NX51_DPM_IRQ_ARM_MASK_RESET_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_DPM_IRQ_ARM_MASK_RESET_BIT_T bf;
} NX51_DPM_IRQ_ARM_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_arm_masked */
/* => DPM Masked Interrupt Status Register for netX internal ARM-CPU. */
/*    A bit is set, when the related mask bit is set in 'dpm_irq_arm_mask'-register and the related interrupt is asserted. */
/*    IRQ for netX internal ARM-CPU is asserted if at least one bit is set here. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for netX internal ARM-CPU without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_arm_masked 0x0000008CU
#define Adr_NX51_dpm_dpm_irq_arm_masked 0x1018C08CU
#define Adr_NX51_dpm_irq_arm_masked     0x1018C08CU

#define MSK_NX51_dpm_irq_arm_masked_dpm_sw     0x00000001U
#define SRT_NX51_dpm_irq_arm_masked_dpm_sw     0
#define MSK_NX51_dpm_irq_arm_masked_dpm_err    0x00000002U
#define SRT_NX51_dpm_irq_arm_masked_dpm_err    1
#define MSK_NX51_dpm_irq_arm_masked_gpio_timer 0x00000008U
#define SRT_NX51_dpm_irq_arm_masked_gpio_timer 3
#define MSK_NX51_dpm_irq_arm_masked_systime_ns 0x00000010U
#define SRT_NX51_dpm_irq_arm_masked_systime_ns 4
#define MSK_NX51_dpm_irq_arm_masked_systime_s  0x00000020U
#define SRT_NX51_dpm_irq_arm_masked_systime_s  5
#define MSK_NX51_dpm_irq_arm_masked_gpio31     0x00000040U
#define SRT_NX51_dpm_irq_arm_masked_gpio31     6
#define MSK_NX51_dpm_irq_arm_masked_watchdog   0x00000080U
#define SRT_NX51_dpm_irq_arm_masked_watchdog   7
#define MSK_NX51_dpm_irq_arm_masked_uart0      0x00000100U
#define SRT_NX51_dpm_irq_arm_masked_uart0      8
#define MSK_NX51_dpm_irq_arm_masked_uart1      0x00000200U
#define SRT_NX51_dpm_irq_arm_masked_uart1      9
#define MSK_NX51_dpm_irq_arm_masked_uart2      0x00000400U
#define SRT_NX51_dpm_irq_arm_masked_uart2      10
#define MSK_NX51_dpm_irq_arm_masked_usb        0x00000800U
#define SRT_NX51_dpm_irq_arm_masked_usb        11
#define MSK_NX51_dpm_irq_arm_masked_spi        0x00001000U
#define SRT_NX51_dpm_irq_arm_masked_spi        12
#define MSK_NX51_dpm_irq_arm_masked_i2c        0x00002000U
#define SRT_NX51_dpm_irq_arm_masked_i2c        13
#define MSK_NX51_dpm_irq_arm_masked_firmware   0x00008000U
#define SRT_NX51_dpm_irq_arm_masked_firmware   15
#define MSK_NX51_dpm_irq_arm_masked_gpio       0x00010000U
#define SRT_NX51_dpm_irq_arm_masked_gpio       16
#define MSK_NX51_dpm_irq_arm_masked_com0       0x00020000U
#define SRT_NX51_dpm_irq_arm_masked_com0       17
#define MSK_NX51_dpm_irq_arm_masked_com1       0x00040000U
#define SRT_NX51_dpm_irq_arm_masked_com1       18
#define MSK_NX51_dpm_irq_arm_masked_xpic_debug 0x00100000U
#define SRT_NX51_dpm_irq_arm_masked_xpic_debug 20
#define MSK_NX51_dpm_irq_arm_masked_msync0     0x00200000U
#define SRT_NX51_dpm_irq_arm_masked_msync0     21
#define MSK_NX51_dpm_irq_arm_masked_msync1     0x00400000U
#define SRT_NX51_dpm_irq_arm_masked_msync1     22
#define MSK_NX51_dpm_irq_arm_masked_int_phy    0x02000000U
#define SRT_NX51_dpm_irq_arm_masked_int_phy    25
#define MSK_NX51_dpm_irq_arm_masked_sysstate   0x04000000U
#define SRT_NX51_dpm_irq_arm_masked_sysstate   26
#define MSK_NX51_dpm_irq_arm_masked_dmac       0x08000000U
#define SRT_NX51_dpm_irq_arm_masked_dmac       27
#define MSK_NX51_dpm_irq_arm_masked_trigger_lt 0x10000000U
#define SRT_NX51_dpm_irq_arm_masked_trigger_lt 28
#define MSK_NX51_dpm_irq_arm_masked_can        0x20000000U
#define SRT_NX51_dpm_irq_arm_masked_can        29
#define MSK_NX51_dpm_irq_arm_masked_osac       0x40000000U
#define SRT_NX51_dpm_irq_arm_masked_osac       30

/* all used bits of 'NX51_dpm_irq_arm_masked': */
#define MSK_USED_BITS_NX51_dpm_irq_arm_masked 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_arm_masked_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_arm_masked_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_arm_masked_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_arm_masked_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_arm_masked_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_arm_masked_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_arm_masked_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_arm_masked_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_arm_masked_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_arm_masked_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_arm_masked_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_arm_masked_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_arm_masked_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_arm_masked_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_arm_masked_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_arm_masked_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_arm_masked_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_arm_masked_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_arm_masked_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_arm_masked_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_arm_masked_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_arm_masked_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_arm_masked_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_arm_masked_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_arm_masked_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_arm_masked_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_arm_masked_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_arm_masked_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_arm_masked_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_arm_masked_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_arm_masked_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_ARM_MASKED_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_arm_masked_dpm_sw;     /* masked software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt state for netX internal ARM-CPU     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_arm_masked_dpm_err;    /* masked DPM access error interrupt state for netX internal ARM-CPU                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_arm_masked_reserved1;  /* reserved                                                                                                */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_arm_masked_gpio_timer; /* masked GPIO Timer 0..4 interrupt state for netX internal ARM-CPU                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_arm_masked_systime_ns; /* masked ARM_TIMER systime_ns/systime_uc_ns interrupt state for netX internal ARM-CPU                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_arm_masked_systime_s;  /* masked ARM_TIMER systime_s/systime_uc_s interrupt state for netX internal ARM-CPU                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_arm_masked_gpio31;     /* masked external GPIO 31 interrupt state for netX internal ARM-CPU                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_arm_masked_watchdog;   /* masked combined Watchdog from WDG_SYS and XPIC_WDG module interrupt state for netX internal ARM-CPU     */
	unsigned int uart0      : BFW_NX51_dpm_irq_arm_masked_uart0;      /* masked UART 0 interrupt state for netX internal ARM-CPU                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_arm_masked_uart1;      /* masked UART 1 interrupt state for netX internal ARM-CPU                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_arm_masked_uart2;      /* masked UART 2 interrupt state for netX internal ARM-CPU                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_arm_masked_usb;        /* masked USB interrupt state for netX internal ARM-CPU                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_arm_masked_spi;        /* masked combined SPI 0 / SQI, SPI 1 interrupt state for netX internal ARM-CPU                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_arm_masked_i2c;        /* masked combined I2C 0 and I2C 1 interrupt state for netX internal ARM-CPU                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_arm_masked_reserved2;  /* reserved                                                                                                */
	unsigned int firmware   : BFW_NX51_dpm_irq_arm_masked_firmware;   /* masked combined handshake-cell and SYS_STA firmware interrupt state for netX internal ARM-CPU           */
	unsigned int gpio       : BFW_NX51_dpm_irq_arm_masked_gpio;       /* masked combined GPIO 0-30 / IOLINK interrupt state for netX internal ARM-CPU                            */
	unsigned int com0       : BFW_NX51_dpm_irq_arm_masked_com0;       /* masked communication channel 0 (= |xpec0_irq[11:0]) interrupt state for netX internal ARM-CPU           */
	unsigned int com1       : BFW_NX51_dpm_irq_arm_masked_com1;       /* masked communication channel 1 (= |xpec1_irq[11:0]) interrupt state for netX internal ARM-CPU           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_arm_masked_reserved3;  /* reserved                                                                                                */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_arm_masked_xpic_debug; /* masked xPIC Debug interrupt state for netX internal ARM-CPU                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_arm_masked_msync0;     /* masked motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt state for netX internal ARM-CPU */
	unsigned int msync1     : BFW_NX51_dpm_irq_arm_masked_msync1;     /* masked motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt state for netX internal ARM-CPU */
	unsigned int reserved4  : BFW_NX51_dpm_irq_arm_masked_reserved4;  /* reserved                                                                                                */
	unsigned int int_phy    : BFW_NX51_dpm_irq_arm_masked_int_phy;    /* masked combined internal PHY 0 / PHY 1 interrupt state for netX internal ARM-CPU                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_arm_masked_sysstate;   /* masked combined licence error and MI timeout interrupt state for netX internal ARM-CPU                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_arm_masked_dmac;       /* masked DMA-Controller interrupt state for netX internal ARM-CPU                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_arm_masked_trigger_lt; /* masked Trigger-Latch interrupt state for netX internal ARM-CPU                                          */
	unsigned int can        : BFW_NX51_dpm_irq_arm_masked_can;        /* masked CAN interrupt state for netX internal ARM-CPU                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_arm_masked_osac;       /* masked OSAC interrupt state for netX internal ARM-CPU                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_arm_masked_reserved5;  /* reserved                                                                                                */
} NX51_DPM_IRQ_ARM_MASKED_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_DPM_IRQ_ARM_MASKED_BIT_T bf;
} NX51_DPM_IRQ_ARM_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_xpic_mask_set */
/* => DPM Interrupt Mask Register for netX internal xPIC-CPU. */
/*    Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for netX internal xPIC-CPU. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for netX internal xPIC-CPU without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_xpic_mask_set  0x00000090U
#define Adr_NX51_dpm_dpm_irq_xpic_mask_set  0x1018C090U
#define Adr_NX51_dpm_irq_xpic_mask_set      0x1018C090U
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set 0x00000000U

#define MSK_NX51_dpm_irq_xpic_mask_set_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_xpic_mask_set_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_xpic_mask_set_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_xpic_mask_set_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_xpic_mask_set_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_xpic_mask_set_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_xpic_mask_set_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_xpic_mask_set_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_uart0              0x00000100U
#define SRT_NX51_dpm_irq_xpic_mask_set_uart0              8
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_uart0      0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_uart1              0x00000200U
#define SRT_NX51_dpm_irq_xpic_mask_set_uart1              9
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_uart1      0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_uart2              0x00000400U
#define SRT_NX51_dpm_irq_xpic_mask_set_uart2              10
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_uart2      0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_usb                0x00000800U
#define SRT_NX51_dpm_irq_xpic_mask_set_usb                11
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_usb        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_spi                0x00001000U
#define SRT_NX51_dpm_irq_xpic_mask_set_spi                12
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_spi        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_i2c                0x00002000U
#define SRT_NX51_dpm_irq_xpic_mask_set_i2c                13
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_i2c        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_firmware           0x00008000U
#define SRT_NX51_dpm_irq_xpic_mask_set_firmware           15
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_firmware   0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_gpio               0x00010000U
#define SRT_NX51_dpm_irq_xpic_mask_set_gpio               16
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_gpio       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_com0               0x00020000U
#define SRT_NX51_dpm_irq_xpic_mask_set_com0               17
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_com0       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_com1               0x00040000U
#define SRT_NX51_dpm_irq_xpic_mask_set_com1               18
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_com1       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_xpic_mask_set_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_msync0             0x00200000U
#define SRT_NX51_dpm_irq_xpic_mask_set_msync0             21
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_msync0     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_msync1             0x00400000U
#define SRT_NX51_dpm_irq_xpic_mask_set_msync1             22
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_msync1     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_xpic_mask_set_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_xpic_mask_set_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_dmac               0x08000000U
#define SRT_NX51_dpm_irq_xpic_mask_set_dmac               27
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_dmac       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_xpic_mask_set_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_can                0x20000000U
#define SRT_NX51_dpm_irq_xpic_mask_set_can                29
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_can        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_set_osac               0x40000000U
#define SRT_NX51_dpm_irq_xpic_mask_set_osac               30
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_set_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_set_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_xpic_mask_set': */
#define MSK_USED_BITS_NX51_dpm_irq_xpic_mask_set 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_xpic_mask_set_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_xpic_mask_set_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_xpic_mask_set_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_xpic_mask_set_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_xpic_mask_set_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_xpic_mask_set_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_xpic_mask_set_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_xpic_mask_set_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_xpic_mask_set_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_xpic_mask_set_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_xpic_mask_set_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_xpic_mask_set_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_xpic_mask_set_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_xpic_mask_set_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_xpic_mask_set_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_xpic_mask_set_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_xpic_mask_set_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_xpic_mask_set_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_xpic_mask_set_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_xpic_mask_set_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_xpic_mask_set_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_xpic_mask_set_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_xpic_mask_set_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_xpic_mask_set_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_xpic_mask_set_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_xpic_mask_set_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_xpic_mask_set_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_xpic_mask_set_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_xpic_mask_set_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_xpic_mask_set_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_xpic_mask_set_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_XPIC_MASK_SET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_xpic_mask_set_dpm_sw;     /* set software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for netX internal xPIC-CPU     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_xpic_mask_set_dpm_err;    /* set DPM access error interrupt mask for netX internal xPIC-CPU                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_xpic_mask_set_reserved1;  /* reserved                                                                                             */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_xpic_mask_set_gpio_timer; /* set GPIO Timer 0..4 interrupt mask for netX internal xPIC-CPU                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_xpic_mask_set_systime_ns; /* set ARM_TIMER systime_ns/systime_uc_ns interrupt mask for netX internal xPIC-CPU                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_xpic_mask_set_systime_s;  /* set ARM_TIMER systime_s/systime_uc_s interrupt mask for netX internal xPIC-CPU                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_xpic_mask_set_gpio31;     /* set external GPIO 31 interrupt mask for netX internal xPIC-CPU                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_xpic_mask_set_watchdog;   /* set combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for netX internal xPIC-CPU     */
	unsigned int uart0      : BFW_NX51_dpm_irq_xpic_mask_set_uart0;      /* set UART 0 interrupt mask for netX internal xPIC-CPU                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_xpic_mask_set_uart1;      /* set UART 1 interrupt mask for netX internal xPIC-CPU                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_xpic_mask_set_uart2;      /* set UART 2 interrupt mask for netX internal xPIC-CPU                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_xpic_mask_set_usb;        /* set USB interrupt mask for netX internal xPIC-CPU                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_xpic_mask_set_spi;        /* set combined SPI 0 / SQI, SPI 1 interrupt mask for netX internal xPIC-CPU                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_xpic_mask_set_i2c;        /* set combined I2C 0 and I2C 1 interrupt mask for netX internal xPIC-CPU                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_xpic_mask_set_reserved2;  /* reserved                                                                                             */
	unsigned int firmware   : BFW_NX51_dpm_irq_xpic_mask_set_firmware;   /* set combined handshake-cell and SYS_STA firmware interrupt mask for netX internal xPIC-CPU           */
	unsigned int gpio       : BFW_NX51_dpm_irq_xpic_mask_set_gpio;       /* set combined GPIO 0-30 / IOLINK interrupt mask for netX internal xPIC-CPU                            */
	unsigned int com0       : BFW_NX51_dpm_irq_xpic_mask_set_com0;       /* set communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for netX internal xPIC-CPU           */
	unsigned int com1       : BFW_NX51_dpm_irq_xpic_mask_set_com1;       /* set communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for netX internal xPIC-CPU           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_xpic_mask_set_reserved3;  /* reserved                                                                                             */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_xpic_mask_set_xpic_debug; /* set xPIC Debug interrupt mask for netX internal xPIC-CPU                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_xpic_mask_set_msync0;     /* set motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for netX internal xPIC-CPU */
	unsigned int msync1     : BFW_NX51_dpm_irq_xpic_mask_set_msync1;     /* set motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for netX internal xPIC-CPU */
	unsigned int reserved4  : BFW_NX51_dpm_irq_xpic_mask_set_reserved4;  /* reserved                                                                                             */
	unsigned int int_phy    : BFW_NX51_dpm_irq_xpic_mask_set_int_phy;    /* set combined internal PHY 0 / PHY 1 interrupt mask for netX internal xPIC-CPU                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_xpic_mask_set_sysstate;   /* set combined licence error and MI timeout interrupt mask for netX internal xPIC-CPU                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_xpic_mask_set_dmac;       /* set DMA-Controller interrupt mask for netX internal xPIC-CPU                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_xpic_mask_set_trigger_lt; /* set Trigger-Latch interrupt mask for netX internal xPIC-CPU                                          */
	unsigned int can        : BFW_NX51_dpm_irq_xpic_mask_set_can;        /* set CAN interrupt mask for netX internal xPIC-CPU                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_xpic_mask_set_osac;       /* set OSAC interrupt mask for netX internal xPIC-CPU                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_xpic_mask_set_reserved5;  /* reserved                                                                                             */
} NX51_DPM_IRQ_XPIC_MASK_SET_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_DPM_IRQ_XPIC_MASK_SET_BIT_T bf;
} NX51_DPM_IRQ_XPIC_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_xpic_mask_reset */
/* => DPM Interrupt Mask Reset Register for netX internal xPIC-CPU. */
/*    Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for netX internal xPIC-CPU. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for netX internal xPIC-CPU without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_xpic_mask_reset  0x00000094U
#define Adr_NX51_dpm_dpm_irq_xpic_mask_reset  0x1018C094U
#define Adr_NX51_dpm_irq_xpic_mask_reset      0x1018C094U
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset 0x00000000U

#define MSK_NX51_dpm_irq_xpic_mask_reset_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_xpic_mask_reset_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_xpic_mask_reset_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_xpic_mask_reset_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_xpic_mask_reset_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_xpic_mask_reset_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_xpic_mask_reset_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_xpic_mask_reset_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_uart0              0x00000100U
#define SRT_NX51_dpm_irq_xpic_mask_reset_uart0              8
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_uart0      0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_uart1              0x00000200U
#define SRT_NX51_dpm_irq_xpic_mask_reset_uart1              9
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_uart1      0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_uart2              0x00000400U
#define SRT_NX51_dpm_irq_xpic_mask_reset_uart2              10
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_uart2      0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_usb                0x00000800U
#define SRT_NX51_dpm_irq_xpic_mask_reset_usb                11
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_usb        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_spi                0x00001000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_spi                12
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_spi        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_i2c                0x00002000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_i2c                13
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_i2c        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_firmware           0x00008000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_firmware           15
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_firmware   0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_gpio               0x00010000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_gpio               16
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_gpio       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_com0               0x00020000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_com0               17
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_com0       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_com1               0x00040000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_com1               18
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_com1       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_msync0             0x00200000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_msync0             21
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_msync0     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_msync1             0x00400000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_msync1             22
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_msync1     0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_dmac               0x08000000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_dmac               27
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_dmac       0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_can                0x20000000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_can                29
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_can        0x00000000U
#define MSK_NX51_dpm_irq_xpic_mask_reset_osac               0x40000000U
#define SRT_NX51_dpm_irq_xpic_mask_reset_osac               30
#define DFLT_VAL_NX51_dpm_irq_xpic_mask_reset_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_xpic_mask_reset_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_xpic_mask_reset': */
#define MSK_USED_BITS_NX51_dpm_irq_xpic_mask_reset 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_xpic_mask_reset_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_xpic_mask_reset_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_xpic_mask_reset_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_xpic_mask_reset_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_xpic_mask_reset_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_xpic_mask_reset_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_xpic_mask_reset_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_xpic_mask_reset_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_xpic_mask_reset_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_xpic_mask_reset_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_xpic_mask_reset_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_xpic_mask_reset_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_xpic_mask_reset_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_xpic_mask_reset_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_xpic_mask_reset_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_xpic_mask_reset_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_xpic_mask_reset_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_xpic_mask_reset_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_xpic_mask_reset_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_xpic_mask_reset_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_xpic_mask_reset_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_xpic_mask_reset_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_xpic_mask_reset_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_xpic_mask_reset_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_xpic_mask_reset_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_xpic_mask_reset_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_xpic_mask_reset_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_xpic_mask_reset_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_xpic_mask_reset_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_xpic_mask_reset_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_xpic_mask_reset_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_XPIC_MASK_RESET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_xpic_mask_reset_dpm_sw;     /* reset software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for netX internal xPIC-CPU     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_xpic_mask_reset_dpm_err;    /* reset DPM access error interrupt mask for netX internal xPIC-CPU                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_xpic_mask_reset_reserved1;  /* reserved                                                                                               */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_xpic_mask_reset_gpio_timer; /* reset GPIO Timer 0..4 interrupt mask for netX internal xPIC-CPU                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_xpic_mask_reset_systime_ns; /* reset ARM_TIMER systime_ns/systime_uc_ns interrupt mask for netX internal xPIC-CPU                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_xpic_mask_reset_systime_s;  /* reset ARM_TIMER systime_s/systime_uc_s interrupt mask for netX internal xPIC-CPU                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_xpic_mask_reset_gpio31;     /* reset external GPIO 31 interrupt mask for netX internal xPIC-CPU                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_xpic_mask_reset_watchdog;   /* reset combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for netX internal xPIC-CPU     */
	unsigned int uart0      : BFW_NX51_dpm_irq_xpic_mask_reset_uart0;      /* reset UART 0 interrupt mask for netX internal xPIC-CPU                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_xpic_mask_reset_uart1;      /* reset UART 1 interrupt mask for netX internal xPIC-CPU                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_xpic_mask_reset_uart2;      /* reset UART 2 interrupt mask for netX internal xPIC-CPU                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_xpic_mask_reset_usb;        /* reset USB interrupt mask for netX internal xPIC-CPU                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_xpic_mask_reset_spi;        /* reset combined SPI 0 / SQI, SPI 1 interrupt mask for netX internal xPIC-CPU                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_xpic_mask_reset_i2c;        /* reset combined I2C 0 and I2C 1 interrupt mask for netX internal xPIC-CPU                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_xpic_mask_reset_reserved2;  /* reserved                                                                                               */
	unsigned int firmware   : BFW_NX51_dpm_irq_xpic_mask_reset_firmware;   /* reset combined handshake-cell and SYS_STA firmware interrupt mask for netX internal xPIC-CPU           */
	unsigned int gpio       : BFW_NX51_dpm_irq_xpic_mask_reset_gpio;       /* reset combined GPIO 0-30 / IOLINK interrupt mask for netX internal xPIC-CPU                            */
	unsigned int com0       : BFW_NX51_dpm_irq_xpic_mask_reset_com0;       /* reset communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for netX internal xPIC-CPU           */
	unsigned int com1       : BFW_NX51_dpm_irq_xpic_mask_reset_com1;       /* reset communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for netX internal xPIC-CPU           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_xpic_mask_reset_reserved3;  /* reserved                                                                                               */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_xpic_mask_reset_xpic_debug; /* reset xPIC Debug interrupt mask for netX internal xPIC-CPU                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_xpic_mask_reset_msync0;     /* reset motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for netX internal xPIC-CPU */
	unsigned int msync1     : BFW_NX51_dpm_irq_xpic_mask_reset_msync1;     /* reset motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for netX internal xPIC-CPU */
	unsigned int reserved4  : BFW_NX51_dpm_irq_xpic_mask_reset_reserved4;  /* reserved                                                                                               */
	unsigned int int_phy    : BFW_NX51_dpm_irq_xpic_mask_reset_int_phy;    /* reset combined internal PHY 0 / PHY 1 interrupt mask for netX internal xPIC-CPU                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_xpic_mask_reset_sysstate;   /* reset combined licence error and MI timeout interrupt mask for netX internal xPIC-CPU                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_xpic_mask_reset_dmac;       /* reset DMA-Controller interrupt mask for netX internal xPIC-CPU                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_xpic_mask_reset_trigger_lt; /* reset Trigger-Latch interrupt mask for netX internal xPIC-CPU                                          */
	unsigned int can        : BFW_NX51_dpm_irq_xpic_mask_reset_can;        /* reset CAN interrupt mask for netX internal xPIC-CPU                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_xpic_mask_reset_osac;       /* reset OSAC interrupt mask for netX internal xPIC-CPU                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_xpic_mask_reset_reserved5;  /* reserved                                                                                               */
} NX51_DPM_IRQ_XPIC_MASK_RESET_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_DPM_IRQ_XPIC_MASK_RESET_BIT_T bf;
} NX51_DPM_IRQ_XPIC_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_xpic_masked */
/* => DPM Masked Interrupt Status Register for netX internal xPIC-CPU. */
/*    A bit is set, when the related mask bit is set in 'dpm_irq_xpic_mask'-register and the related interrupt is asserted. */
/*    IRQ for netX internal xPIC-CPU is asserted if at least one bit is set here. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for netX internal xPIC-CPU without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_xpic_masked 0x00000098U
#define Adr_NX51_dpm_dpm_irq_xpic_masked 0x1018C098U
#define Adr_NX51_dpm_irq_xpic_masked     0x1018C098U

#define MSK_NX51_dpm_irq_xpic_masked_dpm_sw     0x00000001U
#define SRT_NX51_dpm_irq_xpic_masked_dpm_sw     0
#define MSK_NX51_dpm_irq_xpic_masked_dpm_err    0x00000002U
#define SRT_NX51_dpm_irq_xpic_masked_dpm_err    1
#define MSK_NX51_dpm_irq_xpic_masked_gpio_timer 0x00000008U
#define SRT_NX51_dpm_irq_xpic_masked_gpio_timer 3
#define MSK_NX51_dpm_irq_xpic_masked_systime_ns 0x00000010U
#define SRT_NX51_dpm_irq_xpic_masked_systime_ns 4
#define MSK_NX51_dpm_irq_xpic_masked_systime_s  0x00000020U
#define SRT_NX51_dpm_irq_xpic_masked_systime_s  5
#define MSK_NX51_dpm_irq_xpic_masked_gpio31     0x00000040U
#define SRT_NX51_dpm_irq_xpic_masked_gpio31     6
#define MSK_NX51_dpm_irq_xpic_masked_watchdog   0x00000080U
#define SRT_NX51_dpm_irq_xpic_masked_watchdog   7
#define MSK_NX51_dpm_irq_xpic_masked_uart0      0x00000100U
#define SRT_NX51_dpm_irq_xpic_masked_uart0      8
#define MSK_NX51_dpm_irq_xpic_masked_uart1      0x00000200U
#define SRT_NX51_dpm_irq_xpic_masked_uart1      9
#define MSK_NX51_dpm_irq_xpic_masked_uart2      0x00000400U
#define SRT_NX51_dpm_irq_xpic_masked_uart2      10
#define MSK_NX51_dpm_irq_xpic_masked_usb        0x00000800U
#define SRT_NX51_dpm_irq_xpic_masked_usb        11
#define MSK_NX51_dpm_irq_xpic_masked_spi        0x00001000U
#define SRT_NX51_dpm_irq_xpic_masked_spi        12
#define MSK_NX51_dpm_irq_xpic_masked_i2c        0x00002000U
#define SRT_NX51_dpm_irq_xpic_masked_i2c        13
#define MSK_NX51_dpm_irq_xpic_masked_firmware   0x00008000U
#define SRT_NX51_dpm_irq_xpic_masked_firmware   15
#define MSK_NX51_dpm_irq_xpic_masked_gpio       0x00010000U
#define SRT_NX51_dpm_irq_xpic_masked_gpio       16
#define MSK_NX51_dpm_irq_xpic_masked_com0       0x00020000U
#define SRT_NX51_dpm_irq_xpic_masked_com0       17
#define MSK_NX51_dpm_irq_xpic_masked_com1       0x00040000U
#define SRT_NX51_dpm_irq_xpic_masked_com1       18
#define MSK_NX51_dpm_irq_xpic_masked_xpic_debug 0x00100000U
#define SRT_NX51_dpm_irq_xpic_masked_xpic_debug 20
#define MSK_NX51_dpm_irq_xpic_masked_msync0     0x00200000U
#define SRT_NX51_dpm_irq_xpic_masked_msync0     21
#define MSK_NX51_dpm_irq_xpic_masked_msync1     0x00400000U
#define SRT_NX51_dpm_irq_xpic_masked_msync1     22
#define MSK_NX51_dpm_irq_xpic_masked_int_phy    0x02000000U
#define SRT_NX51_dpm_irq_xpic_masked_int_phy    25
#define MSK_NX51_dpm_irq_xpic_masked_sysstate   0x04000000U
#define SRT_NX51_dpm_irq_xpic_masked_sysstate   26
#define MSK_NX51_dpm_irq_xpic_masked_dmac       0x08000000U
#define SRT_NX51_dpm_irq_xpic_masked_dmac       27
#define MSK_NX51_dpm_irq_xpic_masked_trigger_lt 0x10000000U
#define SRT_NX51_dpm_irq_xpic_masked_trigger_lt 28
#define MSK_NX51_dpm_irq_xpic_masked_can        0x20000000U
#define SRT_NX51_dpm_irq_xpic_masked_can        29
#define MSK_NX51_dpm_irq_xpic_masked_osac       0x40000000U
#define SRT_NX51_dpm_irq_xpic_masked_osac       30

/* all used bits of 'NX51_dpm_irq_xpic_masked': */
#define MSK_USED_BITS_NX51_dpm_irq_xpic_masked 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_xpic_masked_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_xpic_masked_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_xpic_masked_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_xpic_masked_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_xpic_masked_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_xpic_masked_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_xpic_masked_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_xpic_masked_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_xpic_masked_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_xpic_masked_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_xpic_masked_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_xpic_masked_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_xpic_masked_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_xpic_masked_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_xpic_masked_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_xpic_masked_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_xpic_masked_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_xpic_masked_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_xpic_masked_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_xpic_masked_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_xpic_masked_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_xpic_masked_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_xpic_masked_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_xpic_masked_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_xpic_masked_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_xpic_masked_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_xpic_masked_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_xpic_masked_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_xpic_masked_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_xpic_masked_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_xpic_masked_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_XPIC_MASKED_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_xpic_masked_dpm_sw;     /* masked software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt state for netX internal xPIC-CPU     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_xpic_masked_dpm_err;    /* masked DPM access error interrupt state for netX internal xPIC-CPU                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_xpic_masked_reserved1;  /* reserved                                                                                                 */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_xpic_masked_gpio_timer; /* masked GPIO Timer 0..4 interrupt state for netX internal xPIC-CPU                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_xpic_masked_systime_ns; /* masked ARM_TIMER systime_ns/systime_uc_ns interrupt state for netX internal xPIC-CPU                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_xpic_masked_systime_s;  /* masked ARM_TIMER systime_s/systime_uc_s interrupt state for netX internal xPIC-CPU                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_xpic_masked_gpio31;     /* masked external GPIO 31 interrupt state for netX internal xPIC-CPU                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_xpic_masked_watchdog;   /* masked combined Watchdog from WDG_SYS and XPIC_WDG module interrupt state for netX internal xPIC-CPU     */
	unsigned int uart0      : BFW_NX51_dpm_irq_xpic_masked_uart0;      /* masked UART 0 interrupt state for netX internal xPIC-CPU                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_xpic_masked_uart1;      /* masked UART 1 interrupt state for netX internal xPIC-CPU                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_xpic_masked_uart2;      /* masked UART 2 interrupt state for netX internal xPIC-CPU                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_xpic_masked_usb;        /* masked USB interrupt state for netX internal xPIC-CPU                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_xpic_masked_spi;        /* masked combined SPI 0 / SQI, SPI 1 interrupt state for netX internal xPIC-CPU                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_xpic_masked_i2c;        /* masked combined I2C 0 and I2C 1 interrupt state for netX internal xPIC-CPU                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_xpic_masked_reserved2;  /* reserved                                                                                                 */
	unsigned int firmware   : BFW_NX51_dpm_irq_xpic_masked_firmware;   /* masked combined handshake-cell and SYS_STA firmware interrupt state for netX internal xPIC-CPU           */
	unsigned int gpio       : BFW_NX51_dpm_irq_xpic_masked_gpio;       /* masked combined GPIO 0-30 / IOLINK interrupt state for netX internal xPIC-CPU                            */
	unsigned int com0       : BFW_NX51_dpm_irq_xpic_masked_com0;       /* masked communication channel 0 (= |xpec0_irq[11:0]) interrupt state for netX internal xPIC-CPU           */
	unsigned int com1       : BFW_NX51_dpm_irq_xpic_masked_com1;       /* masked communication channel 1 (= |xpec1_irq[11:0]) interrupt state for netX internal xPIC-CPU           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_xpic_masked_reserved3;  /* reserved                                                                                                 */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_xpic_masked_xpic_debug; /* masked xPIC Debug interrupt state for netX internal xPIC-CPU                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_xpic_masked_msync0;     /* masked motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt state for netX internal xPIC-CPU */
	unsigned int msync1     : BFW_NX51_dpm_irq_xpic_masked_msync1;     /* masked motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt state for netX internal xPIC-CPU */
	unsigned int reserved4  : BFW_NX51_dpm_irq_xpic_masked_reserved4;  /* reserved                                                                                                 */
	unsigned int int_phy    : BFW_NX51_dpm_irq_xpic_masked_int_phy;    /* masked combined internal PHY 0 / PHY 1 interrupt state for netX internal xPIC-CPU                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_xpic_masked_sysstate;   /* masked combined licence error and MI timeout interrupt state for netX internal xPIC-CPU                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_xpic_masked_dmac;       /* masked DMA-Controller interrupt state for netX internal xPIC-CPU                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_xpic_masked_trigger_lt; /* masked Trigger-Latch interrupt state for netX internal xPIC-CPU                                          */
	unsigned int can        : BFW_NX51_dpm_irq_xpic_masked_can;        /* masked CAN interrupt state for netX internal xPIC-CPU                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_xpic_masked_osac;       /* masked OSAC interrupt state for netX internal xPIC-CPU                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_xpic_masked_reserved5;  /* reserved                                                                                                 */
} NX51_DPM_IRQ_XPIC_MASKED_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_DPM_IRQ_XPIC_MASKED_BIT_T bf;
} NX51_DPM_IRQ_XPIC_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_fiq_mask_set */
/* => DPM Interrupt Mask Register for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ). */
/*    Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ). */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_fiq_mask_set  0x0000009CU
#define Adr_NX51_dpm_dpm_irq_fiq_mask_set  0x1018C09CU
#define Adr_NX51_dpm_irq_fiq_mask_set      0x1018C09CU
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set 0x00000000U

#define MSK_NX51_dpm_irq_fiq_mask_set_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_fiq_mask_set_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_fiq_mask_set_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_fiq_mask_set_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_fiq_mask_set_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_fiq_mask_set_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_fiq_mask_set_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_fiq_mask_set_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_uart0              0x00000100U
#define SRT_NX51_dpm_irq_fiq_mask_set_uart0              8
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_uart0      0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_uart1              0x00000200U
#define SRT_NX51_dpm_irq_fiq_mask_set_uart1              9
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_uart1      0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_uart2              0x00000400U
#define SRT_NX51_dpm_irq_fiq_mask_set_uart2              10
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_uart2      0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_usb                0x00000800U
#define SRT_NX51_dpm_irq_fiq_mask_set_usb                11
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_usb        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_spi                0x00001000U
#define SRT_NX51_dpm_irq_fiq_mask_set_spi                12
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_spi        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_i2c                0x00002000U
#define SRT_NX51_dpm_irq_fiq_mask_set_i2c                13
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_i2c        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_firmware           0x00008000U
#define SRT_NX51_dpm_irq_fiq_mask_set_firmware           15
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_firmware   0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_gpio               0x00010000U
#define SRT_NX51_dpm_irq_fiq_mask_set_gpio               16
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_gpio       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_com0               0x00020000U
#define SRT_NX51_dpm_irq_fiq_mask_set_com0               17
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_com0       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_com1               0x00040000U
#define SRT_NX51_dpm_irq_fiq_mask_set_com1               18
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_com1       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_fiq_mask_set_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_msync0             0x00200000U
#define SRT_NX51_dpm_irq_fiq_mask_set_msync0             21
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_msync0     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_msync1             0x00400000U
#define SRT_NX51_dpm_irq_fiq_mask_set_msync1             22
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_msync1     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_fiq_mask_set_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_fiq_mask_set_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_dmac               0x08000000U
#define SRT_NX51_dpm_irq_fiq_mask_set_dmac               27
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_dmac       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_fiq_mask_set_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_can                0x20000000U
#define SRT_NX51_dpm_irq_fiq_mask_set_can                29
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_can        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_set_osac               0x40000000U
#define SRT_NX51_dpm_irq_fiq_mask_set_osac               30
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_set_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_set_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_fiq_mask_set': */
#define MSK_USED_BITS_NX51_dpm_irq_fiq_mask_set 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_fiq_mask_set_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_fiq_mask_set_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_fiq_mask_set_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_fiq_mask_set_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_fiq_mask_set_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_fiq_mask_set_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_fiq_mask_set_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_fiq_mask_set_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_fiq_mask_set_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_fiq_mask_set_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_fiq_mask_set_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_fiq_mask_set_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_fiq_mask_set_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_fiq_mask_set_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_fiq_mask_set_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_fiq_mask_set_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_fiq_mask_set_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_fiq_mask_set_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_fiq_mask_set_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_fiq_mask_set_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_fiq_mask_set_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_fiq_mask_set_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_fiq_mask_set_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_fiq_mask_set_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_fiq_mask_set_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_fiq_mask_set_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_fiq_mask_set_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_fiq_mask_set_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_fiq_mask_set_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_fiq_mask_set_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_fiq_mask_set_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_FIQ_MASK_SET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_fiq_mask_set_dpm_sw;     /* set software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_fiq_mask_set_dpm_err;    /* set DPM access error interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_fiq_mask_set_reserved1;  /* reserved                                                                                                                           */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_fiq_mask_set_gpio_timer; /* set GPIO Timer 0..4 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_fiq_mask_set_systime_ns; /* set ARM_TIMER systime_ns/systime_uc_ns interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_fiq_mask_set_systime_s;  /* set ARM_TIMER systime_s/systime_uc_s interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_fiq_mask_set_gpio31;     /* set external GPIO 31 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_fiq_mask_set_watchdog;   /* set combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)     */
	unsigned int uart0      : BFW_NX51_dpm_irq_fiq_mask_set_uart0;      /* set UART 0 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_fiq_mask_set_uart1;      /* set UART 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_fiq_mask_set_uart2;      /* set UART 2 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_fiq_mask_set_usb;        /* set USB interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_fiq_mask_set_spi;        /* set combined SPI 0 / SQI, SPI 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_fiq_mask_set_i2c;        /* set combined I2C 0 and I2C 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_fiq_mask_set_reserved2;  /* reserved                                                                                                                           */
	unsigned int firmware   : BFW_NX51_dpm_irq_fiq_mask_set_firmware;   /* set combined handshake-cell and SYS_STA firmware interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int gpio       : BFW_NX51_dpm_irq_fiq_mask_set_gpio;       /* set combined GPIO 0-30 / IOLINK interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                            */
	unsigned int com0       : BFW_NX51_dpm_irq_fiq_mask_set_com0;       /* set communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int com1       : BFW_NX51_dpm_irq_fiq_mask_set_com1;       /* set communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_fiq_mask_set_reserved3;  /* reserved                                                                                                                           */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_fiq_mask_set_xpic_debug; /* set xPIC Debug interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_fiq_mask_set_msync0;     /* set motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) */
	unsigned int msync1     : BFW_NX51_dpm_irq_fiq_mask_set_msync1;     /* set motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) */
	unsigned int reserved4  : BFW_NX51_dpm_irq_fiq_mask_set_reserved4;  /* reserved                                                                                                                           */
	unsigned int int_phy    : BFW_NX51_dpm_irq_fiq_mask_set_int_phy;    /* set combined internal PHY 0 / PHY 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_fiq_mask_set_sysstate;   /* set combined licence error and MI timeout interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_fiq_mask_set_dmac;       /* set DMA-Controller interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_fiq_mask_set_trigger_lt; /* set Trigger-Latch interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                          */
	unsigned int can        : BFW_NX51_dpm_irq_fiq_mask_set_can;        /* set CAN interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_fiq_mask_set_osac;       /* set OSAC interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_fiq_mask_set_reserved5;  /* reserved                                                                                                                           */
} NX51_DPM_IRQ_FIQ_MASK_SET_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DPM_IRQ_FIQ_MASK_SET_BIT_T bf;
} NX51_DPM_IRQ_FIQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_fiq_mask_reset */
/* => DPM Interrupt Mask Reset Register for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ). */
/*    Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ). */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_fiq_mask_reset  0x000000A0U
#define Adr_NX51_dpm_dpm_irq_fiq_mask_reset  0x1018C0A0U
#define Adr_NX51_dpm_irq_fiq_mask_reset      0x1018C0A0U
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset 0x00000000U

#define MSK_NX51_dpm_irq_fiq_mask_reset_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_fiq_mask_reset_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_fiq_mask_reset_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_fiq_mask_reset_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_fiq_mask_reset_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_fiq_mask_reset_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_fiq_mask_reset_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_fiq_mask_reset_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_uart0              0x00000100U
#define SRT_NX51_dpm_irq_fiq_mask_reset_uart0              8
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_uart0      0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_uart1              0x00000200U
#define SRT_NX51_dpm_irq_fiq_mask_reset_uart1              9
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_uart1      0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_uart2              0x00000400U
#define SRT_NX51_dpm_irq_fiq_mask_reset_uart2              10
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_uart2      0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_usb                0x00000800U
#define SRT_NX51_dpm_irq_fiq_mask_reset_usb                11
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_usb        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_spi                0x00001000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_spi                12
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_spi        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_i2c                0x00002000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_i2c                13
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_i2c        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_firmware           0x00008000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_firmware           15
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_firmware   0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_gpio               0x00010000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_gpio               16
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_gpio       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_com0               0x00020000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_com0               17
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_com0       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_com1               0x00040000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_com1               18
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_com1       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_msync0             0x00200000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_msync0             21
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_msync0     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_msync1             0x00400000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_msync1             22
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_msync1     0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_dmac               0x08000000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_dmac               27
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_dmac       0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_can                0x20000000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_can                29
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_can        0x00000000U
#define MSK_NX51_dpm_irq_fiq_mask_reset_osac               0x40000000U
#define SRT_NX51_dpm_irq_fiq_mask_reset_osac               30
#define DFLT_VAL_NX51_dpm_irq_fiq_mask_reset_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_fiq_mask_reset_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_fiq_mask_reset': */
#define MSK_USED_BITS_NX51_dpm_irq_fiq_mask_reset 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_fiq_mask_reset_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_fiq_mask_reset_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_fiq_mask_reset_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_fiq_mask_reset_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_fiq_mask_reset_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_fiq_mask_reset_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_fiq_mask_reset_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_fiq_mask_reset_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_fiq_mask_reset_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_fiq_mask_reset_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_fiq_mask_reset_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_fiq_mask_reset_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_fiq_mask_reset_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_fiq_mask_reset_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_fiq_mask_reset_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_fiq_mask_reset_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_fiq_mask_reset_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_fiq_mask_reset_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_fiq_mask_reset_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_fiq_mask_reset_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_fiq_mask_reset_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_fiq_mask_reset_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_fiq_mask_reset_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_fiq_mask_reset_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_fiq_mask_reset_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_fiq_mask_reset_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_fiq_mask_reset_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_fiq_mask_reset_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_fiq_mask_reset_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_fiq_mask_reset_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_fiq_mask_reset_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_FIQ_MASK_RESET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_fiq_mask_reset_dpm_sw;     /* reset software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_fiq_mask_reset_dpm_err;    /* reset DPM access error interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_fiq_mask_reset_reserved1;  /* reserved                                                                                                                             */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_fiq_mask_reset_gpio_timer; /* reset GPIO Timer 0..4 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_fiq_mask_reset_systime_ns; /* reset ARM_TIMER systime_ns/systime_uc_ns interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_fiq_mask_reset_systime_s;  /* reset ARM_TIMER systime_s/systime_uc_s interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_fiq_mask_reset_gpio31;     /* reset external GPIO 31 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_fiq_mask_reset_watchdog;   /* reset combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)     */
	unsigned int uart0      : BFW_NX51_dpm_irq_fiq_mask_reset_uart0;      /* reset UART 0 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_fiq_mask_reset_uart1;      /* reset UART 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_fiq_mask_reset_uart2;      /* reset UART 2 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_fiq_mask_reset_usb;        /* reset USB interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_fiq_mask_reset_spi;        /* reset combined SPI 0 / SQI, SPI 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_fiq_mask_reset_i2c;        /* reset combined I2C 0 and I2C 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_fiq_mask_reset_reserved2;  /* reserved                                                                                                                             */
	unsigned int firmware   : BFW_NX51_dpm_irq_fiq_mask_reset_firmware;   /* reset combined handshake-cell and SYS_STA firmware interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int gpio       : BFW_NX51_dpm_irq_fiq_mask_reset_gpio;       /* reset combined GPIO 0-30 / IOLINK interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                            */
	unsigned int com0       : BFW_NX51_dpm_irq_fiq_mask_reset_com0;       /* reset communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int com1       : BFW_NX51_dpm_irq_fiq_mask_reset_com1;       /* reset communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_fiq_mask_reset_reserved3;  /* reserved                                                                                                                             */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_fiq_mask_reset_xpic_debug; /* reset xPIC Debug interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_fiq_mask_reset_msync0;     /* reset motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) */
	unsigned int msync1     : BFW_NX51_dpm_irq_fiq_mask_reset_msync1;     /* reset motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) */
	unsigned int reserved4  : BFW_NX51_dpm_irq_fiq_mask_reset_reserved4;  /* reserved                                                                                                                             */
	unsigned int int_phy    : BFW_NX51_dpm_irq_fiq_mask_reset_int_phy;    /* reset combined internal PHY 0 / PHY 1 interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_fiq_mask_reset_sysstate;   /* reset combined licence error and MI timeout interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_fiq_mask_reset_dmac;       /* reset DMA-Controller interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_fiq_mask_reset_trigger_lt; /* reset Trigger-Latch interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                          */
	unsigned int can        : BFW_NX51_dpm_irq_fiq_mask_reset_can;        /* reset CAN interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_fiq_mask_reset_osac;       /* reset OSAC interrupt mask for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_fiq_mask_reset_reserved5;  /* reserved                                                                                                                             */
} NX51_DPM_IRQ_FIQ_MASK_RESET_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_DPM_IRQ_FIQ_MASK_RESET_BIT_T bf;
} NX51_DPM_IRQ_FIQ_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_fiq_masked */
/* => DPM Masked Interrupt Status Register for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ). */
/*    A bit is set, when the related mask bit is set in 'dpm_irq_fiq_mask'-register and the related interrupt is asserted. */
/*    IRQ for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) is asserted if at least one bit is set here. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_fiq_masked 0x000000A4U
#define Adr_NX51_dpm_dpm_irq_fiq_masked 0x1018C0A4U
#define Adr_NX51_dpm_irq_fiq_masked     0x1018C0A4U

#define MSK_NX51_dpm_irq_fiq_masked_dpm_sw     0x00000001U
#define SRT_NX51_dpm_irq_fiq_masked_dpm_sw     0
#define MSK_NX51_dpm_irq_fiq_masked_dpm_err    0x00000002U
#define SRT_NX51_dpm_irq_fiq_masked_dpm_err    1
#define MSK_NX51_dpm_irq_fiq_masked_gpio_timer 0x00000008U
#define SRT_NX51_dpm_irq_fiq_masked_gpio_timer 3
#define MSK_NX51_dpm_irq_fiq_masked_systime_ns 0x00000010U
#define SRT_NX51_dpm_irq_fiq_masked_systime_ns 4
#define MSK_NX51_dpm_irq_fiq_masked_systime_s  0x00000020U
#define SRT_NX51_dpm_irq_fiq_masked_systime_s  5
#define MSK_NX51_dpm_irq_fiq_masked_gpio31     0x00000040U
#define SRT_NX51_dpm_irq_fiq_masked_gpio31     6
#define MSK_NX51_dpm_irq_fiq_masked_watchdog   0x00000080U
#define SRT_NX51_dpm_irq_fiq_masked_watchdog   7
#define MSK_NX51_dpm_irq_fiq_masked_uart0      0x00000100U
#define SRT_NX51_dpm_irq_fiq_masked_uart0      8
#define MSK_NX51_dpm_irq_fiq_masked_uart1      0x00000200U
#define SRT_NX51_dpm_irq_fiq_masked_uart1      9
#define MSK_NX51_dpm_irq_fiq_masked_uart2      0x00000400U
#define SRT_NX51_dpm_irq_fiq_masked_uart2      10
#define MSK_NX51_dpm_irq_fiq_masked_usb        0x00000800U
#define SRT_NX51_dpm_irq_fiq_masked_usb        11
#define MSK_NX51_dpm_irq_fiq_masked_spi        0x00001000U
#define SRT_NX51_dpm_irq_fiq_masked_spi        12
#define MSK_NX51_dpm_irq_fiq_masked_i2c        0x00002000U
#define SRT_NX51_dpm_irq_fiq_masked_i2c        13
#define MSK_NX51_dpm_irq_fiq_masked_firmware   0x00008000U
#define SRT_NX51_dpm_irq_fiq_masked_firmware   15
#define MSK_NX51_dpm_irq_fiq_masked_gpio       0x00010000U
#define SRT_NX51_dpm_irq_fiq_masked_gpio       16
#define MSK_NX51_dpm_irq_fiq_masked_com0       0x00020000U
#define SRT_NX51_dpm_irq_fiq_masked_com0       17
#define MSK_NX51_dpm_irq_fiq_masked_com1       0x00040000U
#define SRT_NX51_dpm_irq_fiq_masked_com1       18
#define MSK_NX51_dpm_irq_fiq_masked_xpic_debug 0x00100000U
#define SRT_NX51_dpm_irq_fiq_masked_xpic_debug 20
#define MSK_NX51_dpm_irq_fiq_masked_msync0     0x00200000U
#define SRT_NX51_dpm_irq_fiq_masked_msync0     21
#define MSK_NX51_dpm_irq_fiq_masked_msync1     0x00400000U
#define SRT_NX51_dpm_irq_fiq_masked_msync1     22
#define MSK_NX51_dpm_irq_fiq_masked_int_phy    0x02000000U
#define SRT_NX51_dpm_irq_fiq_masked_int_phy    25
#define MSK_NX51_dpm_irq_fiq_masked_sysstate   0x04000000U
#define SRT_NX51_dpm_irq_fiq_masked_sysstate   26
#define MSK_NX51_dpm_irq_fiq_masked_dmac       0x08000000U
#define SRT_NX51_dpm_irq_fiq_masked_dmac       27
#define MSK_NX51_dpm_irq_fiq_masked_trigger_lt 0x10000000U
#define SRT_NX51_dpm_irq_fiq_masked_trigger_lt 28
#define MSK_NX51_dpm_irq_fiq_masked_can        0x20000000U
#define SRT_NX51_dpm_irq_fiq_masked_can        29
#define MSK_NX51_dpm_irq_fiq_masked_osac       0x40000000U
#define SRT_NX51_dpm_irq_fiq_masked_osac       30

/* all used bits of 'NX51_dpm_irq_fiq_masked': */
#define MSK_USED_BITS_NX51_dpm_irq_fiq_masked 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_fiq_masked_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_fiq_masked_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_fiq_masked_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_fiq_masked_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_fiq_masked_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_fiq_masked_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_fiq_masked_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_fiq_masked_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_fiq_masked_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_fiq_masked_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_fiq_masked_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_fiq_masked_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_fiq_masked_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_fiq_masked_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_fiq_masked_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_fiq_masked_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_fiq_masked_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_fiq_masked_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_fiq_masked_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_fiq_masked_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_fiq_masked_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_fiq_masked_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_fiq_masked_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_fiq_masked_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_fiq_masked_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_fiq_masked_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_fiq_masked_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_fiq_masked_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_fiq_masked_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_fiq_masked_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_fiq_masked_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_FIQ_MASKED_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_fiq_masked_dpm_sw;     /* masked software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_fiq_masked_dpm_err;    /* masked DPM access error interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_fiq_masked_reserved1;  /* reserved                                                                                                                               */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_fiq_masked_gpio_timer; /* masked GPIO Timer 0..4 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_fiq_masked_systime_ns; /* masked ARM_TIMER systime_ns/systime_uc_ns interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_fiq_masked_systime_s;  /* masked ARM_TIMER systime_s/systime_uc_s interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_fiq_masked_gpio31;     /* masked external GPIO 31 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_fiq_masked_watchdog;   /* masked combined Watchdog from WDG_SYS and XPIC_WDG module interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)     */
	unsigned int uart0      : BFW_NX51_dpm_irq_fiq_masked_uart0;      /* masked UART 0 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_fiq_masked_uart1;      /* masked UART 1 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_fiq_masked_uart2;      /* masked UART 2 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_fiq_masked_usb;        /* masked USB interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_fiq_masked_spi;        /* masked combined SPI 0 / SQI, SPI 1 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_fiq_masked_i2c;        /* masked combined I2C 0 and I2C 1 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_fiq_masked_reserved2;  /* reserved                                                                                                                               */
	unsigned int firmware   : BFW_NX51_dpm_irq_fiq_masked_firmware;   /* masked combined handshake-cell and SYS_STA firmware interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int gpio       : BFW_NX51_dpm_irq_fiq_masked_gpio;       /* masked combined GPIO 0-30 / IOLINK interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                            */
	unsigned int com0       : BFW_NX51_dpm_irq_fiq_masked_com0;       /* masked communication channel 0 (= |xpec0_irq[11:0]) interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int com1       : BFW_NX51_dpm_irq_fiq_masked_com1;       /* masked communication channel 1 (= |xpec1_irq[11:0]) interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_fiq_masked_reserved3;  /* reserved                                                                                                                               */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_fiq_masked_xpic_debug; /* masked xPIC Debug interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_fiq_masked_msync0;     /* masked motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) */
	unsigned int msync1     : BFW_NX51_dpm_irq_fiq_masked_msync1;     /* masked motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ) */
	unsigned int reserved4  : BFW_NX51_dpm_irq_fiq_masked_reserved4;  /* reserved                                                                                                                               */
	unsigned int int_phy    : BFW_NX51_dpm_irq_fiq_masked_int_phy;    /* masked combined internal PHY 0 / PHY 1 interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_fiq_masked_sysstate;   /* masked combined licence error and MI timeout interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_fiq_masked_dmac;       /* masked DMA-Controller interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_fiq_masked_trigger_lt; /* masked Trigger-Latch interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                          */
	unsigned int can        : BFW_NX51_dpm_irq_fiq_masked_can;        /* masked CAN interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_fiq_masked_osac;       /* masked OSAC interrupt state for fast netX interrupt output signal (DPM_FIQ/HIF_SIRQ)                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_fiq_masked_reserved5;  /* reserved                                                                                                                               */
} NX51_DPM_IRQ_FIQ_MASKED_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_DPM_IRQ_FIQ_MASKED_BIT_T bf;
} NX51_DPM_IRQ_FIQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_irq_mask_set */
/* => DPM Interrupt Mask Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ). */
/*    Write access with '1' sets related interrupt mask bits (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ). */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_irq_mask_set  0x000000A8U
#define Adr_NX51_dpm_dpm_irq_irq_mask_set  0x1018C0A8U
#define Adr_NX51_dpm_irq_irq_mask_set      0x1018C0A8U
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set 0x00000000U

#define MSK_NX51_dpm_irq_irq_mask_set_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_irq_mask_set_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_irq_mask_set_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_irq_mask_set_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_irq_mask_set_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_irq_mask_set_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_irq_mask_set_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_irq_mask_set_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_uart0              0x00000100U
#define SRT_NX51_dpm_irq_irq_mask_set_uart0              8
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_uart0      0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_uart1              0x00000200U
#define SRT_NX51_dpm_irq_irq_mask_set_uart1              9
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_uart1      0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_uart2              0x00000400U
#define SRT_NX51_dpm_irq_irq_mask_set_uart2              10
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_uart2      0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_usb                0x00000800U
#define SRT_NX51_dpm_irq_irq_mask_set_usb                11
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_usb        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_spi                0x00001000U
#define SRT_NX51_dpm_irq_irq_mask_set_spi                12
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_spi        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_i2c                0x00002000U
#define SRT_NX51_dpm_irq_irq_mask_set_i2c                13
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_i2c        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_firmware           0x00008000U
#define SRT_NX51_dpm_irq_irq_mask_set_firmware           15
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_firmware   0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_gpio               0x00010000U
#define SRT_NX51_dpm_irq_irq_mask_set_gpio               16
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_gpio       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_com0               0x00020000U
#define SRT_NX51_dpm_irq_irq_mask_set_com0               17
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_com0       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_com1               0x00040000U
#define SRT_NX51_dpm_irq_irq_mask_set_com1               18
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_com1       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_irq_mask_set_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_msync0             0x00200000U
#define SRT_NX51_dpm_irq_irq_mask_set_msync0             21
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_msync0     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_msync1             0x00400000U
#define SRT_NX51_dpm_irq_irq_mask_set_msync1             22
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_msync1     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_irq_mask_set_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_irq_mask_set_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_dmac               0x08000000U
#define SRT_NX51_dpm_irq_irq_mask_set_dmac               27
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_dmac       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_irq_mask_set_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_can                0x20000000U
#define SRT_NX51_dpm_irq_irq_mask_set_can                29
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_can        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_set_osac               0x40000000U
#define SRT_NX51_dpm_irq_irq_mask_set_osac               30
#define DFLT_VAL_NX51_dpm_irq_irq_mask_set_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_set_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_irq_mask_set': */
#define MSK_USED_BITS_NX51_dpm_irq_irq_mask_set 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_irq_mask_set_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_irq_mask_set_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_irq_mask_set_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_irq_mask_set_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_irq_mask_set_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_irq_mask_set_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_irq_mask_set_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_irq_mask_set_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_irq_mask_set_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_irq_mask_set_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_irq_mask_set_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_irq_mask_set_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_irq_mask_set_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_irq_mask_set_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_irq_mask_set_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_irq_mask_set_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_irq_mask_set_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_irq_mask_set_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_irq_mask_set_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_irq_mask_set_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_irq_mask_set_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_irq_mask_set_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_irq_mask_set_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_irq_mask_set_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_irq_mask_set_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_irq_mask_set_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_irq_mask_set_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_irq_mask_set_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_irq_mask_set_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_irq_mask_set_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_irq_mask_set_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_IRQ_MASK_SET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_irq_mask_set_dpm_sw;     /* set software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_irq_mask_set_dpm_err;    /* set DPM access error interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_irq_mask_set_reserved1;  /* reserved                                                                                                                             */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_irq_mask_set_gpio_timer; /* set GPIO Timer 0..4 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_irq_mask_set_systime_ns; /* set ARM_TIMER systime_ns/systime_uc_ns interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_irq_mask_set_systime_s;  /* set ARM_TIMER systime_s/systime_uc_s interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_irq_mask_set_gpio31;     /* set external GPIO 31 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_irq_mask_set_watchdog;   /* set combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)     */
	unsigned int uart0      : BFW_NX51_dpm_irq_irq_mask_set_uart0;      /* set UART 0 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_irq_mask_set_uart1;      /* set UART 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_irq_mask_set_uart2;      /* set UART 2 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_irq_mask_set_usb;        /* set USB interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_irq_mask_set_spi;        /* set combined SPI 0 / SQI, SPI 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_irq_mask_set_i2c;        /* set combined I2C 0 and I2C 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_irq_mask_set_reserved2;  /* reserved                                                                                                                             */
	unsigned int firmware   : BFW_NX51_dpm_irq_irq_mask_set_firmware;   /* set combined handshake-cell and SYS_STA firmware interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int gpio       : BFW_NX51_dpm_irq_irq_mask_set_gpio;       /* set combined GPIO 0-30 / IOLINK interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                            */
	unsigned int com0       : BFW_NX51_dpm_irq_irq_mask_set_com0;       /* set communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int com1       : BFW_NX51_dpm_irq_irq_mask_set_com1;       /* set communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_irq_mask_set_reserved3;  /* reserved                                                                                                                             */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_irq_mask_set_xpic_debug; /* set xPIC Debug interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_irq_mask_set_msync0;     /* set motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) */
	unsigned int msync1     : BFW_NX51_dpm_irq_irq_mask_set_msync1;     /* set motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) */
	unsigned int reserved4  : BFW_NX51_dpm_irq_irq_mask_set_reserved4;  /* reserved                                                                                                                             */
	unsigned int int_phy    : BFW_NX51_dpm_irq_irq_mask_set_int_phy;    /* set combined internal PHY 0 / PHY 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_irq_mask_set_sysstate;   /* set combined licence error and MI timeout interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_irq_mask_set_dmac;       /* set DMA-Controller interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_irq_mask_set_trigger_lt; /* set Trigger-Latch interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                          */
	unsigned int can        : BFW_NX51_dpm_irq_irq_mask_set_can;        /* set CAN interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_irq_mask_set_osac;       /* set OSAC interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_irq_mask_set_reserved5;  /* reserved                                                                                                                             */
} NX51_DPM_IRQ_IRQ_MASK_SET_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DPM_IRQ_IRQ_MASK_SET_BIT_T bf;
} NX51_DPM_IRQ_IRQ_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_irq_mask_reset */
/* => DPM Interrupt Mask Reset Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ). */
/*    Write access with '1' resets related interrupt mask bits (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence related interrupt mask bit. */
/*    Read access shows actual interrupt mask. */
/*    If a mask bit is set, the related interrupt will activate the IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ). */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_irq_mask_reset  0x000000ACU
#define Adr_NX51_dpm_dpm_irq_irq_mask_reset  0x1018C0ACU
#define Adr_NX51_dpm_irq_irq_mask_reset      0x1018C0ACU
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset 0x00000000U

#define MSK_NX51_dpm_irq_irq_mask_reset_dpm_sw             0x00000001U
#define SRT_NX51_dpm_irq_irq_mask_reset_dpm_sw             0
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_dpm_sw        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_dpm_sw     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_dpm_err            0x00000002U
#define SRT_NX51_dpm_irq_irq_mask_reset_dpm_err            1
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_dpm_err       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_dpm_err    0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_gpio_timer         0x00000008U
#define SRT_NX51_dpm_irq_irq_mask_reset_gpio_timer         3
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_gpio_timer 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_systime_ns         0x00000010U
#define SRT_NX51_dpm_irq_irq_mask_reset_systime_ns         4
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_systime_ns 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_systime_s          0x00000020U
#define SRT_NX51_dpm_irq_irq_mask_reset_systime_s          5
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_systime_s  0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_gpio31             0x00000040U
#define SRT_NX51_dpm_irq_irq_mask_reset_gpio31             6
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_gpio31     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_watchdog           0x00000080U
#define SRT_NX51_dpm_irq_irq_mask_reset_watchdog           7
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_watchdog   0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_uart0              0x00000100U
#define SRT_NX51_dpm_irq_irq_mask_reset_uart0              8
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_uart0      0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_uart1              0x00000200U
#define SRT_NX51_dpm_irq_irq_mask_reset_uart1              9
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_uart1      0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_uart2              0x00000400U
#define SRT_NX51_dpm_irq_irq_mask_reset_uart2              10
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_uart2      0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_usb                0x00000800U
#define SRT_NX51_dpm_irq_irq_mask_reset_usb                11
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_usb           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_usb        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_spi                0x00001000U
#define SRT_NX51_dpm_irq_irq_mask_reset_spi                12
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_spi           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_spi        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_i2c                0x00002000U
#define SRT_NX51_dpm_irq_irq_mask_reset_i2c                13
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_i2c        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_firmware           0x00008000U
#define SRT_NX51_dpm_irq_irq_mask_reset_firmware           15
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_firmware      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_firmware   0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_gpio               0x00010000U
#define SRT_NX51_dpm_irq_irq_mask_reset_gpio               16
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_gpio       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_com0               0x00020000U
#define SRT_NX51_dpm_irq_irq_mask_reset_com0               17
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_com0       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_com1               0x00040000U
#define SRT_NX51_dpm_irq_irq_mask_reset_com1               18
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_com1       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_xpic_debug         0x00100000U
#define SRT_NX51_dpm_irq_irq_mask_reset_xpic_debug         20
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_xpic_debug    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_xpic_debug 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_msync0             0x00200000U
#define SRT_NX51_dpm_irq_irq_mask_reset_msync0             21
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_msync0     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_msync1             0x00400000U
#define SRT_NX51_dpm_irq_irq_mask_reset_msync1             22
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_msync1     0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_int_phy            0x02000000U
#define SRT_NX51_dpm_irq_irq_mask_reset_int_phy            25
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_int_phy    0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_sysstate           0x04000000U
#define SRT_NX51_dpm_irq_irq_mask_reset_sysstate           26
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_sysstate   0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_dmac               0x08000000U
#define SRT_NX51_dpm_irq_irq_mask_reset_dmac               27
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_dmac       0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_trigger_lt         0x10000000U
#define SRT_NX51_dpm_irq_irq_mask_reset_trigger_lt         28
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_trigger_lt 0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_can                0x20000000U
#define SRT_NX51_dpm_irq_irq_mask_reset_can                29
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_can           0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_can        0x00000000U
#define MSK_NX51_dpm_irq_irq_mask_reset_osac               0x40000000U
#define SRT_NX51_dpm_irq_irq_mask_reset_osac               30
#define DFLT_VAL_NX51_dpm_irq_irq_mask_reset_osac          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_irq_irq_mask_reset_osac       0x00000000U

/* all used bits of 'NX51_dpm_irq_irq_mask_reset': */
#define MSK_USED_BITS_NX51_dpm_irq_irq_mask_reset 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_irq_mask_reset_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_irq_mask_reset_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_irq_mask_reset_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_irq_mask_reset_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_irq_mask_reset_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_irq_mask_reset_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_irq_mask_reset_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_irq_mask_reset_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_irq_mask_reset_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_irq_mask_reset_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_irq_mask_reset_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_irq_mask_reset_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_irq_mask_reset_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_irq_mask_reset_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_irq_mask_reset_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_irq_mask_reset_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_irq_mask_reset_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_irq_mask_reset_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_irq_mask_reset_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_irq_mask_reset_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_irq_mask_reset_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_irq_mask_reset_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_irq_mask_reset_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_irq_mask_reset_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_irq_mask_reset_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_irq_mask_reset_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_irq_mask_reset_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_irq_mask_reset_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_irq_mask_reset_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_irq_mask_reset_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_irq_mask_reset_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_IRQ_MASK_RESET_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_irq_mask_reset_dpm_sw;     /* reset software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_irq_mask_reset_dpm_err;    /* reset DPM access error interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_irq_mask_reset_reserved1;  /* reserved                                                                                                                               */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_irq_mask_reset_gpio_timer; /* reset GPIO Timer 0..4 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_irq_mask_reset_systime_ns; /* reset ARM_TIMER systime_ns/systime_uc_ns interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_irq_mask_reset_systime_s;  /* reset ARM_TIMER systime_s/systime_uc_s interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_irq_mask_reset_gpio31;     /* reset external GPIO 31 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_irq_mask_reset_watchdog;   /* reset combined Watchdog from WDG_SYS and XPIC_WDG module interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)     */
	unsigned int uart0      : BFW_NX51_dpm_irq_irq_mask_reset_uart0;      /* reset UART 0 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_irq_mask_reset_uart1;      /* reset UART 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_irq_mask_reset_uart2;      /* reset UART 2 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_irq_mask_reset_usb;        /* reset USB interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_irq_mask_reset_spi;        /* reset combined SPI 0 / SQI, SPI 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_irq_mask_reset_i2c;        /* reset combined I2C 0 and I2C 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_irq_mask_reset_reserved2;  /* reserved                                                                                                                               */
	unsigned int firmware   : BFW_NX51_dpm_irq_irq_mask_reset_firmware;   /* reset combined handshake-cell and SYS_STA firmware interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int gpio       : BFW_NX51_dpm_irq_irq_mask_reset_gpio;       /* reset combined GPIO 0-30 / IOLINK interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                            */
	unsigned int com0       : BFW_NX51_dpm_irq_irq_mask_reset_com0;       /* reset communication channel 0 (= |xpec0_irq[11:0]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int com1       : BFW_NX51_dpm_irq_irq_mask_reset_com1;       /* reset communication channel 1 (= |xpec1_irq[11:0]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_irq_mask_reset_reserved3;  /* reserved                                                                                                                               */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_irq_mask_reset_xpic_debug; /* reset xPIC Debug interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_irq_mask_reset_msync0;     /* reset motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) */
	unsigned int msync1     : BFW_NX51_dpm_irq_irq_mask_reset_msync1;     /* reset motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) */
	unsigned int reserved4  : BFW_NX51_dpm_irq_irq_mask_reset_reserved4;  /* reserved                                                                                                                               */
	unsigned int int_phy    : BFW_NX51_dpm_irq_irq_mask_reset_int_phy;    /* reset combined internal PHY 0 / PHY 1 interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_irq_mask_reset_sysstate;   /* reset combined licence error and MI timeout interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_irq_mask_reset_dmac;       /* reset DMA-Controller interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_irq_mask_reset_trigger_lt; /* reset Trigger-Latch interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                          */
	unsigned int can        : BFW_NX51_dpm_irq_irq_mask_reset_can;        /* reset CAN interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_irq_mask_reset_osac;       /* reset OSAC interrupt mask for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_irq_mask_reset_reserved5;  /* reserved                                                                                                                               */
} NX51_DPM_IRQ_IRQ_MASK_RESET_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_DPM_IRQ_IRQ_MASK_RESET_BIT_T bf;
} NX51_DPM_IRQ_IRQ_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register dpm_irq_irq_masked */
/* => DPM Masked Interrupt Status Register for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ). */
/*    A bit is set, when the related mask bit is set in 'dpm_irq_irq_mask'-register and the related interrupt is asserted. */
/*    IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) is asserted if at least one bit is set here. */
/*    Interrupts must be reset in interrupt generating module. Interrupts cannot be cleared here. */
/*    To release IRQ for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) without clearing interrupt in module, reset related mask bit to 0. */
/*    Note: */
/*       For further information view description of 'dpm_irq_raw' register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_irq_irq_masked 0x000000B0U
#define Adr_NX51_dpm_dpm_irq_irq_masked 0x1018C0B0U
#define Adr_NX51_dpm_irq_irq_masked     0x1018C0B0U

#define MSK_NX51_dpm_irq_irq_masked_dpm_sw     0x00000001U
#define SRT_NX51_dpm_irq_irq_masked_dpm_sw     0
#define MSK_NX51_dpm_irq_irq_masked_dpm_err    0x00000002U
#define SRT_NX51_dpm_irq_irq_masked_dpm_err    1
#define MSK_NX51_dpm_irq_irq_masked_gpio_timer 0x00000008U
#define SRT_NX51_dpm_irq_irq_masked_gpio_timer 3
#define MSK_NX51_dpm_irq_irq_masked_systime_ns 0x00000010U
#define SRT_NX51_dpm_irq_irq_masked_systime_ns 4
#define MSK_NX51_dpm_irq_irq_masked_systime_s  0x00000020U
#define SRT_NX51_dpm_irq_irq_masked_systime_s  5
#define MSK_NX51_dpm_irq_irq_masked_gpio31     0x00000040U
#define SRT_NX51_dpm_irq_irq_masked_gpio31     6
#define MSK_NX51_dpm_irq_irq_masked_watchdog   0x00000080U
#define SRT_NX51_dpm_irq_irq_masked_watchdog   7
#define MSK_NX51_dpm_irq_irq_masked_uart0      0x00000100U
#define SRT_NX51_dpm_irq_irq_masked_uart0      8
#define MSK_NX51_dpm_irq_irq_masked_uart1      0x00000200U
#define SRT_NX51_dpm_irq_irq_masked_uart1      9
#define MSK_NX51_dpm_irq_irq_masked_uart2      0x00000400U
#define SRT_NX51_dpm_irq_irq_masked_uart2      10
#define MSK_NX51_dpm_irq_irq_masked_usb        0x00000800U
#define SRT_NX51_dpm_irq_irq_masked_usb        11
#define MSK_NX51_dpm_irq_irq_masked_spi        0x00001000U
#define SRT_NX51_dpm_irq_irq_masked_spi        12
#define MSK_NX51_dpm_irq_irq_masked_i2c        0x00002000U
#define SRT_NX51_dpm_irq_irq_masked_i2c        13
#define MSK_NX51_dpm_irq_irq_masked_firmware   0x00008000U
#define SRT_NX51_dpm_irq_irq_masked_firmware   15
#define MSK_NX51_dpm_irq_irq_masked_gpio       0x00010000U
#define SRT_NX51_dpm_irq_irq_masked_gpio       16
#define MSK_NX51_dpm_irq_irq_masked_com0       0x00020000U
#define SRT_NX51_dpm_irq_irq_masked_com0       17
#define MSK_NX51_dpm_irq_irq_masked_com1       0x00040000U
#define SRT_NX51_dpm_irq_irq_masked_com1       18
#define MSK_NX51_dpm_irq_irq_masked_xpic_debug 0x00100000U
#define SRT_NX51_dpm_irq_irq_masked_xpic_debug 20
#define MSK_NX51_dpm_irq_irq_masked_msync0     0x00200000U
#define SRT_NX51_dpm_irq_irq_masked_msync0     21
#define MSK_NX51_dpm_irq_irq_masked_msync1     0x00400000U
#define SRT_NX51_dpm_irq_irq_masked_msync1     22
#define MSK_NX51_dpm_irq_irq_masked_int_phy    0x02000000U
#define SRT_NX51_dpm_irq_irq_masked_int_phy    25
#define MSK_NX51_dpm_irq_irq_masked_sysstate   0x04000000U
#define SRT_NX51_dpm_irq_irq_masked_sysstate   26
#define MSK_NX51_dpm_irq_irq_masked_dmac       0x08000000U
#define SRT_NX51_dpm_irq_irq_masked_dmac       27
#define MSK_NX51_dpm_irq_irq_masked_trigger_lt 0x10000000U
#define SRT_NX51_dpm_irq_irq_masked_trigger_lt 28
#define MSK_NX51_dpm_irq_irq_masked_can        0x20000000U
#define SRT_NX51_dpm_irq_irq_masked_can        29
#define MSK_NX51_dpm_irq_irq_masked_osac       0x40000000U
#define SRT_NX51_dpm_irq_irq_masked_osac       30

/* all used bits of 'NX51_dpm_irq_irq_masked': */
#define MSK_USED_BITS_NX51_dpm_irq_irq_masked 0x7e77bffbU

enum {
	BFW_NX51_dpm_irq_irq_masked_dpm_sw     = 1, /* [0] */
	BFW_NX51_dpm_irq_irq_masked_dpm_err    = 1, /* [1] */
	BFW_NX51_dpm_irq_irq_masked_reserved1  = 1, /* [2] */
	BFW_NX51_dpm_irq_irq_masked_gpio_timer = 1, /* [3] */
	BFW_NX51_dpm_irq_irq_masked_systime_ns = 1, /* [4] */
	BFW_NX51_dpm_irq_irq_masked_systime_s  = 1, /* [5] */
	BFW_NX51_dpm_irq_irq_masked_gpio31     = 1, /* [6] */
	BFW_NX51_dpm_irq_irq_masked_watchdog   = 1, /* [7] */
	BFW_NX51_dpm_irq_irq_masked_uart0      = 1, /* [8] */
	BFW_NX51_dpm_irq_irq_masked_uart1      = 1, /* [9] */
	BFW_NX51_dpm_irq_irq_masked_uart2      = 1, /* [10] */
	BFW_NX51_dpm_irq_irq_masked_usb        = 1, /* [11] */
	BFW_NX51_dpm_irq_irq_masked_spi        = 1, /* [12] */
	BFW_NX51_dpm_irq_irq_masked_i2c        = 1, /* [13] */
	BFW_NX51_dpm_irq_irq_masked_reserved2  = 1, /* [14] */
	BFW_NX51_dpm_irq_irq_masked_firmware   = 1, /* [15] */
	BFW_NX51_dpm_irq_irq_masked_gpio       = 1, /* [16] */
	BFW_NX51_dpm_irq_irq_masked_com0       = 1, /* [17] */
	BFW_NX51_dpm_irq_irq_masked_com1       = 1, /* [18] */
	BFW_NX51_dpm_irq_irq_masked_reserved3  = 1, /* [19] */
	BFW_NX51_dpm_irq_irq_masked_xpic_debug = 1, /* [20] */
	BFW_NX51_dpm_irq_irq_masked_msync0     = 1, /* [21] */
	BFW_NX51_dpm_irq_irq_masked_msync1     = 1, /* [22] */
	BFW_NX51_dpm_irq_irq_masked_reserved4  = 2, /* [24:23] */
	BFW_NX51_dpm_irq_irq_masked_int_phy    = 1, /* [25] */
	BFW_NX51_dpm_irq_irq_masked_sysstate   = 1, /* [26] */
	BFW_NX51_dpm_irq_irq_masked_dmac       = 1, /* [27] */
	BFW_NX51_dpm_irq_irq_masked_trigger_lt = 1, /* [28] */
	BFW_NX51_dpm_irq_irq_masked_can        = 1, /* [29] */
	BFW_NX51_dpm_irq_irq_masked_osac       = 1, /* [30] */
	BFW_NX51_dpm_irq_irq_masked_reserved5  = 1  /* [31] */
};

typedef struct NX51_DPM_IRQ_IRQ_MASKED_BIT_Ttag {
	unsigned int dpm_sw     : BFW_NX51_dpm_irq_irq_masked_dpm_sw;     /* masked software IRQ for netX IRQ targets (e.g. ARM, xPIC) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)     */
	unsigned int dpm_err    : BFW_NX51_dpm_irq_irq_masked_dpm_err;    /* masked DPM access error interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                       */
	unsigned int reserved1  : BFW_NX51_dpm_irq_irq_masked_reserved1;  /* reserved                                                                                                                                 */
	unsigned int gpio_timer : BFW_NX51_dpm_irq_irq_masked_gpio_timer; /* masked GPIO Timer 0..4 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                        */
	unsigned int systime_ns : BFW_NX51_dpm_irq_irq_masked_systime_ns; /* masked ARM_TIMER systime_ns/systime_uc_ns interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                     */
	unsigned int systime_s  : BFW_NX51_dpm_irq_irq_masked_systime_s;  /* masked ARM_TIMER systime_s/systime_uc_s interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                       */
	unsigned int gpio31     : BFW_NX51_dpm_irq_irq_masked_gpio31;     /* masked external GPIO 31 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                       */
	unsigned int watchdog   : BFW_NX51_dpm_irq_irq_masked_watchdog;   /* masked combined Watchdog from WDG_SYS and XPIC_WDG module interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)     */
	unsigned int uart0      : BFW_NX51_dpm_irq_irq_masked_uart0;      /* masked UART 0 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int uart1      : BFW_NX51_dpm_irq_irq_masked_uart1;      /* masked UART 1 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int uart2      : BFW_NX51_dpm_irq_irq_masked_uart2;      /* masked UART 2 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                 */
	unsigned int usb        : BFW_NX51_dpm_irq_irq_masked_usb;        /* masked USB interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                    */
	unsigned int spi        : BFW_NX51_dpm_irq_irq_masked_spi;        /* masked combined SPI 0 / SQI, SPI 1 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                            */
	unsigned int i2c        : BFW_NX51_dpm_irq_irq_masked_i2c;        /* masked combined I2C 0 and I2C 1 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                               */
	unsigned int reserved2  : BFW_NX51_dpm_irq_irq_masked_reserved2;  /* reserved                                                                                                                                 */
	unsigned int firmware   : BFW_NX51_dpm_irq_irq_masked_firmware;   /* masked combined handshake-cell and SYS_STA firmware interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int gpio       : BFW_NX51_dpm_irq_irq_masked_gpio;       /* masked combined GPIO 0-30 / IOLINK interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                            */
	unsigned int com0       : BFW_NX51_dpm_irq_irq_masked_com0;       /* masked communication channel 0 (= |xpec0_irq[11:0]) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int com1       : BFW_NX51_dpm_irq_irq_masked_com1;       /* masked communication channel 1 (= |xpec1_irq[11:0]) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)           */
	unsigned int reserved3  : BFW_NX51_dpm_irq_irq_masked_reserved3;  /* reserved                                                                                                                                 */
	unsigned int xpic_debug : BFW_NX51_dpm_irq_irq_masked_xpic_debug; /* masked xPIC Debug interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                             */
	unsigned int msync0     : BFW_NX51_dpm_irq_irq_masked_msync0;     /* masked motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) */
	unsigned int msync1     : BFW_NX51_dpm_irq_irq_masked_msync1;     /* masked motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ) */
	unsigned int reserved4  : BFW_NX51_dpm_irq_irq_masked_reserved4;  /* reserved                                                                                                                                 */
	unsigned int int_phy    : BFW_NX51_dpm_irq_irq_masked_int_phy;    /* masked combined internal PHY 0 / PHY 1 interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                        */
	unsigned int sysstate   : BFW_NX51_dpm_irq_irq_masked_sysstate;   /* masked combined licence error and MI timeout interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                  */
	unsigned int dmac       : BFW_NX51_dpm_irq_irq_masked_dmac;       /* masked DMA-Controller interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_irq_irq_masked_trigger_lt; /* masked Trigger-Latch interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                          */
	unsigned int can        : BFW_NX51_dpm_irq_irq_masked_can;        /* masked CAN interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                    */
	unsigned int osac       : BFW_NX51_dpm_irq_irq_masked_osac;       /* masked OSAC interrupt state for normal netX interrupt output signal (DPM_IRQ/HIF_DIRQ)                                                   */
	unsigned int reserved5  : BFW_NX51_dpm_irq_irq_masked_reserved5;  /* reserved                                                                                                                                 */
} NX51_DPM_IRQ_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_DPM_IRQ_IRQ_MASKED_BIT_T bf;
} NX51_DPM_IRQ_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register dpm_sw_irq */
/* => DPM Register for Software Interrupt Generation to Host and netX Interrupt Targets. */
/*    Host and netX masters can generate an interrupt to netX interrupt targets (e.g. ARM-VIC, xPIC-VIC) */
/*    or DPM IRQ signals by this register. */
/*    To propagate interrupt states from this register to the interrupt target the 'dpm_sw' bit must */
/*    be set inside the appropriate interrupt mask (e.g. 'dpm_irq_arm_mask_set' register). */
/*    Example: */
/*       The 'dpm_sw' IRQs can be used by the host to flag one IRQ to the ARM by */
/*       setting the arm-dpm_sw and another IRQ to the xPIC by setting the xpic-dpm_sw. The */
/*       ARM can use at the same time the irq-dpm_sw to flag an IRQ to the host while the */
/*       xPIC could use the fiq-dpm_sw to flag another IRQ to the host. */
/*    Note: */
/*       For each netX interrupt target  there is a set and a reset bit provided to avoid read-modify-write sequences. */
/*       When both (set and reset) bits are set for the same target, the related interrupt will be set (set will win). */
/*       Reset bits are always 0 on read. Set-bits show current interrupt status when read. */
/*    Note: */
/*       This register is a new netx51 feature.. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_sw_irq  0x000000B8U
#define Adr_NX51_dpm_dpm_sw_irq  0x1018C0B8U
#define Adr_NX51_dpm_sw_irq      0x1018C0B8U
#define DFLT_VAL_NX51_dpm_sw_irq 0x00000000U

#define MSK_NX51_dpm_sw_irq_set_arm            0x00000001U
#define SRT_NX51_dpm_sw_irq_set_arm            0
#define DFLT_VAL_NX51_dpm_sw_irq_set_arm       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_set_arm    0x00000000U
#define MSK_NX51_dpm_sw_irq_set_xpic           0x00000002U
#define SRT_NX51_dpm_sw_irq_set_xpic           1
#define DFLT_VAL_NX51_dpm_sw_irq_set_xpic      0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_set_xpic   0x00000000U
#define MSK_NX51_dpm_sw_irq_set_fiq            0x00000004U
#define SRT_NX51_dpm_sw_irq_set_fiq            2
#define DFLT_VAL_NX51_dpm_sw_irq_set_fiq       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_set_fiq    0x00000000U
#define MSK_NX51_dpm_sw_irq_set_irq            0x00000008U
#define SRT_NX51_dpm_sw_irq_set_irq            3
#define DFLT_VAL_NX51_dpm_sw_irq_set_irq       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_set_irq    0x00000000U
#define MSK_NX51_dpm_sw_irq_reset_arm          0x00000100U
#define SRT_NX51_dpm_sw_irq_reset_arm          8
#define DFLT_VAL_NX51_dpm_sw_irq_reset_arm     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_reset_arm  0x00000000U
#define MSK_NX51_dpm_sw_irq_reset_xpic         0x00000200U
#define SRT_NX51_dpm_sw_irq_reset_xpic         9
#define DFLT_VAL_NX51_dpm_sw_irq_reset_xpic    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_reset_xpic 0x00000000U
#define MSK_NX51_dpm_sw_irq_reset_fiq          0x00000400U
#define SRT_NX51_dpm_sw_irq_reset_fiq          10
#define DFLT_VAL_NX51_dpm_sw_irq_reset_fiq     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_reset_fiq  0x00000000U
#define MSK_NX51_dpm_sw_irq_reset_irq          0x00000800U
#define SRT_NX51_dpm_sw_irq_reset_irq          11
#define DFLT_VAL_NX51_dpm_sw_irq_reset_irq     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sw_irq_reset_irq  0x00000000U

/* all used bits of 'NX51_dpm_sw_irq': */
#define MSK_USED_BITS_NX51_dpm_sw_irq 0x00000f0fU

enum {
	BFW_NX51_dpm_sw_irq_set_arm    = 1,  /* [0] */
	BFW_NX51_dpm_sw_irq_set_xpic   = 1,  /* [1] */
	BFW_NX51_dpm_sw_irq_set_fiq    = 1,  /* [2] */
	BFW_NX51_dpm_sw_irq_set_irq    = 1,  /* [3] */
	BFW_NX51_dpm_sw_irq_reserved1  = 4,  /* [7:4] */
	BFW_NX51_dpm_sw_irq_reset_arm  = 1,  /* [8] */
	BFW_NX51_dpm_sw_irq_reset_xpic = 1,  /* [9] */
	BFW_NX51_dpm_sw_irq_reset_fiq  = 1,  /* [10] */
	BFW_NX51_dpm_sw_irq_reset_irq  = 1,  /* [11] */
	BFW_NX51_dpm_sw_irq_reserved2  = 20  /* [31:12] */
};

typedef struct NX51_DPM_SW_IRQ_BIT_Ttag {
	unsigned int set_arm    : BFW_NX51_dpm_sw_irq_set_arm;    /* Set 'dpm_sw' IRQ for ARM (current 'dpm_sw' status for ARM when read)        */
	unsigned int set_xpic   : BFW_NX51_dpm_sw_irq_set_xpic;   /* Set 'dpm_sw' IRQ for xPIC (current 'dpm_sw' status for xPIC when read)      */
	unsigned int set_fiq    : BFW_NX51_dpm_sw_irq_set_fiq;    /* Set 'dpm_sw' IRQ for FIQ-signal (current 'dpm_sw' status for FIQ when read) */
	unsigned int set_irq    : BFW_NX51_dpm_sw_irq_set_irq;    /* Set 'dpm_sw' IRQ for IRQ-signal (current 'dpm_sw' status for IRQ when read) */
	unsigned int reserved1  : BFW_NX51_dpm_sw_irq_reserved1;  /* reserved                                                                    */
	unsigned int reset_arm  : BFW_NX51_dpm_sw_irq_reset_arm;  /* Reset 'dpm_sw' IRQ for ARM (always 0 when read)                             */
	unsigned int reset_xpic : BFW_NX51_dpm_sw_irq_reset_xpic; /* Reset 'dpm_sw' IRQ for xPIC (always 0 when read)                            */
	unsigned int reset_fiq  : BFW_NX51_dpm_sw_irq_reset_fiq;  /* Reset 'dpm_sw' IRQ for FIQ-signal (always 0 when read)                      */
	unsigned int reset_irq  : BFW_NX51_dpm_sw_irq_reset_irq;  /* Reset 'dpm_sw' IRQ for IRQ-signal (always 0 when read)                      */
	unsigned int reserved2  : BFW_NX51_dpm_sw_irq_reserved2;  /* reserved                                                                    */
} NX51_DPM_SW_IRQ_BIT_T;

typedef union {
	unsigned int          val;
	NX51_DPM_SW_IRQ_BIT_T bf;
} NX51_DPM_SW_IRQ_T;

/* --------------------------------------------------------------------- */
/* Register dpm_reserved_netx50_wgd_host_timeout */
/* => Address reserved for netx50 DPM_HOST_WDG_HOST_TIMEOUT. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_reserved_netx50_wgd_host_timeout 0x000000C0U
#define Adr_NX51_dpm_dpm_reserved_netx50_wgd_host_timeout 0x1018C0C0U
#define Adr_NX51_dpm_reserved_netx50_wgd_host_timeout     0x1018C0C0U

#define MSK_NX51_dpm_reserved_netx50_wgd_host_timeout_zero_ro 0xffffffffU
#define SRT_NX51_dpm_reserved_netx50_wgd_host_timeout_zero_ro 0

/* all used bits of 'NX51_dpm_reserved_netx50_wgd_host_timeout': */
#define MSK_USED_BITS_NX51_dpm_reserved_netx50_wgd_host_timeout 0xffffffffU

enum {
	BFW_NX51_dpm_reserved_netx50_wgd_host_timeout_zero_ro = 32  /* [31:0] */
};

typedef struct NX51_DPM_RESERVED_NETX50_WGD_HOST_TIMEOUT_BIT_Ttag {
	unsigned int zero_ro : BFW_NX51_dpm_reserved_netx50_wgd_host_timeout_zero_ro; /* reserved for netx50 DPM_HOST_WDG_HOST_TIMEOUT. */
} NX51_DPM_RESERVED_NETX50_WGD_HOST_TIMEOUT_BIT_T;

typedef union {
	unsigned int                                    val;
	NX51_DPM_RESERVED_NETX50_WGD_HOST_TIMEOUT_BIT_T bf;
} NX51_DPM_RESERVED_NETX50_WGD_HOST_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register dpm_reserved_netx50_wgd_host_trigger */
/* => Address reserved for netx50 DPM_HOST_WDG_HOST_TRIG. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_reserved_netx50_wgd_host_trigger 0x000000C4U
#define Adr_NX51_dpm_dpm_reserved_netx50_wgd_host_trigger 0x1018C0C4U
#define Adr_NX51_dpm_reserved_netx50_wgd_host_trigger     0x1018C0C4U

#define MSK_NX51_dpm_reserved_netx50_wgd_host_trigger_zero_ro 0xffffffffU
#define SRT_NX51_dpm_reserved_netx50_wgd_host_trigger_zero_ro 0

/* all used bits of 'NX51_dpm_reserved_netx50_wgd_host_trigger': */
#define MSK_USED_BITS_NX51_dpm_reserved_netx50_wgd_host_trigger 0xffffffffU

enum {
	BFW_NX51_dpm_reserved_netx50_wgd_host_trigger_zero_ro = 32  /* [31:0] */
};

typedef struct NX51_DPM_RESERVED_NETX50_WGD_HOST_TRIGGER_BIT_Ttag {
	unsigned int zero_ro : BFW_NX51_dpm_reserved_netx50_wgd_host_trigger_zero_ro; /* reserved for netx50 DPM_HOST_WDG_HOST_TRIG. */
} NX51_DPM_RESERVED_NETX50_WGD_HOST_TRIGGER_BIT_T;

typedef union {
	unsigned int                                    val;
	NX51_DPM_RESERVED_NETX50_WGD_HOST_TRIGGER_BIT_T bf;
} NX51_DPM_RESERVED_NETX50_WGD_HOST_TRIGGER_T;

/* --------------------------------------------------------------------- */
/* Register dpm_reserved_netx50_wgd_netx_timeout */
/* => Address reserved for netx50 DPM_HOST_WDG_ARM_TIMEOUT. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_reserved_netx50_wgd_netx_timeout 0x000000C8U
#define Adr_NX51_dpm_dpm_reserved_netx50_wgd_netx_timeout 0x1018C0C8U
#define Adr_NX51_dpm_reserved_netx50_wgd_netx_timeout     0x1018C0C8U

#define MSK_NX51_dpm_reserved_netx50_wgd_netx_timeout_zero_ro 0xffffffffU
#define SRT_NX51_dpm_reserved_netx50_wgd_netx_timeout_zero_ro 0

/* all used bits of 'NX51_dpm_reserved_netx50_wgd_netx_timeout': */
#define MSK_USED_BITS_NX51_dpm_reserved_netx50_wgd_netx_timeout 0xffffffffU

enum {
	BFW_NX51_dpm_reserved_netx50_wgd_netx_timeout_zero_ro = 32  /* [31:0] */
};

typedef struct NX51_DPM_RESERVED_NETX50_WGD_NETX_TIMEOUT_BIT_Ttag {
	unsigned int zero_ro : BFW_NX51_dpm_reserved_netx50_wgd_netx_timeout_zero_ro; /* reserved for netx50 DPM_HOST_WDG_ARM_TIMEOUT. */
} NX51_DPM_RESERVED_NETX50_WGD_NETX_TIMEOUT_BIT_T;

typedef union {
	unsigned int                                    val;
	NX51_DPM_RESERVED_NETX50_WGD_NETX_TIMEOUT_BIT_T bf;
} NX51_DPM_RESERVED_NETX50_WGD_NETX_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register dpm_sys_sta_bigend16 */
/* => DPM System Status Information Register in big endianess 16 data mapping. */
/*    Read-only, use dpm_sys_sta for programming. */
/*    This register can be used for firmware status information. */
/*    Reading this register data can be done from uninitialized DPM interface in the same way */
/*    as reading netx version (adr_dpm_netx_version_bigend16, adr_dpm_netx_version) by using dpm_sys_sta_bigend16 register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_sys_sta_bigend16 0x000000CCU
#define Adr_NX51_dpm_dpm_sys_sta_bigend16 0x1018C0CCU
#define Adr_NX51_dpm_sys_sta_bigend16     0x1018C0CCU

#define MSK_NX51_dpm_sys_sta_bigend16_NETX_STA_CODE_swap_ro 0x000000ffU
#define SRT_NX51_dpm_sys_sta_bigend16_NETX_STA_CODE_swap_ro 0
#define MSK_NX51_dpm_sys_sta_bigend16_RDY_ro                0x00000100U
#define SRT_NX51_dpm_sys_sta_bigend16_RDY_ro                8
#define MSK_NX51_dpm_sys_sta_bigend16_RUN_ro                0x00000200U
#define SRT_NX51_dpm_sys_sta_bigend16_RUN_ro                9
#define MSK_NX51_dpm_sys_sta_bigend16_NETX_STATE_swap_ro    0x00000c00U
#define SRT_NX51_dpm_sys_sta_bigend16_NETX_STATE_swap_ro    10
#define MSK_NX51_dpm_sys_sta_bigend16_HOST_STATE_swap_ro    0x0000f000U
#define SRT_NX51_dpm_sys_sta_bigend16_HOST_STATE_swap_ro    12

/* all used bits of 'NX51_dpm_sys_sta_bigend16': */
#define MSK_USED_BITS_NX51_dpm_sys_sta_bigend16 0x0000ffffU

enum {
	BFW_NX51_dpm_sys_sta_bigend16_NETX_STA_CODE_swap_ro = 8,  /* [7:0] */
	BFW_NX51_dpm_sys_sta_bigend16_RDY_ro                = 1,  /* [8] */
	BFW_NX51_dpm_sys_sta_bigend16_RUN_ro                = 1,  /* [9] */
	BFW_NX51_dpm_sys_sta_bigend16_NETX_STATE_swap_ro    = 2,  /* [11:10] */
	BFW_NX51_dpm_sys_sta_bigend16_HOST_STATE_swap_ro    = 4,  /* [15:12] */
	BFW_NX51_dpm_sys_sta_bigend16_reserved1             = 16  /* [31:16] */
};

typedef struct NX51_DPM_SYS_STA_BIGEND16_BIT_Ttag {
	unsigned int NETX_STA_CODE_swap_ro : BFW_NX51_dpm_sys_sta_bigend16_NETX_STA_CODE_swap_ro; /* Bit field for Hilscher firmware compatibility. */
	unsigned int RDY_ro                : BFW_NX51_dpm_sys_sta_bigend16_RDY_ro;                /* Output state of netX RDY LED IO.               */
	unsigned int RUN_ro                : BFW_NX51_dpm_sys_sta_bigend16_RUN_ro;                /* Output state of netX RUN LED IO.               */
	unsigned int NETX_STATE_swap_ro    : BFW_NX51_dpm_sys_sta_bigend16_NETX_STATE_swap_ro;    /* Bit field for Hilscher firmware compatibility. */
	unsigned int HOST_STATE_swap_ro    : BFW_NX51_dpm_sys_sta_bigend16_HOST_STATE_swap_ro;    /* Bit field for Hilscher firmware compatibility. */
	unsigned int reserved1             : BFW_NX51_dpm_sys_sta_bigend16_reserved1;             /* reserved                                       */
} NX51_DPM_SYS_STA_BIGEND16_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DPM_SYS_STA_BIGEND16_BIT_T bf;
} NX51_DPM_SYS_STA_BIGEND16_T;

/* --------------------------------------------------------------------- */
/* Register dpm_reserved_netx50_timer_ctrl */
/* => Address reserved for netx50 DPM_HOST_TMR_CTRL. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_reserved_netx50_timer_ctrl 0x000000D0U
#define Adr_NX51_dpm_dpm_reserved_netx50_timer_ctrl 0x1018C0D0U
#define Adr_NX51_dpm_reserved_netx50_timer_ctrl     0x1018C0D0U

#define MSK_NX51_dpm_reserved_netx50_timer_ctrl_zero_ro 0xffffffffU
#define SRT_NX51_dpm_reserved_netx50_timer_ctrl_zero_ro 0

/* all used bits of 'NX51_dpm_reserved_netx50_timer_ctrl': */
#define MSK_USED_BITS_NX51_dpm_reserved_netx50_timer_ctrl 0xffffffffU

enum {
	BFW_NX51_dpm_reserved_netx50_timer_ctrl_zero_ro = 32  /* [31:0] */
};

typedef struct NX51_DPM_RESERVED_NETX50_TIMER_CTRL_BIT_Ttag {
	unsigned int zero_ro : BFW_NX51_dpm_reserved_netx50_timer_ctrl_zero_ro; /* reserved for netx50 DPM_HOST_TMR_CTRL. */
} NX51_DPM_RESERVED_NETX50_TIMER_CTRL_BIT_T;

typedef union {
	unsigned int                              val;
	NX51_DPM_RESERVED_NETX50_TIMER_CTRL_BIT_T bf;
} NX51_DPM_RESERVED_NETX50_TIMER_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register dpm_reserved_netx50_timer_start_val */
/* => Address reserved for netx50 DPM_HOST_TMR_START_VAL. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_reserved_netx50_timer_start_val 0x000000D4U
#define Adr_NX51_dpm_dpm_reserved_netx50_timer_start_val 0x1018C0D4U
#define Adr_NX51_dpm_reserved_netx50_timer_start_val     0x1018C0D4U

#define MSK_NX51_dpm_reserved_netx50_timer_start_val_zero_ro 0xffffffffU
#define SRT_NX51_dpm_reserved_netx50_timer_start_val_zero_ro 0

/* all used bits of 'NX51_dpm_reserved_netx50_timer_start_val': */
#define MSK_USED_BITS_NX51_dpm_reserved_netx50_timer_start_val 0xffffffffU

enum {
	BFW_NX51_dpm_reserved_netx50_timer_start_val_zero_ro = 32  /* [31:0] */
};

typedef struct NX51_DPM_RESERVED_NETX50_TIMER_START_VAL_BIT_Ttag {
	unsigned int zero_ro : BFW_NX51_dpm_reserved_netx50_timer_start_val_zero_ro; /* reserved for netx50 DPM_HOST_TMR_START_VAL. */
} NX51_DPM_RESERVED_NETX50_TIMER_START_VAL_BIT_T;

typedef union {
	unsigned int                                   val;
	NX51_DPM_RESERVED_NETX50_TIMER_START_VAL_BIT_T bf;
} NX51_DPM_RESERVED_NETX50_TIMER_START_VAL_T;

/* --------------------------------------------------------------------- */
/* Register dpm_sys_sta */
/* => DPM System Status Information Register. */
/*    This register can be used for firmware status information. */
/*    Reading this register data can be done from uninitialized DPM interface in the same way */
/*    as reading netx version (adr_dpm_netx_version_bigend16, adr_dpm_netx_version) by using dpm_sys_sta_bigend16 register. */
/*    Note: This register is compatible to netx50 DPM_HOST_SYS_STAT register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_sys_sta  0x000000D8U
#define Adr_NX51_dpm_dpm_sys_sta  0x1018C0D8U
#define Adr_NX51_dpm_sys_sta      0x1018C0D8U
#define DFLT_VAL_NX51_dpm_sys_sta 0x00000000U

#define MSK_NX51_dpm_sys_sta_RDY_ro                   0x00000001U
#define SRT_NX51_dpm_sys_sta_RDY_ro                   0
#define DFLT_VAL_NX51_dpm_sys_sta_RDY_ro              0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sys_sta_RDY_ro           0x00000000U
#define MSK_NX51_dpm_sys_sta_RUN_ro                   0x00000002U
#define SRT_NX51_dpm_sys_sta_RUN_ro                   1
#define DFLT_VAL_NX51_dpm_sys_sta_RUN_ro              0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sys_sta_RUN_ro           0x00000000U
#define MSK_NX51_dpm_sys_sta_NETX_STATE_ro            0x0000000cU
#define SRT_NX51_dpm_sys_sta_NETX_STATE_ro            2
#define DFLT_VAL_NX51_dpm_sys_sta_NETX_STATE_ro       0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sys_sta_NETX_STATE_ro    0x00000000U
#define MSK_NX51_dpm_sys_sta_HOST_STATE               0x000000f0U
#define SRT_NX51_dpm_sys_sta_HOST_STATE               4
#define DFLT_VAL_NX51_dpm_sys_sta_HOST_STATE          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sys_sta_HOST_STATE       0x00000000U
#define MSK_NX51_dpm_sys_sta_NETX_STA_CODE_ro         0x0000ff00U
#define SRT_NX51_dpm_sys_sta_NETX_STA_CODE_ro         8
#define DFLT_VAL_NX51_dpm_sys_sta_NETX_STA_CODE_ro    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_sys_sta_NETX_STA_CODE_ro 0x00000000U

/* all used bits of 'NX51_dpm_sys_sta': */
#define MSK_USED_BITS_NX51_dpm_sys_sta 0x0000ffffU

enum {
	BFW_NX51_dpm_sys_sta_RDY_ro           = 1,  /* [0] */
	BFW_NX51_dpm_sys_sta_RUN_ro           = 1,  /* [1] */
	BFW_NX51_dpm_sys_sta_NETX_STATE_ro    = 2,  /* [3:2] */
	BFW_NX51_dpm_sys_sta_HOST_STATE       = 4,  /* [7:4] */
	BFW_NX51_dpm_sys_sta_NETX_STA_CODE_ro = 8,  /* [15:8] */
	BFW_NX51_dpm_sys_sta_reserved1        = 16  /* [31:16] */
};

typedef struct NX51_DPM_SYS_STA_BIT_Ttag {
	unsigned int RDY_ro           : BFW_NX51_dpm_sys_sta_RDY_ro;           /* Output state of netX RDY LED IO.                                                             */
	                                                                       /* Note: This bit field can be changed by rdy_run_cfg-register inside ASIC_CTRL address area.   */
	unsigned int RUN_ro           : BFW_NX51_dpm_sys_sta_RUN_ro;           /* Output state of netX RUN LED IO.                                                             */
	                                                                       /* Note: This bit field can be changed by rdy_run_cfg-register inside ASIC_CTRL address area.   */
	unsigned int NETX_STATE_ro    : BFW_NX51_dpm_sys_sta_NETX_STATE_ro;    /* Bit field for Hilscher firmware compatibility.                                               */
	                                                                       /* Note: This bit field can be changed by rdy_run_cfg-register inside ASIC_CTRL address area.   */
	unsigned int HOST_STATE       : BFW_NX51_dpm_sys_sta_HOST_STATE;       /* Bit field for Hilscher firmware compatibility.                                               */
	                                                                       /* Note: This bit field can be read also at rdy_run_cfg-register inside ASIC_CTRL address area. */
	unsigned int NETX_STA_CODE_ro : BFW_NX51_dpm_sys_sta_NETX_STA_CODE_ro; /* Bit field for Hilscher firmware compatibility (read only).                                   */
	                                                                       /* Note: This bit field can be changed by rdy_run_cfg-register inside ASIC_CTRL address area.   */
	unsigned int reserved1        : BFW_NX51_dpm_sys_sta_reserved1;        /* reserved                                                                                     */
} NX51_DPM_SYS_STA_BIT_T;

typedef union {
	unsigned int           val;
	NX51_DPM_SYS_STA_BIT_T bf;
} NX51_DPM_SYS_STA_T;

/* --------------------------------------------------------------------- */
/* Register dpm_reset_request */
/* => DPM Reset Request Register. */
/*    Note: This register is compatible to netx50 DPM_HOST_RESET_REQ register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_reset_request  0x000000DCU
#define Adr_NX51_dpm_dpm_reset_request  0x1018C0DCU
#define Adr_NX51_dpm_reset_request      0x1018C0DCU
#define DFLT_VAL_NX51_dpm_reset_request 0x00000000U

#define MSK_NX51_dpm_reset_request_reset_key         0x000000ffU
#define SRT_NX51_dpm_reset_request_reset_key         0
#define DFLT_VAL_NX51_dpm_reset_request_reset_key    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_reset_request_reset_key 0x00000000U

/* all used bits of 'NX51_dpm_reset_request': */
#define MSK_USED_BITS_NX51_dpm_reset_request 0x000000ffU

enum {
	BFW_NX51_dpm_reset_request_reset_key = 8,  /* [7:0] */
	BFW_NX51_dpm_reset_request_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_DPM_RESET_REQUEST_BIT_Ttag {
	unsigned int reset_key : BFW_NX51_dpm_reset_request_reset_key; /* Reset key sequence register.                                                              */
	                                                               /* A netx hardware reset is generated if the following sequence is written to this register: */
	                                                               /*   1st access:    write 0x00                                                               */
	                                                               /*   2nd access:    write 0x01                                                               */
	                                                               /*   3rd access:    write 0x03                                                               */
	                                                               /*   4th access:    write 0x07                                                               */
	                                                               /*   5th access:    write 0x0f                                                               */
	                                                               /*   6th access:    write 0x1f                                                               */
	                                                               /*   7th access:    write 0x3f                                                               */
	                                                               /*   8th access:    write 0x7f                                                               */
	                                                               /* Reading this register will provide the next write data. Hence it is also possible         */
	                                                               /* performing 8 times a read-write sequence to this register. However read could be omitted. */
	                                                               /* Note:                                                                                     */
	                                                               /*   The sequence must not interrupted by any other write access to any other DPM register.  */
	                                                               /*   Read access have no influence.                                                          */
	                                                               /* Note:                                                                                     */
	                                                               /*   For netx10 a 9th access (write 0xff) was necessary to performe a reset  This access     */
	                                                               /*   is not netx50 compatible and not required any longer since netx51.                      */
	unsigned int reserved1 : BFW_NX51_dpm_reset_request_reserved1; /* reserved                                                                                  */
} NX51_DPM_RESET_REQUEST_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_DPM_RESET_REQUEST_BIT_T bf;
} NX51_DPM_RESET_REQUEST_T;

/* --------------------------------------------------------------------- */
/* Register dpm_firmware_irq_raw */
/* => 1st netx50 compatible DPM Interrupt Status Register (related to 'dpm_firmware_irq_mask'-register). */
/*    Writing a '1' to an IRQ flag will clear the Interrupt. This is always done even if related bit inside */
/*    'dpm_firmware_irq_mask'-register is not set (this is compatible to netx50). */
/*    Important: There are two completely independent sets of IRQ registers: */
/*       IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers). */
/*       IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). */
/*       Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs */
/*       can be found in both sets (e.g. com0). */
/*    Note: This register is compatible to netx50 DPM_HOST_INT_STAT0 register, however some unused */
/*       IRQs have been removed. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_firmware_irq_raw  0x000000E0U
#define Adr_NX51_dpm_dpm_firmware_irq_raw  0x1018C0E0U
#define Adr_NX51_dpm_firmware_irq_raw      0x1018C0E0U
#define DFLT_VAL_NX51_dpm_firmware_irq_raw 0x00000000U

#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT0               0x00000001U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT0               0
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT0       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT1               0x00000002U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT1               1
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT1       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT2               0x00000004U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT2               2
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT2          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT2       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT3               0x00000008U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT3               3
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT3          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT3       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT4               0x00000010U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT4               4
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT4          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT4       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT5               0x00000020U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT5               5
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT5          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT5       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT6               0x00000040U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT6               6
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT6          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT6       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT7               0x00000080U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT7               7
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT7          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT7       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT8               0x00000100U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT8               8
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT8          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT8       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT9               0x00000200U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT9               9
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT9          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT9       0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT10              0x00000400U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT10              10
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT10         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT10      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT11              0x00000800U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT11              11
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT11         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT11      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT12              0x00001000U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT12              12
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT12         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT12      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT13              0x00002000U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT13              13
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT13         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT13      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT14              0x00004000U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT14              14
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT14         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT14      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_HS_EVENT15              0x00008000U
#define SRT_NX51_dpm_firmware_irq_raw_HS_EVENT15              15
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT15         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_HS_EVENT15      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_IRQ_VECTOR              0x00ff0000U
#define SRT_NX51_dpm_firmware_irq_raw_IRQ_VECTOR              16
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_IRQ_VECTOR         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_IRQ_VECTOR      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_res_TMR_ro              0x02000000U
#define SRT_NX51_dpm_firmware_irq_raw_res_TMR_ro              25
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_res_TMR_ro         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_res_TMR_ro      0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_SYS_STA                 0x04000000U
#define SRT_NX51_dpm_firmware_irq_raw_SYS_STA                 26
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_SYS_STA            0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_SYS_STA         0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_RDY_TIMEOUT             0x10000000U
#define SRT_NX51_dpm_firmware_irq_raw_RDY_TIMEOUT             28
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_RDY_TIMEOUT        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_RDY_TIMEOUT     0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_res_WDG_NETX_ro         0x20000000U
#define SRT_NX51_dpm_firmware_irq_raw_res_WDG_NETX_ro         29
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_res_WDG_NETX_ro    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_res_WDG_NETX_ro 0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_res_MEM_LCK_ro          0x40000000U
#define SRT_NX51_dpm_firmware_irq_raw_res_MEM_LCK_ro          30
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_res_MEM_LCK_ro     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_res_MEM_LCK_ro  0x00000000U
#define MSK_NX51_dpm_firmware_irq_raw_INT_REQ                 0x80000000U
#define SRT_NX51_dpm_firmware_irq_raw_INT_REQ                 31
#define DFLT_VAL_NX51_dpm_firmware_irq_raw_INT_REQ            0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_raw_INT_REQ         0x00000000U

/* all used bits of 'NX51_dpm_firmware_irq_raw': */
#define MSK_USED_BITS_NX51_dpm_firmware_irq_raw 0xf6ffffffU

enum {
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT0       = 1, /* [0] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT1       = 1, /* [1] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT2       = 1, /* [2] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT3       = 1, /* [3] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT4       = 1, /* [4] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT5       = 1, /* [5] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT6       = 1, /* [6] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT7       = 1, /* [7] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT8       = 1, /* [8] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT9       = 1, /* [9] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT10      = 1, /* [10] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT11      = 1, /* [11] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT12      = 1, /* [12] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT13      = 1, /* [13] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT14      = 1, /* [14] */
	BFW_NX51_dpm_firmware_irq_raw_HS_EVENT15      = 1, /* [15] */
	BFW_NX51_dpm_firmware_irq_raw_IRQ_VECTOR      = 8, /* [23:16] */
	BFW_NX51_dpm_firmware_irq_raw_reserved1       = 1, /* [24] */
	BFW_NX51_dpm_firmware_irq_raw_res_TMR_ro      = 1, /* [25] */
	BFW_NX51_dpm_firmware_irq_raw_SYS_STA         = 1, /* [26] */
	BFW_NX51_dpm_firmware_irq_raw_reserved2       = 1, /* [27] */
	BFW_NX51_dpm_firmware_irq_raw_RDY_TIMEOUT     = 1, /* [28] */
	BFW_NX51_dpm_firmware_irq_raw_res_WDG_NETX_ro = 1, /* [29] */
	BFW_NX51_dpm_firmware_irq_raw_res_MEM_LCK_ro  = 1, /* [30] */
	BFW_NX51_dpm_firmware_irq_raw_INT_REQ         = 1  /* [31] */
};

typedef struct NX51_DPM_FIRMWARE_IRQ_RAW_BIT_Ttag {
	unsigned int HS_EVENT0       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT0;       /* Handshake Event 0  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT1       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT1;       /* Handshake Event 1  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT2       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT2;       /* Handshake Event 2  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT3       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT3;       /* Handshake Event 3  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT4       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT4;       /* Handshake Event 4  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT5       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT5;       /* Handshake Event 5  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT6       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT6;       /* Handshake Event 6  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT7       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT7;       /* Handshake Event 7  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT8       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT8;       /* Handshake Event 8  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT9       : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT9;       /* Handshake Event 9  IRQ Enable flag.                                                              */
	unsigned int HS_EVENT10      : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT10;      /* Handshake Event 10 IRQ Enable flag.                                                              */
	unsigned int HS_EVENT11      : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT11;      /* Handshake Event 11 IRQ Enable flag.                                                              */
	unsigned int HS_EVENT12      : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT12;      /* Handshake Event 12 IRQ Enable flag.                                                              */
	unsigned int HS_EVENT13      : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT13;      /* Handshake Event 13 IRQ Enable flag.                                                              */
	unsigned int HS_EVENT14      : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT14;      /* Handshake Event 14 IRQ Enable flag.                                                              */
	unsigned int HS_EVENT15      : BFW_NX51_dpm_firmware_irq_raw_HS_EVENT15;      /* Handshake Event 15 IRQ Enable flag.                                                              */
	unsigned int IRQ_VECTOR      : BFW_NX51_dpm_firmware_irq_raw_IRQ_VECTOR;      /* Interrupt Vector according to status flags generated by enabled IRQ sources.                     */
	                                                                              /* {     |                                                                                          */
	                                                                              /*  Code   IRQ status                                                                               */
	                                                                              /*  0x00   No IRQ.                                                                                  */
	                                                                              /*  ----   -------                                                                                  */
	                                                                              /*  0x07   trigger_lt (related to DPM_HOST_INT_STA2.trigger_lt).                                    */
	                                                                              /*  0x0a   sync1 (related to DPM_HOST_INT_STA2.sync1)			.                                           */
	                                                                              /*  0x0b   sync0 (related to DPM_HOST_INT_STA2.sync0)			.                                           */
	                                                                              /*  0x0e   com1 (related to DPM_HOST_INT_STA2.com1)			.                                             */
	                                                                              /*  0x0f   com0 (related to DPM_HOST_INT_STA2.com0)			.                                             */
	                                                                              /*  ----   -------                                                                                  */
	                                                                              /*  0x10   Handshake Cell 0 IRQ.                                                                    */
	                                                                              /*  0x11   Handshake Cell 1 IRQ.                                                                    */
	                                                                              /*  0x12   Handshake Cell 2 IRQ.                                                                    */
	                                                                              /*  0x13   Handshake Cell 3 IRQ.                                                                    */
	                                                                              /*  0x14   Handshake Cell 4 IRQ.                                                                    */
	                                                                              /*  0x15   Handshake Cell 5 IRQ.                                                                    */
	                                                                              /*  0x16   Handshake Cell 6 IRQ.                                                                    */
	                                                                              /*  0x17   Handshake Cell 7 IRQ.                                                                    */
	                                                                              /*  0x18   Handshake Cell 8 IRQ.                                                                    */
	                                                                              /*  0x19   Handshake Cell 9 IRQ.                                                                    */
	                                                                              /*  0x1a   Handshake Cell 10 IRQ.                                                                   */
	                                                                              /*  0x1b   Handshake Cell 11 IRQ.                                                                   */
	                                                                              /*  0x1c   Handshake Cell 12 IRQ.                                                                   */
	                                                                              /*  0x1d   Handshake Cell 13 IRQ.                                                                   */
	                                                                              /*  0x1e   Handshake Cell 14 IRQ.                                                                   */
	                                                                              /*  0x1f   Handshake Cell 15 IRQ.                                                                   */
	                                                                              /*  ----   -------                                                                                  */
	                                                                              /*  0x67   RDY_TIMEOUT IRQ                                                                          */
	                                                                              /*  0x70   SYS_STA IRQ                                                                              */
	                                                                              /*  Other  values are reserved.}                                                                    */
	                                                                              /* Note:                                                                                            */
	                                                                              /*    The current IRQ state in VECTOR depends only on the single IRQ enable bits. It                */
	                                                                              /*    does not depend on global IRQ enable INT_EN. VECTOR shows always the highest priority enabled */
	                                                                              /*    flagged IRQ even is INT_EN is '0'.                                                            */
	unsigned int reserved1       : BFW_NX51_dpm_firmware_irq_raw_reserved1;       /* reserved                                                                                         */
	unsigned int res_TMR_ro      : BFW_NX51_dpm_firmware_irq_raw_res_TMR_ro;      /* reserved for Timer IRQ flag (not available in this netX version).                                */
	unsigned int SYS_STA         : BFW_NX51_dpm_firmware_irq_raw_SYS_STA;         /* System Status Change IRQ flag.                                                                   */
	unsigned int reserved2       : BFW_NX51_dpm_firmware_irq_raw_reserved2;       /* reserved                                                                                         */
	unsigned int RDY_TIMEOUT     : BFW_NX51_dpm_firmware_irq_raw_RDY_TIMEOUT;     /* DPM_RDY timeout error was detected.                                                              */
	                                                                              /* Note:                                                                                            */
	                                                                              /*    This flag is not affected by 'dpm_status_err' registers.                                      */
	unsigned int res_WDG_NETX_ro : BFW_NX51_dpm_firmware_irq_raw_res_WDG_NETX_ro; /* reserved for netX supervision Watchdog Timeout IRQ flag (not available in this netX version).    */
	unsigned int res_MEM_LCK_ro  : BFW_NX51_dpm_firmware_irq_raw_res_MEM_LCK_ro;  /* reserved for Memory Lock IRQ flag (not available in this netX version).                          */
	unsigned int INT_REQ         : BFW_NX51_dpm_firmware_irq_raw_INT_REQ;         /* Interrupt Request for IRQs handled in this register.                                             */
	                                                                              /* 0: No Interrupts to host requested by IRQ sources handled in this register.                      */
	                                                                              /* 1: IRQ sources handled in this register request a host IRQ.                                      */
	                                                                              /* Note: This bit is masked by INT_EN-bit in dpm_firmware_irq_mask register.                        */
	                                                                              /*    For propagation of INT_REQ to host, ARM or xPIC, INT_EN-bit must be set and firmware IRQ      */
	                                                                              /*    must be activated in related dpm_irq_* register.                                              */
} NX51_DPM_FIRMWARE_IRQ_RAW_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DPM_FIRMWARE_IRQ_RAW_BIT_T bf;
} NX51_DPM_FIRMWARE_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register dpm_firmware_irq_raw2 */
/* => 2nd netx50 compatible DPM Interrupt Status Register (related to 'dpm_firmware_irq_mask2'-register). */
/*    All IRQs from this register are also part of 'DPM_HOST_INT_STAT.IRQ_VECTOR' bit-field. */
/*    Important: This is a read-only status register. IRQs can not be cleared here: In contrast to */
/*       'dpm_firmware_irq_raw'/'STAT0'-register writing '1's will have no effect. IRQs are straight forwarded */
/*       from IRQ generating units (e.g. 'trigger_lt'-IRQ from netX trigger-sample-unit). */
/*    Important: There are two completely independent sets of IRQ registers: */
/*       IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers). */
/*       IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). */
/*       Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs */
/*       can be found in both sets (e.g. com0). */
/*    Note: This register is compatible to netx50 DPM_HOST_INT_STAT2 register, however some unused */
/*       IRQs have been removed. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_firmware_irq_raw2 0x000000E8U
#define Adr_NX51_dpm_dpm_firmware_irq_raw2 0x1018C0E8U
#define Adr_NX51_dpm_firmware_irq_raw2     0x1018C0E8U

#define MSK_NX51_dpm_firmware_irq_raw2_com0       0x00000001U
#define SRT_NX51_dpm_firmware_irq_raw2_com0       0
#define MSK_NX51_dpm_firmware_irq_raw2_com1       0x00000002U
#define SRT_NX51_dpm_firmware_irq_raw2_com1       1
#define MSK_NX51_dpm_firmware_irq_raw2_msync0     0x00000010U
#define SRT_NX51_dpm_firmware_irq_raw2_msync0     4
#define MSK_NX51_dpm_firmware_irq_raw2_msync1     0x00000020U
#define SRT_NX51_dpm_firmware_irq_raw2_msync1     5
#define MSK_NX51_dpm_firmware_irq_raw2_trigger_lt 0x00000100U
#define SRT_NX51_dpm_firmware_irq_raw2_trigger_lt 8

/* all used bits of 'NX51_dpm_firmware_irq_raw2': */
#define MSK_USED_BITS_NX51_dpm_firmware_irq_raw2 0x00000133U

enum {
	BFW_NX51_dpm_firmware_irq_raw2_com0       = 1,  /* [0] */
	BFW_NX51_dpm_firmware_irq_raw2_com1       = 1,  /* [1] */
	BFW_NX51_dpm_firmware_irq_raw2_reserved1  = 2,  /* [3:2] */
	BFW_NX51_dpm_firmware_irq_raw2_msync0     = 1,  /* [4] */
	BFW_NX51_dpm_firmware_irq_raw2_msync1     = 1,  /* [5] */
	BFW_NX51_dpm_firmware_irq_raw2_reserved2  = 2,  /* [7:6] */
	BFW_NX51_dpm_firmware_irq_raw2_trigger_lt = 1,  /* [8] */
	BFW_NX51_dpm_firmware_irq_raw2_reserved3  = 23  /* [31:9] */
};

typedef struct NX51_DPM_FIRMWARE_IRQ_RAW2_BIT_Ttag {
	unsigned int com0       : BFW_NX51_dpm_firmware_irq_raw2_com0;       /* communication channel 0 (= |xpec0_irq[11:0]) interrupt.           */
	unsigned int com1       : BFW_NX51_dpm_firmware_irq_raw2_com1;       /* communication channel 1 (= |xpec1_irq[11:0]) interrupt.           */
	unsigned int reserved1  : BFW_NX51_dpm_firmware_irq_raw2_reserved1;  /* reserved                                                          */
	unsigned int msync0     : BFW_NX51_dpm_firmware_irq_raw2_msync0;     /* motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt. */
	unsigned int msync1     : BFW_NX51_dpm_firmware_irq_raw2_msync1;     /* motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt. */
	unsigned int reserved2  : BFW_NX51_dpm_firmware_irq_raw2_reserved2;  /* reserved                                                          */
	unsigned int trigger_lt : BFW_NX51_dpm_firmware_irq_raw2_trigger_lt; /* trigger-Latch interrupt.                                          */
	unsigned int reserved3  : BFW_NX51_dpm_firmware_irq_raw2_reserved3;  /* reserved                                                          */
} NX51_DPM_FIRMWARE_IRQ_RAW2_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_DPM_FIRMWARE_IRQ_RAW2_BIT_T bf;
} NX51_DPM_FIRMWARE_IRQ_RAW2_T;

/* --------------------------------------------------------------------- */
/* Register dpm_firmware_irq_mask */
/* => DPM Handshake Interrupt Enable Register. */
/*    Only netx50 compatible 'dpm_firmware_irq' registers are related to settings of this register. */
/*    Note: This register is compatible to netx50 DPM_HOST_INT_EN0 register, however some unused */
/*       IRQs have been removed. */
/*    Note: HS_EVENT-bits are not read-only. This is netX50 compliant. */
/*       Recent netX50 Documentation marks HS_EVENT-bits as read-only. This is an dokumentation error. */
/*       For netX50 compatibility, these bits can also be controlled from netX-side in HANDSHAKE_CTRL address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_firmware_irq_mask  0x000000F0U
#define Adr_NX51_dpm_dpm_firmware_irq_mask  0x1018C0F0U
#define Adr_NX51_dpm_firmware_irq_mask      0x1018C0F0U
#define DFLT_VAL_NX51_dpm_firmware_irq_mask 0x00000000U

#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT0               0x00000001U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT0               0
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT0       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT1               0x00000002U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT1               1
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT1       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT2               0x00000004U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT2               2
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT2          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT2       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT3               0x00000008U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT3               3
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT3          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT3       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT4               0x00000010U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT4               4
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT4          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT4       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT5               0x00000020U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT5               5
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT5          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT5       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT6               0x00000040U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT6               6
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT6          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT6       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT7               0x00000080U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT7               7
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT7          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT7       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT8               0x00000100U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT8               8
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT8          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT8       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT9               0x00000200U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT9               9
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT9          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT9       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT10              0x00000400U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT10              10
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT10         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT10      0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT11              0x00000800U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT11              11
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT11         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT11      0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT12              0x00001000U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT12              12
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT12         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT12      0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT13              0x00002000U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT13              13
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT13         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT13      0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT14              0x00004000U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT14              14
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT14         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT14      0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_HS_EVENT15              0x00008000U
#define SRT_NX51_dpm_firmware_irq_mask_HS_EVENT15              15
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT15         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_HS_EVENT15      0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_res_TMR_ro              0x02000000U
#define SRT_NX51_dpm_firmware_irq_mask_res_TMR_ro              25
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_res_TMR_ro         0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_res_TMR_ro      0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_SYS_STA                 0x04000000U
#define SRT_NX51_dpm_firmware_irq_mask_SYS_STA                 26
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_SYS_STA            0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_SYS_STA         0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_RDY_TIMEOUT             0x10000000U
#define SRT_NX51_dpm_firmware_irq_mask_RDY_TIMEOUT             28
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_RDY_TIMEOUT        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_RDY_TIMEOUT     0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_res_WDG_NETX_ro         0x20000000U
#define SRT_NX51_dpm_firmware_irq_mask_res_WDG_NETX_ro         29
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_res_WDG_NETX_ro    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_res_WDG_NETX_ro 0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_res_MEM_LCK_ro          0x40000000U
#define SRT_NX51_dpm_firmware_irq_mask_res_MEM_LCK_ro          30
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_res_MEM_LCK_ro     0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_res_MEM_LCK_ro  0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask_INT_EN                  0x80000000U
#define SRT_NX51_dpm_firmware_irq_mask_INT_EN                  31
#define DFLT_VAL_NX51_dpm_firmware_irq_mask_INT_EN             0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask_INT_EN          0x00000000U

/* all used bits of 'NX51_dpm_firmware_irq_mask': */
#define MSK_USED_BITS_NX51_dpm_firmware_irq_mask 0xf600ffffU

enum {
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT0       = 1, /* [0] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT1       = 1, /* [1] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT2       = 1, /* [2] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT3       = 1, /* [3] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT4       = 1, /* [4] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT5       = 1, /* [5] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT6       = 1, /* [6] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT7       = 1, /* [7] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT8       = 1, /* [8] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT9       = 1, /* [9] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT10      = 1, /* [10] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT11      = 1, /* [11] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT12      = 1, /* [12] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT13      = 1, /* [13] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT14      = 1, /* [14] */
	BFW_NX51_dpm_firmware_irq_mask_HS_EVENT15      = 1, /* [15] */
	BFW_NX51_dpm_firmware_irq_mask_reserved1       = 9, /* [24:16] */
	BFW_NX51_dpm_firmware_irq_mask_res_TMR_ro      = 1, /* [25] */
	BFW_NX51_dpm_firmware_irq_mask_SYS_STA         = 1, /* [26] */
	BFW_NX51_dpm_firmware_irq_mask_reserved2       = 1, /* [27] */
	BFW_NX51_dpm_firmware_irq_mask_RDY_TIMEOUT     = 1, /* [28] */
	BFW_NX51_dpm_firmware_irq_mask_res_WDG_NETX_ro = 1, /* [29] */
	BFW_NX51_dpm_firmware_irq_mask_res_MEM_LCK_ro  = 1, /* [30] */
	BFW_NX51_dpm_firmware_irq_mask_INT_EN          = 1  /* [31] */
};

typedef struct NX51_DPM_FIRMWARE_IRQ_MASK_BIT_Ttag {
	unsigned int HS_EVENT0       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT0;       /* Handshake Event 0  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT1       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT1;       /* Handshake Event 1  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT2       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT2;       /* Handshake Event 2  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT3       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT3;       /* Handshake Event 3  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT4       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT4;       /* Handshake Event 4  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT5       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT5;       /* Handshake Event 5  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT6       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT6;       /* Handshake Event 6  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT7       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT7;       /* Handshake Event 7  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT8       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT8;       /* Handshake Event 8  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT9       : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT9;       /* Handshake Event 9  IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT10      : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT10;      /* Handshake Event 10 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT11      : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT11;      /* Handshake Event 11 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT12      : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT12;      /* Handshake Event 12 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT13      : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT13;      /* Handshake Event 13 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT14      : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT14;      /* Handshake Event 14 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int HS_EVENT15      : BFW_NX51_dpm_firmware_irq_mask_HS_EVENT15;      /* Handshake Event 15 IRQ Enable (also netX-controllable by HANDSHAKE_CTRL, netX50 comp.).       */
	unsigned int reserved1       : BFW_NX51_dpm_firmware_irq_mask_reserved1;       /* reserved                                                                                      */
	unsigned int res_TMR_ro      : BFW_NX51_dpm_firmware_irq_mask_res_TMR_ro;      /* reserved for Timer IRQ (not available in this netX version).                                  */
	unsigned int SYS_STA         : BFW_NX51_dpm_firmware_irq_mask_SYS_STA;         /* System Status Change IRQ Enable.                                                              */
	unsigned int reserved2       : BFW_NX51_dpm_firmware_irq_mask_reserved2;       /* reserved                                                                                      */
	unsigned int RDY_TIMEOUT     : BFW_NX51_dpm_firmware_irq_mask_RDY_TIMEOUT;     /* Enable for 'dpm_firmware_irq_raw.RDY_TIMEOUT' bit.                                            */
	unsigned int res_WDG_NETX_ro : BFW_NX51_dpm_firmware_irq_mask_res_WDG_NETX_ro; /* reserved for netX supervision Watchdog Timeout IRQ (not available in this netX version).      */
	unsigned int res_MEM_LCK_ro  : BFW_NX51_dpm_firmware_irq_mask_res_MEM_LCK_ro;  /* reserved for Memory Lock IRQ (not available in this netX version).                            */
	unsigned int INT_EN          : BFW_NX51_dpm_firmware_irq_mask_INT_EN;          /* Interrupt Enable for IRQs handled in this register.                                           */
	                                                                               /* Only if this bit is set, global firmware IRQ will be asserted to host CPU, ARM or xPIC        */
	                                                                               /* by dpm_irq_* registers.                                                                       */
	                                                                               /* 0: No Interrupts to host, ARM or xPIC are generated by IRQ sources handled in this register.  */
	                                                                               /* 1: Enabled IRQ sources handled in this register generate a host, ARM or xPIC IRQ if asserted. */
	                                                                               /* Note: Enable bits for single IRQ events are not affected if this bit is set or reset.         */
} NX51_DPM_FIRMWARE_IRQ_MASK_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_DPM_FIRMWARE_IRQ_MASK_BIT_T bf;
} NX51_DPM_FIRMWARE_IRQ_MASK_T;

/* --------------------------------------------------------------------- */
/* Register dpm_netx_version_bigend16 */
/* => DPM netX Version Register in big endianess 16 data mapping. */
/*    This registers content is mirrored form asic_ctrl register area and can be set during netX booting phase by netX firmware. */
/*    This register is not valid if unlocked bit is not set in dpm_status register. */
/*    Together with dpm_netx_version register, full 32 bit version can be read by any host device, even if DPM interface is not initialized yet. */
/*    Bytes byte1 and byte3 can be always read here even if DPM is uninitialized (8 bit default from dpm_cfg0x0 after power on) and */
/*    host device has 8, 16 or 32 bit data width. */
/*    {                 |                           |                           | */
/*                        8 bit DPM                   16 bit DPM                  32 bit DPM */
/*      byte 0 (D7:0)     byte read this address +1   adr_dpm_netx_version        adr_dpm_netx_version */
/*      byte 1 (D15:8)    byte read this address +0   byte read this address      DWord read this address */
/*      byte 2 (D23:16)   byte read this address +3   adr_dpm_netx_version        adr_dpm_netx_version */
/*      byte 3 (D31:24)   byte read this address +2   byte read this address +2   byte read this address +0 } */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_netx_version_bigend16 0x000000F4U
#define Adr_NX51_dpm_dpm_netx_version_bigend16 0x1018C0F4U
#define Adr_NX51_dpm_netx_version_bigend16     0x1018C0F4U

#define MSK_NX51_dpm_netx_version_bigend16_netx_version_byte1_swap 0x000000ffU
#define SRT_NX51_dpm_netx_version_bigend16_netx_version_byte1_swap 0
#define MSK_NX51_dpm_netx_version_bigend16_netx_version_byte0_swap 0x0000ff00U
#define SRT_NX51_dpm_netx_version_bigend16_netx_version_byte0_swap 8
#define MSK_NX51_dpm_netx_version_bigend16_netx_version_byte3_swap 0x00ff0000U
#define SRT_NX51_dpm_netx_version_bigend16_netx_version_byte3_swap 16
#define MSK_NX51_dpm_netx_version_bigend16_netx_version_byte2_swap 0xff000000U
#define SRT_NX51_dpm_netx_version_bigend16_netx_version_byte2_swap 24

/* all used bits of 'NX51_dpm_netx_version_bigend16': */
#define MSK_USED_BITS_NX51_dpm_netx_version_bigend16 0xffffffffU

enum {
	BFW_NX51_dpm_netx_version_bigend16_netx_version_byte1_swap = 8, /* [7:0] */
	BFW_NX51_dpm_netx_version_bigend16_netx_version_byte0_swap = 8, /* [15:8] */
	BFW_NX51_dpm_netx_version_bigend16_netx_version_byte3_swap = 8, /* [23:16] */
	BFW_NX51_dpm_netx_version_bigend16_netx_version_byte2_swap = 8  /* [31:24] */
};

typedef struct NX51_DPM_NETX_VERSION_BIGEND16_BIT_Ttag {
	unsigned int netx_version_byte1_swap : BFW_NX51_dpm_netx_version_bigend16_netx_version_byte1_swap; /* netX version bits 16 to 8.  */
	unsigned int netx_version_byte0_swap : BFW_NX51_dpm_netx_version_bigend16_netx_version_byte0_swap; /* netX version bits 8 to 0.   */
	unsigned int netx_version_byte3_swap : BFW_NX51_dpm_netx_version_bigend16_netx_version_byte3_swap; /* netX version bits 31 to 24. */
	unsigned int netx_version_byte2_swap : BFW_NX51_dpm_netx_version_bigend16_netx_version_byte2_swap; /* netX version bits 24 to 16. */
} NX51_DPM_NETX_VERSION_BIGEND16_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_DPM_NETX_VERSION_BIGEND16_BIT_T bf;
} NX51_DPM_NETX_VERSION_BIGEND16_T;

/* --------------------------------------------------------------------- */
/* Register dpm_firmware_irq_mask2 */
/* => netX50 compatible Interrupt Enable Register No.2. */
/*    Only netx50 compatible 'dpm_firmware_irq' registers are related to settings of this register. */
/*    Important: There are two completely independent sets of IRQ registers: */
/*       IRQ register-set 1: 'dpm_irq_raw' (and related registers e.g. 'dpm_irq_irq_*' registers). */
/*       IRQ register-set 2: 'dpm_firmware_irq_* registers' (netx50 compatible register set: DPM_HOST_INT_EN0,2 DPM_HOST_INT_STA0,2). */
/*       Programming (masking or clearing IRQs) of one register-set has no impact to the other register-set even if some IRQs */
/*       can be found in both sets (e.g. com0). */
/*    Note: This register is compatible to netx50 DPM_HOST_INT_EN2 register, however some unused */
/*       IRQs have been removed. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_firmware_irq_mask2  0x000000F8U
#define Adr_NX51_dpm_dpm_firmware_irq_mask2  0x1018C0F8U
#define Adr_NX51_dpm_firmware_irq_mask2      0x1018C0F8U
#define DFLT_VAL_NX51_dpm_firmware_irq_mask2 0x00000000U

#define MSK_NX51_dpm_firmware_irq_mask2_com0               0x00000001U
#define SRT_NX51_dpm_firmware_irq_mask2_com0               0
#define DFLT_VAL_NX51_dpm_firmware_irq_mask2_com0          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask2_com0       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask2_com1               0x00000002U
#define SRT_NX51_dpm_firmware_irq_mask2_com1               1
#define DFLT_VAL_NX51_dpm_firmware_irq_mask2_com1          0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask2_com1       0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask2_msync0             0x00000010U
#define SRT_NX51_dpm_firmware_irq_mask2_msync0             4
#define DFLT_VAL_NX51_dpm_firmware_irq_mask2_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask2_msync0     0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask2_msync1             0x00000020U
#define SRT_NX51_dpm_firmware_irq_mask2_msync1             5
#define DFLT_VAL_NX51_dpm_firmware_irq_mask2_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask2_msync1     0x00000000U
#define MSK_NX51_dpm_firmware_irq_mask2_trigger_lt         0x00000100U
#define SRT_NX51_dpm_firmware_irq_mask2_trigger_lt         8
#define DFLT_VAL_NX51_dpm_firmware_irq_mask2_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_dpm_firmware_irq_mask2_trigger_lt 0x00000000U

/* all used bits of 'NX51_dpm_firmware_irq_mask2': */
#define MSK_USED_BITS_NX51_dpm_firmware_irq_mask2 0x00000133U

enum {
	BFW_NX51_dpm_firmware_irq_mask2_com0       = 1,  /* [0] */
	BFW_NX51_dpm_firmware_irq_mask2_com1       = 1,  /* [1] */
	BFW_NX51_dpm_firmware_irq_mask2_reserved1  = 2,  /* [3:2] */
	BFW_NX51_dpm_firmware_irq_mask2_msync0     = 1,  /* [4] */
	BFW_NX51_dpm_firmware_irq_mask2_msync1     = 1,  /* [5] */
	BFW_NX51_dpm_firmware_irq_mask2_reserved2  = 2,  /* [7:6] */
	BFW_NX51_dpm_firmware_irq_mask2_trigger_lt = 1,  /* [8] */
	BFW_NX51_dpm_firmware_irq_mask2_reserved3  = 23  /* [31:9] */
};

typedef struct NX51_DPM_FIRMWARE_IRQ_MASK2_BIT_Ttag {
	unsigned int com0       : BFW_NX51_dpm_firmware_irq_mask2_com0;       /* Enable of communication channel 0 (= |xpec0_irq[11:0]) interrupt for 'dpm_firmware_irq_raw' registers.           */
	unsigned int com1       : BFW_NX51_dpm_firmware_irq_mask2_com1;       /* Enable of communication channel 1 (= |xpec1_irq[11:0]) interrupt for 'dpm_firmware_irq_raw' registers.           */
	unsigned int reserved1  : BFW_NX51_dpm_firmware_irq_mask2_reserved1;  /* reserved                                                                                                         */
	unsigned int msync0     : BFW_NX51_dpm_firmware_irq_mask2_msync0;     /* Enable of motion synchronization channel 0 (= |xpec0_irq[15:12]) interrupt for 'dpm_firmware_irq_raw' registers. */
	unsigned int msync1     : BFW_NX51_dpm_firmware_irq_mask2_msync1;     /* Enable of motion synchronization channel 1 (= |xpec1_irq[15:12]) interrupt for 'dpm_firmware_irq_raw' registers. */
	unsigned int reserved2  : BFW_NX51_dpm_firmware_irq_mask2_reserved2;  /* reserved                                                                                                         */
	unsigned int trigger_lt : BFW_NX51_dpm_firmware_irq_mask2_trigger_lt; /* Enable of trigger-Latch interrupt for 'dpm_firmware_irq_raw' registers.                                          */
	unsigned int reserved3  : BFW_NX51_dpm_firmware_irq_mask2_reserved3;  /* reserved                                                                                                         */
} NX51_DPM_FIRMWARE_IRQ_MASK2_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_DPM_FIRMWARE_IRQ_MASK2_BIT_T bf;
} NX51_DPM_FIRMWARE_IRQ_MASK2_T;

/* --------------------------------------------------------------------- */
/* Register dpm_netx_version */
/* => DPM netX Version Register. */
/*    This register is mirrored form asic_ctrl register area and can be set during netX booting phase by netX firmware. */
/*    This register is not valid if unlocked bit is not set in dpm_status register. */
/*    Together with dpm_netx_version register, full 32 bit version can be read by any host device, even if DPM interface is not initialized yet. */
/*    Bytes byte0 and byte2 can be always read here even if DPM is uninitialized (8 bit default from dpm_cfg0x0 after power on) and */
/*    host device has 8, 16 or 32 bit data width. */
/*    {                 |                           |                               | */
/*                        8 bit DPM                   16 bit DPM                     32 bit DPM */
/*      byte 0 (D7:0)     byte read this address +0   byte read this address          DWord read this address */
/*      byte 1 (D15:8)    byte read this address +1   adr_dpm_netx_version_bigend16   adr_dpm_netx_version_bigend16 */
/*      byte 2 (D23:16)   byte read this address +2   byte read this address +2       byte read this address +0 */
/*      byte 3 (D31:24)   byte read this address +3   adr_dpm_netx_version_bigend16   adr_dpm_netx_version_bigend16 } */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dpm_netx_version 0x000000FCU
#define Adr_NX51_dpm_dpm_netx_version 0x1018C0FCU
#define Adr_NX51_dpm_netx_version     0x1018C0FCU

#define MSK_NX51_dpm_netx_version_netx_version_byte0 0x000000ffU
#define SRT_NX51_dpm_netx_version_netx_version_byte0 0
#define MSK_NX51_dpm_netx_version_netx_version_byte1 0x0000ff00U
#define SRT_NX51_dpm_netx_version_netx_version_byte1 8
#define MSK_NX51_dpm_netx_version_netx_version_byte2 0x00ff0000U
#define SRT_NX51_dpm_netx_version_netx_version_byte2 16
#define MSK_NX51_dpm_netx_version_netx_version_byte3 0xff000000U
#define SRT_NX51_dpm_netx_version_netx_version_byte3 24

/* all used bits of 'NX51_dpm_netx_version': */
#define MSK_USED_BITS_NX51_dpm_netx_version 0xffffffffU

enum {
	BFW_NX51_dpm_netx_version_netx_version_byte0 = 8, /* [7:0] */
	BFW_NX51_dpm_netx_version_netx_version_byte1 = 8, /* [15:8] */
	BFW_NX51_dpm_netx_version_netx_version_byte2 = 8, /* [23:16] */
	BFW_NX51_dpm_netx_version_netx_version_byte3 = 8  /* [31:24] */
};

typedef struct NX51_DPM_NETX_VERSION_BIT_Ttag {
	unsigned int netx_version_byte0 : BFW_NX51_dpm_netx_version_netx_version_byte0; /* netX version bits 8 to 0.   */
	unsigned int netx_version_byte1 : BFW_NX51_dpm_netx_version_netx_version_byte1; /* netX version bits 16 to 8.  */
	unsigned int netx_version_byte2 : BFW_NX51_dpm_netx_version_netx_version_byte2; /* netX version bits 24 to 16. */
	unsigned int netx_version_byte3 : BFW_NX51_dpm_netx_version_netx_version_byte3; /* netX version bits 31 to 24. */
} NX51_DPM_NETX_VERSION_BIT_T;

typedef union {
	unsigned int                val;
	NX51_DPM_NETX_VERSION_BIT_T bf;
} NX51_DPM_NETX_VERSION_T;


/* ===================================================================== */

/* Area of asic_ctrl */

/* ===================================================================== */

#define Addr_NX51_asic_ctrl 0x1018C100U
#define NX51_NETX_CTRL_AREA 0x1018C100U

/* --------------------------------------------------------------------- */
/* Register io_config */
/* => IO Config Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Selects can only be activated, if appropriate bit of io_config_mask is set. */
/*    Bits will be reset according to the io_config_mask-register if a new mask is correctly written (netX locking algorithm). */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_config       0x00000000U
#define Adr_NX51_asic_ctrl_io_config 0x1018C100U
#define Adr_NX51_io_config           0x1018C100U
#define DFLT_VAL_NX51_io_config      0x00000000U

#define MSK_NX51_io_config_sel_xm0_tx                 0x00000001U
#define SRT_NX51_io_config_sel_xm0_tx                 0
#define DFLT_VAL_NX51_io_config_sel_xm0_tx            0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_xm0_tx         0x00000000U
#define MSK_NX51_io_config_sel_xm0_txoe               0x00000002U
#define SRT_NX51_io_config_sel_xm0_txoe               1
#define DFLT_VAL_NX51_io_config_sel_xm0_txoe          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_xm0_txoe       0x00000000U
#define MSK_NX51_io_config_sel_xm0_eclk               0x00000004U
#define SRT_NX51_io_config_sel_xm0_eclk               2
#define DFLT_VAL_NX51_io_config_sel_xm0_eclk          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_xm0_eclk       0x00000000U
#define MSK_NX51_io_config_sel_fb0clk_a               0x00000008U
#define SRT_NX51_io_config_sel_fb0clk_a               3
#define DFLT_VAL_NX51_io_config_sel_fb0clk_a          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fb0clk_a       0x00000000U
#define MSK_NX51_io_config_sel_fb0clk_b               0x00000010U
#define SRT_NX51_io_config_sel_fb0clk_b               4
#define DFLT_VAL_NX51_io_config_sel_fb0clk_b          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fb0clk_b       0x00000000U
#define MSK_NX51_io_config_sel_fo0_a                  0x00000020U
#define SRT_NX51_io_config_sel_fo0_a                  5
#define DFLT_VAL_NX51_io_config_sel_fo0_a             0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fo0_a          0x00000000U
#define MSK_NX51_io_config_sel_fo0_b                  0x00000040U
#define SRT_NX51_io_config_sel_fo0_b                  6
#define DFLT_VAL_NX51_io_config_sel_fo0_b             0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fo0_b          0x00000000U
#define MSK_NX51_io_config_sel_xm1_tx                 0x00000080U
#define SRT_NX51_io_config_sel_xm1_tx                 7
#define DFLT_VAL_NX51_io_config_sel_xm1_tx            0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_xm1_tx         0x00000000U
#define MSK_NX51_io_config_sel_xm1_txoe               0x00000100U
#define SRT_NX51_io_config_sel_xm1_txoe               8
#define DFLT_VAL_NX51_io_config_sel_xm1_txoe          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_xm1_txoe       0x00000000U
#define MSK_NX51_io_config_sel_xm1_eclk               0x00000200U
#define SRT_NX51_io_config_sel_xm1_eclk               9
#define DFLT_VAL_NX51_io_config_sel_xm1_eclk          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_xm1_eclk       0x00000000U
#define MSK_NX51_io_config_sel_fb1clk_a               0x00000400U
#define SRT_NX51_io_config_sel_fb1clk_a               10
#define DFLT_VAL_NX51_io_config_sel_fb1clk_a          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fb1clk_a       0x00000000U
#define MSK_NX51_io_config_sel_fb1clk_b               0x00000800U
#define SRT_NX51_io_config_sel_fb1clk_b               11
#define DFLT_VAL_NX51_io_config_sel_fb1clk_b          0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fb1clk_b       0x00000000U
#define MSK_NX51_io_config_sel_fo1_a                  0x00001000U
#define SRT_NX51_io_config_sel_fo1_a                  12
#define DFLT_VAL_NX51_io_config_sel_fo1_a             0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fo1_a          0x00000000U
#define MSK_NX51_io_config_sel_fo1_b                  0x00002000U
#define SRT_NX51_io_config_sel_fo1_b                  13
#define DFLT_VAL_NX51_io_config_sel_fo1_b             0x00000000U
#define DFLT_BF_VAL_NX51_io_config_sel_fo1_b          0x00000000U
#define MSK_NX51_io_config_usb2jtag_en                0x00004000U
#define SRT_NX51_io_config_usb2jtag_en                14
#define DFLT_VAL_NX51_io_config_usb2jtag_en           0x00000000U
#define DFLT_BF_VAL_NX51_io_config_usb2jtag_en        0x00000000U
#define MSK_NX51_io_config_mem_d31to16_pio_en         0x00008000U
#define SRT_NX51_io_config_mem_d31to16_pio_en         15
#define DFLT_VAL_NX51_io_config_mem_d31to16_pio_en    0x00000000U
#define DFLT_BF_VAL_NX51_io_config_mem_d31to16_pio_en 0x00000000U

/* all used bits of 'NX51_io_config': */
#define MSK_USED_BITS_NX51_io_config 0x0000ffffU

enum {
	BFW_NX51_io_config_sel_xm0_tx         = 1,  /* [0] */
	BFW_NX51_io_config_sel_xm0_txoe       = 1,  /* [1] */
	BFW_NX51_io_config_sel_xm0_eclk       = 1,  /* [2] */
	BFW_NX51_io_config_sel_fb0clk_a       = 1,  /* [3] */
	BFW_NX51_io_config_sel_fb0clk_b       = 1,  /* [4] */
	BFW_NX51_io_config_sel_fo0_a          = 1,  /* [5] */
	BFW_NX51_io_config_sel_fo0_b          = 1,  /* [6] */
	BFW_NX51_io_config_sel_xm1_tx         = 1,  /* [7] */
	BFW_NX51_io_config_sel_xm1_txoe       = 1,  /* [8] */
	BFW_NX51_io_config_sel_xm1_eclk       = 1,  /* [9] */
	BFW_NX51_io_config_sel_fb1clk_a       = 1,  /* [10] */
	BFW_NX51_io_config_sel_fb1clk_b       = 1,  /* [11] */
	BFW_NX51_io_config_sel_fo1_a          = 1,  /* [12] */
	BFW_NX51_io_config_sel_fo1_b          = 1,  /* [13] */
	BFW_NX51_io_config_usb2jtag_en        = 1,  /* [14] */
	BFW_NX51_io_config_mem_d31to16_pio_en = 1,  /* [15] */
	BFW_NX51_io_config_reserved1          = 16  /* [31:16] */
};

typedef struct NX51_IO_CONFIG_BIT_Ttag {
	unsigned int sel_xm0_tx         : BFW_NX51_io_config_sel_xm0_tx;         /* select pad for xMAC0 tx-bitstream direct output (s. pinning table)                    */
	unsigned int sel_xm0_txoe       : BFW_NX51_io_config_sel_xm0_txoe;       /* select pad for xMAC0 tx-bitstream direct output enable (s. pinning table)             */
	unsigned int sel_xm0_eclk       : BFW_NX51_io_config_sel_xm0_eclk;       /* select pad for xMAC0 eclk (s. pinning table)                                          */
	unsigned int sel_fb0clk_a       : BFW_NX51_io_config_sel_fb0clk_a;       /* select pad for fieldbus-clk0 at position A (s. pinning table)                         */
	unsigned int sel_fb0clk_b       : BFW_NX51_io_config_sel_fb0clk_b;       /* select pad for fieldbus-clk0 at position B (s. pinning table)                         */
	unsigned int sel_fo0_a          : BFW_NX51_io_config_sel_fo0_a;          /* select Fiber Optics of PHY0 at position A (s. pinning table)                          */
	unsigned int sel_fo0_b          : BFW_NX51_io_config_sel_fo0_b;          /* select Fiber Optics of PHY0 at position B (s. pinning table)                          */
	unsigned int sel_xm1_tx         : BFW_NX51_io_config_sel_xm1_tx;         /* select pad for xMAC1 tx-bitstream direct output (s. pinning table)                    */
	unsigned int sel_xm1_txoe       : BFW_NX51_io_config_sel_xm1_txoe;       /* select pad for xMAC1 tx-bitstream direct output enable (s. pinning table)             */
	unsigned int sel_xm1_eclk       : BFW_NX51_io_config_sel_xm1_eclk;       /* select pad for xMAC1 eclk (s. pinning table)                                          */
	unsigned int sel_fb1clk_a       : BFW_NX51_io_config_sel_fb1clk_a;       /* select pad for fieldbus-clk1 at position A (s. pinning table)                         */
	unsigned int sel_fb1clk_b       : BFW_NX51_io_config_sel_fb1clk_b;       /* select pad for fieldbus-clk1 at position B (s. pinning table)                         */
	unsigned int sel_fo1_a          : BFW_NX51_io_config_sel_fo1_a;          /* select Fiber Optics of PHY1 at position A (s. pinning table)                          */
	unsigned int sel_fo1_b          : BFW_NX51_io_config_sel_fo1_b;          /* select Fiber Optics of PHY1 at position B (s. pinning table)                          */
	unsigned int usb2jtag_en        : BFW_NX51_io_config_usb2jtag_en;        /* global enable of USB2JTAG debug feature:                                              */
	                                                                         /* Note: Addionally USB2JTAG debugging requires an enable from USB_DEV module,           */
	                                                                         /*       which is only active, if USB_DEV module is running and connection               */
	                                                                         /*       is established (s. usb_dev_cfg-usb_to_jtag_enable).                             */
	                                                                         /*       Unless both enables are active, ARM-JTAG is controlled by netx JT_* pins.       */
	unsigned int mem_d31to16_pio_en : BFW_NX51_io_config_mem_d31to16_pio_en; /* PIO mode enable for MEM_D31 to MEM_D16. View 'extmem_pio_ctrl' area for more details. */
	unsigned int reserved1          : BFW_NX51_io_config_reserved1;          /* reserved                                                                              */
} NX51_IO_CONFIG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_IO_CONFIG_BIT_T bf;
} NX51_IO_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register io_config_mask */
/* => IO Config Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by netX locking algorithm. It will only be reset on Power on, not on normal system nres. */
/*    The io_config-register will change according to this register if a new mask is correctly written (netX locking algorithm). */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_config_mask       0x00000004U
#define Adr_NX51_asic_ctrl_io_config_mask 0x1018C104U
#define Adr_NX51_io_config_mask           0x1018C104U
#define DFLT_VAL_NX51_io_config_mask      0x0000ffffU

#define MSK_NX51_io_config_mask_sel_xm0_tx                 0x00000001U
#define SRT_NX51_io_config_mask_sel_xm0_tx                 0
#define DFLT_VAL_NX51_io_config_mask_sel_xm0_tx            0x00000001U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_xm0_tx         0x00000001U
#define MSK_NX51_io_config_mask_sel_xm0_txoe               0x00000002U
#define SRT_NX51_io_config_mask_sel_xm0_txoe               1
#define DFLT_VAL_NX51_io_config_mask_sel_xm0_txoe          0x00000002U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_xm0_txoe       0x00000001U
#define MSK_NX51_io_config_mask_sel_xm0_eclk               0x00000004U
#define SRT_NX51_io_config_mask_sel_xm0_eclk               2
#define DFLT_VAL_NX51_io_config_mask_sel_xm0_eclk          0x00000004U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_xm0_eclk       0x00000001U
#define MSK_NX51_io_config_mask_sel_fb0clk_a               0x00000008U
#define SRT_NX51_io_config_mask_sel_fb0clk_a               3
#define DFLT_VAL_NX51_io_config_mask_sel_fb0clk_a          0x00000008U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fb0clk_a       0x00000001U
#define MSK_NX51_io_config_mask_sel_fb0clk_b               0x00000010U
#define SRT_NX51_io_config_mask_sel_fb0clk_b               4
#define DFLT_VAL_NX51_io_config_mask_sel_fb0clk_b          0x00000010U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fb0clk_b       0x00000001U
#define MSK_NX51_io_config_mask_sel_fo0_a                  0x00000020U
#define SRT_NX51_io_config_mask_sel_fo0_a                  5
#define DFLT_VAL_NX51_io_config_mask_sel_fo0_a             0x00000020U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fo0_a          0x00000001U
#define MSK_NX51_io_config_mask_sel_fo0_b                  0x00000040U
#define SRT_NX51_io_config_mask_sel_fo0_b                  6
#define DFLT_VAL_NX51_io_config_mask_sel_fo0_b             0x00000040U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fo0_b          0x00000001U
#define MSK_NX51_io_config_mask_sel_xm1_tx                 0x00000080U
#define SRT_NX51_io_config_mask_sel_xm1_tx                 7
#define DFLT_VAL_NX51_io_config_mask_sel_xm1_tx            0x00000080U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_xm1_tx         0x00000001U
#define MSK_NX51_io_config_mask_sel_xm1_txoe               0x00000100U
#define SRT_NX51_io_config_mask_sel_xm1_txoe               8
#define DFLT_VAL_NX51_io_config_mask_sel_xm1_txoe          0x00000100U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_xm1_txoe       0x00000001U
#define MSK_NX51_io_config_mask_sel_xm1_eclk               0x00000200U
#define SRT_NX51_io_config_mask_sel_xm1_eclk               9
#define DFLT_VAL_NX51_io_config_mask_sel_xm1_eclk          0x00000200U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_xm1_eclk       0x00000001U
#define MSK_NX51_io_config_mask_sel_fb1clk_a               0x00000400U
#define SRT_NX51_io_config_mask_sel_fb1clk_a               10
#define DFLT_VAL_NX51_io_config_mask_sel_fb1clk_a          0x00000400U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fb1clk_a       0x00000001U
#define MSK_NX51_io_config_mask_sel_fb1clk_b               0x00000800U
#define SRT_NX51_io_config_mask_sel_fb1clk_b               11
#define DFLT_VAL_NX51_io_config_mask_sel_fb1clk_b          0x00000800U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fb1clk_b       0x00000001U
#define MSK_NX51_io_config_mask_sel_fo1_a                  0x00001000U
#define SRT_NX51_io_config_mask_sel_fo1_a                  12
#define DFLT_VAL_NX51_io_config_mask_sel_fo1_a             0x00001000U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fo1_a          0x00000001U
#define MSK_NX51_io_config_mask_sel_fo1_b                  0x00002000U
#define SRT_NX51_io_config_mask_sel_fo1_b                  13
#define DFLT_VAL_NX51_io_config_mask_sel_fo1_b             0x00002000U
#define DFLT_BF_VAL_NX51_io_config_mask_sel_fo1_b          0x00000001U
#define MSK_NX51_io_config_mask_usb2jtag_en                0x00004000U
#define SRT_NX51_io_config_mask_usb2jtag_en                14
#define DFLT_VAL_NX51_io_config_mask_usb2jtag_en           0x00004000U
#define DFLT_BF_VAL_NX51_io_config_mask_usb2jtag_en        0x00000001U
#define MSK_NX51_io_config_mask_mem_d31to16_pio_en         0x00008000U
#define SRT_NX51_io_config_mask_mem_d31to16_pio_en         15
#define DFLT_VAL_NX51_io_config_mask_mem_d31to16_pio_en    0x00008000U
#define DFLT_BF_VAL_NX51_io_config_mask_mem_d31to16_pio_en 0x00000001U

/* all used bits of 'NX51_io_config_mask': */
#define MSK_USED_BITS_NX51_io_config_mask 0x0000ffffU

enum {
	BFW_NX51_io_config_mask_sel_xm0_tx         = 1,  /* [0] */
	BFW_NX51_io_config_mask_sel_xm0_txoe       = 1,  /* [1] */
	BFW_NX51_io_config_mask_sel_xm0_eclk       = 1,  /* [2] */
	BFW_NX51_io_config_mask_sel_fb0clk_a       = 1,  /* [3] */
	BFW_NX51_io_config_mask_sel_fb0clk_b       = 1,  /* [4] */
	BFW_NX51_io_config_mask_sel_fo0_a          = 1,  /* [5] */
	BFW_NX51_io_config_mask_sel_fo0_b          = 1,  /* [6] */
	BFW_NX51_io_config_mask_sel_xm1_tx         = 1,  /* [7] */
	BFW_NX51_io_config_mask_sel_xm1_txoe       = 1,  /* [8] */
	BFW_NX51_io_config_mask_sel_xm1_eclk       = 1,  /* [9] */
	BFW_NX51_io_config_mask_sel_fb1clk_a       = 1,  /* [10] */
	BFW_NX51_io_config_mask_sel_fb1clk_b       = 1,  /* [11] */
	BFW_NX51_io_config_mask_sel_fo1_a          = 1,  /* [12] */
	BFW_NX51_io_config_mask_sel_fo1_b          = 1,  /* [13] */
	BFW_NX51_io_config_mask_usb2jtag_en        = 1,  /* [14] */
	BFW_NX51_io_config_mask_mem_d31to16_pio_en = 1,  /* [15] */
	BFW_NX51_io_config_mask_reserved1          = 16  /* [31:16] */
};

typedef struct NX51_IO_CONFIG_MASK_BIT_Ttag {
	unsigned int sel_xm0_tx         : BFW_NX51_io_config_mask_sel_xm0_tx;         /* select pad for xMAC0 tx-bitstream direct output (s. pinning table)                    */
	unsigned int sel_xm0_txoe       : BFW_NX51_io_config_mask_sel_xm0_txoe;       /* select pad for xMAC0 tx-bitstream direct output enable (s. pinning table)             */
	unsigned int sel_xm0_eclk       : BFW_NX51_io_config_mask_sel_xm0_eclk;       /* select pad for xMAC0 eclk (s. pinning table)                                          */
	unsigned int sel_fb0clk_a       : BFW_NX51_io_config_mask_sel_fb0clk_a;       /* select pad for fieldbus-clk0 at position A (s. pinning table)                         */
	unsigned int sel_fb0clk_b       : BFW_NX51_io_config_mask_sel_fb0clk_b;       /* select pad for fieldbus-clk0 at position B (s. pinning table)                         */
	unsigned int sel_fo0_a          : BFW_NX51_io_config_mask_sel_fo0_a;          /* select Fiber Optics of PHY0 at position A (s. pinning table)                          */
	unsigned int sel_fo0_b          : BFW_NX51_io_config_mask_sel_fo0_b;          /* select Fiber Optics of PHY0 at position B (s. pinning table)                          */
	unsigned int sel_xm1_tx         : BFW_NX51_io_config_mask_sel_xm1_tx;         /* select pad for xMAC1 tx-bitstream direct output (s. pinning table)                    */
	unsigned int sel_xm1_txoe       : BFW_NX51_io_config_mask_sel_xm1_txoe;       /* select pad for xMAC1 tx-bitstream direct output enable (s. pinning table)             */
	unsigned int sel_xm1_eclk       : BFW_NX51_io_config_mask_sel_xm1_eclk;       /* select pad for xMAC1 eclk (s. pinning table)                                          */
	unsigned int sel_fb1clk_a       : BFW_NX51_io_config_mask_sel_fb1clk_a;       /* select pad for fieldbus-clk1 at position A (s. pinning table)                         */
	unsigned int sel_fb1clk_b       : BFW_NX51_io_config_mask_sel_fb1clk_b;       /* select pad for fieldbus-clk1 at position B (s. pinning table)                         */
	unsigned int sel_fo1_a          : BFW_NX51_io_config_mask_sel_fo1_a;          /* select Fiber Optics of PHY1 at position A (s. pinning table)                          */
	unsigned int sel_fo1_b          : BFW_NX51_io_config_mask_sel_fo1_b;          /* select Fiber Optics of PHY1 at position B (s. pinning table)                          */
	unsigned int usb2jtag_en        : BFW_NX51_io_config_mask_usb2jtag_en;        /* internal enable of USB2JTAG debug feature:                                            */
	                                                                              /* Note: Addionally USB2JTAG debugging requires an enable from USB_DEV module,           */
	                                                                              /*       which is only active, if USB_DEV module is running and connection               */
	                                                                              /*       is established (s. usb_dev_cfg-usb_to_jtag_enable).                             */
	                                                                              /*       Unless both enables are active, ARM-JTAG is controlled by netx JT_* pins.       */
	unsigned int mem_d31to16_pio_en : BFW_NX51_io_config_mask_mem_d31to16_pio_en; /* PIO mode enable for MEM_D31 to MEM_D16. View 'extmem_pio_ctrl' area for more details. */
	unsigned int reserved1          : BFW_NX51_io_config_mask_reserved1;          /* reserved                                                                              */
} NX51_IO_CONFIG_MASK_BIT_T;

typedef union {
	unsigned int              val;
	NX51_IO_CONFIG_MASK_BIT_T bf;
} NX51_IO_CONFIG_MASK_T;

/* --------------------------------------------------------------------- */
/* Register io_config2 */
/* => IO Config2 Register: */
/*    Selects of output pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    Selects can only be activated, if appropriate bit of io_config2_mask is set. */
/*    Bits will be reset according to the io_config2_mask-register if a new mask is correctly written (netX locking algorithm). */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/*    Note: Selecting MMIO40..47 on HIF IOs: */
/*      Selecting MMIO40..47 on HIF IOs is done by programming related MMIO to non-PIO function in MMIO_CTRL address area. */
/*      E.g.: Programming MMIO40 as MMIO-PIO: HIF_D16 will be HIF IO. */
/*      Programming MMIO40 to non-PIO function (e.g. xm0_io0) will switch HIF_D16 to MMIO (XM0_IO0) function. */
/*      PIO function of MMIO40..47 is not available via MMIO_CTRL address area. PIO function of related HIF-IOs */
/*      must be configured inside HIF_IO_CTRL address area. */
/*    Note: */
/*      HIF IO configuration must be done inside hif_io_cfg-register (area HIF_IO_CTRL). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_config2       0x00000008U
#define Adr_NX51_asic_ctrl_io_config2 0x1018C108U
#define Adr_NX51_io_config2           0x1018C108U
#define DFLT_VAL_NX51_io_config2      0x00000000U

#define MSK_NX51_io_config2_sel_iolink0                0x00000001U
#define SRT_NX51_io_config2_sel_iolink0                0
#define DFLT_VAL_NX51_io_config2_sel_iolink0           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink0        0x00000000U
#define MSK_NX51_io_config2_sel_iolink1                0x00000002U
#define SRT_NX51_io_config2_sel_iolink1                1
#define DFLT_VAL_NX51_io_config2_sel_iolink1           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink1        0x00000000U
#define MSK_NX51_io_config2_sel_iolink2                0x00000004U
#define SRT_NX51_io_config2_sel_iolink2                2
#define DFLT_VAL_NX51_io_config2_sel_iolink2           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink2        0x00000000U
#define MSK_NX51_io_config2_sel_iolink3                0x00000008U
#define SRT_NX51_io_config2_sel_iolink3                3
#define DFLT_VAL_NX51_io_config2_sel_iolink3           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink3        0x00000000U
#define MSK_NX51_io_config2_sel_iolink4                0x00000010U
#define SRT_NX51_io_config2_sel_iolink4                4
#define DFLT_VAL_NX51_io_config2_sel_iolink4           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink4        0x00000000U
#define MSK_NX51_io_config2_sel_iolink5                0x00000020U
#define SRT_NX51_io_config2_sel_iolink5                5
#define DFLT_VAL_NX51_io_config2_sel_iolink5           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink5        0x00000000U
#define MSK_NX51_io_config2_sel_iolink6                0x00000040U
#define SRT_NX51_io_config2_sel_iolink6                6
#define DFLT_VAL_NX51_io_config2_sel_iolink6           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink6        0x00000000U
#define MSK_NX51_io_config2_sel_iolink7                0x00000080U
#define SRT_NX51_io_config2_sel_iolink7                7
#define DFLT_VAL_NX51_io_config2_sel_iolink7           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_iolink7        0x00000000U
#define MSK_NX51_io_config2_sel_xm0_mii                0x00000700U
#define SRT_NX51_io_config2_sel_xm0_mii                8
#define DFLT_VAL_NX51_io_config2_sel_xm0_mii           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_xm0_mii        0x00000000U
#define MSK_NX51_io_config2_sel_xm1_mii                0x00003800U
#define SRT_NX51_io_config2_sel_xm1_mii                11
#define DFLT_VAL_NX51_io_config2_sel_xm1_mii           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_xm1_mii        0x00000000U
#define MSK_NX51_io_config2_sel_eth_mii                0x0007c000U
#define SRT_NX51_io_config2_sel_eth_mii                14
#define DFLT_VAL_NX51_io_config2_sel_eth_mii           0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_eth_mii        0x00000000U
#define MSK_NX51_io_config2_sel_phy_devel              0x00080000U
#define SRT_NX51_io_config2_sel_phy_devel              19
#define DFLT_VAL_NX51_io_config2_sel_phy_devel         0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_phy_devel      0x00000000U
#define MSK_NX51_io_config2_nsel_clkout_mmio48         0x00100000U
#define SRT_NX51_io_config2_nsel_clkout_mmio48         20
#define DFLT_VAL_NX51_io_config2_nsel_clkout_mmio48    0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_nsel_clkout_mmio48 0x00000000U
#define MSK_NX51_io_config2_sel_i2c_mmio               0x00200000U
#define SRT_NX51_io_config2_sel_i2c_mmio               21
#define DFLT_VAL_NX51_io_config2_sel_i2c_mmio          0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_i2c_mmio       0x00000000U
#define MSK_NX51_io_config2_sel_etm                    0x00400000U
#define SRT_NX51_io_config2_sel_etm                    22
#define DFLT_VAL_NX51_io_config2_sel_etm               0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_etm            0x00000000U
#define MSK_NX51_io_config2_sel_sqi                    0x00800000U
#define SRT_NX51_io_config2_sel_sqi                    23
#define DFLT_VAL_NX51_io_config2_sel_sqi               0x00000000U
#define DFLT_BF_VAL_NX51_io_config2_sel_sqi            0x00000000U

/* all used bits of 'NX51_io_config2': */
#define MSK_USED_BITS_NX51_io_config2 0x00ffffffU

enum {
	BFW_NX51_io_config2_sel_iolink0        = 1, /* [0] */
	BFW_NX51_io_config2_sel_iolink1        = 1, /* [1] */
	BFW_NX51_io_config2_sel_iolink2        = 1, /* [2] */
	BFW_NX51_io_config2_sel_iolink3        = 1, /* [3] */
	BFW_NX51_io_config2_sel_iolink4        = 1, /* [4] */
	BFW_NX51_io_config2_sel_iolink5        = 1, /* [5] */
	BFW_NX51_io_config2_sel_iolink6        = 1, /* [6] */
	BFW_NX51_io_config2_sel_iolink7        = 1, /* [7] */
	BFW_NX51_io_config2_sel_xm0_mii        = 3, /* [10:8] */
	BFW_NX51_io_config2_sel_xm1_mii        = 3, /* [13:11] */
	BFW_NX51_io_config2_sel_eth_mii        = 5, /* [18:14] */
	BFW_NX51_io_config2_sel_phy_devel      = 1, /* [19] */
	BFW_NX51_io_config2_nsel_clkout_mmio48 = 1, /* [20] */
	BFW_NX51_io_config2_sel_i2c_mmio       = 1, /* [21] */
	BFW_NX51_io_config2_sel_etm            = 1, /* [22] */
	BFW_NX51_io_config2_sel_sqi            = 1, /* [23] */
	BFW_NX51_io_config2_reserved1          = 8  /* [31:24] */
};

typedef struct NX51_IO_CONFIG2_BIT_Ttag {
	unsigned int sel_iolink0        : BFW_NX51_io_config2_sel_iolink0;        /* select IO-Link0(wakeup, txd, txoe, rxd) instead of gpio0..3 (before Multiplexmatrix)                      */
	unsigned int sel_iolink1        : BFW_NX51_io_config2_sel_iolink1;        /* select IO-Link1(wakeup, txd, txoe, rxd) instead of gpio4..7 (before Multiplexmatrix)                      */
	unsigned int sel_iolink2        : BFW_NX51_io_config2_sel_iolink2;        /* select IO-Link2(wakeup, txd, txoe, rxd) instead of gpio8..11 (before Multiplexmatrix)                     */
	unsigned int sel_iolink3        : BFW_NX51_io_config2_sel_iolink3;        /* select IO-Link3(wakeup, txd, txoe, rxd) instead of gpio12..15 (before Multiplexmatrix)                    */
	unsigned int sel_iolink4        : BFW_NX51_io_config2_sel_iolink4;        /* select IO-Link4(wakeup, txd, txoe, rxd) instead of gpio16..19 (before Multiplexmatrix)                    */
	unsigned int sel_iolink5        : BFW_NX51_io_config2_sel_iolink5;        /* select IO-Link5(wakeup, txd, txoe, rxd) instead of gpio20..23 (before Multiplexmatrix)                    */
	unsigned int sel_iolink6        : BFW_NX51_io_config2_sel_iolink6;        /* select IO-Link6(wakeup, txd, txoe, rxd) instead of gpio24..27 (before Multiplexmatrix)                    */
	unsigned int sel_iolink7        : BFW_NX51_io_config2_sel_iolink7;        /* select IO-Link7(wakeup, txd, txoe, rxd) instead of gpio28..31 (before Multiplexmatrix)                    */
	unsigned int sel_xm0_mii        : BFW_NX51_io_config2_sel_xm0_mii;        /* select pads for xMAC0 external MII pins (s. pinning table):                                               */
	                                                                          /* 0: no select                                                                                              */
	                                                                          /* 1: sel_xm0_mii0  : select pins for minimum data transfer (rxclk,rxd,rxdv,txclk,txd,txen)                  */
	                                                                          /* 2: sel_xm0_mii1:0: select also RX error signal (rxer)                                                     */
	                                                                          /* 3: sel_xm0_mii2:0: select also collision and carrier sense (col,crs)                                      */
	                                                                          /* 4: sel_xm0_mii3:0: select also TX error signal (txer)                                                     */
	                                                                          /* 5: sel_xm0_mii4:0: select also interrupt input (irq)                                                      */
	unsigned int sel_xm1_mii        : BFW_NX51_io_config2_sel_xm1_mii;        /* select pads for xMAC1 external MII pins (s. pinning table):                                               */
	                                                                          /* 0: no select                                                                                              */
	                                                                          /* 1: sel_xm1_mii0  : select pins for minimum data transfer (rxclk,rxd,rxdv,txclk,txd,txen)                  */
	                                                                          /* 2: sel_xm1_mii1:0: select also RX error signal (rxer)                                                     */
	                                                                          /* 3: sel_xm1_mii2:0: select also collision and carrier sense (col,crs)                                      */
	                                                                          /* 4: sel_xm1_mii3:0: select also TX error signal (txer)                                                     */
	                                                                          /* 5: sel_xm1_mii4:0: select also interrupt input (irq)                                                      */
	unsigned int sel_eth_mii        : BFW_NX51_io_config2_sel_eth_mii;        /* select pads for ETH external MII pins (s. pinning table):                                                 */
	                                                                          /*  0: no select                                                                                             */
	                                                                          /*  1: sel_eth_mmio_3,0: select MMIO pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)                  */
	                                                                          /*  2: sel_eth_mmio_1:0: select MMIO pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen)    */
	                                                                          /*  3: sel_eth_mmio_2:0: select at MMIO also rxclk pin for mac mode (rxclk)                                  */
	                                                                          /*  4: sel_eth_mmio_3:0: select at MMIO also RX error signal (rxer)                                          */
	                                                                          /*  5: sel_eth_mmio_4:0: select at MMIO also collision and carrier sense (col,crs)                           */
	                                                                          /*  6: sel_eth_mmio_5:0: select at MMIO also TX error signal (txer)                                          */
	                                                                          /*  7: sel_eth_hif1_3,0: select HIFpos1 pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)               */
	                                                                          /*  8: sel_eth_hif1_1:0: select HIFpos1 pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) */
	                                                                          /*  9: sel_eth_hif1_2:0: select at HIFpos1 also rxclk pin for mac mode (rxclk)                               */
	                                                                          /* 10: sel_eth_hif1_3:0: select at HIFpos1 also RX error signal (rxer)                                       */
	                                                                          /* 11: sel_eth_hif1_4:0: select at HIFpos1 also collision and carrier sense (col,crs)                        */
	                                                                          /* 12: sel_eth_hif1_5:0: sel_eth_hif1_5: select at HIFpos1 also TX error signal (txer)                       */
	                                                                          /* 13: sel_eth_hif2_3,0: select HIFpos2 pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)               */
	                                                                          /* 14: sel_eth_hif2_1:0: select HIFpos2 pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) */
	                                                                          /* 15: sel_eth_hif2_2:0: select at HIFpos2 also rxclk pin for mac mode (rxclk)                               */
	                                                                          /* 16: sel_eth_hif2_3:0: select at HIFpos2 also RX error signal (rxer)                                       */
	                                                                          /* 17: sel_eth_hif2_4:0: select at HIFpos2 also collision and carrier sense (col,crs)                        */
	                                                                          /* 18: sel_eth_hif2_5:0: select at HIFpos2 also TX error signal (txer)                                       */
	                                                                          /* 19: sel_eth_hif3_3,0: select HIFpos3 pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)               */
	                                                                          /* 20: sel_eth_hif3_1:0: select HIFpos3 pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) */
	                                                                          /* 21: sel_eth_hif3_2:0: select at HIFpos3 also rxclk pin for mac mode (rxclk)                               */
	                                                                          /* 22: sel_eth_hif3_3:0: select at HIFpos3 also RX error signal (rxer)                                       */
	                                                                          /* 23: sel_eth_hif3_4:0: select at HIFpos3 also collision and carrier sense (col,crs)                        */
	                                                                          /* 24: sel_eth_hif3_5:0: select at HIFpos3 also TX error signal (txer)                                       */
	unsigned int sel_phy_devel      : BFW_NX51_io_config2_sel_phy_devel;      /* select PHY development outputs (s. pinning table)                                                         */
	unsigned int nsel_clkout_mmio48 : BFW_NX51_io_config2_nsel_clkout_mmio48; /* not-select CLKOUT as MMIO48. 0: CLKOUT  is MMIO48, 1: CLKOUT is clock.                                    */
	                                                                          /* Note: CLKOUT is MMIO48 as default after reset, i.e. undriven input.                                       */
	unsigned int sel_i2c_mmio       : BFW_NX51_io_config2_sel_i2c_mmio;       /* select I2C0 via MMIOs instead of dedicated I2C_SDA/I2C_SCL-pads                                           */
	unsigned int sel_etm            : BFW_NX51_io_config2_sel_etm;            /* select pins for ETM9 (s. pinning table)                                                                   */
	unsigned int sel_sqi            : BFW_NX51_io_config2_sel_sqi;            /* select pins for SQI SIO2 and SIO3 signal (s. pinning table)                                               */
	                                                                          /* - activates spi0_sio2/3 at mem_a18/19                                                                     */
	                                                                          /* - switches mem_a18/19 function to pads MEM_A22/23                                                         */
	                                                                          /* - deactivates spi0_sio2/3 inputs from multiplexmatrix (however                                            */
	unsigned int reserved1          : BFW_NX51_io_config2_reserved1;          /* reserved                                                                                                  */
} NX51_IO_CONFIG2_BIT_T;

typedef union {
	unsigned int          val;
	NX51_IO_CONFIG2_BIT_T bf;
} NX51_IO_CONFIG2_T;

/* --------------------------------------------------------------------- */
/* Register io_config2_mask */
/* => IO Config2 Mask Register: */
/*    This register might be used to lock special IO configurations for restricted netX devices. \ */
/*    Any bit of the io_config2 register can only be set, if the corresponding mask bit in this register is set either. */
/*    This register is lockable by netX locking algorithm. It will only be reset on Power on, not on normal system nres. */
/*    The io_config-register will change according to this register if a new mask is correctly written (netX locking algorithm). */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/*    Note: Selecting MMIO40..47 on HIF IOs: */
/*      Selecting MMIO40..47 on HIF IOs is done by programming related MMIO to non-PIO function in MMIO_CTRL address area. */
/*      E.g.: Programming MMIO40 as MMIO-PIO: HIF_D16 will be HIF IO. */
/*      Programming MMIO40 to non-PIO function (e.g. xm0_io0) will switch HIF_D16 to MMIO (XM0_IO0) function. */
/*      PIO function of MMIO40..47 is not available via MMIO_CTRL address area. PIO function of related HIF-IOs */
/*      must be configured inside HIF_IO_CTRL address area. */
/*    Note: */
/*      HIF IO configuration must be done inside hif_io_cfg-register (area HIF_IO_CTRL). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_io_config2_mask       0x0000000CU
#define Adr_NX51_asic_ctrl_io_config2_mask 0x1018C10CU
#define Adr_NX51_io_config2_mask           0x1018C10CU
#define DFLT_VAL_NX51_io_config2_mask      0x00ffffffU

#define MSK_NX51_io_config2_mask_sel_iolink0                0x00000001U
#define SRT_NX51_io_config2_mask_sel_iolink0                0
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink0           0x00000001U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink0        0x00000001U
#define MSK_NX51_io_config2_mask_sel_iolink1                0x00000002U
#define SRT_NX51_io_config2_mask_sel_iolink1                1
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink1           0x00000002U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink1        0x00000001U
#define MSK_NX51_io_config2_mask_sel_iolink2                0x00000004U
#define SRT_NX51_io_config2_mask_sel_iolink2                2
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink2           0x00000004U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink2        0x00000001U
#define MSK_NX51_io_config2_mask_sel_iolink3                0x00000008U
#define SRT_NX51_io_config2_mask_sel_iolink3                3
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink3           0x00000008U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink3        0x00000001U
#define MSK_NX51_io_config2_mask_sel_iolink4                0x00000010U
#define SRT_NX51_io_config2_mask_sel_iolink4                4
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink4           0x00000010U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink4        0x00000001U
#define MSK_NX51_io_config2_mask_sel_iolink5                0x00000020U
#define SRT_NX51_io_config2_mask_sel_iolink5                5
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink5           0x00000020U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink5        0x00000001U
#define MSK_NX51_io_config2_mask_sel_iolink6                0x00000040U
#define SRT_NX51_io_config2_mask_sel_iolink6                6
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink6           0x00000040U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink6        0x00000001U
#define MSK_NX51_io_config2_mask_sel_iolink7                0x00000080U
#define SRT_NX51_io_config2_mask_sel_iolink7                7
#define DFLT_VAL_NX51_io_config2_mask_sel_iolink7           0x00000080U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_iolink7        0x00000001U
#define MSK_NX51_io_config2_mask_sel_xm0_mii                0x00000700U
#define SRT_NX51_io_config2_mask_sel_xm0_mii                8
#define DFLT_VAL_NX51_io_config2_mask_sel_xm0_mii           0x00000700U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_xm0_mii        0x00000007U
#define MSK_NX51_io_config2_mask_sel_xm1_mii                0x00003800U
#define SRT_NX51_io_config2_mask_sel_xm1_mii                11
#define DFLT_VAL_NX51_io_config2_mask_sel_xm1_mii           0x00003800U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_xm1_mii        0x00000007U
#define MSK_NX51_io_config2_mask_sel_eth_mii                0x0007c000U
#define SRT_NX51_io_config2_mask_sel_eth_mii                14
#define DFLT_VAL_NX51_io_config2_mask_sel_eth_mii           0x0007c000U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_eth_mii        0x0000001fU
#define MSK_NX51_io_config2_mask_sel_phy_devel              0x00080000U
#define SRT_NX51_io_config2_mask_sel_phy_devel              19
#define DFLT_VAL_NX51_io_config2_mask_sel_phy_devel         0x00080000U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_phy_devel      0x00000001U
#define MSK_NX51_io_config2_mask_nsel_clkout_mmio48         0x00100000U
#define SRT_NX51_io_config2_mask_nsel_clkout_mmio48         20
#define DFLT_VAL_NX51_io_config2_mask_nsel_clkout_mmio48    0x00100000U
#define DFLT_BF_VAL_NX51_io_config2_mask_nsel_clkout_mmio48 0x00000001U
#define MSK_NX51_io_config2_mask_sel_i2c_mmio               0x00200000U
#define SRT_NX51_io_config2_mask_sel_i2c_mmio               21
#define DFLT_VAL_NX51_io_config2_mask_sel_i2c_mmio          0x00200000U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_i2c_mmio       0x00000001U
#define MSK_NX51_io_config2_mask_sel_etm                    0x00400000U
#define SRT_NX51_io_config2_mask_sel_etm                    22
#define DFLT_VAL_NX51_io_config2_mask_sel_etm               0x00400000U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_etm            0x00000001U
#define MSK_NX51_io_config2_mask_sel_sqi                    0x00800000U
#define SRT_NX51_io_config2_mask_sel_sqi                    23
#define DFLT_VAL_NX51_io_config2_mask_sel_sqi               0x00800000U
#define DFLT_BF_VAL_NX51_io_config2_mask_sel_sqi            0x00000001U

/* all used bits of 'NX51_io_config2_mask': */
#define MSK_USED_BITS_NX51_io_config2_mask 0x00ffffffU

enum {
	BFW_NX51_io_config2_mask_sel_iolink0        = 1, /* [0] */
	BFW_NX51_io_config2_mask_sel_iolink1        = 1, /* [1] */
	BFW_NX51_io_config2_mask_sel_iolink2        = 1, /* [2] */
	BFW_NX51_io_config2_mask_sel_iolink3        = 1, /* [3] */
	BFW_NX51_io_config2_mask_sel_iolink4        = 1, /* [4] */
	BFW_NX51_io_config2_mask_sel_iolink5        = 1, /* [5] */
	BFW_NX51_io_config2_mask_sel_iolink6        = 1, /* [6] */
	BFW_NX51_io_config2_mask_sel_iolink7        = 1, /* [7] */
	BFW_NX51_io_config2_mask_sel_xm0_mii        = 3, /* [10:8] */
	BFW_NX51_io_config2_mask_sel_xm1_mii        = 3, /* [13:11] */
	BFW_NX51_io_config2_mask_sel_eth_mii        = 5, /* [18:14] */
	BFW_NX51_io_config2_mask_sel_phy_devel      = 1, /* [19] */
	BFW_NX51_io_config2_mask_nsel_clkout_mmio48 = 1, /* [20] */
	BFW_NX51_io_config2_mask_sel_i2c_mmio       = 1, /* [21] */
	BFW_NX51_io_config2_mask_sel_etm            = 1, /* [22] */
	BFW_NX51_io_config2_mask_sel_sqi            = 1, /* [23] */
	BFW_NX51_io_config2_mask_reserved1          = 8  /* [31:24] */
};

typedef struct NX51_IO_CONFIG2_MASK_BIT_Ttag {
	unsigned int sel_iolink0        : BFW_NX51_io_config2_mask_sel_iolink0;        /* select IO-Link0(wakeup, txd, txoe, rxd) instead of gpio0..3 (before Multiplexmatrix)                      */
	unsigned int sel_iolink1        : BFW_NX51_io_config2_mask_sel_iolink1;        /* select IO-Link1(wakeup, txd, txoe, rxd) instead of gpio4..7 (before Multiplexmatrix)                      */
	unsigned int sel_iolink2        : BFW_NX51_io_config2_mask_sel_iolink2;        /* select IO-Link2(wakeup, txd, txoe, rxd) instead of gpio8..11 (before Multiplexmatrix)                     */
	unsigned int sel_iolink3        : BFW_NX51_io_config2_mask_sel_iolink3;        /* select IO-Link3(wakeup, txd, txoe, rxd) instead of gpio12..15 (before Multiplexmatrix)                    */
	unsigned int sel_iolink4        : BFW_NX51_io_config2_mask_sel_iolink4;        /* select IO-Link4(wakeup, txd, txoe, rxd) instead of gpio16..19 (before Multiplexmatrix)                    */
	unsigned int sel_iolink5        : BFW_NX51_io_config2_mask_sel_iolink5;        /* select IO-Link5(wakeup, txd, txoe, rxd) instead of gpio20..23 (before Multiplexmatrix)                    */
	unsigned int sel_iolink6        : BFW_NX51_io_config2_mask_sel_iolink6;        /* select IO-Link6(wakeup, txd, txoe, rxd) instead of gpio24..27 (before Multiplexmatrix)                    */
	unsigned int sel_iolink7        : BFW_NX51_io_config2_mask_sel_iolink7;        /* select IO-Link7(wakeup, txd, txoe, rxd) instead of gpio28..31 (before Multiplexmatrix)                    */
	unsigned int sel_xm0_mii        : BFW_NX51_io_config2_mask_sel_xm0_mii;        /* select pads for xMAC0 external MII pins (s. pinning table):                                               */
	                                                                               /* 0: no select                                                                                              */
	                                                                               /* 1: sel_xm0_mii0  : select pins for minimum data transfer (rxclk,rxd,rxdv,txclk,txd,txen)                  */
	                                                                               /* 2: sel_xm0_mii1:0: select also RX error signal (rxer)                                                     */
	                                                                               /* 3: sel_xm0_mii2:0: select also collision and carrier sense (col,crs)                                      */
	                                                                               /* 4: sel_xm0_mii3:0: select also TX error signal (txer)                                                     */
	                                                                               /* 5: sel_xm0_mii4:0: select also interrupt input (irq)                                                      */
	unsigned int sel_xm1_mii        : BFW_NX51_io_config2_mask_sel_xm1_mii;        /* select pads for xMAC1 external MII pins (s. pinning table):                                               */
	                                                                               /* 0: no select                                                                                              */
	                                                                               /* 1: sel_xm1_mii0  : select pins for minimum data transfer (rxclk,rxd,rxdv,txclk,txd,txen)                  */
	                                                                               /* 2: sel_xm1_mii1:0: select also RX error signal (rxer)                                                     */
	                                                                               /* 3: sel_xm1_mii2:0: select also collision and carrier sense (col,crs)                                      */
	                                                                               /* 4: sel_xm1_mii3:0: select also TX error signal (txer)                                                     */
	                                                                               /* 5: sel_xm1_mii4:0: select also interrupt input (irq)                                                      */
	unsigned int sel_eth_mii        : BFW_NX51_io_config2_mask_sel_eth_mii;        /* select pads for ETH external MII pins (s. pinning table):                                                 */
	                                                                               /*  0: no select                                                                                             */
	                                                                               /*  1: sel_eth_mmio_3,0: select MMIO pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)                  */
	                                                                               /*  2: sel_eth_mmio_1:0: select MMIO pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen)    */
	                                                                               /*  3: sel_eth_mmio_2:0: select at MMIO also rxclk pin for mac mode (rxclk)                                  */
	                                                                               /*  4: sel_eth_mmio_3:0: select at MMIO also RX error signal (rxer)                                          */
	                                                                               /*  5: sel_eth_mmio_4:0: select at MMIO also collision and carrier sense (col,crs)                           */
	                                                                               /*  6: sel_eth_mmio_5:0: select at MMIO also TX error signal (txer)                                          */
	                                                                               /*  7: sel_eth_hif1_3,0: select HIFpos1 pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)               */
	                                                                               /*  8: sel_eth_hif1_1:0: select HIFpos1 pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) */
	                                                                               /*  9: sel_eth_hif1_2:0: select at HIFpos1 also rxclk pin for mac mode (rxclk)                               */
	                                                                               /* 10: sel_eth_hif1_3:0: select at HIFpos1 also RX error signal (rxer)                                       */
	                                                                               /* 11: sel_eth_hif1_4:0: select at HIFpos1 also collision and carrier sense (col,crs)                        */
	                                                                               /* 12: sel_eth_hif1_5:0: sel_eth_hif1_5: select at HIFpos1 also TX error signal (txer)                       */
	                                                                               /* 13: sel_eth_hif2_3,0: select HIFpos2 pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)               */
	                                                                               /* 14: sel_eth_hif2_1:0: select HIFpos2 pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) */
	                                                                               /* 15: sel_eth_hif2_2:0: select at HIFpos2 also rxclk pin for mac mode (rxclk)                               */
	                                                                               /* 16: sel_eth_hif2_3:0: select at HIFpos2 also RX error signal (rxer)                                       */
	                                                                               /* 17: sel_eth_hif2_4:0: select at HIFpos2 also collision and carrier sense (col,crs)                        */
	                                                                               /* 18: sel_eth_hif2_5:0: select at HIFpos2 also TX error signal (txer)                                       */
	                                                                               /* 19: sel_eth_hif3_3,0: select HIFpos3 pins for RMII (rxd[1:0],rxdv,rxer,txclk,txd[1:0],txen)               */
	                                                                               /* 20: sel_eth_hif3_1:0: select HIFpos3 pins for minimum data transfer in phy mode (rxd,rxdv,txclk,txd,txen) */
	                                                                               /* 21: sel_eth_hif3_2:0: select at HIFpos3 also rxclk pin for mac mode (rxclk)                               */
	                                                                               /* 22: sel_eth_hif3_3:0: select at HIFpos3 also RX error signal (rxer)                                       */
	                                                                               /* 23: sel_eth_hif3_4:0: select at HIFpos3 also collision and carrier sense (col,crs)                        */
	                                                                               /* 24: sel_eth_hif3_5:0: select at HIFpos3 also TX error signal (txer)                                       */
	unsigned int sel_phy_devel      : BFW_NX51_io_config2_mask_sel_phy_devel;      /* select PHY development outputs (s. pinning table)                                                         */
	unsigned int nsel_clkout_mmio48 : BFW_NX51_io_config2_mask_nsel_clkout_mmio48; /* not-select CLKOUT as MMIO48. 0: CLKOUT  is MMIO48, 1: CLKOUT is clock.                                    */
	                                                                               /* Note: CLKOUT is MMIO48 as default after reset, i.e. undriven input.                                       */
	unsigned int sel_i2c_mmio       : BFW_NX51_io_config2_mask_sel_i2c_mmio;       /* select I2C0 via MMIOs instead of dedicated I2C_SDA/I2C_SCL-pads                                           */
	unsigned int sel_etm            : BFW_NX51_io_config2_mask_sel_etm;            /* select pins for ETM9 (s. pinning table)                                                                   */
	unsigned int sel_sqi            : BFW_NX51_io_config2_mask_sel_sqi;            /* select pins for SQI SIO2 and SIO3 signal (s. pinning table)                                               */
	                                                                               /* - activates spi0_sio2/3 at mem_a18/19                                                                     */
	                                                                               /* - switches mem_a18/19 function to pads MEM_A22/23                                                         */
	                                                                               /* - deactivates spi0_sio2/3 inputs from multiplexmatrix (however                                            */
	unsigned int reserved1          : BFW_NX51_io_config2_mask_reserved1;          /* reserved                                                                                                  */
} NX51_IO_CONFIG2_MASK_BIT_T;

typedef union {
	unsigned int               val;
	NX51_IO_CONFIG2_MASK_BIT_T bf;
} NX51_IO_CONFIG2_MASK_T;

/* --------------------------------------------------------------------- */
/* Register reset_ctrl */
/* => Reset Control Register: */
/*    This register controls the reset functions of the netX chip and indicates the reset state. The reset state */
/*    shows which resets have occurred, allowing the firmware to detect which resets were active. In order to */
/*    determine the source of the last reset, the firmware should evaluate and reset these bits during its start */
/*    sequence. After a power on reset, the RESET_CTRL register is cleared completely. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_reset_ctrl       0x00000010U
#define Adr_NX51_asic_ctrl_reset_ctrl 0x1018C110U
#define Adr_NX51_reset_ctrl           0x1018C110U
#define DFLT_VAL_NX51_reset_ctrl      0x00000000U

#define MSK_NX51_reset_ctrl_RES_IN                   0x00000001U
#define SRT_NX51_reset_ctrl_RES_IN                   0
#define DFLT_VAL_NX51_reset_ctrl_RES_IN              0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_RES_IN           0x00000000U
#define MSK_NX51_reset_ctrl_RES_WDOG                 0x00000002U
#define SRT_NX51_reset_ctrl_RES_WDOG                 1
#define DFLT_VAL_NX51_reset_ctrl_RES_WDOG            0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_RES_WDOG         0x00000000U
#define MSK_NX51_reset_ctrl_RES_HOST                 0x00000004U
#define SRT_NX51_reset_ctrl_RES_HOST                 2
#define DFLT_VAL_NX51_reset_ctrl_RES_HOST            0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_RES_HOST         0x00000000U
#define MSK_NX51_reset_ctrl_RES_FIRMWARE             0x00000008U
#define SRT_NX51_reset_ctrl_RES_FIRMWARE             3
#define DFLT_VAL_NX51_reset_ctrl_RES_FIRMWARE        0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_RES_FIRMWARE     0x00000000U
#define MSK_NX51_reset_ctrl_FIRMWARE_STATUS0         0x00100000U
#define SRT_NX51_reset_ctrl_FIRMWARE_STATUS0         20
#define DFLT_VAL_NX51_reset_ctrl_FIRMWARE_STATUS0    0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_FIRMWARE_STATUS0 0x00000000U
#define MSK_NX51_reset_ctrl_FIRMWARE_STATUS1         0x00200000U
#define SRT_NX51_reset_ctrl_FIRMWARE_STATUS1         21
#define DFLT_VAL_NX51_reset_ctrl_FIRMWARE_STATUS1    0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_FIRMWARE_STATUS1 0x00000000U
#define MSK_NX51_reset_ctrl_FIRMWARE_STATUS2         0x00400000U
#define SRT_NX51_reset_ctrl_FIRMWARE_STATUS2         22
#define DFLT_VAL_NX51_reset_ctrl_FIRMWARE_STATUS2    0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_FIRMWARE_STATUS2 0x00000000U
#define MSK_NX51_reset_ctrl_FIRMWARE_STATUS3         0x00800000U
#define SRT_NX51_reset_ctrl_FIRMWARE_STATUS3         23
#define DFLT_VAL_NX51_reset_ctrl_FIRMWARE_STATUS3    0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_FIRMWARE_STATUS3 0x00000000U
#define MSK_NX51_reset_ctrl_RES_REQ_FIRMWARE         0x01000000U
#define SRT_NX51_reset_ctrl_RES_REQ_FIRMWARE         24
#define DFLT_VAL_NX51_reset_ctrl_RES_REQ_FIRMWARE    0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_RES_REQ_FIRMWARE 0x00000000U
#define MSK_NX51_reset_ctrl_RES_REQ_OUT              0x02000000U
#define SRT_NX51_reset_ctrl_RES_REQ_OUT              25
#define DFLT_VAL_NX51_reset_ctrl_RES_REQ_OUT         0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_RES_REQ_OUT      0x00000000U
#define MSK_NX51_reset_ctrl_EN_RES_REQ_OUT           0x04000000U
#define SRT_NX51_reset_ctrl_EN_RES_REQ_OUT           26
#define DFLT_VAL_NX51_reset_ctrl_EN_RES_REQ_OUT      0x00000000U
#define DFLT_BF_VAL_NX51_reset_ctrl_EN_RES_REQ_OUT   0x00000000U

/* all used bits of 'NX51_reset_ctrl': */
#define MSK_USED_BITS_NX51_reset_ctrl 0x07f0000fU

enum {
	BFW_NX51_reset_ctrl_RES_IN           = 1,  /* [0] */
	BFW_NX51_reset_ctrl_RES_WDOG         = 1,  /* [1] */
	BFW_NX51_reset_ctrl_RES_HOST         = 1,  /* [2] */
	BFW_NX51_reset_ctrl_RES_FIRMWARE     = 1,  /* [3] */
	BFW_NX51_reset_ctrl_reserved1        = 16, /* [19:4] */
	BFW_NX51_reset_ctrl_FIRMWARE_STATUS0 = 1,  /* [20] */
	BFW_NX51_reset_ctrl_FIRMWARE_STATUS1 = 1,  /* [21] */
	BFW_NX51_reset_ctrl_FIRMWARE_STATUS2 = 1,  /* [22] */
	BFW_NX51_reset_ctrl_FIRMWARE_STATUS3 = 1,  /* [23] */
	BFW_NX51_reset_ctrl_RES_REQ_FIRMWARE = 1,  /* [24] */
	BFW_NX51_reset_ctrl_RES_REQ_OUT      = 1,  /* [25] */
	BFW_NX51_reset_ctrl_EN_RES_REQ_OUT   = 1,  /* [26] */
	BFW_NX51_reset_ctrl_reserved2        = 5   /* [31:27] */
};

typedef struct NX51_RESET_CTRL_BIT_Ttag {
	unsigned int RES_IN           : BFW_NX51_reset_ctrl_RES_IN;           /* reset from external pin, after reading write back a "1" to clear the status bit                 */
	unsigned int RES_WDOG         : BFW_NX51_reset_ctrl_RES_WDOG;         /* reset from System WDG, after reading write back a "1" to clear the status bit                   */
	unsigned int RES_HOST         : BFW_NX51_reset_ctrl_RES_HOST;         /* reset from Hostinterface/DPM, after reading write back a "1" to clear the status bit            */
	unsigned int RES_FIRMWARE     : BFW_NX51_reset_ctrl_RES_FIRMWARE;     /* reset from FIRMWARE (software reset), after reading write back a "1" to clear the status bit    */
	unsigned int reserved1        : BFW_NX51_reset_ctrl_reserved1;        /* reserved                                                                                        */
	unsigned int FIRMWARE_STATUS0 : BFW_NX51_reset_ctrl_FIRMWARE_STATUS0; /* readable and writable bit to save the firmware status; only a PowerOn Reset will clear this bit */
	unsigned int FIRMWARE_STATUS1 : BFW_NX51_reset_ctrl_FIRMWARE_STATUS1; /* readable and writable bit to save the firmware status; only a PowerOn Reset will clear this bit */
	unsigned int FIRMWARE_STATUS2 : BFW_NX51_reset_ctrl_FIRMWARE_STATUS2; /* readable and writable bit to save the firmware status; only a PowerOn Reset will clear this bit */
	unsigned int FIRMWARE_STATUS3 : BFW_NX51_reset_ctrl_FIRMWARE_STATUS3; /* readable and writable bit to save the firmware status; only a PowerOn Reset will clear this bit */
	unsigned int RES_REQ_FIRMWARE : BFW_NX51_reset_ctrl_RES_REQ_FIRMWARE; /* (software reset) writing a "1" sets the reset request to reset the whole system (write only)    */
	unsigned int RES_REQ_OUT      : BFW_NX51_reset_ctrl_RES_REQ_OUT;      /* (software reset) programmable reset sets the reset on the external pin                          */
	unsigned int EN_RES_REQ_OUT   : BFW_NX51_reset_ctrl_EN_RES_REQ_OUT;   /* this bit enables the programmable reset                                                         */
	unsigned int reserved2        : BFW_NX51_reset_ctrl_reserved2;        /* reserved                                                                                        */
} NX51_RESET_CTRL_BIT_T;

typedef union {
	unsigned int          val;
	NX51_RESET_CTRL_BIT_T bf;
} NX51_RESET_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register phy_control */
/* => PHY Control Register: */
/*    This register contains all static connectors of the NEC Ethernet PHY. */
/*    Usually the PHY reads these values only during reset, which can be controlled by Bit31. */
/*    This register is NOT protected by the netX access-key mechanism. */
/*    In total the programming sequence should be: */
/*    a: write new value with bit phy_reset=1 */
/*    b: wait for proper reset of PHY(~100us) */
/*    c: write new value with bit phy_reset=0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_phy_control       0x00000014U
#define Adr_NX51_asic_ctrl_phy_control 0x1018C114U
#define Adr_NX51_phy_control           0x1018C114U
#define DFLT_VAL_NX51_phy_control      0x80006006U

#define MSK_NX51_phy_control_phy0_mode                0x0000000fU
#define SRT_NX51_phy_control_phy0_mode                0
#define DFLT_VAL_NX51_phy_control_phy0_mode           0x00000006U
#define DFLT_BF_VAL_NX51_phy_control_phy0_mode        0x00000006U
#define MSK_NX51_phy_control_phy0_fxmode              0x00000010U
#define SRT_NX51_phy_control_phy0_fxmode              4
#define DFLT_VAL_NX51_phy_control_phy0_fxmode         0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy0_fxmode      0x00000000U
#define MSK_NX51_phy_control_phy0_automdix            0x00000020U
#define SRT_NX51_phy_control_phy0_automdix            5
#define DFLT_VAL_NX51_phy_control_phy0_automdix       0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy0_automdix    0x00000000U
#define MSK_NX51_phy_control_phy0_enable              0x00000200U
#define SRT_NX51_phy_control_phy0_enable              9
#define DFLT_VAL_NX51_phy_control_phy0_enable         0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy0_enable      0x00000000U
#define MSK_NX51_phy_control_phy1_mode                0x0000f000U
#define SRT_NX51_phy_control_phy1_mode                12
#define DFLT_VAL_NX51_phy_control_phy1_mode           0x00006000U
#define DFLT_BF_VAL_NX51_phy_control_phy1_mode        0x00000006U
#define MSK_NX51_phy_control_phy1_fxmode              0x00010000U
#define SRT_NX51_phy_control_phy1_fxmode              16
#define DFLT_VAL_NX51_phy_control_phy1_fxmode         0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy1_fxmode      0x00000000U
#define MSK_NX51_phy_control_phy1_automdix            0x00020000U
#define SRT_NX51_phy_control_phy1_automdix            17
#define DFLT_VAL_NX51_phy_control_phy1_automdix       0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy1_automdix    0x00000000U
#define MSK_NX51_phy_control_phy1_enable              0x00200000U
#define SRT_NX51_phy_control_phy1_enable              21
#define DFLT_VAL_NX51_phy_control_phy1_enable         0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy1_enable      0x00000000U
#define MSK_NX51_phy_control_phy_address              0x0f000000U
#define SRT_NX51_phy_control_phy_address              24
#define DFLT_VAL_NX51_phy_control_phy_address         0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy_address      0x00000000U
#define MSK_NX51_phy_control_phy_inv_fo_fn_en         0x20000000U
#define SRT_NX51_phy_control_phy_inv_fo_fn_en         29
#define DFLT_VAL_NX51_phy_control_phy_inv_fo_fn_en    0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy_inv_fo_fn_en 0x00000000U
#define MSK_NX51_phy_control_phy_sim_byp              0x40000000U
#define SRT_NX51_phy_control_phy_sim_byp              30
#define DFLT_VAL_NX51_phy_control_phy_sim_byp         0x00000000U
#define DFLT_BF_VAL_NX51_phy_control_phy_sim_byp      0x00000000U
#define MSK_NX51_phy_control_phy_reset                0x80000000U
#define SRT_NX51_phy_control_phy_reset                31
#define DFLT_VAL_NX51_phy_control_phy_reset           0x80000000U
#define DFLT_BF_VAL_NX51_phy_control_phy_reset        0x00000001U

/* all used bits of 'NX51_phy_control': */
#define MSK_USED_BITS_NX51_phy_control 0xef23f23fU

enum {
	BFW_NX51_phy_control_phy0_mode        = 4, /* [3:0] */
	BFW_NX51_phy_control_phy0_fxmode      = 1, /* [4] */
	BFW_NX51_phy_control_phy0_automdix    = 1, /* [5] */
	BFW_NX51_phy_control_reserved1        = 3, /* [8:6] */
	BFW_NX51_phy_control_phy0_enable      = 1, /* [9] */
	BFW_NX51_phy_control_reserved2        = 2, /* [11:10] */
	BFW_NX51_phy_control_phy1_mode        = 4, /* [15:12] */
	BFW_NX51_phy_control_phy1_fxmode      = 1, /* [16] */
	BFW_NX51_phy_control_phy1_automdix    = 1, /* [17] */
	BFW_NX51_phy_control_reserved3        = 3, /* [20:18] */
	BFW_NX51_phy_control_phy1_enable      = 1, /* [21] */
	BFW_NX51_phy_control_reserved4        = 2, /* [23:22] */
	BFW_NX51_phy_control_phy_address      = 4, /* [27:24] */
	BFW_NX51_phy_control_reserved5        = 1, /* [28] */
	BFW_NX51_phy_control_phy_inv_fo_fn_en = 1, /* [29] */
	BFW_NX51_phy_control_phy_sim_byp      = 1, /* [30] */
	BFW_NX51_phy_control_phy_reset        = 1  /* [31] */
};

typedef struct NX51_PHY_CONTROL_BIT_Ttag {
	unsigned int phy0_mode        : BFW_NX51_phy_control_phy0_mode;        /* PHY0 Mode - TBD: Reset Wert 'Renesas: Don't use (This is for testing)' -> OK?:                  */
	                                                                       /* Default mode is 'power-down'.                                                                   */
	                                                                       /* {     |              |                   |                                                      */
	                                                                       /*  Mode   Speed          Duplex              Auto-Negotiation                                     */
	                                                                       /*  0000   10BaseT        Half                Auto-Negotiation disabled.                           */
	                                                                       /*  0001   10BaseT        Full                Auto-Negotiation disabled.                           */
	                                                                       /*  0010   100BaseTX/FX   Half                Auto-Negotiation disabled.                           */
	                                                                       /*                                            CRS is active during Transmit and Receive.           */
	                                                                       /*  0011   100BaseTX/FX   Full                Auto-Negotiation disabled.                           */
	                                                                       /*                                            CRS is active during Receive.                        */
	                                                                       /*  0100   100BaseT       Half                Auto-Negotiation enabled.                            */
	                                                                       /*                        advertised          CRS is active during Transmit and Receive.           */
	                                                                       /*  0101   100BaseT       Half                Auto-Negotiation enabled.                            */
	                                                                       /*         Repeater mode. advertised          CRS is active during Receive.                        */
	                                                                       /*  0110   Power Down.                        Power Down mode. In this mode the PHY wakes up       */
	                                                                       /*                                            in Power-Down mode.                                  */
	                                                                       /*                                            Don't use (This is for testing).                     */
	                                                                       /*  0111   All            Both                Auto-Negotiation enabled.                            */
	                                                                       /*  1000   All            Forced Full in      Quick Auto-Negotiation enabled,                      */
	                                                                       /*                        parallel detect     Bits 1 and 0 determine timing.                       */
	                                                                       /*  1001   All            Forced Full in      Quick Auto-Negotiation enabled,                      */
	                                                                       /*                        parallel detect     Bits 1 and 0 determine timing.                       */
	                                                                       /*  1010   All            Forced Full in      Quick Auto-Negotiation enabled,                      */
	                                                                       /*                        parallel detect     Bits 1 and 0 determine timing.                       */
	                                                                       /*  1011   All            Forced Full in      Quick Auto-Negotiation enabled,                      */
	                                                                       /*                        parallel detect     Bits 1 and 0 determine timing.                       */
	                                                                       /*                                            IEEE compatible timing                               */
	                                                                       /*  1100   All            Half in parallel    Quick Auto-Negotiation enabled,                      */
	                                                                       /*                        detect (standard)   Bits 1 and 0 determine timing.                       */
	                                                                       /*  1101   All            Half in parallel    Quick Auto-Negotiation enabled,                      */
	                                                                       /*                        detect (standard)   Bits 1 and 0 determine timing.                       */
	                                                                       /*  1110   All            Half in parallel    Quick Auto-Negotiation enabled.,                     */
	                                                                       /*                        detect (standard)   Bits 1 and 0 determine timing                        */
	                                                                       /*  1111   Loopback /                         Loopback mode. The Phy starts in loopback mode       */
	                                                                       /*         Isolate                            with the 0.14 bit set. In this mode the Phy must     */
	                                                                       /*                                            be configured through the SMI interface and          */
	                                                                       /*                                            manually enabled by clearing bit 0.14. Until then it */
	                                                                       /*                                            runs in loopback mode and is isolated from the       */
	                                                                       /*                                            line. Apart from Bit 0.14 the Phy is configured as   */
	                                                                       /*                                            with Phymode = 0111.}                                */
	unsigned int phy0_fxmode      : BFW_NX51_phy_control_phy0_fxmode;      /* PHY0 100BASE-FX mode (phy_mode must be 01x)                                                     */
	unsigned int phy0_automdix    : BFW_NX51_phy_control_phy0_automdix;    /* PHY0 Enables AutoMDIX state machine                                                             */
	unsigned int reserved1        : BFW_NX51_phy_control_reserved1;        /* reserved                                                                                        */
	unsigned int phy0_enable      : BFW_NX51_phy_control_phy0_enable;      /* PHY0 enable                                                                                     */
	unsigned int reserved2        : BFW_NX51_phy_control_reserved2;        /* reserved                                                                                        */
	unsigned int phy1_mode        : BFW_NX51_phy_control_phy1_mode;        /* PHY1 Mode:                                                                                      */
	                                                                       /* Coding is similar to phy0_mode.                                                                 */
	unsigned int phy1_fxmode      : BFW_NX51_phy_control_phy1_fxmode;      /* PHY1 100BASE-FX mode (phy_mode must be 01x)                                                     */
	unsigned int phy1_automdix    : BFW_NX51_phy_control_phy1_automdix;    /* PHY1 Enables AutoMDIX state machine                                                             */
	unsigned int reserved3        : BFW_NX51_phy_control_reserved3;        /* reserved                                                                                        */
	unsigned int phy1_enable      : BFW_NX51_phy_control_phy1_enable;      /* PHY1 enable                                                                                     */
	unsigned int reserved4        : BFW_NX51_phy_control_reserved4;        /* reserved                                                                                        */
	unsigned int phy_address      : BFW_NX51_phy_control_phy_address;      /* Bits 4:1 of PHY mdio-address.                                                                   */
	                                                                       /* Bit0 defines 1st or 2nd internal PHY                                                            */
	unsigned int reserved5        : BFW_NX51_phy_control_reserved5;        /* reserved                                                                                        */
	unsigned int phy_inv_fo_fn_en : BFW_NX51_phy_control_phy_inv_fo_fn_en; /* inverts Fiberoptic output enables fo0_fn_en and fo1_fn_en                                       */
	unsigned int phy_sim_byp      : BFW_NX51_phy_control_phy_sim_byp;      /* PHY Power up Bypass (only used for simulation issues)                                           */
	                                                                       /* 0: normal                                                                                       */
	                                                                       /* 1: bypass                                                                                       */
	                                                                       /* Bit is synchronized to phyclk and drives pwruprstbyp pin of PHY,                                */
	                                                                       /* which bypasses Power Up Reset of PHY for faster simulation.                                     */
	unsigned int phy_reset        : BFW_NX51_phy_control_phy_reset;        /* Hardware reset for PHY                                                                          */
	                                                                       /* 1: reset (connected to RESETB PHY input and inverted before)                                    */
} NX51_PHY_CONTROL_BIT_T;

typedef union {
	unsigned int           val;
	NX51_PHY_CONTROL_BIT_T bf;
} NX51_PHY_CONTROL_T;

/* --------------------------------------------------------------------- */
/* Register armclk_rate_mul_add */
/* => Rate Multiplier Add Value of System Clock: */
/*    This register might be used to change internal system frequency (100MHz of ARM and system). */
/*    Be careful when changing this value, as proper netX functionality is only qualified for the default value. */
/*    This register is lockable by netX locking algorithm. It will be only reset on Power on, not on normal system nres. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_armclk_rate_mul_add       0x00000018U
#define Adr_NX51_asic_ctrl_armclk_rate_mul_add 0x1018C118U
#define Adr_NX51_armclk_rate_mul_add           0x1018C118U
#define DFLT_VAL_NX51_armclk_rate_mul_add      0x00000100U

#define MSK_NX51_armclk_rate_mul_add_armclk_rate_mul_add         0x000001ffU
#define SRT_NX51_armclk_rate_mul_add_armclk_rate_mul_add         0
#define DFLT_VAL_NX51_armclk_rate_mul_add_armclk_rate_mul_add    0x00000100U
#define DFLT_BF_VAL_NX51_armclk_rate_mul_add_armclk_rate_mul_add 0x00000100U

/* all used bits of 'NX51_armclk_rate_mul_add': */
#define MSK_USED_BITS_NX51_armclk_rate_mul_add 0x000001ffU

enum {
	BFW_NX51_armclk_rate_mul_add_armclk_rate_mul_add = 9,  /* [8:0] */
	BFW_NX51_armclk_rate_mul_add_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_ARMCLK_RATE_MUL_ADD_BIT_Ttag {
	unsigned int armclk_rate_mul_add : BFW_NX51_armclk_rate_mul_add_armclk_rate_mul_add; /* This value is added each clk400 cycle to armclk_rate_mul to generate armclk.              */
	                                                                                     /* Change value according to formula:                                                        */
	                                                                                     /* armclk_rate_mul_add = [freq in MHz] / 200 * 2^9.                                          */
	                                                                                     /* Note: SDRAM data sampling loopback clock bypass is reconfiguret automatically             */
	                                                                                     /*       if clock rate is set below 80MHz (view SDRAM timing controll register description). */
	unsigned int reserved1           : BFW_NX51_armclk_rate_mul_add_reserved1;           /* reserved                                                                                  */
} NX51_ARMCLK_RATE_MUL_ADD_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_ARMCLK_RATE_MUL_ADD_BIT_T bf;
} NX51_ARMCLK_RATE_MUL_ADD_T;

/* --------------------------------------------------------------------- */
/* Register usb12clk_rate_mul_add */
/* => Rate Multiplier Add Value of 12MHz USB clock: */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb12clk_rate_mul_add       0x0000001CU
#define Adr_NX51_asic_ctrl_usb12clk_rate_mul_add 0x1018C11CU
#define Adr_NX51_usb12clk_rate_mul_add           0x1018C11CU
#define DFLT_VAL_NX51_usb12clk_rate_mul_add      0x000007aeU

#define MSK_NX51_usb12clk_rate_mul_add_usb12clk_rate_mul_add         0x0000ffffU
#define SRT_NX51_usb12clk_rate_mul_add_usb12clk_rate_mul_add         0
#define DFLT_VAL_NX51_usb12clk_rate_mul_add_usb12clk_rate_mul_add    0x000007aeU
#define DFLT_BF_VAL_NX51_usb12clk_rate_mul_add_usb12clk_rate_mul_add 0x000007aeU

/* all used bits of 'NX51_usb12clk_rate_mul_add': */
#define MSK_USED_BITS_NX51_usb12clk_rate_mul_add 0x0000ffffU

enum {
	BFW_NX51_usb12clk_rate_mul_add_usb12clk_rate_mul_add = 16, /* [15:0] */
	BFW_NX51_usb12clk_rate_mul_add_reserved1             = 16  /* [31:16] */
};

typedef struct NX51_USB12CLK_RATE_MUL_ADD_BIT_Ttag {
	unsigned int usb12clk_rate_mul_add : BFW_NX51_usb12clk_rate_mul_add_usb12clk_rate_mul_add; /* This value is added each clk400 cycle to usb12clk_rate_mul to generate usb12clk. */
	                                                                                           /* Change value according to formula:                                               */
	                                                                                           /* usb12clk_rate_mul_add = [freq in MHz] / 400 * 2^16                               */
	unsigned int reserved1             : BFW_NX51_usb12clk_rate_mul_add_reserved1;             /* reserved                                                                         */
} NX51_USB12CLK_RATE_MUL_ADD_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_USB12CLK_RATE_MUL_ADD_BIT_T bf;
} NX51_USB12CLK_RATE_MUL_ADD_T;

/* --------------------------------------------------------------------- */
/* Register fb0clk_rate_mul_add */
/* => Rate Multiplier Add Value: */
/*    Fieldbus0 clock is generated by internal 400MHz rate multiplier. \ */
/*    At some fieldbus-frequencies, this clock has less jitter, than the xMAC generated output clock. \ */
/*    xMAC fieldbus outputs (xm0_tx_out, xm0_tx_oe) can optionally (io_config-sel_xm0_eclk) be sampled by an extra register running on this clock, */
/*    resulting in jitter less fieldbus outputs. */
/*    Alternatively to this internally generated clock, an external clock (xm0_eclk) can be used to make xMAC outputs jitter free (clock_enable-fb0). \ */
/*    Using external clocks to resample xMAC outputs requires modified xMAC software. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/*    ------------------------------------ */
/*    netX100/netX500 usage of this address: adcclk_rate_mul_add */
/*    ------------------------------------ */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fb0clk_rate_mul_add       0x00000020U
#define Adr_NX51_asic_ctrl_fb0clk_rate_mul_add 0x1018C120U
#define Adr_NX51_fb0clk_rate_mul_add           0x1018C120U
#define DFLT_VAL_NX51_fb0clk_rate_mul_add      0x00000000U

#define MSK_NX51_fb0clk_rate_mul_add_fb0clk_rate_mul_add         0xffffffffU
#define SRT_NX51_fb0clk_rate_mul_add_fb0clk_rate_mul_add         0
#define DFLT_VAL_NX51_fb0clk_rate_mul_add_fb0clk_rate_mul_add    0x00000000U
#define DFLT_BF_VAL_NX51_fb0clk_rate_mul_add_fb0clk_rate_mul_add 0x00000000U

/* all used bits of 'NX51_fb0clk_rate_mul_add': */
#define MSK_USED_BITS_NX51_fb0clk_rate_mul_add 0xffffffffU

enum {
	BFW_NX51_fb0clk_rate_mul_add_fb0clk_rate_mul_add = 32  /* [31:0] */
};

typedef struct NX51_FB0CLK_RATE_MUL_ADD_BIT_Ttag {
	unsigned int fb0clk_rate_mul_add : BFW_NX51_fb0clk_rate_mul_add_fb0clk_rate_mul_add; /* This value is added each clk400 cycle to fb0clk_rate_mul to generate fb0clk.                                */
	                                                                                     /* Values bigger 0x80000000 are not allowed for proper rate_mul functionality.                                 */
	                                                                                     /* fb0clk_rate_mul_add[31:30] == 2'b11 define a special mode, where rate_mul is is forwarding its input clock. */
	                                                                                     /* Change value according to formula:                                                                          */
	                                                                                     /* fb0clk_rate_mul_add = [freq in MHz] / 400 * 2^32 * (fb0clk_div+1)                                           */
} NX51_FB0CLK_RATE_MUL_ADD_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_FB0CLK_RATE_MUL_ADD_BIT_T bf;
} NX51_FB0CLK_RATE_MUL_ADD_T;

/* --------------------------------------------------------------------- */
/* Register fb0clk_div */
/* => Rate Multiplier Predivider: */
/*    Fieldbus0 clock is generated from internal 400MHz by a predivider combined with a rate multiplier. \ */
/*    At some fieldbus-frequencies, this clock has less jitter, than the xMAC generated output clock. \ */
/*    xMAC fieldbus output (xm0_tx_out) can optionally (io_config-sel_xm0_eclk) be sampled by an extra register running on this clock, */
/*    resulting in jitter less fieldbus outputs. */
/*    Alternatively to this internally generated clock, an external clock (xm0_eclk) can be used to make xMAC output jitter free (clock_enable-fb0). \ */
/*    Using external clocks to resample xMAC outputs requires modified xMAC software. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fb0clk_div       0x00000024U
#define Adr_NX51_asic_ctrl_fb0clk_div 0x1018C124U
#define Adr_NX51_fb0clk_div           0x1018C124U
#define DFLT_VAL_NX51_fb0clk_div      0x00000000U

#define MSK_NX51_fb0clk_div_val         0x000000ffU
#define SRT_NX51_fb0clk_div_val         0
#define DFLT_VAL_NX51_fb0clk_div_val    0x00000000U
#define DFLT_BF_VAL_NX51_fb0clk_div_val 0x00000000U

/* all used bits of 'NX51_fb0clk_div': */
#define MSK_USED_BITS_NX51_fb0clk_div 0x000000ffU

enum {
	BFW_NX51_fb0clk_div_val       = 8,  /* [7:0] */
	BFW_NX51_fb0clk_div_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_FB0CLK_DIV_BIT_Ttag {
	unsigned int val       : BFW_NX51_fb0clk_div_val;       /* Fieldbus 0 Predivider value:                                         */
	                                                        /* The value + 1 must be programmed, i.e. val=0 leads to no predivision */
	                                                        /* Change value according to formula:                                   */
	                                                        /* fb0clk_div = (400 / [freq in MHz] * fb0clk_rate_mul_add / 2^32) - 1  */
	unsigned int reserved1 : BFW_NX51_fb0clk_div_reserved1; /* reserved                                                             */
} NX51_FB0CLK_DIV_BIT_T;

typedef union {
	unsigned int          val;
	NX51_FB0CLK_DIV_BIT_T bf;
} NX51_FB0CLK_DIV_T;

/* --------------------------------------------------------------------- */
/* Register fb1clk_rate_mul_add */
/* => Rate Multiplier Add Value: */
/*    Fieldbus0 clock is generated by internal 400MHz rate multiplier. \ */
/*    At some fieldbus-frequencies, this clock has less jitter, than the xMAC generated output clock. \ */
/*    xMAC fieldbus outputs (xm1_tx_out, xm1_tx_oe) can optionally (io_config-sel_xm1_eclk) be sampled by an extra register running on this clock, */
/*    resulting in jitter less fieldbus outputs. */
/*    Alternatively to this internally generated clock, an external clock (xm1_eclk) can be used to make xMAC outputs jitter free (clock_enable-fb1). \ */
/*    Using external clocks to resample xMAC outputs requires modified xMAC software. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fb1clk_rate_mul_add       0x00000028U
#define Adr_NX51_asic_ctrl_fb1clk_rate_mul_add 0x1018C128U
#define Adr_NX51_fb1clk_rate_mul_add           0x1018C128U
#define DFLT_VAL_NX51_fb1clk_rate_mul_add      0x00000000U

#define MSK_NX51_fb1clk_rate_mul_add_fb1clk_rate_mul_add         0xffffffffU
#define SRT_NX51_fb1clk_rate_mul_add_fb1clk_rate_mul_add         0
#define DFLT_VAL_NX51_fb1clk_rate_mul_add_fb1clk_rate_mul_add    0x00000000U
#define DFLT_BF_VAL_NX51_fb1clk_rate_mul_add_fb1clk_rate_mul_add 0x00000000U

/* all used bits of 'NX51_fb1clk_rate_mul_add': */
#define MSK_USED_BITS_NX51_fb1clk_rate_mul_add 0xffffffffU

enum {
	BFW_NX51_fb1clk_rate_mul_add_fb1clk_rate_mul_add = 32  /* [31:0] */
};

typedef struct NX51_FB1CLK_RATE_MUL_ADD_BIT_Ttag {
	unsigned int fb1clk_rate_mul_add : BFW_NX51_fb1clk_rate_mul_add_fb1clk_rate_mul_add; /* This value is added each clk400 cycle to fb1clk_rate_mul to generate fb1clk.                                */
	                                                                                     /* Values bigger 0x80000000 are not allowed for proper rate_mul functionality.                                 */
	                                                                                     /* fb1clk_rate_mul_add[31:30] == 2'b11 define a special mode, where rate_mul is is forwarding its input clock. */
	                                                                                     /* Change value according to formula:                                                                          */
	                                                                                     /* fb1clk_rate_mul_add = [freq in MHz] / 400 * 2^32 * (fb1clk_div+1)                                           */
} NX51_FB1CLK_RATE_MUL_ADD_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_FB1CLK_RATE_MUL_ADD_BIT_T bf;
} NX51_FB1CLK_RATE_MUL_ADD_T;

/* --------------------------------------------------------------------- */
/* Register fb1clk_div */
/* => Rate Multiplier Predivider: */
/*    Fieldbus1 clock is generated from internal 400MHz by a predivider combined with a rate multiplier. \ */
/*    At some fieldbus-frequencies, this clock has less jitter, than the xMAC generated output clock. \ */
/*    xMAC fieldbus output (xm1_tx_out) can optionally (io_config-sel_xm1_eclk) be sampled by an extra register running on this clock, */
/*    resulting in jitter less fieldbus outputs. */
/*    Alternatively to this internally generated clock, an external clock (xm1_eclk) can be used to make xMAC output jitter free (clock_enable-fb1). \ */
/*    Using external clocks to resample xMAC outputs requires modified xMAC software. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_fb1clk_div       0x0000002CU
#define Adr_NX51_asic_ctrl_fb1clk_div 0x1018C12CU
#define Adr_NX51_fb1clk_div           0x1018C12CU
#define DFLT_VAL_NX51_fb1clk_div      0x00000000U

#define MSK_NX51_fb1clk_div_val         0x000000ffU
#define SRT_NX51_fb1clk_div_val         0
#define DFLT_VAL_NX51_fb1clk_div_val    0x00000000U
#define DFLT_BF_VAL_NX51_fb1clk_div_val 0x00000000U

/* all used bits of 'NX51_fb1clk_div': */
#define MSK_USED_BITS_NX51_fb1clk_div 0x000000ffU

enum {
	BFW_NX51_fb1clk_div_val       = 8,  /* [7:0] */
	BFW_NX51_fb1clk_div_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_FB1CLK_DIV_BIT_Ttag {
	unsigned int val       : BFW_NX51_fb1clk_div_val;       /* Fieldbus 1 Predivider value:                                         */
	                                                        /* The value + 1 must be programmed, i.e. val=0 leads to no predivision */
	                                                        /* Change value according to formula:                                   */
	                                                        /* fb1clk_div = (400 / [freq in MHz] * fb1clk_rate_mul_add / 2^32) - 1  */
	unsigned int reserved1 : BFW_NX51_fb1clk_div_reserved1; /* reserved                                                             */
} NX51_FB1CLK_DIV_BIT_T;

typedef union {
	unsigned int          val;
	NX51_FB1CLK_DIV_BIT_T bf;
} NX51_FB1CLK_DIV_T;

/* --------------------------------------------------------------------- */
/* Register clkout_rate_mul_add */
/* => Rate Multiplier Add Value: */
/*    Clkout clock is generated by internal 400MHz rate multiplier. \ */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_clkout_rate_mul_add       0x00000030U
#define Adr_NX51_asic_ctrl_clkout_rate_mul_add 0x1018C130U
#define Adr_NX51_clkout_rate_mul_add           0x1018C130U
#define DFLT_VAL_NX51_clkout_rate_mul_add      0x00000000U

#define MSK_NX51_clkout_rate_mul_add_clkout_rate_mul_add         0xffffffffU
#define SRT_NX51_clkout_rate_mul_add_clkout_rate_mul_add         0
#define DFLT_VAL_NX51_clkout_rate_mul_add_clkout_rate_mul_add    0x00000000U
#define DFLT_BF_VAL_NX51_clkout_rate_mul_add_clkout_rate_mul_add 0x00000000U

/* all used bits of 'NX51_clkout_rate_mul_add': */
#define MSK_USED_BITS_NX51_clkout_rate_mul_add 0xffffffffU

enum {
	BFW_NX51_clkout_rate_mul_add_clkout_rate_mul_add = 32  /* [31:0] */
};

typedef struct NX51_CLKOUT_RATE_MUL_ADD_BIT_Ttag {
	unsigned int clkout_rate_mul_add : BFW_NX51_clkout_rate_mul_add_clkout_rate_mul_add; /* This value is added each clk400 cycle to clkout_rate_mul to generate clkout.                                */
	                                                                                     /* Values bigger 0x80000000 are not allowed for proper rate_mul functionality.                                 */
	                                                                                     /* clkout_rate_mul_add[31:30] == 2'b11 define a special mode, where rate_mul is is forwarding its input clock. */
	                                                                                     /* Change value according to formula:                                                                          */
	                                                                                     /* clkout_rate_mul_add = [freq in MHz] / 400 * 2^32 * (clkout_div+1)                                           */
} NX51_CLKOUT_RATE_MUL_ADD_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_CLKOUT_RATE_MUL_ADD_BIT_T bf;
} NX51_CLKOUT_RATE_MUL_ADD_T;

/* --------------------------------------------------------------------- */
/* Register clkout_div */
/* => Rate Multiplier Predivider: */
/*    Clkout clock is generated from internal 400MHz by a predivider combined with a rate multiplier. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out Locking access-key */
/*    2.: write back Locking access-key */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_clkout_div       0x00000034U
#define Adr_NX51_asic_ctrl_clkout_div 0x1018C134U
#define Adr_NX51_clkout_div           0x1018C134U
#define DFLT_VAL_NX51_clkout_div      0x00000000U

#define MSK_NX51_clkout_div_val         0x000000ffU
#define SRT_NX51_clkout_div_val         0
#define DFLT_VAL_NX51_clkout_div_val    0x00000000U
#define DFLT_BF_VAL_NX51_clkout_div_val 0x00000000U

/* all used bits of 'NX51_clkout_div': */
#define MSK_USED_BITS_NX51_clkout_div 0x000000ffU

enum {
	BFW_NX51_clkout_div_val       = 8,  /* [7:0] */
	BFW_NX51_clkout_div_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CLKOUT_DIV_BIT_Ttag {
	unsigned int val       : BFW_NX51_clkout_div_val;       /* clkout Predivider value:                                             */
	                                                        /* The value + 1 must be programmed, i.e. val=0 leads to no predivision */
	                                                        /* Change value according to formula:                                   */
	                                                        /* clkout_div = (400 / [freq in MHz] * clkout_rate_mul_add / 2^32) - 1  */
	unsigned int reserved1 : BFW_NX51_clkout_div_reserved1; /* reserved                                                             */
} NX51_CLKOUT_DIV_BIT_T;

typedef union {
	unsigned int          val;
	NX51_CLKOUT_DIV_BIT_T bf;
} NX51_CLKOUT_DIV_T;

/* --------------------------------------------------------------------- */
/* Register clock_enable */
/* => Global Clock Enable Register: */
/*    Use this registers to disable modules completely for power saving purposes. */
/*    Changes will only have effect if according bit in clock_enable_mask-register is set. \ */
/*    Bits will be reset according to the clock_enable_mask-register register, if a new mask is correctly written (netX locking algorithm). */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    Note: for low power consumption at power on, all switchable clocks are disabled after reset and mus be enabled before module usage. */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_clock_enable       0x00000038U
#define Adr_NX51_asic_ctrl_clock_enable 0x1018C138U
#define Adr_NX51_clock_enable           0x1018C138U
#define DFLT_VAL_NX51_clock_enable      0x00000000U

#define MSK_NX51_clock_enable_rpec0           0x00000001U
#define SRT_NX51_clock_enable_rpec0           0
#define DFLT_VAL_NX51_clock_enable_rpec0      0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_rpec0   0x00000000U
#define MSK_NX51_clock_enable_rpec1           0x00000002U
#define SRT_NX51_clock_enable_rpec1           1
#define DFLT_VAL_NX51_clock_enable_rpec1      0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_rpec1   0x00000000U
#define MSK_NX51_clock_enable_tpec0           0x00000010U
#define SRT_NX51_clock_enable_tpec0           4
#define DFLT_VAL_NX51_clock_enable_tpec0      0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_tpec0   0x00000000U
#define MSK_NX51_clock_enable_tpec1           0x00000020U
#define SRT_NX51_clock_enable_tpec1           5
#define DFLT_VAL_NX51_clock_enable_tpec1      0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_tpec1   0x00000000U
#define MSK_NX51_clock_enable_xmac0           0x00000100U
#define SRT_NX51_clock_enable_xmac0           8
#define DFLT_VAL_NX51_clock_enable_xmac0      0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_xmac0   0x00000000U
#define MSK_NX51_clock_enable_xmac1           0x00000200U
#define SRT_NX51_clock_enable_xmac1           9
#define DFLT_VAL_NX51_clock_enable_xmac1      0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_xmac1   0x00000000U
#define MSK_NX51_clock_enable_fb0             0x00001000U
#define SRT_NX51_clock_enable_fb0             12
#define DFLT_VAL_NX51_clock_enable_fb0        0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_fb0     0x00000000U
#define MSK_NX51_clock_enable_fb1             0x00002000U
#define SRT_NX51_clock_enable_fb1             13
#define DFLT_VAL_NX51_clock_enable_fb1        0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_fb1     0x00000000U
#define MSK_NX51_clock_enable_xc_misc         0x00010000U
#define SRT_NX51_clock_enable_xc_misc         16
#define DFLT_VAL_NX51_clock_enable_xc_misc    0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_xc_misc 0x00000000U
#define MSK_NX51_clock_enable_xpic            0x00020000U
#define SRT_NX51_clock_enable_xpic            17
#define DFLT_VAL_NX51_clock_enable_xpic       0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_xpic    0x00000000U
#define MSK_NX51_clock_enable_dma             0x00040000U
#define SRT_NX51_clock_enable_dma             18
#define DFLT_VAL_NX51_clock_enable_dma        0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_dma     0x00000000U
#define MSK_NX51_clock_enable_dpm             0x00080000U
#define SRT_NX51_clock_enable_dpm             19
#define DFLT_VAL_NX51_clock_enable_dpm        0x00000000U
#define DFLT_BF_VAL_NX51_clock_enable_dpm     0x00000000U

/* all used bits of 'NX51_clock_enable': */
#define MSK_USED_BITS_NX51_clock_enable 0x000f3333U

enum {
	BFW_NX51_clock_enable_rpec0     = 1,  /* [0] */
	BFW_NX51_clock_enable_rpec1     = 1,  /* [1] */
	BFW_NX51_clock_enable_reserved1 = 2,  /* [3:2] */
	BFW_NX51_clock_enable_tpec0     = 1,  /* [4] */
	BFW_NX51_clock_enable_tpec1     = 1,  /* [5] */
	BFW_NX51_clock_enable_reserved2 = 2,  /* [7:6] */
	BFW_NX51_clock_enable_xmac0     = 1,  /* [8] */
	BFW_NX51_clock_enable_xmac1     = 1,  /* [9] */
	BFW_NX51_clock_enable_reserved3 = 2,  /* [11:10] */
	BFW_NX51_clock_enable_fb0       = 1,  /* [12] */
	BFW_NX51_clock_enable_fb1       = 1,  /* [13] */
	BFW_NX51_clock_enable_reserved4 = 2,  /* [15:14] */
	BFW_NX51_clock_enable_xc_misc   = 1,  /* [16] */
	BFW_NX51_clock_enable_xpic      = 1,  /* [17] */
	BFW_NX51_clock_enable_dma       = 1,  /* [18] */
	BFW_NX51_clock_enable_dpm       = 1,  /* [19] */
	BFW_NX51_clock_enable_reserved5 = 12  /* [31:20] */
};

typedef struct NX51_CLOCK_ENABLE_BIT_Ttag {
	unsigned int rpec0     : BFW_NX51_clock_enable_rpec0;     /* enables clock for rPEC0                                      */
	unsigned int rpec1     : BFW_NX51_clock_enable_rpec1;     /* enables clock for rPEC1                                      */
	unsigned int reserved1 : BFW_NX51_clock_enable_reserved1; /* reserved                                                     */
	unsigned int tpec0     : BFW_NX51_clock_enable_tpec0;     /* enables clock for tPEC0                                      */
	unsigned int tpec1     : BFW_NX51_clock_enable_tpec1;     /* enables clock for tPEC1                                      */
	unsigned int reserved2 : BFW_NX51_clock_enable_reserved2; /* reserved                                                     */
	unsigned int xmac0     : BFW_NX51_clock_enable_xmac0;     /* enables clock for xMAC0                                      */
	unsigned int xmac1     : BFW_NX51_clock_enable_xmac1;     /* enables clock for xMAC1                                      */
	unsigned int reserved3 : BFW_NX51_clock_enable_reserved3; /* reserved                                                     */
	unsigned int fb0       : BFW_NX51_clock_enable_fb0;       /* enables clock for fieldbus0                                  */
	                                                          /* 1: use internally generated fb0clk to resample xMAC0 outputs */
	                                                          /* 0: use external xm0_eclk to resample xMAC outputs            */
	unsigned int fb1       : BFW_NX51_clock_enable_fb1;       /* enables clock for fieldbus1                                  */
	                                                          /* 1: use internally generated fb1clk to resample xMAC1 outputs */
	                                                          /* 0: use external xm1_eclk to resample xMAC outputs            */
	unsigned int reserved4 : BFW_NX51_clock_enable_reserved4; /* reserved                                                     */
	unsigned int xc_misc   : BFW_NX51_clock_enable_xc_misc;   /* enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN  */
	unsigned int xpic      : BFW_NX51_clock_enable_xpic;      /* enables clock for XPIC                                       */
	unsigned int dma       : BFW_NX51_clock_enable_dma;       /* enables clock for DMA-Ctrl                                   */
	unsigned int dpm       : BFW_NX51_clock_enable_dpm;       /* enables clock for DPM                                        */
	unsigned int reserved5 : BFW_NX51_clock_enable_reserved5; /* reserved                                                     */
} NX51_CLOCK_ENABLE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_CLOCK_ENABLE_BIT_T bf;
} NX51_CLOCK_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register clock_enable_mask */
/* => Global Clock Enable Mask Register: */
/*    allows to disable modules for different netX-versions */
/*    This register is lockable by netX locking algorithm. It will be only reset on Power on, not on normal system nres. */
/*    The clock_enable-register will change according to this register if a new mask is correctly written (netX locking algorithm). */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_clock_enable_mask       0x0000003CU
#define Adr_NX51_asic_ctrl_clock_enable_mask 0x1018C13CU
#define Adr_NX51_clock_enable_mask           0x1018C13CU
#define DFLT_VAL_NX51_clock_enable_mask      0x000f3333U

#define MSK_NX51_clock_enable_mask_rpec0           0x00000001U
#define SRT_NX51_clock_enable_mask_rpec0           0
#define DFLT_VAL_NX51_clock_enable_mask_rpec0      0x00000001U
#define DFLT_BF_VAL_NX51_clock_enable_mask_rpec0   0x00000001U
#define MSK_NX51_clock_enable_mask_rpec1           0x00000002U
#define SRT_NX51_clock_enable_mask_rpec1           1
#define DFLT_VAL_NX51_clock_enable_mask_rpec1      0x00000002U
#define DFLT_BF_VAL_NX51_clock_enable_mask_rpec1   0x00000001U
#define MSK_NX51_clock_enable_mask_tpec0           0x00000010U
#define SRT_NX51_clock_enable_mask_tpec0           4
#define DFLT_VAL_NX51_clock_enable_mask_tpec0      0x00000010U
#define DFLT_BF_VAL_NX51_clock_enable_mask_tpec0   0x00000001U
#define MSK_NX51_clock_enable_mask_tpec1           0x00000020U
#define SRT_NX51_clock_enable_mask_tpec1           5
#define DFLT_VAL_NX51_clock_enable_mask_tpec1      0x00000020U
#define DFLT_BF_VAL_NX51_clock_enable_mask_tpec1   0x00000001U
#define MSK_NX51_clock_enable_mask_xmac0           0x00000100U
#define SRT_NX51_clock_enable_mask_xmac0           8
#define DFLT_VAL_NX51_clock_enable_mask_xmac0      0x00000100U
#define DFLT_BF_VAL_NX51_clock_enable_mask_xmac0   0x00000001U
#define MSK_NX51_clock_enable_mask_xmac1           0x00000200U
#define SRT_NX51_clock_enable_mask_xmac1           9
#define DFLT_VAL_NX51_clock_enable_mask_xmac1      0x00000200U
#define DFLT_BF_VAL_NX51_clock_enable_mask_xmac1   0x00000001U
#define MSK_NX51_clock_enable_mask_fb0             0x00001000U
#define SRT_NX51_clock_enable_mask_fb0             12
#define DFLT_VAL_NX51_clock_enable_mask_fb0        0x00001000U
#define DFLT_BF_VAL_NX51_clock_enable_mask_fb0     0x00000001U
#define MSK_NX51_clock_enable_mask_fb1             0x00002000U
#define SRT_NX51_clock_enable_mask_fb1             13
#define DFLT_VAL_NX51_clock_enable_mask_fb1        0x00002000U
#define DFLT_BF_VAL_NX51_clock_enable_mask_fb1     0x00000001U
#define MSK_NX51_clock_enable_mask_xc_misc         0x00010000U
#define SRT_NX51_clock_enable_mask_xc_misc         16
#define DFLT_VAL_NX51_clock_enable_mask_xc_misc    0x00010000U
#define DFLT_BF_VAL_NX51_clock_enable_mask_xc_misc 0x00000001U
#define MSK_NX51_clock_enable_mask_xpic            0x00020000U
#define SRT_NX51_clock_enable_mask_xpic            17
#define DFLT_VAL_NX51_clock_enable_mask_xpic       0x00020000U
#define DFLT_BF_VAL_NX51_clock_enable_mask_xpic    0x00000001U
#define MSK_NX51_clock_enable_mask_dma             0x00040000U
#define SRT_NX51_clock_enable_mask_dma             18
#define DFLT_VAL_NX51_clock_enable_mask_dma        0x00040000U
#define DFLT_BF_VAL_NX51_clock_enable_mask_dma     0x00000001U
#define MSK_NX51_clock_enable_mask_dpm             0x00080000U
#define SRT_NX51_clock_enable_mask_dpm             19
#define DFLT_VAL_NX51_clock_enable_mask_dpm        0x00080000U
#define DFLT_BF_VAL_NX51_clock_enable_mask_dpm     0x00000001U

/* all used bits of 'NX51_clock_enable_mask': */
#define MSK_USED_BITS_NX51_clock_enable_mask 0x000f3333U

enum {
	BFW_NX51_clock_enable_mask_rpec0     = 1,  /* [0] */
	BFW_NX51_clock_enable_mask_rpec1     = 1,  /* [1] */
	BFW_NX51_clock_enable_mask_reserved1 = 2,  /* [3:2] */
	BFW_NX51_clock_enable_mask_tpec0     = 1,  /* [4] */
	BFW_NX51_clock_enable_mask_tpec1     = 1,  /* [5] */
	BFW_NX51_clock_enable_mask_reserved2 = 2,  /* [7:6] */
	BFW_NX51_clock_enable_mask_xmac0     = 1,  /* [8] */
	BFW_NX51_clock_enable_mask_xmac1     = 1,  /* [9] */
	BFW_NX51_clock_enable_mask_reserved3 = 2,  /* [11:10] */
	BFW_NX51_clock_enable_mask_fb0       = 1,  /* [12] */
	BFW_NX51_clock_enable_mask_fb1       = 1,  /* [13] */
	BFW_NX51_clock_enable_mask_reserved4 = 2,  /* [15:14] */
	BFW_NX51_clock_enable_mask_xc_misc   = 1,  /* [16] */
	BFW_NX51_clock_enable_mask_xpic      = 1,  /* [17] */
	BFW_NX51_clock_enable_mask_dma       = 1,  /* [18] */
	BFW_NX51_clock_enable_mask_dpm       = 1,  /* [19] */
	BFW_NX51_clock_enable_mask_reserved5 = 12  /* [31:20] */
};

typedef struct NX51_CLOCK_ENABLE_MASK_BIT_Ttag {
	unsigned int rpec0     : BFW_NX51_clock_enable_mask_rpec0;     /* enables clock for rPEC0                                      */
	unsigned int rpec1     : BFW_NX51_clock_enable_mask_rpec1;     /* enables clock for rPEC1                                      */
	unsigned int reserved1 : BFW_NX51_clock_enable_mask_reserved1; /* reserved                                                     */
	unsigned int tpec0     : BFW_NX51_clock_enable_mask_tpec0;     /* enables clock for tPEC0                                      */
	unsigned int tpec1     : BFW_NX51_clock_enable_mask_tpec1;     /* enables clock for tPEC1                                      */
	unsigned int reserved2 : BFW_NX51_clock_enable_mask_reserved2; /* reserved                                                     */
	unsigned int xmac0     : BFW_NX51_clock_enable_mask_xmac0;     /* enables clock for xMAC0                                      */
	unsigned int xmac1     : BFW_NX51_clock_enable_mask_xmac1;     /* enables clock for xMAC1                                      */
	unsigned int reserved3 : BFW_NX51_clock_enable_mask_reserved3; /* reserved                                                     */
	unsigned int fb0       : BFW_NX51_clock_enable_mask_fb0;       /* enables clock for fieldbus0                                  */
	                                                               /* 1: use internally generated fb0clk to resample xMAC0 outputs */
	                                                               /* 0: use external xm0_eclk to resample xMAC outputs            */
	unsigned int fb1       : BFW_NX51_clock_enable_mask_fb1;       /* enables clock for fieldbus1                                  */
	                                                               /* 1: use internally generated fb1clk to resample xMAC1 outputs */
	                                                               /* 0: use external xm1_eclk to resample xMAC outputs            */
	unsigned int reserved4 : BFW_NX51_clock_enable_mask_reserved4; /* reserved                                                     */
	unsigned int xc_misc   : BFW_NX51_clock_enable_mask_xc_misc;   /* enables clock for misc. XC logic (XC-DMAC, XC-SR, XC-BUFMAN  */
	unsigned int xpic      : BFW_NX51_clock_enable_mask_xpic;      /* enables clock for XPIC                                       */
	unsigned int dma       : BFW_NX51_clock_enable_mask_dma;       /* enables clock for DMA-Ctrl                                   */
	unsigned int dpm       : BFW_NX51_clock_enable_mask_dpm;       /* enables clock for DPM                                        */
	unsigned int reserved5 : BFW_NX51_clock_enable_mask_reserved5; /* reserved                                                     */
} NX51_CLOCK_ENABLE_MASK_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_CLOCK_ENABLE_MASK_BIT_T bf;
} NX51_CLOCK_ENABLE_MASK_T;

/* --------------------------------------------------------------------- */
/* Register misc_asic_ctrl */
/* => Miscellaneous ASIC Control Register: */
/*    This register is lockable by netX locking algorithm. It will be only reset on Power on, not on normal system nres. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_misc_asic_ctrl       0x00000040U
#define Adr_NX51_asic_ctrl_misc_asic_ctrl 0x1018C140U
#define Adr_NX51_misc_asic_ctrl           0x1018C140U
#define DFLT_VAL_NX51_misc_asic_ctrl      0x80000061U

#define MSK_NX51_misc_asic_ctrl_arm_dbgen                0x00000001U
#define SRT_NX51_misc_asic_ctrl_arm_dbgen                0
#define DFLT_VAL_NX51_misc_asic_ctrl_arm_dbgen           0x00000001U
#define DFLT_BF_VAL_NX51_misc_asic_ctrl_arm_dbgen        0x00000001U
#define MSK_NX51_misc_asic_ctrl_sysdebug_ir              0x000000f0U
#define SRT_NX51_misc_asic_ctrl_sysdebug_ir              4
#define DFLT_VAL_NX51_misc_asic_ctrl_sysdebug_ir         0x00000060U
#define DFLT_BF_VAL_NX51_misc_asic_ctrl_sysdebug_ir      0x00000006U
#define MSK_NX51_misc_asic_ctrl_lic_err_taint_en         0x00000100U
#define SRT_NX51_misc_asic_ctrl_lic_err_taint_en         8
#define DFLT_VAL_NX51_misc_asic_ctrl_lic_err_taint_en    0x00000000U
#define DFLT_BF_VAL_NX51_misc_asic_ctrl_lic_err_taint_en 0x00000000U
#define MSK_NX51_misc_asic_ctrl_lic_err_abort_en         0x00000200U
#define SRT_NX51_misc_asic_ctrl_lic_err_abort_en         9
#define DFLT_VAL_NX51_misc_asic_ctrl_lic_err_abort_en    0x00000000U
#define DFLT_BF_VAL_NX51_misc_asic_ctrl_lic_err_abort_en 0x00000000U
#define MSK_NX51_misc_asic_ctrl_lic_err_irq_en           0x00000400U
#define SRT_NX51_misc_asic_ctrl_lic_err_irq_en           10
#define DFLT_VAL_NX51_misc_asic_ctrl_lic_err_irq_en      0x00000000U
#define DFLT_BF_VAL_NX51_misc_asic_ctrl_lic_err_irq_en   0x00000000U
#define MSK_NX51_misc_asic_ctrl_lic_err_delay_en         0x00000800U
#define SRT_NX51_misc_asic_ctrl_lic_err_delay_en         11
#define DFLT_VAL_NX51_misc_asic_ctrl_lic_err_delay_en    0x00000000U
#define DFLT_BF_VAL_NX51_misc_asic_ctrl_lic_err_delay_en 0x00000000U
#define MSK_NX51_misc_asic_ctrl_netx50_io_comp           0x80000000U
#define SRT_NX51_misc_asic_ctrl_netx50_io_comp           31
#define DFLT_VAL_NX51_misc_asic_ctrl_netx50_io_comp      0x80000000U
#define DFLT_BF_VAL_NX51_misc_asic_ctrl_netx50_io_comp   0x00000001U

/* all used bits of 'NX51_misc_asic_ctrl': */
#define MSK_USED_BITS_NX51_misc_asic_ctrl 0x80000ff1U

enum {
	BFW_NX51_misc_asic_ctrl_arm_dbgen        = 1,  /* [0] */
	BFW_NX51_misc_asic_ctrl_reserved1        = 3,  /* [3:1] */
	BFW_NX51_misc_asic_ctrl_sysdebug_ir      = 4,  /* [7:4] */
	BFW_NX51_misc_asic_ctrl_lic_err_taint_en = 1,  /* [8] */
	BFW_NX51_misc_asic_ctrl_lic_err_abort_en = 1,  /* [9] */
	BFW_NX51_misc_asic_ctrl_lic_err_irq_en   = 1,  /* [10] */
	BFW_NX51_misc_asic_ctrl_lic_err_delay_en = 1,  /* [11] */
	BFW_NX51_misc_asic_ctrl_reserved2        = 19, /* [30:12] */
	BFW_NX51_misc_asic_ctrl_netx50_io_comp   = 1   /* [31] */
};

typedef struct NX51_MISC_ASIC_CTRL_BIT_Ttag {
	unsigned int arm_dbgen        : BFW_NX51_misc_asic_ctrl_arm_dbgen;        /* ARM debug enable.                                                                                                             */
	                                                                          /*   1: ARM debug features are enabled                                                                                           */
	                                                                          /*   0: ARM debug features are disabled                                                                                          */
	unsigned int reserved1        : BFW_NX51_misc_asic_ctrl_reserved1;        /* reserved                                                                                                                      */
	unsigned int sysdebug_ir      : BFW_NX51_misc_asic_ctrl_sysdebug_ir;      /* JTAG Instruction for SYSDEBUG usage.                                                                                          */
	                                                                          /* SYSDEBUG is inserted in JTAG DR-shift when this instruction was programmed to                                                 */
	                                                                          /* ARM TAP controller. SYSDEBUG TDO will be asserted to netX JTAG_TDO port then.                                                 */
	                                                                          /* An ARM-unused instruction must be selected for proper working, e.g. 0x6.                                                      */
	                                                                          /* Programming 0x0 here will disable SYSDEBUG function. SYSDEBUG will also be disabled                                           */
	                                                                          /* while ROM-watchdog (adr_rom_wdg, OM is hidden, hide_rom) is running or 'arm_dbgen' is not set.                                */
	                                                                          /* ATTENTION: Default entry here (IR=6) collides with ARM ETM9 used instruction.                                                 */
	                                                                          /*            Set another ARM-unused value here, e.g. 0xa                                                                        */
	                                                                          /* ARM9 used TAR-IR values:                                                                                                      */
	                                                                          /* {               |       |     |                                                                                               */
	                                                                          /*   Instruction     Value   hex   Comment                                                                                       */
	                                                                          /*   EXTEST           0000   0x0   public                                                                                        */
	                                                                          /*   SCAN_N           0010   0x2   public                                                                                        */
	                                                                          /*   SAMPLE_PRELOAD   0011   0x3   public                                                                                        */
	                                                                          /*   RESTART          0100   0x4   public                                                                                        */
	                                                                          /*   ETM9             0110   0x6   public                                                                                        */
	                                                                          /*   CLAMP            0101   0x5   used only in some ARM CPUs, could be private, better don't use.                               */
	                                                                          /*   HIGHZ            0111   0x7   used only in some ARM CPUs, could be private, better don't use.                               */
	                                                                          /*   CLAMPZ           1001   0x9   used only in some ARM CPUs, could be private, better don't use.                               */
	                                                                          /*   SYSDEBUG         1010   0xa   recommended IR for SYSDEBUG                                                                   */
	                                                                          /*   INTEST           1100   0xc   public                                                                                        */
	                                                                          /*   IDCODE           1110   0xe   public                                                                                        */
	                                                                          /*   BYPASS           1111   0xf   public}                                                                                       */
	                                                                          /* When the value programmed in sysdebug_ir is written to ARM TAP by JTAG, SYSDEBUG-TDO will be multiplexed                      */
	                                                                          /* to netX port JT_TDO during TAP-shift-DR state. TDI, TMS, TCK and nTRST will not be effected and                               */
	                                                                          /* are always connected to ARM and ETM input.                                                                                    */
	                                                                          /* SYSDEBUG unit will not do any netX system access when a ARM TAP-IR-value is unequal sysdebug_ir or                            */
	                                                                          /* sysdebug_ir is programmed to 0.                                                                                               */
	unsigned int lic_err_taint_en : BFW_NX51_misc_asic_ctrl_lic_err_taint_en; /* In case of a detected license error, system clock will be reduced to 80MHz                                                    */
	                                                                          /* Tainted mode can be left when this bit is disabled or at unprotected phase after power-on-reset by a valid LICCHECK sequence. */
	unsigned int lic_err_abort_en : BFW_NX51_misc_asic_ctrl_lic_err_abort_en; /* In case of a detected license error, ARM-Abort will be generated on the next data write (no data loss caused)                 */
	unsigned int lic_err_irq_en   : BFW_NX51_misc_asic_ctrl_lic_err_irq_en;   /* In case of a detected license error, ARM-IRQ will be generated                                                                */
	unsigned int lic_err_delay_en : BFW_NX51_misc_asic_ctrl_lic_err_delay_en; /* Random Delay between a detected license error and abort-generation/change to tainted mode                                     */
	unsigned int reserved2        : BFW_NX51_misc_asic_ctrl_reserved2;        /* reserved                                                                                                                      */
	unsigned int netx50_io_comp   : BFW_NX51_misc_asic_ctrl_netx50_io_comp;   /* Protection of netX51 IOs ond netX50 power pad locations (HIF_AHI0,1 on netx50b balls TBD)                                     */
	                                                                          /*   1: HIF_AHI0,1 are forced in hiZ state. netX51 can be used for netX50-drop-in-replacement.                                   */
	                                                                          /*   0: HIF_AHI0,1 can be used as functional IOs. WARNING: Setting this bit to 0 could cause permanent damage                    */
	                                                                          /*      when netX51 is used for netX50-drop-in-replacement.                                                                      */
	                                                                          /* Warning:                                                                                                                      */
	                                                                          /*    Programming this bit to '0' could cause permanent damage to netx when applied for                                          */
	                                                                          /*    netX50-drop-in-replacement designs. This bit protects related IOs only for functional netx                                 */
	                                                                          /*    application modes. It does not protect IOs being driven as outputs in test-modes. E.g. there                               */
	                                                                          /*    is no protection when related IOs are switched to driving mode by boundary scan or activating                              */
	                                                                          /*    other build-in test-modes implemented for production test purpose (e.g. scantest-mode).                                    */
} NX51_MISC_ASIC_CTRL_BIT_T;

typedef union {
	unsigned int              val;
	NX51_MISC_ASIC_CTRL_BIT_T bf;
} NX51_MISC_ASIC_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register only_porn */
/* => Firmware Status register: */
/*    This register is not Reset by SW resets, only PORn will reset this register. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_only_porn       0x00000044U
#define Adr_NX51_asic_ctrl_only_porn 0x1018C144U
#define Adr_NX51_only_porn           0x1018C144U
#define DFLT_VAL_NX51_only_porn      0x00000000U

#define MSK_NX51_only_porn_only_porn         0xffffffffU
#define SRT_NX51_only_porn_only_porn         0
#define DFLT_VAL_NX51_only_porn_only_porn    0x00000000U
#define DFLT_BF_VAL_NX51_only_porn_only_porn 0x00000000U

/* all used bits of 'NX51_only_porn': */
#define MSK_USED_BITS_NX51_only_porn 0xffffffffU

enum {
	BFW_NX51_only_porn_only_porn = 32  /* [31:0] */
};

typedef struct NX51_ONLY_PORN_BIT_Ttag {
	unsigned int only_porn : BFW_NX51_only_porn_only_porn; /* netX Firmware status */
} NX51_ONLY_PORN_BIT_T;

typedef union {
	unsigned int         val;
	NX51_ONLY_PORN_BIT_T bf;
} NX51_ONLY_PORN_T;

/* --------------------------------------------------------------------- */
/* Register netx_version */
/* => netX Revision Register: */
/*    This register contains information about netX hardware and bootloader revision. */
/*    This register is lockable by netX locking algorithm. It will be only reset on Power on, not on normal system nres. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_version       0x00000048U
#define Adr_NX51_asic_ctrl_netx_version 0x1018C148U
#define Adr_NX51_netx_version           0x1018C148U
#define DFLT_VAL_NX51_netx_version      0x00000005U

#define MSK_NX51_netx_version_netx_version         0x000000ffU
#define SRT_NX51_netx_version_netx_version         0
#define DFLT_VAL_NX51_netx_version_netx_version    0x00000005U
#define DFLT_BF_VAL_NX51_netx_version_netx_version 0x00000005U

/* all used bits of 'NX51_netx_version': */
#define MSK_USED_BITS_NX51_netx_version 0x000000ffU

enum {
	BFW_NX51_netx_version_netx_version = 8,  /* [7:0] */
	BFW_NX51_netx_version_reserved1    = 24  /* [31:8] */
};

typedef struct NX51_NETX_VERSION_BIT_Ttag {
	unsigned int netx_version : BFW_NX51_netx_version_netx_version; /* netX51 revision number:                                                    */
	                                                                /* Hardware reset values of netX version register is:                         */
	                                                                /* 0x01: netx100, netx500                                                     */
	                                                                /* 0x01: netx50                                                               */
	                                                                /* 0x02: netx5_mpw                                                            */
	                                                                /* 0x41: netx5                                                                */
	                                                                /* 0x50: netx10                                                               */
	                                                                /* 0x05: netx51                                                               */
	                                                                /* Further netX revisions should increment (netx: 0x06).                      */
	                                                                /* This register is changed to Hilscher netX bootloader revision by ROM-code: */
	                                                                /* Hardware reset values should differ from Hilscher values!                  */
	                                                                /* netX50 revision number starts with "B" (0x42).                             */
	                                                                /* 0x41: netx500                                                              */
	                                                                /* 0x42: netx50                                                               */
	                                                                /* 0x42: netx100                                                              */
	                                                                /* 0x41: netx5                                                                */
	                                                                /* 0x42: netx10                                                               */
	                                                                /* 0x42: netx51                                                               */
	unsigned int reserved1    : BFW_NX51_netx_version_reserved1;    /* reserved                                                                   */
} NX51_NETX_VERSION_BIT_T;

typedef union {
	unsigned int            val;
	NX51_NETX_VERSION_BIT_T bf;
} NX51_NETX_VERSION_T;

/* --------------------------------------------------------------------- */
/* Register rom_wdg */
/* => netX ROM Watchdog: */
/*    Write to this register to reset rom-hide-watchdog, no access-key-protection. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_rom_wdg       0x0000004CU
#define Adr_NX51_asic_ctrl_rom_wdg 0x1018C14CU
#define Adr_NX51_rom_wdg           0x1018C14CU
#define DFLT_VAL_NX51_rom_wdg      0x000001ffU

#define MSK_NX51_rom_wdg_rst_wdg         0xffffffffU
#define SRT_NX51_rom_wdg_rst_wdg         0
#define DFLT_VAL_NX51_rom_wdg_rst_wdg    0x000001ffU
#define DFLT_BF_VAL_NX51_rom_wdg_rst_wdg 0x000001ffU

/* all used bits of 'NX51_rom_wdg': */
#define MSK_USED_BITS_NX51_rom_wdg 0xffffffffU

enum {
	BFW_NX51_rom_wdg_rst_wdg = 32  /* [31:0] */
};

typedef struct NX51_ROM_WDG_BIT_Ttag {
	unsigned int rst_wdg : BFW_NX51_rom_wdg_rst_wdg; /* write here to reset rom-watchdog to 0x1ff                                                            */
	                                                 /* The watchdog will decrement with each positiv clk (100MHz) edge.                                     */
	                                                 /* If watchdog reaches 0x0, highest 4kB ROM will be hidden. 4kB-block below will be seen by any master. */
	                                                 /* The watchdog will only be reset at power-on-reset (PORn).                                            */
} NX51_ROM_WDG_BIT_T;

typedef union {
	unsigned int       val;
	NX51_ROM_WDG_BIT_T bf;
} NX51_ROM_WDG_T;

/* --------------------------------------------------------------------- */
/* Register sample_at_nres */
/* => IO Sampled at Reset Status Register. */
/*    Note: */
/*       Configure sample_at_nres (sar_*)-IOs with pullups or down resistors to configure netX */
/*       environment (e.g. DPM enable, DPM serial mode selection,...). Related IOs are not driven by netX */
/*       by default. For correct functionality ensure that they are also not driven by external devices during */
/*       netX power up and reset. */
/*    Note: */
/*       MI data lines are not used for sample at nres: When reset is done during */
/*       SDRAM read access, SDRAM device will keep driving data bus. Pull-up/down values will be overdriven by that. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sample_at_nres       0x00000050U
#define Adr_NX51_asic_ctrl_sample_at_nres 0x1018C150U
#define Adr_NX51_sample_at_nres           0x1018C150U

#define MSK_NX51_sample_at_nres_sar_mem_a0      0x00000001U
#define SRT_NX51_sample_at_nres_sar_mem_a0      0
#define MSK_NX51_sample_at_nres_sar_mem_a1      0x00000002U
#define SRT_NX51_sample_at_nres_sar_mem_a1      1
#define MSK_NX51_sample_at_nres_sar_mem_a2      0x00000004U
#define SRT_NX51_sample_at_nres_sar_mem_a2      2
#define MSK_NX51_sample_at_nres_sar_mem_a3      0x00000008U
#define SRT_NX51_sample_at_nres_sar_mem_a3      3
#define MSK_NX51_sample_at_nres_sar_mem_a4      0x00000010U
#define SRT_NX51_sample_at_nres_sar_mem_a4      4
#define MSK_NX51_sample_at_nres_sar_mem_a5      0x00000020U
#define SRT_NX51_sample_at_nres_sar_mem_a5      5
#define MSK_NX51_sample_at_nres_sar_mem_a6      0x00000040U
#define SRT_NX51_sample_at_nres_sar_mem_a6      6
#define MSK_NX51_sample_at_nres_sar_mem_a7      0x00000080U
#define SRT_NX51_sample_at_nres_sar_mem_a7      7
#define MSK_NX51_sample_at_nres_sar_mem_a8      0x00000100U
#define SRT_NX51_sample_at_nres_sar_mem_a8      8
#define MSK_NX51_sample_at_nres_sar_mem_a9      0x00000200U
#define SRT_NX51_sample_at_nres_sar_mem_a9      9
#define MSK_NX51_sample_at_nres_sar_mem_a10     0x00000400U
#define SRT_NX51_sample_at_nres_sar_mem_a10     10
#define MSK_NX51_sample_at_nres_sar_mem_a11     0x00000800U
#define SRT_NX51_sample_at_nres_sar_mem_a11     11
#define MSK_NX51_sample_at_nres_sar_mem_a12     0x00001000U
#define SRT_NX51_sample_at_nres_sar_mem_a12     12
#define MSK_NX51_sample_at_nres_sar_mem_a13     0x00002000U
#define SRT_NX51_sample_at_nres_sar_mem_a13     13
#define MSK_NX51_sample_at_nres_sar_mem_a14     0x00004000U
#define SRT_NX51_sample_at_nres_sar_mem_a14     14
#define MSK_NX51_sample_at_nres_sar_mem_a15     0x00008000U
#define SRT_NX51_sample_at_nres_sar_mem_a15     15
#define MSK_NX51_sample_at_nres_sar_mem_a16     0x00010000U
#define SRT_NX51_sample_at_nres_sar_mem_a16     16
#define MSK_NX51_sample_at_nres_sar_mem_a17     0x00020000U
#define SRT_NX51_sample_at_nres_sar_mem_a17     17
#define MSK_NX51_sample_at_nres_sar_mem_a18     0x00040000U
#define SRT_NX51_sample_at_nres_sar_mem_a18     18
#define MSK_NX51_sample_at_nres_sar_mem_a19     0x00080000U
#define SRT_NX51_sample_at_nres_sar_mem_a19     19
#define MSK_NX51_sample_at_nres_sar_mem_a20     0x00100000U
#define SRT_NX51_sample_at_nres_sar_mem_a20     20
#define MSK_NX51_sample_at_nres_sar_mem_a21     0x00200000U
#define SRT_NX51_sample_at_nres_sar_mem_a21     21
#define MSK_NX51_sample_at_nres_sar_mem_a22     0x00400000U
#define SRT_NX51_sample_at_nres_sar_mem_a22     22
#define MSK_NX51_sample_at_nres_sar_mem_a23     0x00800000U
#define SRT_NX51_sample_at_nres_sar_mem_a23     23
#define MSK_NX51_sample_at_nres_sar_mem_dqm0    0x01000000U
#define SRT_NX51_sample_at_nres_sar_mem_dqm0    24
#define MSK_NX51_sample_at_nres_sar_mem_dqm1    0x02000000U
#define SRT_NX51_sample_at_nres_sar_mem_dqm1    25
#define MSK_NX51_sample_at_nres_sar_mem_dqm2    0x04000000U
#define SRT_NX51_sample_at_nres_sar_mem_dqm2    26
#define MSK_NX51_sample_at_nres_sar_mem_dqm3    0x08000000U
#define SRT_NX51_sample_at_nres_sar_mem_dqm3    27
#define MSK_NX51_sample_at_nres_sar_mem_sdwe_n  0x10000000U
#define SRT_NX51_sample_at_nres_sar_mem_sdwe_n  28
#define MSK_NX51_sample_at_nres_sar_mem_sdras_n 0x20000000U
#define SRT_NX51_sample_at_nres_sar_mem_sdras_n 29
#define MSK_NX51_sample_at_nres_sar_mem_sdcas_n 0x40000000U
#define SRT_NX51_sample_at_nres_sar_mem_sdcas_n 30
#define MSK_NX51_sample_at_nres_sar_mem_sdcke   0x80000000U
#define SRT_NX51_sample_at_nres_sar_mem_sdcke   31

/* all used bits of 'NX51_sample_at_nres': */
#define MSK_USED_BITS_NX51_sample_at_nres 0xffffffffU

enum {
	BFW_NX51_sample_at_nres_sar_mem_a0      = 1, /* [0] */
	BFW_NX51_sample_at_nres_sar_mem_a1      = 1, /* [1] */
	BFW_NX51_sample_at_nres_sar_mem_a2      = 1, /* [2] */
	BFW_NX51_sample_at_nres_sar_mem_a3      = 1, /* [3] */
	BFW_NX51_sample_at_nres_sar_mem_a4      = 1, /* [4] */
	BFW_NX51_sample_at_nres_sar_mem_a5      = 1, /* [5] */
	BFW_NX51_sample_at_nres_sar_mem_a6      = 1, /* [6] */
	BFW_NX51_sample_at_nres_sar_mem_a7      = 1, /* [7] */
	BFW_NX51_sample_at_nres_sar_mem_a8      = 1, /* [8] */
	BFW_NX51_sample_at_nres_sar_mem_a9      = 1, /* [9] */
	BFW_NX51_sample_at_nres_sar_mem_a10     = 1, /* [10] */
	BFW_NX51_sample_at_nres_sar_mem_a11     = 1, /* [11] */
	BFW_NX51_sample_at_nres_sar_mem_a12     = 1, /* [12] */
	BFW_NX51_sample_at_nres_sar_mem_a13     = 1, /* [13] */
	BFW_NX51_sample_at_nres_sar_mem_a14     = 1, /* [14] */
	BFW_NX51_sample_at_nres_sar_mem_a15     = 1, /* [15] */
	BFW_NX51_sample_at_nres_sar_mem_a16     = 1, /* [16] */
	BFW_NX51_sample_at_nres_sar_mem_a17     = 1, /* [17] */
	BFW_NX51_sample_at_nres_sar_mem_a18     = 1, /* [18] */
	BFW_NX51_sample_at_nres_sar_mem_a19     = 1, /* [19] */
	BFW_NX51_sample_at_nres_sar_mem_a20     = 1, /* [20] */
	BFW_NX51_sample_at_nres_sar_mem_a21     = 1, /* [21] */
	BFW_NX51_sample_at_nres_sar_mem_a22     = 1, /* [22] */
	BFW_NX51_sample_at_nres_sar_mem_a23     = 1, /* [23] */
	BFW_NX51_sample_at_nres_sar_mem_dqm0    = 1, /* [24] */
	BFW_NX51_sample_at_nres_sar_mem_dqm1    = 1, /* [25] */
	BFW_NX51_sample_at_nres_sar_mem_dqm2    = 1, /* [26] */
	BFW_NX51_sample_at_nres_sar_mem_dqm3    = 1, /* [27] */
	BFW_NX51_sample_at_nres_sar_mem_sdwe_n  = 1, /* [28] */
	BFW_NX51_sample_at_nres_sar_mem_sdras_n = 1, /* [29] */
	BFW_NX51_sample_at_nres_sar_mem_sdcas_n = 1, /* [30] */
	BFW_NX51_sample_at_nres_sar_mem_sdcke   = 1  /* [31] */
};

typedef struct NX51_SAMPLE_AT_NRES_BIT_Ttag {
	unsigned int sar_mem_a0      : BFW_NX51_sample_at_nres_sar_mem_a0;      /* Sampled input level of IO 'mem_a0' at power on reset      */
	unsigned int sar_mem_a1      : BFW_NX51_sample_at_nres_sar_mem_a1;      /* Sampled input level of IO 'mem_a1' at power on reset      */
	unsigned int sar_mem_a2      : BFW_NX51_sample_at_nres_sar_mem_a2;      /* Sampled input level of IO 'mem_a2' at power on reset      */
	unsigned int sar_mem_a3      : BFW_NX51_sample_at_nres_sar_mem_a3;      /* Sampled input level of IO 'mem_a3' at power on reset      */
	unsigned int sar_mem_a4      : BFW_NX51_sample_at_nres_sar_mem_a4;      /* Sampled input level of IO 'mem_a4' at power on reset      */
	unsigned int sar_mem_a5      : BFW_NX51_sample_at_nres_sar_mem_a5;      /* Sampled input level of IO 'mem_a5' at power on reset      */
	unsigned int sar_mem_a6      : BFW_NX51_sample_at_nres_sar_mem_a6;      /* Sampled input level of IO 'mem_a6' at power on reset      */
	unsigned int sar_mem_a7      : BFW_NX51_sample_at_nres_sar_mem_a7;      /* Sampled input level of IO 'mem_a7' at power on reset      */
	unsigned int sar_mem_a8      : BFW_NX51_sample_at_nres_sar_mem_a8;      /* Sampled input level of IO 'mem_a8' at power on reset      */
	unsigned int sar_mem_a9      : BFW_NX51_sample_at_nres_sar_mem_a9;      /* Sampled input level of IO 'mem_a9' at power on reset      */
	unsigned int sar_mem_a10     : BFW_NX51_sample_at_nres_sar_mem_a10;     /* Sampled input level of IO 'mem_a10' at power on reset     */
	unsigned int sar_mem_a11     : BFW_NX51_sample_at_nres_sar_mem_a11;     /* Sampled input level of IO 'mem_a11' at power on reset     */
	unsigned int sar_mem_a12     : BFW_NX51_sample_at_nres_sar_mem_a12;     /* Sampled input level of IO 'mem_a12' at power on reset     */
	unsigned int sar_mem_a13     : BFW_NX51_sample_at_nres_sar_mem_a13;     /* Sampled input level of IO 'mem_a13' at power on reset     */
	unsigned int sar_mem_a14     : BFW_NX51_sample_at_nres_sar_mem_a14;     /* Sampled input level of IO 'mem_a14' at power on reset     */
	unsigned int sar_mem_a15     : BFW_NX51_sample_at_nres_sar_mem_a15;     /* Sampled input level of IO 'mem_a15' at power on reset     */
	unsigned int sar_mem_a16     : BFW_NX51_sample_at_nres_sar_mem_a16;     /* Sampled input level of IO 'mem_a16' at power on reset     */
	unsigned int sar_mem_a17     : BFW_NX51_sample_at_nres_sar_mem_a17;     /* Sampled input level of IO 'mem_a17' at power on reset     */
	unsigned int sar_mem_a18     : BFW_NX51_sample_at_nres_sar_mem_a18;     /* Sampled input level of IO 'mem_a18' at power on reset     */
	unsigned int sar_mem_a19     : BFW_NX51_sample_at_nres_sar_mem_a19;     /* Sampled input level of IO 'mem_a19' at power on reset     */
	unsigned int sar_mem_a20     : BFW_NX51_sample_at_nres_sar_mem_a20;     /* Sampled input level of IO 'mem_a20' at power on reset     */
	unsigned int sar_mem_a21     : BFW_NX51_sample_at_nres_sar_mem_a21;     /* Sampled input level of IO 'mem_a21' at power on reset     */
	unsigned int sar_mem_a22     : BFW_NX51_sample_at_nres_sar_mem_a22;     /* Sampled input level of IO 'mem_a22' at power on reset     */
	unsigned int sar_mem_a23     : BFW_NX51_sample_at_nres_sar_mem_a23;     /* Sampled input level of IO 'mem_a23' at power on reset     */
	unsigned int sar_mem_dqm0    : BFW_NX51_sample_at_nres_sar_mem_dqm0;    /* Sampled input level of IO 'mem_dqm0' at power on reset    */
	unsigned int sar_mem_dqm1    : BFW_NX51_sample_at_nres_sar_mem_dqm1;    /* Sampled input level of IO 'mem_dqm1' at power on reset    */
	unsigned int sar_mem_dqm2    : BFW_NX51_sample_at_nres_sar_mem_dqm2;    /* Sampled input level of IO 'mem_dqm2' at power on reset    */
	unsigned int sar_mem_dqm3    : BFW_NX51_sample_at_nres_sar_mem_dqm3;    /* Sampled input level of IO 'mem_dqm3' at power on reset    */
	unsigned int sar_mem_sdwe_n  : BFW_NX51_sample_at_nres_sar_mem_sdwe_n;  /* Sampled input level of IO 'mem_sdwe_n' at power on reset  */
	unsigned int sar_mem_sdras_n : BFW_NX51_sample_at_nres_sar_mem_sdras_n; /* Sampled input level of IO 'mem_sdras_n' at power on reset */
	unsigned int sar_mem_sdcas_n : BFW_NX51_sample_at_nres_sar_mem_sdcas_n; /* Sampled input level of IO 'mem_sdcas_n' at power on reset */
	unsigned int sar_mem_sdcke   : BFW_NX51_sample_at_nres_sar_mem_sdcke;   /* Sampled input level of IO 'mem_sdcke' at power on reset   */
} NX51_SAMPLE_AT_NRES_BIT_T;

typedef union {
	unsigned int              val;
	NX51_SAMPLE_AT_NRES_BIT_T bf;
} NX51_SAMPLE_AT_NRES_T;

/* --------------------------------------------------------------------- */
/* Register netx_status */
/* => netX System Status Configuration Register. */
/*    This Register was implemented in Hilscher HIF module originally. */
/*    From Hilscher Program Reference Guide: The general status of a netX based system is usually indicated by the System LED, which can either */
/*    consist of a dual LED or two single LEDs. */
/*    Access to this register is not protected by any locking or access protection algorithm. */
/*    IMPORTANT: netX50/100/500 Change Note: */
/*       The netX50/100/500 SYS_STA register was byte acessible. This changed: This register is only 32bit accessible. */
/*       In netx50/100/500, write access to bits 0..15 of SYS_STA register can generated an IRQ to external host CPU. */
/*       As the register now is 32bit accessible only, this is changed to whole register access. I.e. any write */
/*       access to this register will generate an host IRQ if enabled. To change the upper 16 bits of this register without */
/*       host IRQ generation, use register rdy_run_cfg. */
/*    Note: */
/*       Changing bits here will also change rdy_run_cfg register bits. */
/*    Note: */
/*       Bits 0..3 and 8..15 are read-only-mirrored to DPM/Host Status register dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). */
/*       Read-only bits 4..7 can be programmed by DPM/Host Status register dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_status       0x00000054U
#define Adr_NX51_asic_ctrl_netx_status 0x1018C154U
#define Adr_NX51_netx_status           0x1018C154U
#define DFLT_VAL_NX51_netx_status      0x0003f000U

#define MSK_NX51_netx_status_RDY                   0x00000001U
#define SRT_NX51_netx_status_RDY                   0
#define DFLT_VAL_NX51_netx_status_RDY              0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_RDY           0x00000000U
#define MSK_NX51_netx_status_RUN                   0x00000002U
#define SRT_NX51_netx_status_RUN                   1
#define DFLT_VAL_NX51_netx_status_RUN              0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_RUN           0x00000000U
#define MSK_NX51_netx_status_NETX_STATE            0x0000000cU
#define SRT_NX51_netx_status_NETX_STATE            2
#define DFLT_VAL_NX51_netx_status_NETX_STATE       0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_NETX_STATE    0x00000000U
#define MSK_NX51_netx_status_HOST_STATE_ro         0x000000f0U
#define SRT_NX51_netx_status_HOST_STATE_ro         4
#define DFLT_VAL_NX51_netx_status_HOST_STATE_ro    0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_HOST_STATE_ro 0x00000000U
#define MSK_NX51_netx_status_NETX_STA_CODE         0x0000ff00U
#define SRT_NX51_netx_status_NETX_STA_CODE         8
#define DFLT_VAL_NX51_netx_status_NETX_STA_CODE    0x0000f000U
#define DFLT_BF_VAL_NX51_netx_status_NETX_STA_CODE 0x000000f0U
#define MSK_NX51_netx_status_RDY_IN                0x00010000U
#define SRT_NX51_netx_status_RDY_IN                16
#define DFLT_VAL_NX51_netx_status_RDY_IN           0x00010000U
#define DFLT_BF_VAL_NX51_netx_status_RDY_IN        0x00000001U
#define MSK_NX51_netx_status_RUN_IN                0x00020000U
#define SRT_NX51_netx_status_RUN_IN                17
#define DFLT_VAL_NX51_netx_status_RUN_IN           0x00020000U
#define DFLT_BF_VAL_NX51_netx_status_RUN_IN        0x00000001U
#define MSK_NX51_netx_status_RDY_POL               0x00040000U
#define SRT_NX51_netx_status_RDY_POL               18
#define DFLT_VAL_NX51_netx_status_RDY_POL          0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_RDY_POL       0x00000000U
#define MSK_NX51_netx_status_RUN_POL               0x00080000U
#define SRT_NX51_netx_status_RUN_POL               19
#define DFLT_VAL_NX51_netx_status_RUN_POL          0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_RUN_POL       0x00000000U
#define MSK_NX51_netx_status_RDY_DRV               0x01000000U
#define SRT_NX51_netx_status_RDY_DRV               24
#define DFLT_VAL_NX51_netx_status_RDY_DRV          0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_RDY_DRV       0x00000000U
#define MSK_NX51_netx_status_RUN_DRV               0x02000000U
#define SRT_NX51_netx_status_RUN_DRV               25
#define DFLT_VAL_NX51_netx_status_RUN_DRV          0x00000000U
#define DFLT_BF_VAL_NX51_netx_status_RUN_DRV       0x00000000U

/* all used bits of 'NX51_netx_status': */
#define MSK_USED_BITS_NX51_netx_status 0x030fffffU

enum {
	BFW_NX51_netx_status_RDY           = 1, /* [0] */
	BFW_NX51_netx_status_RUN           = 1, /* [1] */
	BFW_NX51_netx_status_NETX_STATE    = 2, /* [3:2] */
	BFW_NX51_netx_status_HOST_STATE_ro = 4, /* [7:4] */
	BFW_NX51_netx_status_NETX_STA_CODE = 8, /* [15:8] */
	BFW_NX51_netx_status_RDY_IN        = 1, /* [16] */
	BFW_NX51_netx_status_RUN_IN        = 1, /* [17] */
	BFW_NX51_netx_status_RDY_POL       = 1, /* [18] */
	BFW_NX51_netx_status_RUN_POL       = 1, /* [19] */
	BFW_NX51_netx_status_reserved1     = 4, /* [23:20] */
	BFW_NX51_netx_status_RDY_DRV       = 1, /* [24] */
	BFW_NX51_netx_status_RUN_DRV       = 1, /* [25] */
	BFW_NX51_netx_status_reserved2     = 6  /* [31:26] */
};

typedef struct NX51_NETX_STATUS_BIT_Ttag {
	unsigned int RDY           : BFW_NX51_netx_status_RDY;           /* Signal level of the RDY LED output.                                             */
	                                                                 /* Note:                                                                           */
	                                                                 /*    This bit is read-only-mirrored to DPM/Host Status register                   */
	                                                                 /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing this bit can produce    */
	                                                                 /*    a IRQ to host CPU.                                                           */
	unsigned int RUN           : BFW_NX51_netx_status_RUN;           /* Signal Level of the RUN LED output.                                             */
	                                                                 /* Note:                                                                           */
	                                                                 /*    This bit is read-only-mirrored to DPM/Host Status register                   */
	                                                                 /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing this bit can produce    */
	                                                                 /*    a IRQ to host CPU.                                                           */
	unsigned int NETX_STATE    : BFW_NX51_netx_status_NETX_STATE;    /* User defined status bits.                                                       */
	                                                                 /* Note:                                                                           */
	                                                                 /*    These bits are read-only-mirrored to DPM/Host Status register                */
	                                                                 /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing these bits can produce  */
	                                                                 /*    a IRQ to host CPU.                                                           */
	unsigned int HOST_STATE_ro : BFW_NX51_netx_status_HOST_STATE_ro; /* Host Status Code.                                                               */
	                                                                 /* User defined status is read only here. These bits can be programmed by DPM/Host */
	                                                                 /* Status register dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM).                     */
	unsigned int NETX_STA_CODE : BFW_NX51_netx_status_NETX_STA_CODE; /* netX Status Code.                                                               */
	                                                                 /* The netX status codes are software defined.                                     */
	                                                                 /* The predefined code values are:                                                 */
	                                                                 /*    F0h: Status after power on reset.                                            */
	                                                                 /* Note:                                                                           */
	                                                                 /*    These bits are read-only-mirrored to DPM/Host Status register                */
	                                                                 /*    dpm_sys_sta (DPM_HOST_SYS_STAT) (Area DPM). Changing these bits can produce  */
	                                                                 /*    a IRQ to host CPU.                                                           */
	unsigned int RDY_IN        : BFW_NX51_netx_status_RDY_IN;        /* Physical input signal level at RDY pin (read-only).                             */
	unsigned int RUN_IN        : BFW_NX51_netx_status_RUN_IN;        /* Physical input signal level at RUN pin (read-only).                             */
	unsigned int RDY_POL       : BFW_NX51_netx_status_RDY_POL;       /* Output polarity RDY LED; outsig = RDY exor RDY_POL.                             */
	unsigned int RUN_POL       : BFW_NX51_netx_status_RUN_POL;       /* Output polarity RUN LED; outsig = RUN exor RUN_POL.                             */
	unsigned int reserved1     : BFW_NX51_netx_status_reserved1;     /* reserved                                                                        */
	unsigned int RDY_DRV       : BFW_NX51_netx_status_RDY_DRV;       /* Driver enable for RDY LED. Enables output driver when set.                      */
	unsigned int RUN_DRV       : BFW_NX51_netx_status_RUN_DRV;       /* Driver enable for RUN LED. Enables output driver when set.                      */
	unsigned int reserved2     : BFW_NX51_netx_status_reserved2;     /* reserved                                                                        */
} NX51_NETX_STATUS_BIT_T;

typedef union {
	unsigned int           val;
	NX51_NETX_STATUS_BIT_T bf;
} NX51_NETX_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register rdy_run_cfg */
/* => netX RDY/RUN IO System Status Configuration Register. */
/*    RDY/RUN signal programming was implemented in Hilscher HIF module originally. */
/*    From Hilscher Program Reference Guide: The general status of a netX based system is usually indicated by the System LED, which can either */
/*    consist of a dual LED or two single LEDs. */
/*    Access to this register is not protected by any locking or access protection algorithm. */
/*    Note: */
/*       Use this register to change the upper 16 bits of sys_sta (SYS_STA) register witout */
/*       host IRQ generation. For further information see sys_sta register description. Changing bits here */
/*       will also change sys_sta register bits, however no host IRQ will be generated. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_rdy_run_cfg       0x00000058U
#define Adr_NX51_asic_ctrl_rdy_run_cfg 0x1018C158U
#define Adr_NX51_rdy_run_cfg           0x1018C158U
#define DFLT_VAL_NX51_rdy_run_cfg      0x00030000U

#define MSK_NX51_rdy_run_cfg_RDY             0x00000001U
#define SRT_NX51_rdy_run_cfg_RDY             0
#define DFLT_VAL_NX51_rdy_run_cfg_RDY        0x00000000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RDY     0x00000000U
#define MSK_NX51_rdy_run_cfg_RUN             0x00000002U
#define SRT_NX51_rdy_run_cfg_RUN             1
#define DFLT_VAL_NX51_rdy_run_cfg_RUN        0x00000000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RUN     0x00000000U
#define MSK_NX51_rdy_run_cfg_RDY_IN          0x00010000U
#define SRT_NX51_rdy_run_cfg_RDY_IN          16
#define DFLT_VAL_NX51_rdy_run_cfg_RDY_IN     0x00010000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RDY_IN  0x00000001U
#define MSK_NX51_rdy_run_cfg_RUN_IN          0x00020000U
#define SRT_NX51_rdy_run_cfg_RUN_IN          17
#define DFLT_VAL_NX51_rdy_run_cfg_RUN_IN     0x00020000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RUN_IN  0x00000001U
#define MSK_NX51_rdy_run_cfg_RDY_POL         0x00040000U
#define SRT_NX51_rdy_run_cfg_RDY_POL         18
#define DFLT_VAL_NX51_rdy_run_cfg_RDY_POL    0x00000000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RDY_POL 0x00000000U
#define MSK_NX51_rdy_run_cfg_RUN_POL         0x00080000U
#define SRT_NX51_rdy_run_cfg_RUN_POL         19
#define DFLT_VAL_NX51_rdy_run_cfg_RUN_POL    0x00000000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RUN_POL 0x00000000U
#define MSK_NX51_rdy_run_cfg_RDY_DRV         0x01000000U
#define SRT_NX51_rdy_run_cfg_RDY_DRV         24
#define DFLT_VAL_NX51_rdy_run_cfg_RDY_DRV    0x00000000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RDY_DRV 0x00000000U
#define MSK_NX51_rdy_run_cfg_RUN_DRV         0x02000000U
#define SRT_NX51_rdy_run_cfg_RUN_DRV         25
#define DFLT_VAL_NX51_rdy_run_cfg_RUN_DRV    0x00000000U
#define DFLT_BF_VAL_NX51_rdy_run_cfg_RUN_DRV 0x00000000U

/* all used bits of 'NX51_rdy_run_cfg': */
#define MSK_USED_BITS_NX51_rdy_run_cfg 0x030f0003U

enum {
	BFW_NX51_rdy_run_cfg_RDY       = 1,  /* [0] */
	BFW_NX51_rdy_run_cfg_RUN       = 1,  /* [1] */
	BFW_NX51_rdy_run_cfg_reserved1 = 14, /* [15:2] */
	BFW_NX51_rdy_run_cfg_RDY_IN    = 1,  /* [16] */
	BFW_NX51_rdy_run_cfg_RUN_IN    = 1,  /* [17] */
	BFW_NX51_rdy_run_cfg_RDY_POL   = 1,  /* [18] */
	BFW_NX51_rdy_run_cfg_RUN_POL   = 1,  /* [19] */
	BFW_NX51_rdy_run_cfg_reserved2 = 4,  /* [23:20] */
	BFW_NX51_rdy_run_cfg_RDY_DRV   = 1,  /* [24] */
	BFW_NX51_rdy_run_cfg_RUN_DRV   = 1,  /* [25] */
	BFW_NX51_rdy_run_cfg_reserved3 = 6   /* [31:26] */
};

typedef struct NX51_RDY_RUN_CFG_BIT_Ttag {
	unsigned int RDY       : BFW_NX51_rdy_run_cfg_RDY;       /* Signal level of the RDY LED output.                        */
	unsigned int RUN       : BFW_NX51_rdy_run_cfg_RUN;       /* Signal Level of the RUN LED output.                        */
	unsigned int reserved1 : BFW_NX51_rdy_run_cfg_reserved1; /* reserved                                                   */
	unsigned int RDY_IN    : BFW_NX51_rdy_run_cfg_RDY_IN;    /* Physical input signal level at RDY pin (read-only).        */
	unsigned int RUN_IN    : BFW_NX51_rdy_run_cfg_RUN_IN;    /* Physical input signal level at RUN pin (read-only).        */
	unsigned int RDY_POL   : BFW_NX51_rdy_run_cfg_RDY_POL;   /* Output polarity RDY LED; outsig = RDY exor RDY_POL.        */
	unsigned int RUN_POL   : BFW_NX51_rdy_run_cfg_RUN_POL;   /* Output polarity RUN LED; outsig = RUN exor RUN_POL.        */
	unsigned int reserved2 : BFW_NX51_rdy_run_cfg_reserved2; /* reserved                                                   */
	unsigned int RDY_DRV   : BFW_NX51_rdy_run_cfg_RDY_DRV;   /* Driver enable for RDY LED. Enables output driver when set. */
	unsigned int RUN_DRV   : BFW_NX51_rdy_run_cfg_RUN_DRV;   /* Driver enable for RUN LED. Enables output driver when set. */
	unsigned int reserved3 : BFW_NX51_rdy_run_cfg_reserved3; /* reserved                                                   */
} NX51_RDY_RUN_CFG_BIT_T;

typedef union {
	unsigned int           val;
	NX51_RDY_RUN_CFG_BIT_T bf;
} NX51_RDY_RUN_CFG_T;

/* --------------------------------------------------------------------- */
/* Register system_status */
/* => netX System Status Register. */
/*    This register provides information of special netX system events, e.g: System related interrupt activity, Abort activity. */
/*    Abort status flag can be cleared by writing a '1' to the according bits. */
/*    IRQ status flags can be cleared by writing a '1' to the according bits. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_system_status       0x0000005CU
#define Adr_NX51_asic_ctrl_system_status 0x1018C15CU
#define Adr_NX51_system_status           0x1018C15CU

#define MSK_NX51_system_status_lic_err_irq_status      0x00000001U
#define SRT_NX51_system_status_lic_err_irq_status      0
#define MSK_NX51_system_status_extbus_to_irq_status    0x00000002U
#define SRT_NX51_system_status_extbus_to_irq_status    1
#define MSK_NX51_system_status_mem_to_irq_status       0x00000004U
#define SRT_NX51_system_status_mem_to_irq_status       2
#define MSK_NX51_system_status_parity_error_irq_status 0x00000008U
#define SRT_NX51_system_status_parity_error_irq_status 3
#define MSK_NX51_system_status_lic_err_abort_status    0x00010000U
#define SRT_NX51_system_status_lic_err_abort_status    16
#define MSK_NX51_system_status_TEST                    0x00020000U
#define SRT_NX51_system_status_TEST                    17
#define MSK_NX51_system_status_pll_bypass              0x00040000U
#define SRT_NX51_system_status_pll_bypass              18
#define MSK_NX51_system_status_quick_count             0x00080000U
#define SRT_NX51_system_status_quick_count             19
#define MSK_NX51_system_status_arm_crashdetect         0x00100000U
#define SRT_NX51_system_status_arm_crashdetect         20

/* all used bits of 'NX51_system_status': */
#define MSK_USED_BITS_NX51_system_status 0x001f000fU

enum {
	BFW_NX51_system_status_lic_err_irq_status      = 1,  /* [0] */
	BFW_NX51_system_status_extbus_to_irq_status    = 1,  /* [1] */
	BFW_NX51_system_status_mem_to_irq_status       = 1,  /* [2] */
	BFW_NX51_system_status_parity_error_irq_status = 1,  /* [3] */
	BFW_NX51_system_status_reserved1               = 12, /* [15:4] */
	BFW_NX51_system_status_lic_err_abort_status    = 1,  /* [16] */
	BFW_NX51_system_status_TEST                    = 1,  /* [17] */
	BFW_NX51_system_status_pll_bypass              = 1,  /* [18] */
	BFW_NX51_system_status_quick_count             = 1,  /* [19] */
	BFW_NX51_system_status_arm_crashdetect         = 1,  /* [20] */
	BFW_NX51_system_status_reserved2               = 11  /* [31:21] */
};

typedef struct NX51_SYSTEM_STATUS_BIT_Ttag {
	unsigned int lic_err_irq_status      : BFW_NX51_system_status_lic_err_irq_status;      /* Current status of netX licence error IRQ.                                                                              */
	                                                                                       /* Note: This IRQ (bit) can only be cleared by running a valid netx licence check sequence.                               */
	                                                                                       /* Note: Generation of this IRQ is controlled by misc_asic_ctrl register.                                                 */
	                                                                                       /* Note: This IRQ is not maskablel.                                                                                       */
	unsigned int extbus_to_irq_status    : BFW_NX51_system_status_extbus_to_irq_status;    /* Current status of HIF-Extension Bus Ready Timeout IRQ.                                                                 */
	                                                                                       /* Note: This IRQ is controlled/cleared by ext_rdy_cfg register (area hif_asyncmem_ctrl).                                 */
	unsigned int mem_to_irq_status       : BFW_NX51_system_status_mem_to_irq_status;       /* Current status of MEM-Bus Ready Timeout IRQ.                                                                           */
	                                                                                       /* Note: This IRQ is controlled/cleared by ext_rdy_cfg register (area ext_asyncmem_ctrl). MEM_RDY                         */
	                                                                                       /*     is a multiplex-matrix signal.                                                                                      */
	unsigned int parity_error_irq_status : BFW_NX51_system_status_parity_error_irq_status; /* Current status of parity error IRQ                                                                                     */
	unsigned int reserved1               : BFW_NX51_system_status_reserved1;               /* reserved                                                                                                               */
	unsigned int lic_err_abort_status    : BFW_NX51_system_status_lic_err_abort_status;    /* Current status of netX licence abort.                                                                                  */
	                                                                                       /* Note: This bit must be cleared by writing a '1'. It is not cleared automatically if ARM Abort mode is left.            */
	                                                                                       /* Note: Generation of this Abort is controlled by misc_asic_ctrl register.                                               */
	unsigned int TEST                    : BFW_NX51_system_status_TEST;                    /* sampled netx TEST input for production test purpose                                                                    */
	unsigned int pll_bypass              : BFW_NX51_system_status_pll_bypass;              /* Testmode 'pll_bypass' is activated by BSCAN JTAG TAP controller                                                        */
	                                                                                       /* -> 400MHz-PLL is bypassed, PLL output is unused, 400MHz-Clocks (clk400, clk400_2sdram) is directly connected to XTALIN */
	unsigned int quick_count             : BFW_NX51_system_status_quick_count;             /* Testmode 'quick_count' is activated by BSCAN JTAG TAP controller                                                       */
	                                                                                       /* -> diverse internal counters count faster (RTC-clock-divider, PLL-stby-controller,...)                                 */
	unsigned int arm_crashdetect         : BFW_NX51_system_status_arm_crashdetect;         /* arm_crashdetect_cpclken. For HSoCT Simulation purpose only!!!                                                          */
	unsigned int reserved2               : BFW_NX51_system_status_reserved2;               /* reserved                                                                                                               */
} NX51_SYSTEM_STATUS_BIT_T;

typedef union {
	unsigned int             val;
	NX51_SYSTEM_STATUS_BIT_T bf;
} NX51_SYSTEM_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register netx_lic_id */
/* => netX License ID Register: */
/*    This register contains license information read from security memory during boot phase */
/*    This register is lockable by netX locking algorithm. It will be only reset on Power on, not on normal system nres. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lic_id       0x00000060U
#define Adr_NX51_asic_ctrl_netx_lic_id 0x1018C160U
#define Adr_NX51_netx_lic_id           0x1018C160U
#define DFLT_VAL_NX51_netx_lic_id      0x00000000U

#define MSK_NX51_netx_lic_id_id         0xffffffffU
#define SRT_NX51_netx_lic_id_id         0
#define DFLT_VAL_NX51_netx_lic_id_id    0x00000000U
#define DFLT_BF_VAL_NX51_netx_lic_id_id 0x00000000U

/* all used bits of 'NX51_netx_lic_id': */
#define MSK_USED_BITS_NX51_netx_lic_id 0xffffffffU

enum {
	BFW_NX51_netx_lic_id_id = 32  /* [31:0] */
};

typedef struct NX51_NETX_LIC_ID_BIT_Ttag {
	unsigned int id : BFW_NX51_netx_lic_id_id; /* License ID from security memory */
} NX51_NETX_LIC_ID_BIT_T;

typedef union {
	unsigned int           val;
	NX51_NETX_LIC_ID_BIT_T bf;
} NX51_NETX_LIC_ID_T;

/* --------------------------------------------------------------------- */
/* Register netx_lic_flags0 */
/* => netX License Flags 0 Register: */
/*    This register is part of netX licence error detection mechanism. If netX software requested an unavailable licence, this */
/*    will be flagged in netx_lic_errors0 register. */
/*    This register contains license information read from security memory during boot phase */
/*    This register is lockable by netX locking algorithm. It will be only reset on Power on, not on normal system nres. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lic_flags0       0x00000064U
#define Adr_NX51_asic_ctrl_netx_lic_flags0 0x1018C164U
#define Adr_NX51_netx_lic_flags0           0x1018C164U
#define DFLT_VAL_NX51_netx_lic_flags0      0x00000000U

#define MSK_NX51_netx_lic_flags0_flags         0xffffffffU
#define SRT_NX51_netx_lic_flags0_flags         0
#define DFLT_VAL_NX51_netx_lic_flags0_flags    0x00000000U
#define DFLT_BF_VAL_NX51_netx_lic_flags0_flags 0x00000000U

/* all used bits of 'NX51_netx_lic_flags0': */
#define MSK_USED_BITS_NX51_netx_lic_flags0 0xffffffffU

enum {
	BFW_NX51_netx_lic_flags0_flags = 32  /* [31:0] */
};

typedef struct NX51_NETX_LIC_FLAGS0_BIT_Ttag {
	unsigned int flags : BFW_NX51_netx_lic_flags0_flags; /* License flag bits from security memory */
} NX51_NETX_LIC_FLAGS0_BIT_T;

typedef union {
	unsigned int               val;
	NX51_NETX_LIC_FLAGS0_BIT_T bf;
} NX51_NETX_LIC_FLAGS0_T;

/* --------------------------------------------------------------------- */
/* Register netx_lic_flags1 */
/* => netX License Flags 1 Register: */
/*    This register is part of netX licence error detection mechanism. If netX software requested an unavailable licence, this */
/*    will be flagged in netx_lic_errors1 register. */
/*    This register contains license information read from security memory during boot phase */
/*    This register is lockable by netX locking algorithm. It will be only reset on Power on, not on normal system nres. */
/*    This register is protected by the netX access-key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access-key from ACCESS_KEY register */
/*    2.: write back access-key to ACCESS_KEY register */
/*    3.: write desired value to this register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lic_flags1       0x00000068U
#define Adr_NX51_asic_ctrl_netx_lic_flags1 0x1018C168U
#define Adr_NX51_netx_lic_flags1           0x1018C168U
#define DFLT_VAL_NX51_netx_lic_flags1      0x00000000U

#define MSK_NX51_netx_lic_flags1_flags         0xffffffffU
#define SRT_NX51_netx_lic_flags1_flags         0
#define DFLT_VAL_NX51_netx_lic_flags1_flags    0x00000000U
#define DFLT_BF_VAL_NX51_netx_lic_flags1_flags 0x00000000U

/* all used bits of 'NX51_netx_lic_flags1': */
#define MSK_USED_BITS_NX51_netx_lic_flags1 0xffffffffU

enum {
	BFW_NX51_netx_lic_flags1_flags = 32  /* [31:0] */
};

typedef struct NX51_NETX_LIC_FLAGS1_BIT_Ttag {
	unsigned int flags : BFW_NX51_netx_lic_flags1_flags; /* License flag bits from security memory */
} NX51_NETX_LIC_FLAGS1_BIT_T;

typedef union {
	unsigned int               val;
	NX51_NETX_LIC_FLAGS1_BIT_T bf;
} NX51_NETX_LIC_FLAGS1_T;

/* --------------------------------------------------------------------- */
/* Register netx_lic_errors0 */
/* => netX License Errors 0 Status Register: */
/*    This register is part of netX licence error detection mechanism. If netX software requested a licence not */
/*    provided by netx_lic_flags0, this will be flagged here. */
/*    This register contains 0 in case of no license error */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lic_errors0       0x0000006CU
#define Adr_NX51_asic_ctrl_netx_lic_errors0 0x1018C16CU
#define Adr_NX51_netx_lic_errors0           0x1018C16CU

#define MSK_NX51_netx_lic_errors0_err_ro 0xffffffffU
#define SRT_NX51_netx_lic_errors0_err_ro 0

/* all used bits of 'NX51_netx_lic_errors0': */
#define MSK_USED_BITS_NX51_netx_lic_errors0 0xffffffffU

enum {
	BFW_NX51_netx_lic_errors0_err_ro = 32  /* [31:0] */
};

typedef struct NX51_NETX_LIC_ERRORS0_BIT_Ttag {
	unsigned int err_ro : BFW_NX51_netx_lic_errors0_err_ro; /* License error bits set in case of license mismatch according to netx_lic_flags0 (OR of all occured errors) */
} NX51_NETX_LIC_ERRORS0_BIT_T;

typedef union {
	unsigned int                val;
	NX51_NETX_LIC_ERRORS0_BIT_T bf;
} NX51_NETX_LIC_ERRORS0_T;

/* --------------------------------------------------------------------- */
/* Register netx_lic_errors1 */
/* => netX License Errors 1 Status Register: */
/*    This register is part of netX licence error detection mechanism. If netX software requested a licence not */
/*    provided by netx_lic_flags1, this will be flagged here. */
/*    This register contains 0 in case of no license error */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lic_errors1       0x00000070U
#define Adr_NX51_asic_ctrl_netx_lic_errors1 0x1018C170U
#define Adr_NX51_netx_lic_errors1           0x1018C170U

#define MSK_NX51_netx_lic_errors1_err_ro 0xffffffffU
#define SRT_NX51_netx_lic_errors1_err_ro 0

/* all used bits of 'NX51_netx_lic_errors1': */
#define MSK_USED_BITS_NX51_netx_lic_errors1 0xffffffffU

enum {
	BFW_NX51_netx_lic_errors1_err_ro = 32  /* [31:0] */
};

typedef struct NX51_NETX_LIC_ERRORS1_BIT_Ttag {
	unsigned int err_ro : BFW_NX51_netx_lic_errors1_err_ro; /* License error bits set in case of license mismatch according to netx_lic_flags1 (OR of all occured errors) */
} NX51_NETX_LIC_ERRORS1_BIT_T;

typedef union {
	unsigned int                val;
	NX51_NETX_LIC_ERRORS1_BIT_T bf;
} NX51_NETX_LIC_ERRORS1_T;

/* --------------------------------------------------------------------- */
/* Register netx_lock_reserved_ul */
/* => prior adr_netx_lock_reserved00 */
/*    reserved address for netX locking purpose */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lock_reserved_ul       0x00000074U
#define Adr_NX51_asic_ctrl_netx_lock_reserved_ul 0x1018C174U
#define Adr_NX51_netx_lock_reserved_ul           0x1018C174U

#define MSK_NX51_netx_lock_reserved_ul_lock 0xffffffffU
#define SRT_NX51_netx_lock_reserved_ul_lock 0

/* all used bits of 'NX51_netx_lock_reserved_ul': */
#define MSK_USED_BITS_NX51_netx_lock_reserved_ul 0xffffffffU

enum {
	BFW_NX51_netx_lock_reserved_ul_lock = 32  /* [31:0] */
};

typedef struct NX51_NETX_LOCK_RESERVED_UL_BIT_Ttag {
	unsigned int lock : BFW_NX51_netx_lock_reserved_ul_lock; /* locking purpose */
} NX51_NETX_LOCK_RESERVED_UL_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_NETX_LOCK_RESERVED_UL_BIT_T bf;
} NX51_NETX_LOCK_RESERVED_UL_T;

/* --------------------------------------------------------------------- */
/* Register netx_lock_reserved_lf */
/* => prior adr_netx_lock_reserved01 */
/*    reserved address for netX final locking purpose */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lock_reserved_lf       0x00000078U
#define Adr_NX51_asic_ctrl_netx_lock_reserved_lf 0x1018C178U
#define Adr_NX51_netx_lock_reserved_lf           0x1018C178U

#define MSK_NX51_netx_lock_reserved_lf_lock 0xffffffffU
#define SRT_NX51_netx_lock_reserved_lf_lock 0

/* all used bits of 'NX51_netx_lock_reserved_lf': */
#define MSK_USED_BITS_NX51_netx_lock_reserved_lf 0xffffffffU

enum {
	BFW_NX51_netx_lock_reserved_lf_lock = 32  /* [31:0] */
};

typedef struct NX51_NETX_LOCK_RESERVED_LF_BIT_Ttag {
	unsigned int lock : BFW_NX51_netx_lock_reserved_lf_lock; /* locking purpose */
} NX51_NETX_LOCK_RESERVED_LF_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_NETX_LOCK_RESERVED_LF_BIT_T bf;
} NX51_NETX_LOCK_RESERVED_LF_T;

/* --------------------------------------------------------------------- */
/* Register asic_ctrl_access_key */
/* => ASIC Control Locking access-key Register: */
/*    Writing to any register in the asic_ctrl or mmio_ctrl address area is only possible after */
/*    setting the correct key here to avoid unmeant changes e.g. by crashed software. */
/*    ---- */
/*    Changing a control register in the asic_ctrl or mmio_ctrl address area is only possible by the following sequence: */
/*    1.: Read out the Locking access-key from this register. */
/*    2.: Write back this Locking access-key to this register. */
/*    3.: Write desired value to the control register. */
/*    ---- */
/*    The Locking access-key will become invalid after each access to any register in the asic_ctrl or mmio_ctrl address area */
/*    and has to be read out and set again for sequent accesses. */
/*    Note: */
/*       Since netX51 there are 3 separated instances of access-key-protection logic: One for ARM, one for xPIC and */
/*       one shared by all other netX system masters. That allows ARM and XPIC running access-key read-write sequence */
/*       and configuration access without any synchronisation or locking completely independent. Before netX51 a sequence */
/*       started by one master (e.g. ARM) became invalid when interrupted by another master (e.g. xPIC). That was changed: ARM */
/*       and xPIC are able to remove protection without being influenced by each other (or by any other master). Once a */
/*       access-key-sequence was performed protected configuration registers are only writable for the master which performed */
/*       it. */
/*       To allow access to protected register for other masters (e.g. XPECs or SYSDEBUG) the third instance of */
/*       access-key-protection logic is implemented. This is shared by all masters except ARM and xPIC. When more */
/*       than one of these masters should use this, locking must be done in software to avoid sequence of one master */
/*       being interrupted by another. */
/*       Access-key read and write address is the same for all masters. However, ARM-key is only readable or writable by ARM, xPIC-key */
/*       only by xPIC and shared key only by all other masters but never by ARM or xPIC. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_asic_ctrl_access_key       0x0000007CU
#define Adr_NX51_asic_ctrl_asic_ctrl_access_key 0x1018C17CU
#define Adr_NX51_asic_ctrl_access_key           0x1018C17CU
#define DFLT_VAL_NX51_asic_ctrl_access_key      0x00000000U

#define MSK_NX51_asic_ctrl_access_key_access_key         0x0000ffffU
#define SRT_NX51_asic_ctrl_access_key_access_key         0
#define DFLT_VAL_NX51_asic_ctrl_access_key_access_key    0x00000000U
#define DFLT_BF_VAL_NX51_asic_ctrl_access_key_access_key 0x00000000U

/* all used bits of 'NX51_asic_ctrl_access_key': */
#define MSK_USED_BITS_NX51_asic_ctrl_access_key 0x0000ffffU

enum {
	BFW_NX51_asic_ctrl_access_key_access_key = 16, /* [15:0] */
	BFW_NX51_asic_ctrl_access_key_reserved1  = 16  /* [31:16] */
};

typedef struct NX51_ASIC_CTRL_ACCESS_KEY_BIT_Ttag {
	unsigned int access_key : BFW_NX51_asic_ctrl_access_key_access_key; /* Locking access-key for next write access. */
	unsigned int reserved1  : BFW_NX51_asic_ctrl_access_key_reserved1;  /* reserved                                  */
} NX51_ASIC_CTRL_ACCESS_KEY_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_ASIC_CTRL_ACCESS_KEY_BIT_T bf;
} NX51_ASIC_CTRL_ACCESS_KEY_T;

/* --------------------------------------------------------------------- */
/* Register netx_lock_reserved_start */
/* => Reserved start address for netX locking purpose address area */
/*    Don't implement other registers at 0x80 .. 0xfc! */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lock_reserved_start       0x00000080U
#define Adr_NX51_asic_ctrl_netx_lock_reserved_start 0x1018C180U
#define Adr_NX51_netx_lock_reserved_start           0x1018C180U

#define MSK_NX51_netx_lock_reserved_start_lock 0xffffffffU
#define SRT_NX51_netx_lock_reserved_start_lock 0

/* all used bits of 'NX51_netx_lock_reserved_start': */
#define MSK_USED_BITS_NX51_netx_lock_reserved_start 0xffffffffU

enum {
	BFW_NX51_netx_lock_reserved_start_lock = 32  /* [31:0] */
};

typedef struct NX51_NETX_LOCK_RESERVED_START_BIT_Ttag {
	unsigned int lock : BFW_NX51_netx_lock_reserved_start_lock; /* locking purpose */
} NX51_NETX_LOCK_RESERVED_START_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_NETX_LOCK_RESERVED_START_BIT_T bf;
} NX51_NETX_LOCK_RESERVED_START_T;

/* --------------------------------------------------------------------- */
/* Register netx_lock_reserved_end */
/* => Reserved end address for netX locking purpose address area */
/*    Don't implement other registers at 0x80 .. 0xfc! */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_lock_reserved_end       0x000000FCU
#define Adr_NX51_asic_ctrl_netx_lock_reserved_end 0x1018C1FCU
#define Adr_NX51_netx_lock_reserved_end           0x1018C1FCU

#define MSK_NX51_netx_lock_reserved_end_lock 0xffffffffU
#define SRT_NX51_netx_lock_reserved_end_lock 0

/* all used bits of 'NX51_netx_lock_reserved_end': */
#define MSK_USED_BITS_NX51_netx_lock_reserved_end 0xffffffffU

enum {
	BFW_NX51_netx_lock_reserved_end_lock = 32  /* [31:0] */
};

typedef struct NX51_NETX_LOCK_RESERVED_END_BIT_Ttag {
	unsigned int lock : BFW_NX51_netx_lock_reserved_end_lock; /* locking purpose */
} NX51_NETX_LOCK_RESERVED_END_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_NETX_LOCK_RESERVED_END_BIT_T bf;
} NX51_NETX_LOCK_RESERVED_END_T;


/* ===================================================================== */

/* Area of mmio_ctrl */

/* ===================================================================== */

#define Addr_NX51_mmio_ctrl      0x1018C200U
#define NX51_NETX_MMIO_CTRL_AREA 0x1018C200U

/* --------------------------------------------------------------------- */
/* Register mmio0_cfg */
/* => Multiplexmatrix Configuration Register for MMIO0 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    ------------------------------- */
/*    mmio*_sel - coding: */
/*    {     |                        |                           | border=1 */
/*    Coding netX internal function \ signal type                 functional group */
/*           (core connection) */
/*    0x00   xm0_io0                  bidirectional,              Fieldbus0 */
/*    0x01   xm0_io1                  bidirectional,              Fieldbus0 */
/*    0x02   xm0_io2                  bidirectional,              Fieldbus0 */
/*    0x03   xm0_io3                  bidirectional,              Fieldbus0 */
/*    0x04   xm0_io4                  bidirectional,              Fieldbus0 */
/*    0x05   xm0_io5                  bidirectional,              Fieldbus0 */
/*    0x06   xm0_rx                   input,                      Fieldbus0 */
/*    0x07   xm0_tx_out               tristatable output,         Fieldbus0 */
/*    0x08   xm1_io0                  bidirectional,              Fieldbus1 */
/*    0x09   xm1_io1                  bidirectional,              Fieldbus1 */
/*    0x0a   xm1_io2                  bidirectional,              Fieldbus1 */
/*    0x0b   xm1_io3                  bidirectional,              Fieldbus1 */
/*    0x0c   xm1_io4                  bidirectional,              Fieldbus1 */
/*    0x0d   xm1_io5                  bidirectional,              Fieldbus1 */
/*    0x0e   xm1_rx                   input,                      Fieldbus1 */
/*    0x0f   xm1_tx_out               tristatable output,         Fieldbus1 */
/*    0x10   gpio0                    bidirectional,              GPIO/IO-Link */
/*    0x11   gpio1                    bidirectional,              GPIO/IO-Link */
/*    0x12   gpio2                    bidirectional,              GPIO/IO-Link */
/*    0x13   gpio3                    bidirectional,              GPIO/IO-Link */
/*    0x14   gpio4                    bidirectional,              GPIO/IO-Link */
/*    0x15   gpio5                    bidirectional,              GPIO/IO-Link */
/*    0x16   gpio6                    bidirectional,              GPIO/IO-Link */
/*    0x17   gpio7                    bidirectional,              GPIO/IO-Link */
/*    0x18   gpio8                    bidirectional,              GPIO/IO-Link */
/*    0x19   gpio9                    bidirectional,              GPIO/IO-Link */
/*    0x1a   gpio10                   bidirectional,              GPIO/IO-Link */
/*    0x1b   gpio11                   bidirectional,              GPIO/IO-Link */
/*    0x1c   gpio12                   bidirectional,              GPIO/IO-Link */
/*    0x1d   gpio13                   bidirectional,              GPIO/IO-Link */
/*    0x1e   gpio14                   bidirectional,              GPIO/IO-Link */
/*    0x1f   gpio15                   bidirectional,              GPIO/IO-Link */
/*    0x20   gpio16                   bidirectional,              GPIO/IO-Link */
/*    0x21   gpio17                   bidirectional,              GPIO/IO-Link */
/*    0x22   gpio18                   bidirectional,              GPIO/IO-Link */
/*    0x23   gpio19                   bidirectional,              GPIO/IO-Link */
/*    0x24   gpio20                   bidirectional,              GPIO/IO-Link */
/*    0x25   gpio21                   bidirectional,              GPIO/IO-Link */
/*    0x26   gpio22                   bidirectional,              GPIO/IO-Link */
/*    0x27   gpio23                   bidirectional,              GPIO/IO-Link */
/*    0x28   gpio24                   bidirectional,              GPIO/IO-Link */
/*    0x29   gpio25                   bidirectional,              GPIO/IO-Link */
/*    0x2a   gpio26                   bidirectional,              GPIO/IO-Link */
/*    0x2b   gpio27                   bidirectional,              GPIO/IO-Link */
/*    0x2c   gpio28                   bidirectional,              GPIO/IO-Link */
/*    0x2d   gpio29                   bidirectional,              GPIO/IO-Link */
/*    0x2e   gpio30                   bidirectional,              GPIO/IO-Link */
/*    0x2f   gpio31                   bidirectional,              GPIO/IO-Link */
/*    0x30   phy0_led0                always driven output,       INT_PHY_CTRL0 link */
/*    0x31   phy0_led1                always driven output,       INT_PHY_CTRL0 trans */
/*    0x32   phy0_led2                always driven output,       INT_PHY_CTRL0 speed100 */
/*    0x33   phy0_led3                always driven output,       INT_PHY_CTRL0 duplex */
/*    0x34   phy1_led0                always driven output,       INT_PHY_CTRL1 link */
/*    0x35   phy1_led1                always driven output,       INT_PHY_CTRL1 trans */
/*    0x36   phy1_led2                always driven output,       INT_PHY_CTRL1 speed100 */
/*    0x37   phy1_led3                always driven output,       INT_PHY_CTRL1 duplex */
/*    0x38   mii_mdc                  always driven output,       MDIO */
/*    0x39   mii_mdio                 bidirectional,              MDIO */
/*    0x3a   spi0_cs2n                bidirectional,              SPI0 3rd chip select */
/*    0x3b   spi0_sio2_mmio           bidirectional,              SPI0 */
/*    0x3c   spi0_sio3_mmio           bidirectional,              SPI0 */
/*    0x3d   spi1_clk                 bidirectional,              SPI1 */
/*    0x3e   spi1_cs0n                bidirectional,              SPI1 */
/*    0x3f   spi1_cs1n                bidirectional,              SPI1 */
/*    0x40   spi1_cs2n                bidirectional,              SPI1 */
/*    0x41   spi1_miso                bidirectional,              SPI1 */
/*    0x42   spi1_mosi                bidirectional,              SPI1 */
/*    0x43   i2c0_scl_mmio            bidirectional,              I2C */
/*    0x44   i2c0_sda_mmio            bidirectional,              I2C */
/*    0x45   i2c1_scl                 bidirectional,              I2C */
/*    0x46   i2c1_sda                 bidirectional,              I2C */
/*    0x47   xc_sample0               input,                      Trigger/Latch Unit */
/*    0x48   xc_sample1               input,                      Trigger/Latch Unit */
/*    0x49   xc_trigger0              tristatable output,         Trigger/Latch Unit */
/*    0x4a   xc_trigger1              tristatable output,         Trigger/Latch Unit */
/*    0x4b   uart0_ctsn               input,                      UART 0 */
/*    0x4c   uart0_rtsn               tristatable output,         UART 0 */
/*    0x4d   uart0_rxd                input,                      UART 0 */
/*    0x4e   uart0_txd                tristatable output,         UART 0 */
/*    0x4f   uart1_ctsn               input,                      UART 1 */
/*    0x50   uart1_rtsn               tristatable output,         UART 1 */
/*    0x51   uart1_rxd                input,                      UART 1 */
/*    0x52   uart1_txd                tristatable output,         UART 1 */
/*    0x53   uart2_ctsn               input,                      UART 2 */
/*    0x54   uart2_rtsn               tristatable output,         UART 2 */
/*    0x55   uart2_rxd                input,                      UART 2 */
/*    0x56   uart2_txd                tristatable output,         UART 2 */
/*    0x57   can_rx                   input,                      CAN */
/*    0x58   can_tx                   always driven output,       CAN */
/*    0x59   mem_rdy                  input,                      MEM IF ready/busy input */
/*    0x5a   pio0                     bidirectional,              PIO */
/*    0x5b   pio1                     bidirectional,              PIO */
/*    0x5c   pio2                     bidirectional,              PIO */
/*    0x5d   pio3                     bidirectional,              PIO */
/*    0x5e   pio4                     bidirectional,              PIO */
/*    0x5f   pio5                     bidirectional,              PIO */
/*    0x60   pio6                     bidirectional,              PIO */
/*    0x61   pio7                     bidirectional,              PIO */
/*    0x7f   PIO mode                 use MMIO PIO line registers PIO function} */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio0_cfg       0x00000000U
#define Adr_NX51_mmio_ctrl_mmio0_cfg 0x1018C200U
#define Adr_NX51_mmio0_cfg           0x1018C200U
#define DFLT_VAL_NX51_mmio0_cfg      0x00000010U

#define MSK_NX51_mmio0_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio0_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio0_cfg_mmio_sel        0x00000010U
#define DFLT_BF_VAL_NX51_mmio0_cfg_mmio_sel     0x00000010U
#define MSK_NX51_mmio0_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio0_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio0_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio0_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio0_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio0_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio0_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio0_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio0_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio0_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio0_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio0_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio0_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio0_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio0_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio0_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio0_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio0_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio0_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio0_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio0_cfg': */
#define MSK_USED_BITS_NX51_mmio0_cfg 0x0007037fU

enum {
	BFW_NX51_mmio0_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio0_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio0_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio0_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio0_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio0_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio0_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio0_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio0_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO0_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio0_cfg_mmio_sel;     /* mmio0 signal selection (default: gpio0, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio0_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio0_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio0_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio0_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio0_cfg_pio_oe;       /* PIO mode output enable of mmio0, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio0_cfg_pio_out;      /* PIO mode output drive level of mmio0, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio0_cfg_status_in_ro; /* current input status of mmio0, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio0_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO0_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO0_CFG_BIT_T bf;
} NX51_MMIO0_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio1_cfg */
/* => Multiplexmatrix Configuration Register for MMIO1 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio1_cfg       0x00000004U
#define Adr_NX51_mmio_ctrl_mmio1_cfg 0x1018C204U
#define Adr_NX51_mmio1_cfg           0x1018C204U
#define DFLT_VAL_NX51_mmio1_cfg      0x00000011U

#define MSK_NX51_mmio1_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio1_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio1_cfg_mmio_sel        0x00000011U
#define DFLT_BF_VAL_NX51_mmio1_cfg_mmio_sel     0x00000011U
#define MSK_NX51_mmio1_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio1_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio1_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio1_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio1_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio1_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio1_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio1_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio1_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio1_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio1_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio1_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio1_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio1_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio1_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio1_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio1_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio1_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio1_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio1_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio1_cfg': */
#define MSK_USED_BITS_NX51_mmio1_cfg 0x0007037fU

enum {
	BFW_NX51_mmio1_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio1_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio1_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio1_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio1_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio1_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio1_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio1_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio1_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO1_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio1_cfg_mmio_sel;     /* mmio1 signal selection (default: gpio1, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio1_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio1_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio1_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio1_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio1_cfg_pio_oe;       /* PIO mode output enable of mmio1, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio1_cfg_pio_out;      /* PIO mode output drive level of mmio1, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio1_cfg_status_in_ro; /* current input status of mmio1, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio1_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO1_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO1_CFG_BIT_T bf;
} NX51_MMIO1_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio2_cfg */
/* => Multiplexmatrix Configuration Register for MMIO2 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio2_cfg       0x00000008U
#define Adr_NX51_mmio_ctrl_mmio2_cfg 0x1018C208U
#define Adr_NX51_mmio2_cfg           0x1018C208U
#define DFLT_VAL_NX51_mmio2_cfg      0x00000012U

#define MSK_NX51_mmio2_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio2_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio2_cfg_mmio_sel        0x00000012U
#define DFLT_BF_VAL_NX51_mmio2_cfg_mmio_sel     0x00000012U
#define MSK_NX51_mmio2_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio2_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio2_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio2_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio2_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio2_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio2_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio2_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio2_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio2_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio2_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio2_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio2_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio2_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio2_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio2_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio2_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio2_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio2_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio2_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio2_cfg': */
#define MSK_USED_BITS_NX51_mmio2_cfg 0x0007037fU

enum {
	BFW_NX51_mmio2_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio2_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio2_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio2_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio2_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio2_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio2_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio2_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio2_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO2_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio2_cfg_mmio_sel;     /* mmio2 signal selection (default: gpio2, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio2_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio2_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio2_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio2_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio2_cfg_pio_oe;       /* PIO mode output enable of mmio2, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio2_cfg_pio_out;      /* PIO mode output drive level of mmio2, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio2_cfg_status_in_ro; /* current input status of mmio2, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio2_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO2_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO2_CFG_BIT_T bf;
} NX51_MMIO2_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio3_cfg */
/* => Multiplexmatrix Configuration Register for MMIO3 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio3_cfg       0x0000000CU
#define Adr_NX51_mmio_ctrl_mmio3_cfg 0x1018C20CU
#define Adr_NX51_mmio3_cfg           0x1018C20CU
#define DFLT_VAL_NX51_mmio3_cfg      0x00000013U

#define MSK_NX51_mmio3_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio3_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio3_cfg_mmio_sel        0x00000013U
#define DFLT_BF_VAL_NX51_mmio3_cfg_mmio_sel     0x00000013U
#define MSK_NX51_mmio3_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio3_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio3_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio3_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio3_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio3_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio3_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio3_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio3_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio3_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio3_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio3_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio3_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio3_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio3_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio3_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio3_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio3_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio3_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio3_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio3_cfg': */
#define MSK_USED_BITS_NX51_mmio3_cfg 0x0007037fU

enum {
	BFW_NX51_mmio3_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio3_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio3_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio3_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio3_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio3_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio3_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio3_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio3_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO3_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio3_cfg_mmio_sel;     /* mmio3 signal selection (default: gpio3, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio3_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio3_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio3_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio3_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio3_cfg_pio_oe;       /* PIO mode output enable of mmio3, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio3_cfg_pio_out;      /* PIO mode output drive level of mmio3, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio3_cfg_status_in_ro; /* current input status of mmio3, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio3_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO3_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO3_CFG_BIT_T bf;
} NX51_MMIO3_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio4_cfg */
/* => Multiplexmatrix Configuration Register for MMIO4 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio4_cfg       0x00000010U
#define Adr_NX51_mmio_ctrl_mmio4_cfg 0x1018C210U
#define Adr_NX51_mmio4_cfg           0x1018C210U
#define DFLT_VAL_NX51_mmio4_cfg      0x00000014U

#define MSK_NX51_mmio4_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio4_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio4_cfg_mmio_sel        0x00000014U
#define DFLT_BF_VAL_NX51_mmio4_cfg_mmio_sel     0x00000014U
#define MSK_NX51_mmio4_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio4_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio4_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio4_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio4_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio4_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio4_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio4_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio4_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio4_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio4_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio4_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio4_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio4_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio4_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio4_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio4_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio4_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio4_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio4_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio4_cfg': */
#define MSK_USED_BITS_NX51_mmio4_cfg 0x0007037fU

enum {
	BFW_NX51_mmio4_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio4_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio4_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio4_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio4_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio4_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio4_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio4_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio4_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO4_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio4_cfg_mmio_sel;     /* mmio4 signal selection (default: gpio4, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio4_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio4_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio4_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio4_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio4_cfg_pio_oe;       /* PIO mode output enable of mmio4, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio4_cfg_pio_out;      /* PIO mode output drive level of mmio4, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio4_cfg_status_in_ro; /* current input status of mmio4, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio4_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO4_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO4_CFG_BIT_T bf;
} NX51_MMIO4_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio5_cfg */
/* => Multiplexmatrix Configuration Register for MMIO5 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio5_cfg       0x00000014U
#define Adr_NX51_mmio_ctrl_mmio5_cfg 0x1018C214U
#define Adr_NX51_mmio5_cfg           0x1018C214U
#define DFLT_VAL_NX51_mmio5_cfg      0x00000015U

#define MSK_NX51_mmio5_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio5_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio5_cfg_mmio_sel        0x00000015U
#define DFLT_BF_VAL_NX51_mmio5_cfg_mmio_sel     0x00000015U
#define MSK_NX51_mmio5_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio5_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio5_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio5_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio5_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio5_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio5_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio5_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio5_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio5_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio5_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio5_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio5_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio5_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio5_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio5_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio5_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio5_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio5_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio5_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio5_cfg': */
#define MSK_USED_BITS_NX51_mmio5_cfg 0x0007037fU

enum {
	BFW_NX51_mmio5_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio5_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio5_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio5_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio5_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio5_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio5_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio5_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio5_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO5_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio5_cfg_mmio_sel;     /* mmio5 signal selection (default: gpio5, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio5_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio5_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio5_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio5_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio5_cfg_pio_oe;       /* PIO mode output enable of mmio5, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio5_cfg_pio_out;      /* PIO mode output drive level of mmio5, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio5_cfg_status_in_ro; /* current input status of mmio5, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio5_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO5_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO5_CFG_BIT_T bf;
} NX51_MMIO5_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio6_cfg */
/* => Multiplexmatrix Configuration Register for MMIO6 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio6_cfg       0x00000018U
#define Adr_NX51_mmio_ctrl_mmio6_cfg 0x1018C218U
#define Adr_NX51_mmio6_cfg           0x1018C218U
#define DFLT_VAL_NX51_mmio6_cfg      0x00000016U

#define MSK_NX51_mmio6_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio6_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio6_cfg_mmio_sel        0x00000016U
#define DFLT_BF_VAL_NX51_mmio6_cfg_mmio_sel     0x00000016U
#define MSK_NX51_mmio6_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio6_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio6_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio6_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio6_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio6_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio6_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio6_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio6_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio6_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio6_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio6_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio6_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio6_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio6_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio6_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio6_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio6_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio6_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio6_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio6_cfg': */
#define MSK_USED_BITS_NX51_mmio6_cfg 0x0007037fU

enum {
	BFW_NX51_mmio6_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio6_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio6_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio6_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio6_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio6_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio6_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio6_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio6_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO6_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio6_cfg_mmio_sel;     /* mmio6 signal selection (default: gpio6, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio6_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio6_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio6_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio6_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio6_cfg_pio_oe;       /* PIO mode output enable of mmio6, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio6_cfg_pio_out;      /* PIO mode output drive level of mmio6, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio6_cfg_status_in_ro; /* current input status of mmio6, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio6_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO6_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO6_CFG_BIT_T bf;
} NX51_MMIO6_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio7_cfg */
/* => Multiplexmatrix Configuration Register for MMIO7 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio7_cfg       0x0000001CU
#define Adr_NX51_mmio_ctrl_mmio7_cfg 0x1018C21CU
#define Adr_NX51_mmio7_cfg           0x1018C21CU
#define DFLT_VAL_NX51_mmio7_cfg      0x00000017U

#define MSK_NX51_mmio7_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio7_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio7_cfg_mmio_sel        0x00000017U
#define DFLT_BF_VAL_NX51_mmio7_cfg_mmio_sel     0x00000017U
#define MSK_NX51_mmio7_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio7_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio7_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio7_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio7_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio7_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio7_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio7_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio7_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio7_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio7_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio7_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio7_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio7_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio7_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio7_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio7_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio7_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio7_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio7_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio7_cfg': */
#define MSK_USED_BITS_NX51_mmio7_cfg 0x0007037fU

enum {
	BFW_NX51_mmio7_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio7_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio7_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio7_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio7_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio7_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio7_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio7_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio7_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO7_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio7_cfg_mmio_sel;     /* mmio7 signal selection (default: gpio7, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio7_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio7_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio7_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio7_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio7_cfg_pio_oe;       /* PIO mode output enable of mmio7, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio7_cfg_pio_out;      /* PIO mode output drive level of mmio7, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio7_cfg_status_in_ro; /* current input status of mmio7, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio7_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO7_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO7_CFG_BIT_T bf;
} NX51_MMIO7_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio8_cfg */
/* => Multiplexmatrix Configuration Register for MMIO8 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio8_cfg       0x00000020U
#define Adr_NX51_mmio_ctrl_mmio8_cfg 0x1018C220U
#define Adr_NX51_mmio8_cfg           0x1018C220U
#define DFLT_VAL_NX51_mmio8_cfg      0x00000018U

#define MSK_NX51_mmio8_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio8_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio8_cfg_mmio_sel        0x00000018U
#define DFLT_BF_VAL_NX51_mmio8_cfg_mmio_sel     0x00000018U
#define MSK_NX51_mmio8_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio8_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio8_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio8_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio8_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio8_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio8_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio8_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio8_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio8_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio8_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio8_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio8_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio8_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio8_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio8_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio8_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio8_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio8_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio8_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio8_cfg': */
#define MSK_USED_BITS_NX51_mmio8_cfg 0x0007037fU

enum {
	BFW_NX51_mmio8_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio8_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio8_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio8_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio8_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio8_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio8_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio8_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio8_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO8_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio8_cfg_mmio_sel;     /* mmio8 signal selection (default: gpio8, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio8_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio8_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio8_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio8_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio8_cfg_pio_oe;       /* PIO mode output enable of mmio8, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio8_cfg_pio_out;      /* PIO mode output drive level of mmio8, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio8_cfg_status_in_ro; /* current input status of mmio8, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio8_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO8_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO8_CFG_BIT_T bf;
} NX51_MMIO8_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio9_cfg */
/* => Multiplexmatrix Configuration Register for MMIO9 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio9_cfg       0x00000024U
#define Adr_NX51_mmio_ctrl_mmio9_cfg 0x1018C224U
#define Adr_NX51_mmio9_cfg           0x1018C224U
#define DFLT_VAL_NX51_mmio9_cfg      0x00000019U

#define MSK_NX51_mmio9_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio9_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio9_cfg_mmio_sel        0x00000019U
#define DFLT_BF_VAL_NX51_mmio9_cfg_mmio_sel     0x00000019U
#define MSK_NX51_mmio9_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio9_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio9_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio9_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio9_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio9_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio9_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio9_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio9_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio9_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio9_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio9_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio9_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio9_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio9_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio9_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio9_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio9_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio9_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio9_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio9_cfg': */
#define MSK_USED_BITS_NX51_mmio9_cfg 0x0007037fU

enum {
	BFW_NX51_mmio9_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio9_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio9_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio9_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio9_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio9_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio9_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio9_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio9_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO9_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio9_cfg_mmio_sel;     /* mmio9 signal selection (default: gpio9, access-key-protected).                                                    */
	unsigned int reserved1    : BFW_NX51_mmio9_cfg_reserved1;    /* reserved                                                                                                          */
	unsigned int mmio_out_inv : BFW_NX51_mmio9_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                  */
	unsigned int mmio_in_inv  : BFW_NX51_mmio9_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int reserved2    : BFW_NX51_mmio9_cfg_reserved2;    /* reserved                                                                                                          */
	unsigned int pio_oe       : BFW_NX51_mmio9_cfg_pio_oe;       /* PIO mode output enable of mmio9, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                              */
	unsigned int pio_out      : BFW_NX51_mmio9_cfg_pio_out;      /* PIO mode output drive level of mmio9, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                             /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                             */
	unsigned int status_in_ro : BFW_NX51_mmio9_cfg_status_in_ro; /* current input status of mmio9, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio9_cfg_reserved3;    /* reserved                                                                                                          */
} NX51_MMIO9_CFG_BIT_T;

typedef union {
	unsigned int         val;
	NX51_MMIO9_CFG_BIT_T bf;
} NX51_MMIO9_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio10_cfg */
/* => Multiplexmatrix Configuration Register for MMIO10 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio10_cfg       0x00000028U
#define Adr_NX51_mmio_ctrl_mmio10_cfg 0x1018C228U
#define Adr_NX51_mmio10_cfg           0x1018C228U
#define DFLT_VAL_NX51_mmio10_cfg      0x0000001aU

#define MSK_NX51_mmio10_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio10_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio10_cfg_mmio_sel        0x0000001aU
#define DFLT_BF_VAL_NX51_mmio10_cfg_mmio_sel     0x0000001aU
#define MSK_NX51_mmio10_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio10_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio10_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio10_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio10_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio10_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio10_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio10_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio10_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio10_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio10_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio10_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio10_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio10_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio10_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio10_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio10_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio10_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio10_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio10_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio10_cfg': */
#define MSK_USED_BITS_NX51_mmio10_cfg 0x0007037fU

enum {
	BFW_NX51_mmio10_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio10_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio10_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio10_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio10_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio10_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio10_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio10_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio10_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO10_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio10_cfg_mmio_sel;     /* mmio10 signal selection (default: gpio10, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio10_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio10_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio10_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio10_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio10_cfg_pio_oe;       /* PIO mode output enable of mmio10, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio10_cfg_pio_out;      /* PIO mode output drive level of mmio10, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio10_cfg_status_in_ro; /* current input status of mmio10, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio10_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO10_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO10_CFG_BIT_T bf;
} NX51_MMIO10_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio11_cfg */
/* => Multiplexmatrix Configuration Register for MMIO11 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio11_cfg       0x0000002CU
#define Adr_NX51_mmio_ctrl_mmio11_cfg 0x1018C22CU
#define Adr_NX51_mmio11_cfg           0x1018C22CU
#define DFLT_VAL_NX51_mmio11_cfg      0x0000001bU

#define MSK_NX51_mmio11_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio11_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio11_cfg_mmio_sel        0x0000001bU
#define DFLT_BF_VAL_NX51_mmio11_cfg_mmio_sel     0x0000001bU
#define MSK_NX51_mmio11_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio11_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio11_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio11_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio11_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio11_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio11_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio11_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio11_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio11_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio11_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio11_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio11_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio11_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio11_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio11_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio11_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio11_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio11_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio11_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio11_cfg': */
#define MSK_USED_BITS_NX51_mmio11_cfg 0x0007037fU

enum {
	BFW_NX51_mmio11_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio11_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio11_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio11_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio11_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio11_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio11_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio11_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio11_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO11_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio11_cfg_mmio_sel;     /* mmio11 signal selection (default: gpio11, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio11_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio11_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio11_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio11_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio11_cfg_pio_oe;       /* PIO mode output enable of mmio11, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio11_cfg_pio_out;      /* PIO mode output drive level of mmio11, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio11_cfg_status_in_ro; /* current input status of mmio11, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio11_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO11_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO11_CFG_BIT_T bf;
} NX51_MMIO11_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio12_cfg */
/* => Multiplexmatrix Configuration Register for MMIO12 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio12_cfg       0x00000030U
#define Adr_NX51_mmio_ctrl_mmio12_cfg 0x1018C230U
#define Adr_NX51_mmio12_cfg           0x1018C230U
#define DFLT_VAL_NX51_mmio12_cfg      0x0000001cU

#define MSK_NX51_mmio12_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio12_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio12_cfg_mmio_sel        0x0000001cU
#define DFLT_BF_VAL_NX51_mmio12_cfg_mmio_sel     0x0000001cU
#define MSK_NX51_mmio12_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio12_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio12_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio12_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio12_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio12_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio12_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio12_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio12_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio12_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio12_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio12_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio12_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio12_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio12_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio12_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio12_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio12_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio12_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio12_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio12_cfg': */
#define MSK_USED_BITS_NX51_mmio12_cfg 0x0007037fU

enum {
	BFW_NX51_mmio12_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio12_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio12_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio12_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio12_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio12_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio12_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio12_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio12_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO12_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio12_cfg_mmio_sel;     /* mmio12 signal selection (default: gpio12, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio12_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio12_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio12_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio12_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio12_cfg_pio_oe;       /* PIO mode output enable of mmio12, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio12_cfg_pio_out;      /* PIO mode output drive level of mmio12, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio12_cfg_status_in_ro; /* current input status of mmio12, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio12_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO12_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO12_CFG_BIT_T bf;
} NX51_MMIO12_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio13_cfg */
/* => Multiplexmatrix Configuration Register for MMIO13 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio13_cfg       0x00000034U
#define Adr_NX51_mmio_ctrl_mmio13_cfg 0x1018C234U
#define Adr_NX51_mmio13_cfg           0x1018C234U
#define DFLT_VAL_NX51_mmio13_cfg      0x0000001dU

#define MSK_NX51_mmio13_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio13_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio13_cfg_mmio_sel        0x0000001dU
#define DFLT_BF_VAL_NX51_mmio13_cfg_mmio_sel     0x0000001dU
#define MSK_NX51_mmio13_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio13_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio13_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio13_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio13_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio13_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio13_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio13_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio13_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio13_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio13_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio13_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio13_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio13_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio13_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio13_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio13_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio13_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio13_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio13_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio13_cfg': */
#define MSK_USED_BITS_NX51_mmio13_cfg 0x0007037fU

enum {
	BFW_NX51_mmio13_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio13_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio13_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio13_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio13_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio13_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio13_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio13_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio13_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO13_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio13_cfg_mmio_sel;     /* mmio13 signal selection (default: gpio13, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio13_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio13_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio13_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio13_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio13_cfg_pio_oe;       /* PIO mode output enable of mmio13, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio13_cfg_pio_out;      /* PIO mode output drive level of mmio13, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio13_cfg_status_in_ro; /* current input status of mmio13, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio13_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO13_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO13_CFG_BIT_T bf;
} NX51_MMIO13_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio14_cfg */
/* => Multiplexmatrix Configuration Register for MMIO14 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio14_cfg       0x00000038U
#define Adr_NX51_mmio_ctrl_mmio14_cfg 0x1018C238U
#define Adr_NX51_mmio14_cfg           0x1018C238U
#define DFLT_VAL_NX51_mmio14_cfg      0x0000001eU

#define MSK_NX51_mmio14_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio14_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio14_cfg_mmio_sel        0x0000001eU
#define DFLT_BF_VAL_NX51_mmio14_cfg_mmio_sel     0x0000001eU
#define MSK_NX51_mmio14_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio14_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio14_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio14_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio14_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio14_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio14_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio14_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio14_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio14_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio14_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio14_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio14_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio14_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio14_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio14_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio14_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio14_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio14_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio14_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio14_cfg': */
#define MSK_USED_BITS_NX51_mmio14_cfg 0x0007037fU

enum {
	BFW_NX51_mmio14_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio14_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio14_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio14_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio14_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio14_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio14_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio14_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio14_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO14_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio14_cfg_mmio_sel;     /* mmio14 signal selection (default: gpio14, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio14_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio14_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio14_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio14_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio14_cfg_pio_oe;       /* PIO mode output enable of mmio14, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio14_cfg_pio_out;      /* PIO mode output drive level of mmio14, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio14_cfg_status_in_ro; /* current input status of mmio14, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio14_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO14_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO14_CFG_BIT_T bf;
} NX51_MMIO14_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio15_cfg */
/* => Multiplexmatrix Configuration Register for MMIO15 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio15_cfg       0x0000003CU
#define Adr_NX51_mmio_ctrl_mmio15_cfg 0x1018C23CU
#define Adr_NX51_mmio15_cfg           0x1018C23CU
#define DFLT_VAL_NX51_mmio15_cfg      0x0000001fU

#define MSK_NX51_mmio15_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio15_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio15_cfg_mmio_sel        0x0000001fU
#define DFLT_BF_VAL_NX51_mmio15_cfg_mmio_sel     0x0000001fU
#define MSK_NX51_mmio15_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio15_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio15_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio15_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio15_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio15_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio15_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio15_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio15_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio15_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio15_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio15_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio15_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio15_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio15_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio15_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio15_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio15_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio15_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio15_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio15_cfg': */
#define MSK_USED_BITS_NX51_mmio15_cfg 0x0007037fU

enum {
	BFW_NX51_mmio15_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio15_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio15_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio15_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio15_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio15_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio15_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio15_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio15_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO15_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio15_cfg_mmio_sel;     /* mmio15 signal selection (default: gpio15, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio15_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio15_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio15_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio15_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio15_cfg_pio_oe;       /* PIO mode output enable of mmio15, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio15_cfg_pio_out;      /* PIO mode output drive level of mmio15, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio15_cfg_status_in_ro; /* current input status of mmio15, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio15_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO15_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO15_CFG_BIT_T bf;
} NX51_MMIO15_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio16_cfg */
/* => Multiplexmatrix Configuration Register for MMIO16 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio16_cfg       0x00000040U
#define Adr_NX51_mmio_ctrl_mmio16_cfg 0x1018C240U
#define Adr_NX51_mmio16_cfg           0x1018C240U
#define DFLT_VAL_NX51_mmio16_cfg      0x00000020U

#define MSK_NX51_mmio16_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio16_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio16_cfg_mmio_sel        0x00000020U
#define DFLT_BF_VAL_NX51_mmio16_cfg_mmio_sel     0x00000020U
#define MSK_NX51_mmio16_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio16_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio16_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio16_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio16_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio16_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio16_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio16_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio16_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio16_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio16_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio16_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio16_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio16_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio16_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio16_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio16_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio16_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio16_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio16_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio16_cfg': */
#define MSK_USED_BITS_NX51_mmio16_cfg 0x0007037fU

enum {
	BFW_NX51_mmio16_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio16_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio16_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio16_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio16_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio16_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio16_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio16_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio16_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO16_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio16_cfg_mmio_sel;     /* mmio16 signal selection (default: gpio16, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio16_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio16_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio16_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio16_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio16_cfg_pio_oe;       /* PIO mode output enable of mmio16, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio16_cfg_pio_out;      /* PIO mode output drive level of mmio16, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio16_cfg_status_in_ro; /* current input status of mmio16, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio16_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO16_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO16_CFG_BIT_T bf;
} NX51_MMIO16_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio17_cfg */
/* => Multiplexmatrix Configuration Register for MMIO17 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio17_cfg       0x00000044U
#define Adr_NX51_mmio_ctrl_mmio17_cfg 0x1018C244U
#define Adr_NX51_mmio17_cfg           0x1018C244U
#define DFLT_VAL_NX51_mmio17_cfg      0x00000021U

#define MSK_NX51_mmio17_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio17_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio17_cfg_mmio_sel        0x00000021U
#define DFLT_BF_VAL_NX51_mmio17_cfg_mmio_sel     0x00000021U
#define MSK_NX51_mmio17_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio17_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio17_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio17_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio17_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio17_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio17_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio17_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio17_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio17_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio17_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio17_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio17_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio17_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio17_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio17_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio17_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio17_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio17_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio17_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio17_cfg': */
#define MSK_USED_BITS_NX51_mmio17_cfg 0x0007037fU

enum {
	BFW_NX51_mmio17_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio17_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio17_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio17_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio17_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio17_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio17_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio17_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio17_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO17_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio17_cfg_mmio_sel;     /* mmio17 signal selection (default: gpio17, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio17_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio17_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio17_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio17_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio17_cfg_pio_oe;       /* PIO mode output enable of mmio17, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio17_cfg_pio_out;      /* PIO mode output drive level of mmio17, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio17_cfg_status_in_ro; /* current input status of mmio17, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio17_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO17_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO17_CFG_BIT_T bf;
} NX51_MMIO17_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio18_cfg */
/* => Multiplexmatrix Configuration Register for MMIO18 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio18_cfg       0x00000048U
#define Adr_NX51_mmio_ctrl_mmio18_cfg 0x1018C248U
#define Adr_NX51_mmio18_cfg           0x1018C248U
#define DFLT_VAL_NX51_mmio18_cfg      0x00000022U

#define MSK_NX51_mmio18_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio18_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio18_cfg_mmio_sel        0x00000022U
#define DFLT_BF_VAL_NX51_mmio18_cfg_mmio_sel     0x00000022U
#define MSK_NX51_mmio18_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio18_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio18_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio18_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio18_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio18_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio18_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio18_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio18_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio18_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio18_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio18_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio18_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio18_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio18_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio18_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio18_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio18_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio18_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio18_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio18_cfg': */
#define MSK_USED_BITS_NX51_mmio18_cfg 0x0007037fU

enum {
	BFW_NX51_mmio18_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio18_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio18_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio18_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio18_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio18_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio18_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio18_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio18_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO18_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio18_cfg_mmio_sel;     /* mmio18 signal selection (default: gpio18, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio18_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio18_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio18_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio18_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio18_cfg_pio_oe;       /* PIO mode output enable of mmio18, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio18_cfg_pio_out;      /* PIO mode output drive level of mmio18, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio18_cfg_status_in_ro; /* current input status of mmio18, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio18_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO18_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO18_CFG_BIT_T bf;
} NX51_MMIO18_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio19_cfg */
/* => Multiplexmatrix Configuration Register for MMIO19 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio19_cfg       0x0000004CU
#define Adr_NX51_mmio_ctrl_mmio19_cfg 0x1018C24CU
#define Adr_NX51_mmio19_cfg           0x1018C24CU
#define DFLT_VAL_NX51_mmio19_cfg      0x00000023U

#define MSK_NX51_mmio19_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio19_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio19_cfg_mmio_sel        0x00000023U
#define DFLT_BF_VAL_NX51_mmio19_cfg_mmio_sel     0x00000023U
#define MSK_NX51_mmio19_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio19_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio19_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio19_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio19_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio19_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio19_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio19_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio19_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio19_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio19_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio19_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio19_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio19_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio19_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio19_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio19_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio19_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio19_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio19_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio19_cfg': */
#define MSK_USED_BITS_NX51_mmio19_cfg 0x0007037fU

enum {
	BFW_NX51_mmio19_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio19_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio19_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio19_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio19_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio19_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio19_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio19_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio19_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO19_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio19_cfg_mmio_sel;     /* mmio19 signal selection (default: gpio19, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio19_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio19_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio19_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio19_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio19_cfg_pio_oe;       /* PIO mode output enable of mmio19, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio19_cfg_pio_out;      /* PIO mode output drive level of mmio19, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio19_cfg_status_in_ro; /* current input status of mmio19, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio19_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO19_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO19_CFG_BIT_T bf;
} NX51_MMIO19_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio20_cfg */
/* => Multiplexmatrix Configuration Register for MMIO20 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio20_cfg       0x00000050U
#define Adr_NX51_mmio_ctrl_mmio20_cfg 0x1018C250U
#define Adr_NX51_mmio20_cfg           0x1018C250U
#define DFLT_VAL_NX51_mmio20_cfg      0x00000024U

#define MSK_NX51_mmio20_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio20_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio20_cfg_mmio_sel        0x00000024U
#define DFLT_BF_VAL_NX51_mmio20_cfg_mmio_sel     0x00000024U
#define MSK_NX51_mmio20_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio20_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio20_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio20_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio20_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio20_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio20_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio20_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio20_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio20_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio20_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio20_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio20_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio20_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio20_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio20_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio20_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio20_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio20_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio20_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio20_cfg': */
#define MSK_USED_BITS_NX51_mmio20_cfg 0x0007037fU

enum {
	BFW_NX51_mmio20_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio20_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio20_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio20_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio20_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio20_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio20_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio20_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio20_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO20_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio20_cfg_mmio_sel;     /* mmio20 signal selection (default: gpio20, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio20_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio20_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio20_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio20_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio20_cfg_pio_oe;       /* PIO mode output enable of mmio20, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio20_cfg_pio_out;      /* PIO mode output drive level of mmio20, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio20_cfg_status_in_ro; /* current input status of mmio20, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio20_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO20_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO20_CFG_BIT_T bf;
} NX51_MMIO20_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio21_cfg */
/* => Multiplexmatrix Configuration Register for MMIO21 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio21_cfg       0x00000054U
#define Adr_NX51_mmio_ctrl_mmio21_cfg 0x1018C254U
#define Adr_NX51_mmio21_cfg           0x1018C254U
#define DFLT_VAL_NX51_mmio21_cfg      0x00000025U

#define MSK_NX51_mmio21_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio21_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio21_cfg_mmio_sel        0x00000025U
#define DFLT_BF_VAL_NX51_mmio21_cfg_mmio_sel     0x00000025U
#define MSK_NX51_mmio21_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio21_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio21_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio21_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio21_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio21_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio21_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio21_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio21_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio21_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio21_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio21_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio21_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio21_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio21_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio21_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio21_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio21_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio21_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio21_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio21_cfg': */
#define MSK_USED_BITS_NX51_mmio21_cfg 0x0007037fU

enum {
	BFW_NX51_mmio21_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio21_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio21_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio21_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio21_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio21_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio21_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio21_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio21_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO21_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio21_cfg_mmio_sel;     /* mmio21 signal selection (default: gpio21, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio21_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio21_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio21_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio21_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio21_cfg_pio_oe;       /* PIO mode output enable of mmio21, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio21_cfg_pio_out;      /* PIO mode output drive level of mmio21, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio21_cfg_status_in_ro; /* current input status of mmio21, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio21_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO21_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO21_CFG_BIT_T bf;
} NX51_MMIO21_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio22_cfg */
/* => Multiplexmatrix Configuration Register for MMIO22 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio22_cfg       0x00000058U
#define Adr_NX51_mmio_ctrl_mmio22_cfg 0x1018C258U
#define Adr_NX51_mmio22_cfg           0x1018C258U
#define DFLT_VAL_NX51_mmio22_cfg      0x00000026U

#define MSK_NX51_mmio22_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio22_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio22_cfg_mmio_sel        0x00000026U
#define DFLT_BF_VAL_NX51_mmio22_cfg_mmio_sel     0x00000026U
#define MSK_NX51_mmio22_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio22_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio22_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio22_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio22_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio22_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio22_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio22_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio22_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio22_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio22_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio22_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio22_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio22_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio22_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio22_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio22_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio22_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio22_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio22_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio22_cfg': */
#define MSK_USED_BITS_NX51_mmio22_cfg 0x0007037fU

enum {
	BFW_NX51_mmio22_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio22_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio22_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio22_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio22_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio22_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio22_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio22_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio22_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO22_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio22_cfg_mmio_sel;     /* mmio22 signal selection (default: gpio22, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio22_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio22_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio22_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio22_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio22_cfg_pio_oe;       /* PIO mode output enable of mmio22, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio22_cfg_pio_out;      /* PIO mode output drive level of mmio22, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio22_cfg_status_in_ro; /* current input status of mmio22, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio22_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO22_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO22_CFG_BIT_T bf;
} NX51_MMIO22_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio23_cfg */
/* => Multiplexmatrix Configuration Register for MMIO23 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio23_cfg       0x0000005CU
#define Adr_NX51_mmio_ctrl_mmio23_cfg 0x1018C25CU
#define Adr_NX51_mmio23_cfg           0x1018C25CU
#define DFLT_VAL_NX51_mmio23_cfg      0x00000027U

#define MSK_NX51_mmio23_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio23_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio23_cfg_mmio_sel        0x00000027U
#define DFLT_BF_VAL_NX51_mmio23_cfg_mmio_sel     0x00000027U
#define MSK_NX51_mmio23_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio23_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio23_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio23_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio23_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio23_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio23_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio23_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio23_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio23_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio23_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio23_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio23_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio23_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio23_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio23_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio23_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio23_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio23_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio23_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio23_cfg': */
#define MSK_USED_BITS_NX51_mmio23_cfg 0x0007037fU

enum {
	BFW_NX51_mmio23_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio23_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio23_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio23_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio23_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio23_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio23_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio23_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio23_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO23_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio23_cfg_mmio_sel;     /* mmio23 signal selection (default: gpio23, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio23_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio23_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio23_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio23_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio23_cfg_pio_oe;       /* PIO mode output enable of mmio23, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio23_cfg_pio_out;      /* PIO mode output drive level of mmio23, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio23_cfg_status_in_ro; /* current input status of mmio23, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio23_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO23_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO23_CFG_BIT_T bf;
} NX51_MMIO23_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio24_cfg */
/* => Multiplexmatrix Configuration Register for MMIO24 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio24_cfg       0x00000060U
#define Adr_NX51_mmio_ctrl_mmio24_cfg 0x1018C260U
#define Adr_NX51_mmio24_cfg           0x1018C260U
#define DFLT_VAL_NX51_mmio24_cfg      0x00000028U

#define MSK_NX51_mmio24_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio24_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio24_cfg_mmio_sel        0x00000028U
#define DFLT_BF_VAL_NX51_mmio24_cfg_mmio_sel     0x00000028U
#define MSK_NX51_mmio24_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio24_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio24_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio24_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio24_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio24_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio24_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio24_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio24_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio24_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio24_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio24_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio24_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio24_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio24_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio24_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio24_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio24_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio24_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio24_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio24_cfg': */
#define MSK_USED_BITS_NX51_mmio24_cfg 0x0007037fU

enum {
	BFW_NX51_mmio24_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio24_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio24_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio24_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio24_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio24_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio24_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio24_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio24_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO24_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio24_cfg_mmio_sel;     /* mmio24 signal selection (default: gpio24, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio24_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio24_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio24_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio24_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio24_cfg_pio_oe;       /* PIO mode output enable of mmio24, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio24_cfg_pio_out;      /* PIO mode output drive level of mmio24, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio24_cfg_status_in_ro; /* current input status of mmio24, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio24_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO24_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO24_CFG_BIT_T bf;
} NX51_MMIO24_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio25_cfg */
/* => Multiplexmatrix Configuration Register for MMIO25 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio25_cfg       0x00000064U
#define Adr_NX51_mmio_ctrl_mmio25_cfg 0x1018C264U
#define Adr_NX51_mmio25_cfg           0x1018C264U
#define DFLT_VAL_NX51_mmio25_cfg      0x00000029U

#define MSK_NX51_mmio25_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio25_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio25_cfg_mmio_sel        0x00000029U
#define DFLT_BF_VAL_NX51_mmio25_cfg_mmio_sel     0x00000029U
#define MSK_NX51_mmio25_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio25_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio25_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio25_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio25_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio25_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio25_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio25_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio25_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio25_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio25_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio25_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio25_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio25_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio25_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio25_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio25_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio25_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio25_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio25_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio25_cfg': */
#define MSK_USED_BITS_NX51_mmio25_cfg 0x0007037fU

enum {
	BFW_NX51_mmio25_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio25_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio25_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio25_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio25_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio25_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio25_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio25_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio25_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO25_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio25_cfg_mmio_sel;     /* mmio25 signal selection (default: gpio25, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio25_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio25_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio25_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio25_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio25_cfg_pio_oe;       /* PIO mode output enable of mmio25, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio25_cfg_pio_out;      /* PIO mode output drive level of mmio25, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio25_cfg_status_in_ro; /* current input status of mmio25, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio25_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO25_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO25_CFG_BIT_T bf;
} NX51_MMIO25_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio26_cfg */
/* => Multiplexmatrix Configuration Register for MMIO26 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio26_cfg       0x00000068U
#define Adr_NX51_mmio_ctrl_mmio26_cfg 0x1018C268U
#define Adr_NX51_mmio26_cfg           0x1018C268U
#define DFLT_VAL_NX51_mmio26_cfg      0x0000002aU

#define MSK_NX51_mmio26_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio26_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio26_cfg_mmio_sel        0x0000002aU
#define DFLT_BF_VAL_NX51_mmio26_cfg_mmio_sel     0x0000002aU
#define MSK_NX51_mmio26_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio26_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio26_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio26_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio26_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio26_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio26_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio26_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio26_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio26_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio26_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio26_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio26_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio26_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio26_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio26_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio26_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio26_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio26_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio26_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio26_cfg': */
#define MSK_USED_BITS_NX51_mmio26_cfg 0x0007037fU

enum {
	BFW_NX51_mmio26_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio26_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio26_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio26_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio26_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio26_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio26_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio26_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio26_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO26_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio26_cfg_mmio_sel;     /* mmio26 signal selection (default: gpio26, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio26_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio26_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio26_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio26_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio26_cfg_pio_oe;       /* PIO mode output enable of mmio26, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio26_cfg_pio_out;      /* PIO mode output drive level of mmio26, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio26_cfg_status_in_ro; /* current input status of mmio26, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio26_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO26_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO26_CFG_BIT_T bf;
} NX51_MMIO26_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio27_cfg */
/* => Multiplexmatrix Configuration Register for MMIO27 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio27_cfg       0x0000006CU
#define Adr_NX51_mmio_ctrl_mmio27_cfg 0x1018C26CU
#define Adr_NX51_mmio27_cfg           0x1018C26CU
#define DFLT_VAL_NX51_mmio27_cfg      0x0000002bU

#define MSK_NX51_mmio27_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio27_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio27_cfg_mmio_sel        0x0000002bU
#define DFLT_BF_VAL_NX51_mmio27_cfg_mmio_sel     0x0000002bU
#define MSK_NX51_mmio27_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio27_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio27_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio27_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio27_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio27_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio27_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio27_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio27_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio27_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio27_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio27_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio27_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio27_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio27_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio27_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio27_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio27_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio27_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio27_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio27_cfg': */
#define MSK_USED_BITS_NX51_mmio27_cfg 0x0007037fU

enum {
	BFW_NX51_mmio27_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio27_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio27_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio27_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio27_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio27_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio27_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio27_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio27_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO27_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio27_cfg_mmio_sel;     /* mmio27 signal selection (default: gpio27, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio27_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio27_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio27_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio27_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio27_cfg_pio_oe;       /* PIO mode output enable of mmio27, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio27_cfg_pio_out;      /* PIO mode output drive level of mmio27, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio27_cfg_status_in_ro; /* current input status of mmio27, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio27_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO27_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO27_CFG_BIT_T bf;
} NX51_MMIO27_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio28_cfg */
/* => Multiplexmatrix Configuration Register for MMIO28 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio28_cfg       0x00000070U
#define Adr_NX51_mmio_ctrl_mmio28_cfg 0x1018C270U
#define Adr_NX51_mmio28_cfg           0x1018C270U
#define DFLT_VAL_NX51_mmio28_cfg      0x0000002cU

#define MSK_NX51_mmio28_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio28_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio28_cfg_mmio_sel        0x0000002cU
#define DFLT_BF_VAL_NX51_mmio28_cfg_mmio_sel     0x0000002cU
#define MSK_NX51_mmio28_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio28_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio28_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio28_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio28_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio28_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio28_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio28_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio28_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio28_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio28_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio28_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio28_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio28_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio28_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio28_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio28_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio28_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio28_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio28_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio28_cfg': */
#define MSK_USED_BITS_NX51_mmio28_cfg 0x0007037fU

enum {
	BFW_NX51_mmio28_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio28_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio28_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio28_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio28_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio28_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio28_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio28_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio28_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO28_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio28_cfg_mmio_sel;     /* mmio28 signal selection (default: gpio28, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio28_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio28_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio28_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio28_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio28_cfg_pio_oe;       /* PIO mode output enable of mmio28, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio28_cfg_pio_out;      /* PIO mode output drive level of mmio28, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio28_cfg_status_in_ro; /* current input status of mmio28, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio28_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO28_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO28_CFG_BIT_T bf;
} NX51_MMIO28_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio29_cfg */
/* => Multiplexmatrix Configuration Register for MMIO29 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio29_cfg       0x00000074U
#define Adr_NX51_mmio_ctrl_mmio29_cfg 0x1018C274U
#define Adr_NX51_mmio29_cfg           0x1018C274U
#define DFLT_VAL_NX51_mmio29_cfg      0x0000002dU

#define MSK_NX51_mmio29_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio29_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio29_cfg_mmio_sel        0x0000002dU
#define DFLT_BF_VAL_NX51_mmio29_cfg_mmio_sel     0x0000002dU
#define MSK_NX51_mmio29_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio29_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio29_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio29_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio29_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio29_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio29_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio29_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio29_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio29_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio29_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio29_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio29_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio29_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio29_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio29_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio29_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio29_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio29_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio29_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio29_cfg': */
#define MSK_USED_BITS_NX51_mmio29_cfg 0x0007037fU

enum {
	BFW_NX51_mmio29_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio29_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio29_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio29_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio29_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio29_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio29_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio29_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio29_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO29_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio29_cfg_mmio_sel;     /* mmio29 signal selection (default: gpio29, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio29_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio29_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio29_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio29_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio29_cfg_pio_oe;       /* PIO mode output enable of mmio29, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio29_cfg_pio_out;      /* PIO mode output drive level of mmio29, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio29_cfg_status_in_ro; /* current input status of mmio29, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio29_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO29_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO29_CFG_BIT_T bf;
} NX51_MMIO29_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio30_cfg */
/* => Multiplexmatrix Configuration Register for MMIO30 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio30_cfg       0x00000078U
#define Adr_NX51_mmio_ctrl_mmio30_cfg 0x1018C278U
#define Adr_NX51_mmio30_cfg           0x1018C278U
#define DFLT_VAL_NX51_mmio30_cfg      0x0000002eU

#define MSK_NX51_mmio30_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio30_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio30_cfg_mmio_sel        0x0000002eU
#define DFLT_BF_VAL_NX51_mmio30_cfg_mmio_sel     0x0000002eU
#define MSK_NX51_mmio30_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio30_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio30_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio30_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio30_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio30_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio30_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio30_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio30_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio30_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio30_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio30_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio30_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio30_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio30_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio30_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio30_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio30_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio30_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio30_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio30_cfg': */
#define MSK_USED_BITS_NX51_mmio30_cfg 0x0007037fU

enum {
	BFW_NX51_mmio30_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio30_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio30_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio30_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio30_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio30_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio30_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio30_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio30_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO30_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio30_cfg_mmio_sel;     /* mmio30 signal selection (default: gpio30, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio30_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio30_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio30_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio30_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio30_cfg_pio_oe;       /* PIO mode output enable of mmio30, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio30_cfg_pio_out;      /* PIO mode output drive level of mmio30, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio30_cfg_status_in_ro; /* current input status of mmio30, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio30_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO30_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO30_CFG_BIT_T bf;
} NX51_MMIO30_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio31_cfg */
/* => Multiplexmatrix Configuration Register for MMIO31 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio31_cfg       0x0000007CU
#define Adr_NX51_mmio_ctrl_mmio31_cfg 0x1018C27CU
#define Adr_NX51_mmio31_cfg           0x1018C27CU
#define DFLT_VAL_NX51_mmio31_cfg      0x0000002fU

#define MSK_NX51_mmio31_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio31_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio31_cfg_mmio_sel        0x0000002fU
#define DFLT_BF_VAL_NX51_mmio31_cfg_mmio_sel     0x0000002fU
#define MSK_NX51_mmio31_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio31_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio31_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio31_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio31_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio31_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio31_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio31_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio31_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio31_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio31_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio31_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio31_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio31_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio31_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio31_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio31_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio31_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio31_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio31_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio31_cfg': */
#define MSK_USED_BITS_NX51_mmio31_cfg 0x0007037fU

enum {
	BFW_NX51_mmio31_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio31_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio31_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio31_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio31_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio31_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio31_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio31_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio31_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO31_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio31_cfg_mmio_sel;     /* mmio31 signal selection (default: gpio31, access-key-protected).                                                   */
	unsigned int reserved1    : BFW_NX51_mmio31_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio31_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio31_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio31_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio31_cfg_pio_oe;       /* PIO mode output enable of mmio31, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio31_cfg_pio_out;      /* PIO mode output drive level of mmio31, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio31_cfg_status_in_ro; /* current input status of mmio31, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio31_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO31_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO31_CFG_BIT_T bf;
} NX51_MMIO31_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio32_cfg */
/* => Multiplexmatrix Configuration Register for MMIO32 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio32_cfg       0x00000080U
#define Adr_NX51_mmio_ctrl_mmio32_cfg 0x1018C280U
#define Adr_NX51_mmio32_cfg           0x1018C280U
#define DFLT_VAL_NX51_mmio32_cfg      0x0000004bU

#define MSK_NX51_mmio32_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio32_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio32_cfg_mmio_sel        0x0000004bU
#define DFLT_BF_VAL_NX51_mmio32_cfg_mmio_sel     0x0000004bU
#define MSK_NX51_mmio32_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio32_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio32_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio32_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio32_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio32_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio32_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio32_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio32_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio32_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio32_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio32_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio32_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio32_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio32_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio32_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio32_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio32_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio32_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio32_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio32_cfg': */
#define MSK_USED_BITS_NX51_mmio32_cfg 0x0007037fU

enum {
	BFW_NX51_mmio32_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio32_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio32_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio32_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio32_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio32_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio32_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio32_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio32_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO32_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio32_cfg_mmio_sel;     /* mmio32 signal selection (default: uart0_ctsn, access-key-protected).                                               */
	unsigned int reserved1    : BFW_NX51_mmio32_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio32_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio32_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio32_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio32_cfg_pio_oe;       /* PIO mode output enable of mmio32, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio32_cfg_pio_out;      /* PIO mode output drive level of mmio32, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio32_cfg_status_in_ro; /* current input status of mmio32, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio32_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO32_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO32_CFG_BIT_T bf;
} NX51_MMIO32_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio33_cfg */
/* => Multiplexmatrix Configuration Register for MMIO33 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio33_cfg       0x00000084U
#define Adr_NX51_mmio_ctrl_mmio33_cfg 0x1018C284U
#define Adr_NX51_mmio33_cfg           0x1018C284U
#define DFLT_VAL_NX51_mmio33_cfg      0x0000004cU

#define MSK_NX51_mmio33_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio33_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio33_cfg_mmio_sel        0x0000004cU
#define DFLT_BF_VAL_NX51_mmio33_cfg_mmio_sel     0x0000004cU
#define MSK_NX51_mmio33_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio33_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio33_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio33_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio33_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio33_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio33_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio33_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio33_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio33_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio33_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio33_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio33_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio33_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio33_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio33_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio33_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio33_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio33_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio33_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio33_cfg': */
#define MSK_USED_BITS_NX51_mmio33_cfg 0x0007037fU

enum {
	BFW_NX51_mmio33_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio33_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio33_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio33_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio33_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio33_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio33_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio33_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio33_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO33_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio33_cfg_mmio_sel;     /* mmio33 signal selection (default: uart0_rtsn, access-key-protected).                                               */
	unsigned int reserved1    : BFW_NX51_mmio33_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio33_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio33_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio33_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio33_cfg_pio_oe;       /* PIO mode output enable of mmio33, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio33_cfg_pio_out;      /* PIO mode output drive level of mmio33, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio33_cfg_status_in_ro; /* current input status of mmio33, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio33_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO33_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO33_CFG_BIT_T bf;
} NX51_MMIO33_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio34_cfg */
/* => Multiplexmatrix Configuration Register for MMIO34 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio34_cfg       0x00000088U
#define Adr_NX51_mmio_ctrl_mmio34_cfg 0x1018C288U
#define Adr_NX51_mmio34_cfg           0x1018C288U
#define DFLT_VAL_NX51_mmio34_cfg      0x0000004dU

#define MSK_NX51_mmio34_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio34_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio34_cfg_mmio_sel        0x0000004dU
#define DFLT_BF_VAL_NX51_mmio34_cfg_mmio_sel     0x0000004dU
#define MSK_NX51_mmio34_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio34_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio34_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio34_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio34_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio34_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio34_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio34_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio34_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio34_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio34_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio34_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio34_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio34_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio34_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio34_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio34_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio34_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio34_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio34_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio34_cfg': */
#define MSK_USED_BITS_NX51_mmio34_cfg 0x0007037fU

enum {
	BFW_NX51_mmio34_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio34_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio34_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio34_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio34_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio34_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio34_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio34_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio34_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO34_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio34_cfg_mmio_sel;     /* mmio34 signal selection (default: uart0_rxd, access-key-protected).                                                */
	unsigned int reserved1    : BFW_NX51_mmio34_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio34_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio34_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio34_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio34_cfg_pio_oe;       /* PIO mode output enable of mmio34, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio34_cfg_pio_out;      /* PIO mode output drive level of mmio34, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio34_cfg_status_in_ro; /* current input status of mmio34, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio34_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO34_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO34_CFG_BIT_T bf;
} NX51_MMIO34_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio35_cfg */
/* => Multiplexmatrix Configuration Register for MMIO35 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio35_cfg       0x0000008CU
#define Adr_NX51_mmio_ctrl_mmio35_cfg 0x1018C28CU
#define Adr_NX51_mmio35_cfg           0x1018C28CU
#define DFLT_VAL_NX51_mmio35_cfg      0x0000004eU

#define MSK_NX51_mmio35_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio35_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio35_cfg_mmio_sel        0x0000004eU
#define DFLT_BF_VAL_NX51_mmio35_cfg_mmio_sel     0x0000004eU
#define MSK_NX51_mmio35_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio35_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio35_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio35_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio35_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio35_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio35_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio35_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio35_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio35_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio35_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio35_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio35_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio35_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio35_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio35_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio35_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio35_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio35_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio35_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio35_cfg': */
#define MSK_USED_BITS_NX51_mmio35_cfg 0x0007037fU

enum {
	BFW_NX51_mmio35_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio35_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio35_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio35_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio35_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio35_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio35_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio35_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio35_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO35_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio35_cfg_mmio_sel;     /* mmio35 signal selection (default: uart0_txd, access-key-protected).                                                */
	unsigned int reserved1    : BFW_NX51_mmio35_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio35_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio35_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio35_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio35_cfg_pio_oe;       /* PIO mode output enable of mmio35, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio35_cfg_pio_out;      /* PIO mode output drive level of mmio35, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio35_cfg_status_in_ro; /* current input status of mmio35, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio35_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO35_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO35_CFG_BIT_T bf;
} NX51_MMIO35_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio36_cfg */
/* => Multiplexmatrix Configuration Register for MMIO36 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio36_cfg       0x00000090U
#define Adr_NX51_mmio_ctrl_mmio36_cfg 0x1018C290U
#define Adr_NX51_mmio36_cfg           0x1018C290U
#define DFLT_VAL_NX51_mmio36_cfg      0x0000004fU

#define MSK_NX51_mmio36_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio36_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio36_cfg_mmio_sel        0x0000004fU
#define DFLT_BF_VAL_NX51_mmio36_cfg_mmio_sel     0x0000004fU
#define MSK_NX51_mmio36_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio36_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio36_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio36_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio36_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio36_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio36_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio36_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio36_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio36_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio36_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio36_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio36_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio36_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio36_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio36_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio36_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio36_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio36_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio36_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio36_cfg': */
#define MSK_USED_BITS_NX51_mmio36_cfg 0x0007037fU

enum {
	BFW_NX51_mmio36_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio36_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio36_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio36_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio36_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio36_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio36_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio36_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio36_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO36_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio36_cfg_mmio_sel;     /* mmio36 signal selection (default: uart1_ctsn, access-key-protected).                                               */
	unsigned int reserved1    : BFW_NX51_mmio36_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio36_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio36_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio36_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio36_cfg_pio_oe;       /* PIO mode output enable of mmio36, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio36_cfg_pio_out;      /* PIO mode output drive level of mmio36, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio36_cfg_status_in_ro; /* current input status of mmio36, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio36_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO36_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO36_CFG_BIT_T bf;
} NX51_MMIO36_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio37_cfg */
/* => Multiplexmatrix Configuration Register for MMIO37 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio37_cfg       0x00000094U
#define Adr_NX51_mmio_ctrl_mmio37_cfg 0x1018C294U
#define Adr_NX51_mmio37_cfg           0x1018C294U
#define DFLT_VAL_NX51_mmio37_cfg      0x00000050U

#define MSK_NX51_mmio37_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio37_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio37_cfg_mmio_sel        0x00000050U
#define DFLT_BF_VAL_NX51_mmio37_cfg_mmio_sel     0x00000050U
#define MSK_NX51_mmio37_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio37_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio37_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio37_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio37_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio37_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio37_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio37_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio37_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio37_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio37_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio37_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio37_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio37_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio37_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio37_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio37_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio37_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio37_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio37_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio37_cfg': */
#define MSK_USED_BITS_NX51_mmio37_cfg 0x0007037fU

enum {
	BFW_NX51_mmio37_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio37_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio37_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio37_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio37_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio37_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio37_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio37_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio37_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO37_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio37_cfg_mmio_sel;     /* mmio37 signal selection (default: uart1_rtsn, access-key-protected).                                               */
	unsigned int reserved1    : BFW_NX51_mmio37_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio37_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio37_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio37_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio37_cfg_pio_oe;       /* PIO mode output enable of mmio37, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio37_cfg_pio_out;      /* PIO mode output drive level of mmio37, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio37_cfg_status_in_ro; /* current input status of mmio37, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio37_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO37_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO37_CFG_BIT_T bf;
} NX51_MMIO37_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio38_cfg */
/* => Multiplexmatrix Configuration Register for MMIO38 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio38_cfg       0x00000098U
#define Adr_NX51_mmio_ctrl_mmio38_cfg 0x1018C298U
#define Adr_NX51_mmio38_cfg           0x1018C298U
#define DFLT_VAL_NX51_mmio38_cfg      0x00000051U

#define MSK_NX51_mmio38_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio38_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio38_cfg_mmio_sel        0x00000051U
#define DFLT_BF_VAL_NX51_mmio38_cfg_mmio_sel     0x00000051U
#define MSK_NX51_mmio38_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio38_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio38_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio38_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio38_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio38_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio38_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio38_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio38_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio38_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio38_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio38_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio38_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio38_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio38_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio38_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio38_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio38_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio38_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio38_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio38_cfg': */
#define MSK_USED_BITS_NX51_mmio38_cfg 0x0007037fU

enum {
	BFW_NX51_mmio38_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio38_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio38_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio38_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio38_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio38_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio38_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio38_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio38_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO38_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio38_cfg_mmio_sel;     /* mmio38 signal selection (default: uart1_rxd, access-key-protected).                                                */
	unsigned int reserved1    : BFW_NX51_mmio38_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio38_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio38_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio38_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio38_cfg_pio_oe;       /* PIO mode output enable of mmio38, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio38_cfg_pio_out;      /* PIO mode output drive level of mmio38, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio38_cfg_status_in_ro; /* current input status of mmio38, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio38_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO38_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO38_CFG_BIT_T bf;
} NX51_MMIO38_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio39_cfg */
/* => Multiplexmatrix Configuration Register for MMIO39 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio39_cfg       0x0000009CU
#define Adr_NX51_mmio_ctrl_mmio39_cfg 0x1018C29CU
#define Adr_NX51_mmio39_cfg           0x1018C29CU
#define DFLT_VAL_NX51_mmio39_cfg      0x00000052U

#define MSK_NX51_mmio39_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio39_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio39_cfg_mmio_sel        0x00000052U
#define DFLT_BF_VAL_NX51_mmio39_cfg_mmio_sel     0x00000052U
#define MSK_NX51_mmio39_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio39_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio39_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio39_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio39_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio39_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio39_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio39_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio39_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio39_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio39_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio39_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio39_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio39_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio39_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio39_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio39_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio39_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio39_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio39_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio39_cfg': */
#define MSK_USED_BITS_NX51_mmio39_cfg 0x0007037fU

enum {
	BFW_NX51_mmio39_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio39_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio39_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio39_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio39_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio39_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio39_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio39_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio39_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO39_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio39_cfg_mmio_sel;     /* mmio39 signal selection (default: uart1_txd, access-key-protected).                                                */
	unsigned int reserved1    : BFW_NX51_mmio39_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio39_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio39_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio39_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio39_cfg_pio_oe;       /* PIO mode output enable of mmio39, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio39_cfg_pio_out;      /* PIO mode output drive level of mmio39, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio39_cfg_status_in_ro; /* current input status of mmio39, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio39_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO39_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO39_CFG_BIT_T bf;
} NX51_MMIO39_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio40_cfg */
/* => Multiplexmatrix Configuration Register for MMIO40 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio40 signal is a multiplex option of HIF_D8 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio40_cfg       0x000000A0U
#define Adr_NX51_mmio_ctrl_mmio40_cfg 0x1018C2A0U
#define Adr_NX51_mmio40_cfg           0x1018C2A0U
#define DFLT_VAL_NX51_mmio40_cfg      0x0000007fU

#define MSK_NX51_mmio40_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio40_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio40_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio40_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio40_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio40_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio40_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio40_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio40_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio40_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio40_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio40_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio40_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio40_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio40_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio40_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio40_cfg': */
#define MSK_USED_BITS_NX51_mmio40_cfg 0x0004037fU

enum {
	BFW_NX51_mmio40_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio40_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio40_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio40_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio40_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio40_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio40_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO40_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio40_cfg_mmio_sel;     /* mmio40 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio40 signal is a multiplex option of HIF_D8 and will be selected when this bit-field  */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio40 signal. */
	                                                              /* Default value 0x7f deselects mmio40 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio40_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio40_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio40_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio40_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio40_cfg_status_in_ro; /* current input status of mmio40 port HIF_D8.                                             */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio40_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO40_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO40_CFG_BIT_T bf;
} NX51_MMIO40_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio41_cfg */
/* => Multiplexmatrix Configuration Register for MMIO41 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio41 signal is a multiplex option of HIF_D9 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio41_cfg       0x000000A4U
#define Adr_NX51_mmio_ctrl_mmio41_cfg 0x1018C2A4U
#define Adr_NX51_mmio41_cfg           0x1018C2A4U
#define DFLT_VAL_NX51_mmio41_cfg      0x0000007fU

#define MSK_NX51_mmio41_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio41_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio41_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio41_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio41_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio41_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio41_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio41_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio41_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio41_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio41_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio41_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio41_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio41_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio41_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio41_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio41_cfg': */
#define MSK_USED_BITS_NX51_mmio41_cfg 0x0004037fU

enum {
	BFW_NX51_mmio41_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio41_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio41_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio41_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio41_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio41_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio41_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO41_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio41_cfg_mmio_sel;     /* mmio41 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio41 signal is a multiplex option of HIF_D9 and will be selected when this bit-field  */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio41 signal. */
	                                                              /* Default value 0x7f deselects mmio41 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio41_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio41_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio41_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio41_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio41_cfg_status_in_ro; /* current input status of mmio41 port HIF_D9.                                             */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio41_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO41_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO41_CFG_BIT_T bf;
} NX51_MMIO41_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio42_cfg */
/* => Multiplexmatrix Configuration Register for MMIO42 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio42 signal is a multiplex option of HIF_D10 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio42_cfg       0x000000A8U
#define Adr_NX51_mmio_ctrl_mmio42_cfg 0x1018C2A8U
#define Adr_NX51_mmio42_cfg           0x1018C2A8U
#define DFLT_VAL_NX51_mmio42_cfg      0x0000007fU

#define MSK_NX51_mmio42_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio42_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio42_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio42_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio42_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio42_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio42_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio42_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio42_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio42_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio42_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio42_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio42_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio42_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio42_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio42_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio42_cfg': */
#define MSK_USED_BITS_NX51_mmio42_cfg 0x0004037fU

enum {
	BFW_NX51_mmio42_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio42_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio42_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio42_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio42_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio42_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio42_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO42_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio42_cfg_mmio_sel;     /* mmio42 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio42 signal is a multiplex option of HIF_D10 and will be selected when this bit-field */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio42 signal. */
	                                                              /* Default value 0x7f deselects mmio42 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio42_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio42_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio42_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio42_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio42_cfg_status_in_ro; /* current input status of mmio42 port HIF_D10.                                            */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio42_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO42_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO42_CFG_BIT_T bf;
} NX51_MMIO42_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio43_cfg */
/* => Multiplexmatrix Configuration Register for MMIO43 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio43 signal is a multiplex option of HIF_D11 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio43_cfg       0x000000ACU
#define Adr_NX51_mmio_ctrl_mmio43_cfg 0x1018C2ACU
#define Adr_NX51_mmio43_cfg           0x1018C2ACU
#define DFLT_VAL_NX51_mmio43_cfg      0x0000007fU

#define MSK_NX51_mmio43_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio43_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio43_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio43_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio43_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio43_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio43_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio43_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio43_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio43_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio43_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio43_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio43_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio43_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio43_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio43_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio43_cfg': */
#define MSK_USED_BITS_NX51_mmio43_cfg 0x0004037fU

enum {
	BFW_NX51_mmio43_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio43_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio43_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio43_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio43_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio43_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio43_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO43_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio43_cfg_mmio_sel;     /* mmio43 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio43 signal is a multiplex option of HIF_D11 and will be selected when this bit-field */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio43 signal. */
	                                                              /* Default value 0x7f deselects mmio43 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio43_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio43_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio43_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio43_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio43_cfg_status_in_ro; /* current input status of mmio43 port HIF_D11.                                            */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio43_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO43_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO43_CFG_BIT_T bf;
} NX51_MMIO43_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio44_cfg */
/* => Multiplexmatrix Configuration Register for MMIO44 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio44 signal is a multiplex option of HIF_D12 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio44_cfg       0x000000B0U
#define Adr_NX51_mmio_ctrl_mmio44_cfg 0x1018C2B0U
#define Adr_NX51_mmio44_cfg           0x1018C2B0U
#define DFLT_VAL_NX51_mmio44_cfg      0x0000007fU

#define MSK_NX51_mmio44_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio44_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio44_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio44_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio44_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio44_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio44_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio44_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio44_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio44_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio44_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio44_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio44_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio44_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio44_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio44_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio44_cfg': */
#define MSK_USED_BITS_NX51_mmio44_cfg 0x0004037fU

enum {
	BFW_NX51_mmio44_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio44_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio44_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio44_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio44_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio44_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio44_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO44_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio44_cfg_mmio_sel;     /* mmio44 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio44 signal is a multiplex option of HIF_D12 and will be selected when this bit-field */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio44 signal. */
	                                                              /* Default value 0x7f deselects mmio44 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio44_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio44_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio44_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio44_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio44_cfg_status_in_ro; /* current input status of mmio44 port HIF_D12.                                            */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio44_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO44_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO44_CFG_BIT_T bf;
} NX51_MMIO44_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio45_cfg */
/* => Multiplexmatrix Configuration Register for MMIO45 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio45 signal is a multiplex option of HIF_D13 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio45_cfg       0x000000B4U
#define Adr_NX51_mmio_ctrl_mmio45_cfg 0x1018C2B4U
#define Adr_NX51_mmio45_cfg           0x1018C2B4U
#define DFLT_VAL_NX51_mmio45_cfg      0x0000007fU

#define MSK_NX51_mmio45_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio45_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio45_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio45_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio45_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio45_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio45_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio45_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio45_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio45_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio45_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio45_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio45_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio45_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio45_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio45_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio45_cfg': */
#define MSK_USED_BITS_NX51_mmio45_cfg 0x0004037fU

enum {
	BFW_NX51_mmio45_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio45_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio45_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio45_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio45_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio45_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio45_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO45_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio45_cfg_mmio_sel;     /* mmio45 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio45 signal is a multiplex option of HIF_D13 and will be selected when this bit-field */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio45 signal. */
	                                                              /* Default value 0x7f deselects mmio45 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio45_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio45_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio45_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio45_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio45_cfg_status_in_ro; /* current input status of mmio45 port HIF_D13.                                            */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio45_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO45_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO45_CFG_BIT_T bf;
} NX51_MMIO45_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio46_cfg */
/* => Multiplexmatrix Configuration Register for MMIO46 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio46 signal is a multiplex option of HIF_D14 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio46_cfg       0x000000B8U
#define Adr_NX51_mmio_ctrl_mmio46_cfg 0x1018C2B8U
#define Adr_NX51_mmio46_cfg           0x1018C2B8U
#define DFLT_VAL_NX51_mmio46_cfg      0x0000007fU

#define MSK_NX51_mmio46_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio46_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio46_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio46_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio46_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio46_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio46_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio46_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio46_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio46_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio46_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio46_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio46_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio46_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio46_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio46_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio46_cfg': */
#define MSK_USED_BITS_NX51_mmio46_cfg 0x0004037fU

enum {
	BFW_NX51_mmio46_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio46_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio46_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio46_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio46_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio46_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio46_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO46_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio46_cfg_mmio_sel;     /* mmio46 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio46 signal is a multiplex option of HIF_D14 and will be selected when this bit-field */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio46 signal. */
	                                                              /* Default value 0x7f deselects mmio46 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio46_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio46_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio46_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio46_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio46_cfg_status_in_ro; /* current input status of mmio46 port HIF_D14.                                            */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio46_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO46_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO46_CFG_BIT_T bf;
} NX51_MMIO46_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio47_cfg */
/* => Multiplexmatrix Configuration Register for MMIO47 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/*    Note: */
/*       mmio47 signal is a multiplex option of HIF_D15 and has no PIO function. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio47_cfg       0x000000BCU
#define Adr_NX51_mmio_ctrl_mmio47_cfg 0x1018C2BCU
#define Adr_NX51_mmio47_cfg           0x1018C2BCU
#define DFLT_VAL_NX51_mmio47_cfg      0x0000007fU

#define MSK_NX51_mmio47_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio47_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio47_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio47_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio47_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio47_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio47_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio47_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio47_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio47_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio47_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio47_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio47_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio47_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio47_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio47_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio47_cfg': */
#define MSK_USED_BITS_NX51_mmio47_cfg 0x0004037fU

enum {
	BFW_NX51_mmio47_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio47_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio47_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio47_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio47_cfg_reserved2    = 8,  /* [17:10] */
	BFW_NX51_mmio47_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio47_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO47_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio47_cfg_mmio_sel;     /* mmio47 signal selection and multiplex function enable (access-key-protected).           */
	                                                              /* mmio47 signal is a multiplex option of HIF_D15 and will be selected when this bit-field */
	                                                              /* is programmed to non-PIO MMIO function. PIO mode does not exist for this mmio47 signal. */
	                                                              /* Default value 0x7f deselects mmio47 multiplex option.                                   */
	unsigned int reserved1    : BFW_NX51_mmio47_cfg_reserved1;    /* reserved                                                                                */
	unsigned int mmio_out_inv : BFW_NX51_mmio47_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)        */
	unsigned int mmio_in_inv  : BFW_NX51_mmio47_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)         */
	unsigned int reserved2    : BFW_NX51_mmio47_cfg_reserved2;    /* reserved                                                                                */
	unsigned int status_in_ro : BFW_NX51_mmio47_cfg_status_in_ro; /* current input status of mmio47 port HIF_D15.                                            */
	                                                              /* Could also be read from mmio_in_line_status register                                    */
	unsigned int reserved3    : BFW_NX51_mmio47_cfg_reserved3;    /* reserved                                                                                */
} NX51_MMIO47_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO47_CFG_BIT_T bf;
} NX51_MMIO47_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio48_cfg */
/* => Multiplexmatrix Configuration Register for MMIO48 */
/*    ------------------------------- */
/*    Some bits are protected by netX access-key algorithm. To change them run following sequence first: */
/*    1.: read out access key */
/*    2.: write back access key */
/*    3.: write desired value to this register */
/*    ------------------------------- */
/*    Core-inputs not mapped to any MMIO will be assigned to 0. */
/*    If one core-connection is mapped to more than one MMIO, the core-input-state will be these ored MMIO-states. */
/*    For signal selection codings (mmio*_sel) look at header of register adr_mmio0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio48_cfg       0x000000C0U
#define Adr_NX51_mmio_ctrl_mmio48_cfg 0x1018C2C0U
#define Adr_NX51_mmio48_cfg           0x1018C2C0U
#define DFLT_VAL_NX51_mmio48_cfg      0x0000007fU

#define MSK_NX51_mmio48_cfg_mmio_sel             0x0000007fU
#define SRT_NX51_mmio48_cfg_mmio_sel             0
#define DFLT_VAL_NX51_mmio48_cfg_mmio_sel        0x0000007fU
#define DFLT_BF_VAL_NX51_mmio48_cfg_mmio_sel     0x0000007fU
#define MSK_NX51_mmio48_cfg_mmio_out_inv         0x00000100U
#define SRT_NX51_mmio48_cfg_mmio_out_inv         8
#define DFLT_VAL_NX51_mmio48_cfg_mmio_out_inv    0x00000000U
#define DFLT_BF_VAL_NX51_mmio48_cfg_mmio_out_inv 0x00000000U
#define MSK_NX51_mmio48_cfg_mmio_in_inv          0x00000200U
#define SRT_NX51_mmio48_cfg_mmio_in_inv          9
#define DFLT_VAL_NX51_mmio48_cfg_mmio_in_inv     0x00000000U
#define DFLT_BF_VAL_NX51_mmio48_cfg_mmio_in_inv  0x00000000U
#define MSK_NX51_mmio48_cfg_pio_oe               0x00010000U
#define SRT_NX51_mmio48_cfg_pio_oe               16
#define DFLT_VAL_NX51_mmio48_cfg_pio_oe          0x00000000U
#define DFLT_BF_VAL_NX51_mmio48_cfg_pio_oe       0x00000000U
#define MSK_NX51_mmio48_cfg_pio_out              0x00020000U
#define SRT_NX51_mmio48_cfg_pio_out              17
#define DFLT_VAL_NX51_mmio48_cfg_pio_out         0x00000000U
#define DFLT_BF_VAL_NX51_mmio48_cfg_pio_out      0x00000000U
#define MSK_NX51_mmio48_cfg_status_in_ro         0x00040000U
#define SRT_NX51_mmio48_cfg_status_in_ro         18
#define DFLT_VAL_NX51_mmio48_cfg_status_in_ro    0x00000000U
#define DFLT_BF_VAL_NX51_mmio48_cfg_status_in_ro 0x00000000U

/* all used bits of 'NX51_mmio48_cfg': */
#define MSK_USED_BITS_NX51_mmio48_cfg 0x0007037fU

enum {
	BFW_NX51_mmio48_cfg_mmio_sel     = 7,  /* [6:0] */
	BFW_NX51_mmio48_cfg_reserved1    = 1,  /* [7] */
	BFW_NX51_mmio48_cfg_mmio_out_inv = 1,  /* [8] */
	BFW_NX51_mmio48_cfg_mmio_in_inv  = 1,  /* [9] */
	BFW_NX51_mmio48_cfg_reserved2    = 6,  /* [15:10] */
	BFW_NX51_mmio48_cfg_pio_oe       = 1,  /* [16] */
	BFW_NX51_mmio48_cfg_pio_out      = 1,  /* [17] */
	BFW_NX51_mmio48_cfg_status_in_ro = 1,  /* [18] */
	BFW_NX51_mmio48_cfg_reserved3    = 13  /* [31:19] */
};

typedef struct NX51_MMIO48_CFG_BIT_Ttag {
	unsigned int mmio_sel     : BFW_NX51_mmio48_cfg_mmio_sel;     /* mmio48 signal selection (default: PIO mode, access-key-protected).                                                 */
	unsigned int reserved1    : BFW_NX51_mmio48_cfg_reserved1;    /* reserved                                                                                                           */
	unsigned int mmio_out_inv : BFW_NX51_mmio48_cfg_mmio_out_inv; /* 1: invert output signal; 0: keep original signal polarity (access-key-protected)                                   */
	unsigned int mmio_in_inv  : BFW_NX51_mmio48_cfg_mmio_in_inv;  /* 1: invert input signal; 0: keep original signal polarity (access-key-protected)                                    */
	unsigned int reserved2    : BFW_NX51_mmio48_cfg_reserved2;    /* reserved                                                                                                           */
	unsigned int pio_oe       : BFW_NX51_mmio48_cfg_pio_oe;       /* PIO mode output enable of mmio48, could also be programmd by mmio_pio_oe_line_cfg register (not protected)         */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_oe_line_cfg register'.                               */
	unsigned int pio_out      : BFW_NX51_mmio48_cfg_pio_out;      /* PIO mode output drive level of mmio48, could also be programmd by 'mmio_pio_out_line_cfg' register (not protected) */
	                                                              /* Changing this bit will also change according bit in 'mmio_pio_out_line_cfg register'.                              */
	unsigned int status_in_ro : BFW_NX51_mmio48_cfg_status_in_ro; /* current input status of mmio48, could also be read from 'mmio_in_line_status' register                             */
	unsigned int reserved3    : BFW_NX51_mmio48_cfg_reserved3;    /* reserved                                                                                                           */
} NX51_MMIO48_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_MMIO48_CFG_BIT_T bf;
} NX51_MMIO48_CFG_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_out_line_cfg0 */
/* => MMIO PIO line output level register of MMIO 0 to 31. */
/*    Changing bits here will change 'pio_out' bit of related mmio*_cfg register. Changes there will change related bit inside this register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_pio_out_line_cfg0       0x000000C4U
#define Adr_NX51_mmio_ctrl_mmio_pio_out_line_cfg0 0x1018C2C4U
#define Adr_NX51_mmio_pio_out_line_cfg0           0x1018C2C4U
#define DFLT_VAL_NX51_mmio_pio_out_line_cfg0      0x00000000U

#define MSK_NX51_mmio_pio_out_line_cfg0_line         0xffffffffU
#define SRT_NX51_mmio_pio_out_line_cfg0_line         0
#define DFLT_VAL_NX51_mmio_pio_out_line_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX51_mmio_pio_out_line_cfg0_line 0x00000000U

/* all used bits of 'NX51_mmio_pio_out_line_cfg0': */
#define MSK_USED_BITS_NX51_mmio_pio_out_line_cfg0 0xffffffffU

enum {
	BFW_NX51_mmio_pio_out_line_cfg0_line = 32  /* [31:0] */
};

typedef struct NX51_MMIO_PIO_OUT_LINE_CFG0_BIT_Ttag {
	unsigned int line : BFW_NX51_mmio_pio_out_line_cfg0_line; /* MMIO output state if related MMIO is in PIO mode.                  */
	                                                          /* If related MMIO is not in PIO mode, programmed setting is ignored. */
	                                                          /* Bit 0 controls MMIO0, bit 1 controls MMIO1, ...                    */
} NX51_MMIO_PIO_OUT_LINE_CFG0_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_MMIO_PIO_OUT_LINE_CFG0_BIT_T bf;
} NX51_MMIO_PIO_OUT_LINE_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_out_line_cfg1 */
/* => MMIO PIO line output level register of MMIO 32 to 48. */
/*    Changing bits here will change 'pio_out' bit of related mmio*_cfg register. Changes there will change related bit inside this register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       mmio40 has no PIO function. Settings of related bit 8 inside this register will be ignored. */
/*       mmio41 has no PIO function. Settings of related bit 9 inside this register will be ignored. */
/*       mmio42 has no PIO function. Settings of related bit 10 inside this register will be ignored. */
/*       mmio43 has no PIO function. Settings of related bit 11 inside this register will be ignored. */
/*       mmio44 has no PIO function. Settings of related bit 12 inside this register will be ignored. */
/*       mmio45 has no PIO function. Settings of related bit 13 inside this register will be ignored. */
/*       mmio46 has no PIO function. Settings of related bit 14 inside this register will be ignored. */
/*       mmio47 has no PIO function. Settings of related bit 15 inside this register will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_pio_out_line_cfg1       0x000000C8U
#define Adr_NX51_mmio_ctrl_mmio_pio_out_line_cfg1 0x1018C2C8U
#define Adr_NX51_mmio_pio_out_line_cfg1           0x1018C2C8U
#define DFLT_VAL_NX51_mmio_pio_out_line_cfg1      0x00000000U

#define MSK_NX51_mmio_pio_out_line_cfg1_line         0x0001ffffU
#define SRT_NX51_mmio_pio_out_line_cfg1_line         0
#define DFLT_VAL_NX51_mmio_pio_out_line_cfg1_line    0x00000000U
#define DFLT_BF_VAL_NX51_mmio_pio_out_line_cfg1_line 0x00000000U

/* all used bits of 'NX51_mmio_pio_out_line_cfg1': */
#define MSK_USED_BITS_NX51_mmio_pio_out_line_cfg1 0x0001ffffU

enum {
	BFW_NX51_mmio_pio_out_line_cfg1_line      = 17, /* [16:0] */
	BFW_NX51_mmio_pio_out_line_cfg1_reserved1 = 15  /* [31:17] */
};

typedef struct NX51_MMIO_PIO_OUT_LINE_CFG1_BIT_Ttag {
	unsigned int line      : BFW_NX51_mmio_pio_out_line_cfg1_line;      /* MMIO output state if related MMIO is in PIO mode.                  */
	                                                                    /* If related MMIO is not in PIO mode, programmed setting is ignored. */
	                                                                    /* Bit 0 controls MMIO32, bit 1 controls MMIO33, ...                  */
	unsigned int reserved1 : BFW_NX51_mmio_pio_out_line_cfg1_reserved1; /* reserved                                                           */
} NX51_MMIO_PIO_OUT_LINE_CFG1_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_MMIO_PIO_OUT_LINE_CFG1_BIT_T bf;
} NX51_MMIO_PIO_OUT_LINE_CFG1_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_oe_line_cfg0 */
/* => MMIO PIO line output enable register of MMIO 0 to 31. */
/*    Changing bits here will change 'pio_oe' bit of related mmio*_cfg register. Changes there will change related bit inside this register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_pio_oe_line_cfg0       0x000000CCU
#define Adr_NX51_mmio_ctrl_mmio_pio_oe_line_cfg0 0x1018C2CCU
#define Adr_NX51_mmio_pio_oe_line_cfg0           0x1018C2CCU
#define DFLT_VAL_NX51_mmio_pio_oe_line_cfg0      0x00000000U

#define MSK_NX51_mmio_pio_oe_line_cfg0_line         0xffffffffU
#define SRT_NX51_mmio_pio_oe_line_cfg0_line         0
#define DFLT_VAL_NX51_mmio_pio_oe_line_cfg0_line    0x00000000U
#define DFLT_BF_VAL_NX51_mmio_pio_oe_line_cfg0_line 0x00000000U

/* all used bits of 'NX51_mmio_pio_oe_line_cfg0': */
#define MSK_USED_BITS_NX51_mmio_pio_oe_line_cfg0 0xffffffffU

enum {
	BFW_NX51_mmio_pio_oe_line_cfg0_line = 32  /* [31:0] */
};

typedef struct NX51_MMIO_PIO_OE_LINE_CFG0_BIT_Ttag {
	unsigned int line : BFW_NX51_mmio_pio_oe_line_cfg0_line; /* MMIO output enable if related MMIO is in PIO mode.                 */
	                                                         /* If related MMIO is not in PIO mode, programmed setting is ignored. */
	                                                         /* Bit 0 controls MMIO0, Bit 1 controls MMIO1, ...                    */
} NX51_MMIO_PIO_OE_LINE_CFG0_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_MMIO_PIO_OE_LINE_CFG0_BIT_T bf;
} NX51_MMIO_PIO_OE_LINE_CFG0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_pio_oe_line_cfg1 */
/* => MMIO PIO line output enable register of MMIO 32 to 48. */
/*    Changing bits here will change 'pio_oe' bit of related mmio*_cfg register. Changes there will change related bit inside this register. */
/*    Note: This register is not protected by netX access-key algorithm. */
/*    Note */
/*       mmio40 has no PIO function. Settings of related bit 8 inside this register will be ignored. */
/*       mmio41 has no PIO function. Settings of related bit 9 inside this register will be ignored. */
/*       mmio42 has no PIO function. Settings of related bit 10 inside this register will be ignored. */
/*       mmio43 has no PIO function. Settings of related bit 11 inside this register will be ignored. */
/*       mmio44 has no PIO function. Settings of related bit 12 inside this register will be ignored. */
/*       mmio45 has no PIO function. Settings of related bit 13 inside this register will be ignored. */
/*       mmio46 has no PIO function. Settings of related bit 14 inside this register will be ignored. */
/*       mmio47 has no PIO function. Settings of related bit 15 inside this register will be ignored. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_pio_oe_line_cfg1       0x000000D0U
#define Adr_NX51_mmio_ctrl_mmio_pio_oe_line_cfg1 0x1018C2D0U
#define Adr_NX51_mmio_pio_oe_line_cfg1           0x1018C2D0U
#define DFLT_VAL_NX51_mmio_pio_oe_line_cfg1      0x00000000U

#define MSK_NX51_mmio_pio_oe_line_cfg1_line         0x0001ffffU
#define SRT_NX51_mmio_pio_oe_line_cfg1_line         0
#define DFLT_VAL_NX51_mmio_pio_oe_line_cfg1_line    0x00000000U
#define DFLT_BF_VAL_NX51_mmio_pio_oe_line_cfg1_line 0x00000000U

/* all used bits of 'NX51_mmio_pio_oe_line_cfg1': */
#define MSK_USED_BITS_NX51_mmio_pio_oe_line_cfg1 0x0001ffffU

enum {
	BFW_NX51_mmio_pio_oe_line_cfg1_line      = 17, /* [16:0] */
	BFW_NX51_mmio_pio_oe_line_cfg1_reserved1 = 15  /* [31:17] */
};

typedef struct NX51_MMIO_PIO_OE_LINE_CFG1_BIT_Ttag {
	unsigned int line      : BFW_NX51_mmio_pio_oe_line_cfg1_line;      /* MMIO output enable if related MMIO is in PIO mode.                 */
	                                                                   /* If related MMIO is not in PIO mode, programmed setting is ignored. */
	                                                                   /* Bit 0 controls MMIO32, Bit 1 controls MMIO33, ...                  */
	unsigned int reserved1 : BFW_NX51_mmio_pio_oe_line_cfg1_reserved1; /* reserved                                                           */
} NX51_MMIO_PIO_OE_LINE_CFG1_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_MMIO_PIO_OE_LINE_CFG1_BIT_T bf;
} NX51_MMIO_PIO_OE_LINE_CFG1_T;

/* --------------------------------------------------------------------- */
/* Register mmio_in_line_status0 */
/* => MMIO input line register of MMIO 0 to 31. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_in_line_status0       0x000000D4U
#define Adr_NX51_mmio_ctrl_mmio_in_line_status0 0x1018C2D4U
#define Adr_NX51_mmio_in_line_status0           0x1018C2D4U

#define MSK_NX51_mmio_in_line_status0_line 0xffffffffU
#define SRT_NX51_mmio_in_line_status0_line 0

/* all used bits of 'NX51_mmio_in_line_status0': */
#define MSK_USED_BITS_NX51_mmio_in_line_status0 0xffffffffU

enum {
	BFW_NX51_mmio_in_line_status0_line = 32  /* [31:0] */
};

typedef struct NX51_MMIO_IN_LINE_STATUS0_BIT_Ttag {
	unsigned int line : BFW_NX51_mmio_in_line_status0_line; /* sampled MMIO input state.                           */
	                                                        /* Does not depend whether MMIO is in PIO mode or not. */
	                                                        /* Bit 0 monitors MMIO0, Bit 1 monitors MMIO1, ...     */
} NX51_MMIO_IN_LINE_STATUS0_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_MMIO_IN_LINE_STATUS0_BIT_T bf;
} NX51_MMIO_IN_LINE_STATUS0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_in_line_status1 */
/* => MMIO input line register of MMIO 32 to 48. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_in_line_status1       0x000000D8U
#define Adr_NX51_mmio_ctrl_mmio_in_line_status1 0x1018C2D8U
#define Adr_NX51_mmio_in_line_status1           0x1018C2D8U

#define MSK_NX51_mmio_in_line_status1_line 0x0001ffffU
#define SRT_NX51_mmio_in_line_status1_line 0

/* all used bits of 'NX51_mmio_in_line_status1': */
#define MSK_USED_BITS_NX51_mmio_in_line_status1 0x0001ffffU

enum {
	BFW_NX51_mmio_in_line_status1_line      = 17, /* [16:0] */
	BFW_NX51_mmio_in_line_status1_reserved1 = 15  /* [31:17] */
};

typedef struct NX51_MMIO_IN_LINE_STATUS1_BIT_Ttag {
	unsigned int line      : BFW_NX51_mmio_in_line_status1_line;      /* sampled MMIO input state.                           */
	                                                                  /* Does not depend whether MMIO is in PIO mode or not. */
	                                                                  /* Bit 0 monitors MMIO32, Bit 1 monitors MMIO33, ...   */
	unsigned int reserved1 : BFW_NX51_mmio_in_line_status1_reserved1; /* reserved                                            */
} NX51_MMIO_IN_LINE_STATUS1_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_MMIO_IN_LINE_STATUS1_BIT_T bf;
} NX51_MMIO_IN_LINE_STATUS1_T;

/* --------------------------------------------------------------------- */
/* Register mmio_is_pio_status0 */
/* => MMIO mode line register of MMIO 0 to 31. */
/*    Note: PIO Mode can be enabled or disabled in mmio_cfg registers. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_is_pio_status0       0x000000DCU
#define Adr_NX51_mmio_ctrl_mmio_is_pio_status0 0x1018C2DCU
#define Adr_NX51_mmio_is_pio_status0           0x1018C2DCU

#define MSK_NX51_mmio_is_pio_status0_line 0xffffffffU
#define SRT_NX51_mmio_is_pio_status0_line 0

/* all used bits of 'NX51_mmio_is_pio_status0': */
#define MSK_USED_BITS_NX51_mmio_is_pio_status0 0xffffffffU

enum {
	BFW_NX51_mmio_is_pio_status0_line = 32  /* [31:0] */
};

typedef struct NX51_MMIO_IS_PIO_STATUS0_BIT_Ttag {
	unsigned int line : BFW_NX51_mmio_is_pio_status0_line; /* Bit 0 shows status of MMIO0, Bit 1 shows status of  MMIO1, ...           */
	                                                       /*  0: related MMIO is not in PIO mode (is assigned to core functionality). */
	                                                       /*  1: related MMIO is in PIO mode (is not assigned to core functionality). */
} NX51_MMIO_IS_PIO_STATUS0_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_MMIO_IS_PIO_STATUS0_BIT_T bf;
} NX51_MMIO_IS_PIO_STATUS0_T;

/* --------------------------------------------------------------------- */
/* Register mmio_is_pio_status1 */
/* => MMIO mode line register of MMIO 32 to 48. */
/*    Note: PIO Mode can be enabled or disabled in mmio_cfg registers. */
/*    Note */
/*       mmio40 has no PIO function. When related bit 8 inside this register is set, mmio40 will be active on HIF_D8. */
/*       mmio41 has no PIO function. When related bit 9 inside this register is set, mmio41 will be active on HIF_D9. */
/*       mmio42 has no PIO function. When related bit 10 inside this register is set, mmio42 will be active on HIF_D10. */
/*       mmio43 has no PIO function. When related bit 11 inside this register is set, mmio43 will be active on HIF_D11. */
/*       mmio44 has no PIO function. When related bit 12 inside this register is set, mmio44 will be active on HIF_D12. */
/*       mmio45 has no PIO function. When related bit 13 inside this register is set, mmio45 will be active on HIF_D13. */
/*       mmio46 has no PIO function. When related bit 14 inside this register is set, mmio46 will be active on HIF_D14. */
/*       mmio47 has no PIO function. When related bit 15 inside this register is set, mmio47 will be active on HIF_D15. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_mmio_is_pio_status1       0x000000E0U
#define Adr_NX51_mmio_ctrl_mmio_is_pio_status1 0x1018C2E0U
#define Adr_NX51_mmio_is_pio_status1           0x1018C2E0U

#define MSK_NX51_mmio_is_pio_status1_line 0x0001ffffU
#define SRT_NX51_mmio_is_pio_status1_line 0

/* all used bits of 'NX51_mmio_is_pio_status1': */
#define MSK_USED_BITS_NX51_mmio_is_pio_status1 0x0001ffffU

enum {
	BFW_NX51_mmio_is_pio_status1_line      = 17, /* [16:0] */
	BFW_NX51_mmio_is_pio_status1_reserved1 = 15  /* [31:17] */
};

typedef struct NX51_MMIO_IS_PIO_STATUS1_BIT_Ttag {
	unsigned int line      : BFW_NX51_mmio_is_pio_status1_line;      /* Bit 0 shows status of MMIO32, Bit 1 shows status of  MMIO33, ...         */
	                                                                 /*  0: related MMIO is not in PIO mode (is assigned to core functionality). */
	                                                                 /*  1: related MMIO is in PIO mode (is not assigned to core functionality). */
	unsigned int reserved1 : BFW_NX51_mmio_is_pio_status1_reserved1; /* reserved                                                                 */
} NX51_MMIO_IS_PIO_STATUS1_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_MMIO_IS_PIO_STATUS1_BIT_T bf;
} NX51_MMIO_IS_PIO_STATUS1_T;


/* ===================================================================== */

/* Area of handshake_ctrl */

/* ===================================================================== */

#define Addr_NX51_handshake_ctrl 0x1018C300U

/* --------------------------------------------------------------------- */
/* Register handshake_base_addr */
/* => Handshake Cell address base configuration register. */
/*    Handshake Cells are located in INTRAMHS and can be mapped to any 256 byte border. */
/*    Related master of an access to Handshake Cells is detected by the access to one of three INTRAMHS Mirrors: */
/*    Access via INTRAMHS dpm_mirror is interpreted by Handshake Cells as DPM access. This is regardless whether */
/*    the access was really initiated by DPM master or not. E.g. if xPIC uses dpm_mirror of INTRAMHS for Handshake Cell */
/*    access, this will be interpreted as DPM access and not as xPIC access. */
/*    INTRAMHS can be accessed by 4 different mirrors which are sub address areas of area HANDSHAKE. Furthermore */
/*    HANDSHAKE address area is mirrored multiple inside whole netX address area. Each HANDSHAKE address area */
/*    provides all 4 INTRAMHS mirrors. */
/*    There is one INTRAMHS mirror for each IRQ capable system master (DPM, xPIC, ARM) and one to access whole */
/*    INTRAMHS area without any influence to HANDSHAKE_CTRL unit. However, each system master is able to address */
/*    each INTRAMHS mirror. IRQs are always generated in dependency of mirror addressed by a master on access. IRQ */
/*    generation does not depend on the master running an access. */
/*    Handshake Cell Setup example: */
/*      1. Configure Handshake Cell area offset (e.g. offset 0x200, set base256 to 0x2). */
/*      2. Configure used Handshake Cell width (8bit or 16 bit) in 'handshake_hscX_ctrl' registers. */
/*      3. Configure used Handshake Cells master association (e.g. ARM<->DPM) in 'handshake_hscX_ctrl' registers. */
/*    Example: typical ARM<-> DPM Handshake interaction: */
/*      1. ARM writes request to Handshake Cell N (address: intramhs_arm_mirror+base256*256+N*4). */
/*         -> DPM receives IRQ */
/*      2. DPM reads Handshake Cell N (address: intramhs_dpm_mirror+base256*256+N*4). */
/*         -> DPM IRQ clear. */
/*      3. DPM writes acknowledge to Handshake Cell N (address: intramhs_dpm_mirror+base256*256+N*4). */
/*         -> ARM receives IRQ */
/*      4. ARM reads Handshake Cell N (address: intramhs_dpm_mirror+base256*256+N*4). */
/*         -> ARM IRQ clear. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_base_addr            0x00000000U
#define Adr_NX51_handshake_ctrl_handshake_base_addr 0x1018C300U
#define Adr_NX51_handshake_base_addr                0x1018C300U
#define DFLT_VAL_NX51_handshake_base_addr           0x40000000U

#define MSK_NX51_handshake_base_addr_zero_ro             0x000000ffU
#define SRT_NX51_handshake_base_addr_zero_ro             0
#define DFLT_VAL_NX51_handshake_base_addr_zero_ro        0x00000000U
#define DFLT_BF_VAL_NX51_handshake_base_addr_zero_ro     0x00000000U
#define MSK_NX51_handshake_base_addr_base256             0x00007f00U
#define SRT_NX51_handshake_base_addr_base256             8
#define DFLT_VAL_NX51_handshake_base_addr_base256        0x00000000U
#define DFLT_BF_VAL_NX51_handshake_base_addr_base256     0x00000000U
#define MSK_NX51_handshake_base_addr_netx50_comp         0x40000000U
#define SRT_NX51_handshake_base_addr_netx50_comp         30
#define DFLT_VAL_NX51_handshake_base_addr_netx50_comp    0x40000000U
#define DFLT_BF_VAL_NX51_handshake_base_addr_netx50_comp 0x00000001U
#define MSK_NX51_handshake_base_addr_enable              0x80000000U
#define SRT_NX51_handshake_base_addr_enable              31
#define DFLT_VAL_NX51_handshake_base_addr_enable         0x00000000U
#define DFLT_BF_VAL_NX51_handshake_base_addr_enable      0x00000000U

/* all used bits of 'NX51_handshake_base_addr': */
#define MSK_USED_BITS_NX51_handshake_base_addr 0xc0007fffU

enum {
	BFW_NX51_handshake_base_addr_zero_ro     = 8,  /* [7:0] */
	BFW_NX51_handshake_base_addr_base256     = 7,  /* [14:8] */
	BFW_NX51_handshake_base_addr_reserved1   = 15, /* [29:15] */
	BFW_NX51_handshake_base_addr_netx50_comp = 1,  /* [30] */
	BFW_NX51_handshake_base_addr_enable      = 1   /* [31] */
};

typedef struct NX51_HANDSHAKE_BASE_ADDR_BIT_Ttag {
	unsigned int zero_ro     : BFW_NX51_handshake_base_addr_zero_ro;     /* Low address bits not configurable                                                       */
	unsigned int base256     : BFW_NX51_handshake_base_addr_base256;     /* Address base configuration in 256 byte steps inside INTRAMHS                            */
	unsigned int reserved1   : BFW_NX51_handshake_base_addr_reserved1;   /* reserved                                                                                */
	unsigned int netx50_comp : BFW_NX51_handshake_base_addr_netx50_comp; /* Netx50 compatibility for Handshake Cell IRQ generation.                                 */
	                                                                     /* 1: Handshake Cell IRQ generation is netx50 compatible (default).                        */
	                                                                     /* 0: Handshake Cell IRQ generation is netx10 (not netx50) compatible.                     */
	                                                                     /* This bit effects the behavior of Handshake Cell IRQ generation globally for all         */
	                                                                     /* enabled Cells. For details and difference between netx50 and netx10 Handshake Cell IRQ  */
	                                                                     /* behavior view 'handshake_hsc0_ctrl' register desription.                                */
	                                                                     /* Note:                                                                                   */
	                                                                     /*     This is a new netx51 feature.                                                       */
	unsigned int enable      : BFW_NX51_handshake_base_addr_enable;      /* Global Handshake Cell address compare logic enable.                                     */
	                                                                     /* 0: All Handshake Cell features like IRQ generation or tripple-buffer controlling        */
	                                                                     /*    are disabled. special HCS2 bits come from INTRAMHS and not from shadow logic.        */
	                                                                     /*    Handshake Cells behave like standard memory.                                         */
	                                                                     /* 1: Handshake Cell features are enabled for Handshake Cells which are enabled (mode!=0). */
	                                                                     /*    Special HCS2 bits come from from shadow logic and not from INTRAMHS (independent of  */
	                                                                     /*    mode-setting of HSC2).                                                               */
} NX51_HANDSHAKE_BASE_ADDR_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_BASE_ADDR_BIT_T bf;
} NX51_HANDSHAKE_BASE_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register handshake_dpm_irq_raw_clear */
/* => Handshake Cell Raw Interrupt for DPM register. */
/*    Read access shows status of unmasked IRQs. */
/*    Write access with '1' clears the appropriate IRQ. */
/*    Note: */
/*       DPM related IRQ status can also be read from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQs can also be cleared from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQ masks can also be read from dpm_hs_irq_mask register (area DPM). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_dpm_irq_raw_clear            0x00000010U
#define Adr_NX51_handshake_ctrl_handshake_dpm_irq_raw_clear 0x1018C310U
#define Adr_NX51_handshake_dpm_irq_raw_clear                0x1018C310U
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear           0x00000000U

#define MSK_NX51_handshake_dpm_irq_raw_clear_vector         0x000000ffU
#define SRT_NX51_handshake_dpm_irq_raw_clear_vector         0
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_vector    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_vector 0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc0           0x00000100U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc0           8
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc0      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc0   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc1           0x00000200U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc1           9
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc1      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc1   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc2           0x00000400U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc2           10
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc2      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc2   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc3           0x00000800U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc3           11
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc3      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc3   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc4           0x00001000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc4           12
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc4      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc4   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc5           0x00002000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc5           13
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc5      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc5   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc6           0x00004000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc6           14
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc6      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc6   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc7           0x00008000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc7           15
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc7      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc7   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc8           0x00010000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc8           16
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc8      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc8   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc9           0x00020000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc9           17
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc9      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc9   0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc10          0x00040000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc10          18
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc10     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc10  0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc11          0x00080000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc11          19
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc11     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc11  0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc12          0x00100000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc12          20
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc12     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc12  0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc13          0x00200000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc13          21
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc13     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc13  0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc14          0x00400000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc14          22
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc14     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc14  0x00000000U
#define MSK_NX51_handshake_dpm_irq_raw_clear_hsc15          0x00800000U
#define SRT_NX51_handshake_dpm_irq_raw_clear_hsc15          23
#define DFLT_VAL_NX51_handshake_dpm_irq_raw_clear_hsc15     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_raw_clear_hsc15  0x00000000U

/* all used bits of 'NX51_handshake_dpm_irq_raw_clear': */
#define MSK_USED_BITS_NX51_handshake_dpm_irq_raw_clear 0x00ffffffU

enum {
	BFW_NX51_handshake_dpm_irq_raw_clear_vector    = 8, /* [7:0] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_dpm_irq_raw_clear_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_dpm_irq_raw_clear_reserved1 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_DPM_IRQ_RAW_CLEAR_BIT_Ttag {
	unsigned int vector    : BFW_NX51_handshake_dpm_irq_raw_clear_vector;    /* Interrupt Vector generated by masked DPM IRQ flags.                  */
	                                                                         /* These bits are mirrored from handshake_dpm_irq_masked register.      */
	                                                                         /* Priority and Coding is compliant to netx50 HIF Handshake IRQ Vector: */
	                                                                         /* 0x00 : No IRQ.                                                       */
	                                                                         /* 0x10 : Handshake Cell 0  IRQ.                                        */
	                                                                         /* 0x11 : Handshake Cell 1  IRQ.                                        */
	                                                                         /* 0x12 : Handshake Cell 2  IRQ.                                        */
	                                                                         /* 0x13 : Handshake Cell 3  IRQ.                                        */
	                                                                         /* 0x14 : Handshake Cell 4  IRQ.                                        */
	                                                                         /* 0x15 : Handshake Cell 5  IRQ.                                        */
	                                                                         /* 0x16 : Handshake Cell 6  IRQ.                                        */
	                                                                         /* 0x17 : Handshake Cell 7  IRQ.                                        */
	                                                                         /* 0x18 : Handshake Cell 8  IRQ.                                        */
	                                                                         /* 0x19 : Handshake Cell 9  IRQ.                                        */
	                                                                         /* 0x1a : Handshake Cell 10 IRQ.                                        */
	                                                                         /* 0x1b : Handshake Cell 11 IRQ.                                        */
	                                                                         /* 0x1c : Handshake Cell 12 IRQ.                                        */
	                                                                         /* 0x1d : Handshake Cell 13 IRQ.                                        */
	                                                                         /* 0x1e : Handshake Cell 14 IRQ.                                        */
	                                                                         /* 0x1f : Handshake Cell 15 IRQ.                                        */
	                                                                         /* 0x20..0xff : reserved.                                               */
	unsigned int hsc0      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc0;      /* Handshake Cell 0  IRQ.                                               */
	unsigned int hsc1      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc1;      /* Handshake Cell 1  IRQ.                                               */
	unsigned int hsc2      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc2;      /* Handshake Cell 2  IRQ.                                               */
	unsigned int hsc3      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc3;      /* Handshake Cell 3  IRQ.                                               */
	unsigned int hsc4      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc4;      /* Handshake Cell 4  IRQ.                                               */
	unsigned int hsc5      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc5;      /* Handshake Cell 5  IRQ.                                               */
	unsigned int hsc6      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc6;      /* Handshake Cell 6  IRQ.                                               */
	unsigned int hsc7      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc7;      /* Handshake Cell 7  IRQ.                                               */
	unsigned int hsc8      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc8;      /* Handshake Cell 8  IRQ.                                               */
	unsigned int hsc9      : BFW_NX51_handshake_dpm_irq_raw_clear_hsc9;      /* Handshake Cell 9  IRQ.                                               */
	unsigned int hsc10     : BFW_NX51_handshake_dpm_irq_raw_clear_hsc10;     /* Handshake Cell 10 IRQ.                                               */
	unsigned int hsc11     : BFW_NX51_handshake_dpm_irq_raw_clear_hsc11;     /* Handshake Cell 11 IRQ.                                               */
	unsigned int hsc12     : BFW_NX51_handshake_dpm_irq_raw_clear_hsc12;     /* Handshake Cell 12 IRQ.                                               */
	unsigned int hsc13     : BFW_NX51_handshake_dpm_irq_raw_clear_hsc13;     /* Handshake Cell 13 IRQ.                                               */
	unsigned int hsc14     : BFW_NX51_handshake_dpm_irq_raw_clear_hsc14;     /* Handshake Cell 14 IRQ.                                               */
	unsigned int hsc15     : BFW_NX51_handshake_dpm_irq_raw_clear_hsc15;     /* Handshake Cell 15 IRQ.                                               */
	unsigned int reserved1 : BFW_NX51_handshake_dpm_irq_raw_clear_reserved1; /* reserved                                                             */
} NX51_HANDSHAKE_DPM_IRQ_RAW_CLEAR_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_HANDSHAKE_DPM_IRQ_RAW_CLEAR_BIT_T bf;
} NX51_HANDSHAKE_DPM_IRQ_RAW_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register handshake_dpm_irq_masked */
/* => Handshake Cell Masked Interrupt for DPM register. */
/*    Shows status of masked IRQs (as connected to DPM/host). */
/*    Note: */
/*       DPM related IRQ status can also be read from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQs can also be cleared from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQ masks can also be read from dpm_hs_irq_mask register (area DPM). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_dpm_irq_masked            0x00000014U
#define Adr_NX51_handshake_ctrl_handshake_dpm_irq_masked 0x1018C314U
#define Adr_NX51_handshake_dpm_irq_masked                0x1018C314U

#define MSK_NX51_handshake_dpm_irq_masked_vector 0x000000ffU
#define SRT_NX51_handshake_dpm_irq_masked_vector 0
#define MSK_NX51_handshake_dpm_irq_masked_hsc0   0x00000100U
#define SRT_NX51_handshake_dpm_irq_masked_hsc0   8
#define MSK_NX51_handshake_dpm_irq_masked_hsc1   0x00000200U
#define SRT_NX51_handshake_dpm_irq_masked_hsc1   9
#define MSK_NX51_handshake_dpm_irq_masked_hsc2   0x00000400U
#define SRT_NX51_handshake_dpm_irq_masked_hsc2   10
#define MSK_NX51_handshake_dpm_irq_masked_hsc3   0x00000800U
#define SRT_NX51_handshake_dpm_irq_masked_hsc3   11
#define MSK_NX51_handshake_dpm_irq_masked_hsc4   0x00001000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc4   12
#define MSK_NX51_handshake_dpm_irq_masked_hsc5   0x00002000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc5   13
#define MSK_NX51_handshake_dpm_irq_masked_hsc6   0x00004000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc6   14
#define MSK_NX51_handshake_dpm_irq_masked_hsc7   0x00008000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc7   15
#define MSK_NX51_handshake_dpm_irq_masked_hsc8   0x00010000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc8   16
#define MSK_NX51_handshake_dpm_irq_masked_hsc9   0x00020000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc9   17
#define MSK_NX51_handshake_dpm_irq_masked_hsc10  0x00040000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc10  18
#define MSK_NX51_handshake_dpm_irq_masked_hsc11  0x00080000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc11  19
#define MSK_NX51_handshake_dpm_irq_masked_hsc12  0x00100000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc12  20
#define MSK_NX51_handshake_dpm_irq_masked_hsc13  0x00200000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc13  21
#define MSK_NX51_handshake_dpm_irq_masked_hsc14  0x00400000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc14  22
#define MSK_NX51_handshake_dpm_irq_masked_hsc15  0x00800000U
#define SRT_NX51_handshake_dpm_irq_masked_hsc15  23

/* all used bits of 'NX51_handshake_dpm_irq_masked': */
#define MSK_USED_BITS_NX51_handshake_dpm_irq_masked 0x00ffffffU

enum {
	BFW_NX51_handshake_dpm_irq_masked_vector    = 8, /* [7:0] */
	BFW_NX51_handshake_dpm_irq_masked_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_dpm_irq_masked_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_dpm_irq_masked_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_dpm_irq_masked_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_dpm_irq_masked_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_dpm_irq_masked_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_dpm_irq_masked_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_dpm_irq_masked_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_dpm_irq_masked_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_dpm_irq_masked_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_dpm_irq_masked_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_dpm_irq_masked_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_dpm_irq_masked_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_dpm_irq_masked_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_dpm_irq_masked_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_dpm_irq_masked_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_dpm_irq_masked_reserved1 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_DPM_IRQ_MASKED_BIT_Ttag {
	unsigned int vector    : BFW_NX51_handshake_dpm_irq_masked_vector;    /* Interrupt Vector generated by masked DPM IRQ flags.                  */
	                                                                      /* Priority and Coding is compliant to netx50 HIF Handshake IRQ Vector: */
	                                                                      /* 0x00 : No IRQ.                                                       */
	                                                                      /* 0x10 : Handshake Cell 0  IRQ.                                        */
	                                                                      /* 0x11 : Handshake Cell 1  IRQ.                                        */
	                                                                      /* 0x12 : Handshake Cell 2  IRQ.                                        */
	                                                                      /* 0x13 : Handshake Cell 3  IRQ.                                        */
	                                                                      /* 0x14 : Handshake Cell 4  IRQ.                                        */
	                                                                      /* 0x15 : Handshake Cell 5  IRQ.                                        */
	                                                                      /* 0x16 : Handshake Cell 6  IRQ.                                        */
	                                                                      /* 0x17 : Handshake Cell 7  IRQ.                                        */
	                                                                      /* 0x18 : Handshake Cell 8  IRQ.                                        */
	                                                                      /* 0x19 : Handshake Cell 9  IRQ.                                        */
	                                                                      /* 0x1a : Handshake Cell 10 IRQ.                                        */
	                                                                      /* 0x1b : Handshake Cell 11 IRQ.                                        */
	                                                                      /* 0x1c : Handshake Cell 12 IRQ.                                        */
	                                                                      /* 0x1d : Handshake Cell 13 IRQ.                                        */
	                                                                      /* 0x1e : Handshake Cell 14 IRQ.                                        */
	                                                                      /* 0x1f : Handshake Cell 15 IRQ.                                        */
	                                                                      /* 0x20..0xff : reserved.                                               */
	unsigned int hsc0      : BFW_NX51_handshake_dpm_irq_masked_hsc0;      /* Handshake Cell 0  IRQ.                                               */
	unsigned int hsc1      : BFW_NX51_handshake_dpm_irq_masked_hsc1;      /* Handshake Cell 1  IRQ.                                               */
	unsigned int hsc2      : BFW_NX51_handshake_dpm_irq_masked_hsc2;      /* Handshake Cell 2  IRQ.                                               */
	unsigned int hsc3      : BFW_NX51_handshake_dpm_irq_masked_hsc3;      /* Handshake Cell 3  IRQ.                                               */
	unsigned int hsc4      : BFW_NX51_handshake_dpm_irq_masked_hsc4;      /* Handshake Cell 4  IRQ.                                               */
	unsigned int hsc5      : BFW_NX51_handshake_dpm_irq_masked_hsc5;      /* Handshake Cell 5  IRQ.                                               */
	unsigned int hsc6      : BFW_NX51_handshake_dpm_irq_masked_hsc6;      /* Handshake Cell 6  IRQ.                                               */
	unsigned int hsc7      : BFW_NX51_handshake_dpm_irq_masked_hsc7;      /* Handshake Cell 7  IRQ.                                               */
	unsigned int hsc8      : BFW_NX51_handshake_dpm_irq_masked_hsc8;      /* Handshake Cell 8  IRQ.                                               */
	unsigned int hsc9      : BFW_NX51_handshake_dpm_irq_masked_hsc9;      /* Handshake Cell 9  IRQ.                                               */
	unsigned int hsc10     : BFW_NX51_handshake_dpm_irq_masked_hsc10;     /* Handshake Cell 10 IRQ.                                               */
	unsigned int hsc11     : BFW_NX51_handshake_dpm_irq_masked_hsc11;     /* Handshake Cell 11 IRQ.                                               */
	unsigned int hsc12     : BFW_NX51_handshake_dpm_irq_masked_hsc12;     /* Handshake Cell 12 IRQ.                                               */
	unsigned int hsc13     : BFW_NX51_handshake_dpm_irq_masked_hsc13;     /* Handshake Cell 13 IRQ.                                               */
	unsigned int hsc14     : BFW_NX51_handshake_dpm_irq_masked_hsc14;     /* Handshake Cell 14 IRQ.                                               */
	unsigned int hsc15     : BFW_NX51_handshake_dpm_irq_masked_hsc15;     /* Handshake Cell 15 IRQ.                                               */
	unsigned int reserved1 : BFW_NX51_handshake_dpm_irq_masked_reserved1; /* reserved                                                             */
} NX51_HANDSHAKE_DPM_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_HANDSHAKE_DPM_IRQ_MASKED_BIT_T bf;
} NX51_HANDSHAKE_DPM_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register handshake_dpm_irq_msk_set */
/* => Handshake Cell Interrupt Mask Enable for DPM register. */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Note: */
/*       DPM related IRQ status can also be read from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQs can also be cleared from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQ masks can also be read from dpm_hs_irq_mask register (area DPM). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_dpm_irq_msk_set            0x00000018U
#define Adr_NX51_handshake_ctrl_handshake_dpm_irq_msk_set 0x1018C318U
#define Adr_NX51_handshake_dpm_irq_msk_set                0x1018C318U
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set           0x00000000U

#define MSK_NX51_handshake_dpm_irq_msk_set_hsc0          0x00000100U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc0          8
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc0     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc0  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc1          0x00000200U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc1          9
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc1     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc1  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc2          0x00000400U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc2          10
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc2     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc2  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc3          0x00000800U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc3          11
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc3     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc3  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc4          0x00001000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc4          12
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc4     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc4  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc5          0x00002000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc5          13
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc5     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc5  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc6          0x00004000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc6          14
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc6     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc6  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc7          0x00008000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc7          15
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc7     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc7  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc8          0x00010000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc8          16
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc8     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc8  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc9          0x00020000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc9          17
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc9     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc9  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc10         0x00040000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc10         18
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc10    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc10 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc11         0x00080000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc11         19
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc11    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc11 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc12         0x00100000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc12         20
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc12    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc12 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc13         0x00200000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc13         21
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc13    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc13 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc14         0x00400000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc14         22
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc14    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc14 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_set_hsc15         0x00800000U
#define SRT_NX51_handshake_dpm_irq_msk_set_hsc15         23
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_set_hsc15    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_set_hsc15 0x00000000U

/* all used bits of 'NX51_handshake_dpm_irq_msk_set': */
#define MSK_USED_BITS_NX51_handshake_dpm_irq_msk_set 0x00ffff00U

enum {
	BFW_NX51_handshake_dpm_irq_msk_set_reserved1 = 8, /* [7:0] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_dpm_irq_msk_set_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_dpm_irq_msk_set_reserved2 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_DPM_IRQ_MSK_SET_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_handshake_dpm_irq_msk_set_reserved1; /* reserved               */
	unsigned int hsc0      : BFW_NX51_handshake_dpm_irq_msk_set_hsc0;      /* Handshake Cell 0  IRQ. */
	unsigned int hsc1      : BFW_NX51_handshake_dpm_irq_msk_set_hsc1;      /* Handshake Cell 1  IRQ. */
	unsigned int hsc2      : BFW_NX51_handshake_dpm_irq_msk_set_hsc2;      /* Handshake Cell 2  IRQ. */
	unsigned int hsc3      : BFW_NX51_handshake_dpm_irq_msk_set_hsc3;      /* Handshake Cell 3  IRQ. */
	unsigned int hsc4      : BFW_NX51_handshake_dpm_irq_msk_set_hsc4;      /* Handshake Cell 4  IRQ. */
	unsigned int hsc5      : BFW_NX51_handshake_dpm_irq_msk_set_hsc5;      /* Handshake Cell 5  IRQ. */
	unsigned int hsc6      : BFW_NX51_handshake_dpm_irq_msk_set_hsc6;      /* Handshake Cell 6  IRQ. */
	unsigned int hsc7      : BFW_NX51_handshake_dpm_irq_msk_set_hsc7;      /* Handshake Cell 7  IRQ. */
	unsigned int hsc8      : BFW_NX51_handshake_dpm_irq_msk_set_hsc8;      /* Handshake Cell 8  IRQ. */
	unsigned int hsc9      : BFW_NX51_handshake_dpm_irq_msk_set_hsc9;      /* Handshake Cell 9  IRQ. */
	unsigned int hsc10     : BFW_NX51_handshake_dpm_irq_msk_set_hsc10;     /* Handshake Cell 10 IRQ. */
	unsigned int hsc11     : BFW_NX51_handshake_dpm_irq_msk_set_hsc11;     /* Handshake Cell 11 IRQ. */
	unsigned int hsc12     : BFW_NX51_handshake_dpm_irq_msk_set_hsc12;     /* Handshake Cell 12 IRQ. */
	unsigned int hsc13     : BFW_NX51_handshake_dpm_irq_msk_set_hsc13;     /* Handshake Cell 13 IRQ. */
	unsigned int hsc14     : BFW_NX51_handshake_dpm_irq_msk_set_hsc14;     /* Handshake Cell 14 IRQ. */
	unsigned int hsc15     : BFW_NX51_handshake_dpm_irq_msk_set_hsc15;     /* Handshake Cell 15 IRQ. */
	unsigned int reserved2 : BFW_NX51_handshake_dpm_irq_msk_set_reserved2; /* reserved               */
} NX51_HANDSHAKE_DPM_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_HANDSHAKE_DPM_IRQ_MSK_SET_BIT_T bf;
} NX51_HANDSHAKE_DPM_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register handshake_dpm_irq_msk_reset */
/* => Handshake Cell Interrupt Mask Disable for DPM register. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Note: */
/*       DPM related IRQ status can also be read from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQs can also be cleared from dpm_hs_irq_raw register (area DPM). */
/*       DPM related IRQ masks can also be read from dpm_hs_irq_mask register (area DPM). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_dpm_irq_msk_reset            0x0000001CU
#define Adr_NX51_handshake_ctrl_handshake_dpm_irq_msk_reset 0x1018C31CU
#define Adr_NX51_handshake_dpm_irq_msk_reset                0x1018C31CU
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset           0x00000000U

#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc0          0x00000100U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc0          8
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc0     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc0  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc1          0x00000200U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc1          9
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc1     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc1  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc2          0x00000400U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc2          10
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc2     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc2  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc3          0x00000800U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc3          11
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc3     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc3  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc4          0x00001000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc4          12
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc4     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc4  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc5          0x00002000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc5          13
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc5     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc5  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc6          0x00004000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc6          14
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc6     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc6  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc7          0x00008000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc7          15
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc7     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc7  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc8          0x00010000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc8          16
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc8     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc8  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc9          0x00020000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc9          17
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc9     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc9  0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc10         0x00040000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc10         18
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc10    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc10 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc11         0x00080000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc11         19
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc11    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc11 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc12         0x00100000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc12         20
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc12    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc12 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc13         0x00200000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc13         21
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc13    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc13 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc14         0x00400000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc14         22
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc14    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc14 0x00000000U
#define MSK_NX51_handshake_dpm_irq_msk_reset_hsc15         0x00800000U
#define SRT_NX51_handshake_dpm_irq_msk_reset_hsc15         23
#define DFLT_VAL_NX51_handshake_dpm_irq_msk_reset_hsc15    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_dpm_irq_msk_reset_hsc15 0x00000000U

/* all used bits of 'NX51_handshake_dpm_irq_msk_reset': */
#define MSK_USED_BITS_NX51_handshake_dpm_irq_msk_reset 0x00ffff00U

enum {
	BFW_NX51_handshake_dpm_irq_msk_reset_reserved1 = 8, /* [7:0] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_dpm_irq_msk_reset_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_dpm_irq_msk_reset_reserved2 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_DPM_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_handshake_dpm_irq_msk_reset_reserved1; /* reserved               */
	unsigned int hsc0      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc0;      /* Handshake Cell 0  IRQ. */
	unsigned int hsc1      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc1;      /* Handshake Cell 1  IRQ. */
	unsigned int hsc2      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc2;      /* Handshake Cell 2  IRQ. */
	unsigned int hsc3      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc3;      /* Handshake Cell 3  IRQ. */
	unsigned int hsc4      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc4;      /* Handshake Cell 4  IRQ. */
	unsigned int hsc5      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc5;      /* Handshake Cell 5  IRQ. */
	unsigned int hsc6      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc6;      /* Handshake Cell 6  IRQ. */
	unsigned int hsc7      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc7;      /* Handshake Cell 7  IRQ. */
	unsigned int hsc8      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc8;      /* Handshake Cell 8  IRQ. */
	unsigned int hsc9      : BFW_NX51_handshake_dpm_irq_msk_reset_hsc9;      /* Handshake Cell 9  IRQ. */
	unsigned int hsc10     : BFW_NX51_handshake_dpm_irq_msk_reset_hsc10;     /* Handshake Cell 10 IRQ. */
	unsigned int hsc11     : BFW_NX51_handshake_dpm_irq_msk_reset_hsc11;     /* Handshake Cell 11 IRQ. */
	unsigned int hsc12     : BFW_NX51_handshake_dpm_irq_msk_reset_hsc12;     /* Handshake Cell 12 IRQ. */
	unsigned int hsc13     : BFW_NX51_handshake_dpm_irq_msk_reset_hsc13;     /* Handshake Cell 13 IRQ. */
	unsigned int hsc14     : BFW_NX51_handshake_dpm_irq_msk_reset_hsc14;     /* Handshake Cell 14 IRQ. */
	unsigned int hsc15     : BFW_NX51_handshake_dpm_irq_msk_reset_hsc15;     /* Handshake Cell 15 IRQ. */
	unsigned int reserved2 : BFW_NX51_handshake_dpm_irq_msk_reset_reserved2; /* reserved               */
} NX51_HANDSHAKE_DPM_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_HANDSHAKE_DPM_IRQ_MSK_RESET_BIT_T bf;
} NX51_HANDSHAKE_DPM_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register handshake_arm_irq_raw_clear */
/* => Handshake Cell Raw Interrupt for ARM register. */
/*    Read access shows status of unmasked IRQs. */
/*    Write access with '1' clears the appropriate IRQ. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_arm_irq_raw_clear            0x00000020U
#define Adr_NX51_handshake_ctrl_handshake_arm_irq_raw_clear 0x1018C320U
#define Adr_NX51_handshake_arm_irq_raw_clear                0x1018C320U
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear           0x00000000U

#define MSK_NX51_handshake_arm_irq_raw_clear_vector         0x000000ffU
#define SRT_NX51_handshake_arm_irq_raw_clear_vector         0
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_vector    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_vector 0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc0           0x00000100U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc0           8
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc0      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc0   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc1           0x00000200U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc1           9
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc1      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc1   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc2           0x00000400U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc2           10
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc2      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc2   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc3           0x00000800U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc3           11
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc3      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc3   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc4           0x00001000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc4           12
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc4      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc4   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc5           0x00002000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc5           13
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc5      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc5   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc6           0x00004000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc6           14
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc6      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc6   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc7           0x00008000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc7           15
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc7      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc7   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc8           0x00010000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc8           16
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc8      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc8   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc9           0x00020000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc9           17
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc9      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc9   0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc10          0x00040000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc10          18
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc10     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc10  0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc11          0x00080000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc11          19
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc11     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc11  0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc12          0x00100000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc12          20
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc12     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc12  0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc13          0x00200000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc13          21
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc13     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc13  0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc14          0x00400000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc14          22
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc14     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc14  0x00000000U
#define MSK_NX51_handshake_arm_irq_raw_clear_hsc15          0x00800000U
#define SRT_NX51_handshake_arm_irq_raw_clear_hsc15          23
#define DFLT_VAL_NX51_handshake_arm_irq_raw_clear_hsc15     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_raw_clear_hsc15  0x00000000U

/* all used bits of 'NX51_handshake_arm_irq_raw_clear': */
#define MSK_USED_BITS_NX51_handshake_arm_irq_raw_clear 0x00ffffffU

enum {
	BFW_NX51_handshake_arm_irq_raw_clear_vector    = 8, /* [7:0] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_arm_irq_raw_clear_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_arm_irq_raw_clear_reserved1 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_ARM_IRQ_RAW_CLEAR_BIT_Ttag {
	unsigned int vector    : BFW_NX51_handshake_arm_irq_raw_clear_vector;    /* Interrupt Vector generated by masked ARM IRQ flags.                  */
	                                                                         /* These bits are mirrored from handshake_arm_irq_masked register.      */
	                                                                         /* Priority and Coding is compliant to netx50 HIF Handshake IRQ Vector: */
	                                                                         /* 0x00 : No IRQ.                                                       */
	                                                                         /* 0x10 : Handshake Cell 0  IRQ.                                        */
	                                                                         /* 0x11 : Handshake Cell 1  IRQ.                                        */
	                                                                         /* 0x12 : Handshake Cell 2  IRQ.                                        */
	                                                                         /* 0x13 : Handshake Cell 3  IRQ.                                        */
	                                                                         /* 0x14 : Handshake Cell 4  IRQ.                                        */
	                                                                         /* 0x15 : Handshake Cell 5  IRQ.                                        */
	                                                                         /* 0x16 : Handshake Cell 6  IRQ.                                        */
	                                                                         /* 0x17 : Handshake Cell 7  IRQ.                                        */
	                                                                         /* 0x18 : Handshake Cell 8  IRQ.                                        */
	                                                                         /* 0x19 : Handshake Cell 9  IRQ.                                        */
	                                                                         /* 0x1a : Handshake Cell 10 IRQ.                                        */
	                                                                         /* 0x1b : Handshake Cell 11 IRQ.                                        */
	                                                                         /* 0x1c : Handshake Cell 12 IRQ.                                        */
	                                                                         /* 0x1d : Handshake Cell 13 IRQ.                                        */
	                                                                         /* 0x1e : Handshake Cell 14 IRQ.                                        */
	                                                                         /* 0x1f : Handshake Cell 15 IRQ.                                        */
	                                                                         /* 0x20..0xff : reserved.                                               */
	unsigned int hsc0      : BFW_NX51_handshake_arm_irq_raw_clear_hsc0;      /* Handshake Cell 0  IRQ.                                               */
	unsigned int hsc1      : BFW_NX51_handshake_arm_irq_raw_clear_hsc1;      /* Handshake Cell 1  IRQ.                                               */
	unsigned int hsc2      : BFW_NX51_handshake_arm_irq_raw_clear_hsc2;      /* Handshake Cell 2  IRQ.                                               */
	unsigned int hsc3      : BFW_NX51_handshake_arm_irq_raw_clear_hsc3;      /* Handshake Cell 3  IRQ.                                               */
	unsigned int hsc4      : BFW_NX51_handshake_arm_irq_raw_clear_hsc4;      /* Handshake Cell 4  IRQ.                                               */
	unsigned int hsc5      : BFW_NX51_handshake_arm_irq_raw_clear_hsc5;      /* Handshake Cell 5  IRQ.                                               */
	unsigned int hsc6      : BFW_NX51_handshake_arm_irq_raw_clear_hsc6;      /* Handshake Cell 6  IRQ.                                               */
	unsigned int hsc7      : BFW_NX51_handshake_arm_irq_raw_clear_hsc7;      /* Handshake Cell 7  IRQ.                                               */
	unsigned int hsc8      : BFW_NX51_handshake_arm_irq_raw_clear_hsc8;      /* Handshake Cell 8  IRQ.                                               */
	unsigned int hsc9      : BFW_NX51_handshake_arm_irq_raw_clear_hsc9;      /* Handshake Cell 9  IRQ.                                               */
	unsigned int hsc10     : BFW_NX51_handshake_arm_irq_raw_clear_hsc10;     /* Handshake Cell 10 IRQ.                                               */
	unsigned int hsc11     : BFW_NX51_handshake_arm_irq_raw_clear_hsc11;     /* Handshake Cell 11 IRQ.                                               */
	unsigned int hsc12     : BFW_NX51_handshake_arm_irq_raw_clear_hsc12;     /* Handshake Cell 12 IRQ.                                               */
	unsigned int hsc13     : BFW_NX51_handshake_arm_irq_raw_clear_hsc13;     /* Handshake Cell 13 IRQ.                                               */
	unsigned int hsc14     : BFW_NX51_handshake_arm_irq_raw_clear_hsc14;     /* Handshake Cell 14 IRQ.                                               */
	unsigned int hsc15     : BFW_NX51_handshake_arm_irq_raw_clear_hsc15;     /* Handshake Cell 15 IRQ.                                               */
	unsigned int reserved1 : BFW_NX51_handshake_arm_irq_raw_clear_reserved1; /* reserved                                                             */
} NX51_HANDSHAKE_ARM_IRQ_RAW_CLEAR_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_HANDSHAKE_ARM_IRQ_RAW_CLEAR_BIT_T bf;
} NX51_HANDSHAKE_ARM_IRQ_RAW_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register handshake_arm_irq_masked */
/* => Handshake Cell Masked Interrupt for ARM register. */
/*    Shows status of masked IRQs (as connected to ARM). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_arm_irq_masked            0x00000024U
#define Adr_NX51_handshake_ctrl_handshake_arm_irq_masked 0x1018C324U
#define Adr_NX51_handshake_arm_irq_masked                0x1018C324U

#define MSK_NX51_handshake_arm_irq_masked_vector 0x000000ffU
#define SRT_NX51_handshake_arm_irq_masked_vector 0
#define MSK_NX51_handshake_arm_irq_masked_hsc0   0x00000100U
#define SRT_NX51_handshake_arm_irq_masked_hsc0   8
#define MSK_NX51_handshake_arm_irq_masked_hsc1   0x00000200U
#define SRT_NX51_handshake_arm_irq_masked_hsc1   9
#define MSK_NX51_handshake_arm_irq_masked_hsc2   0x00000400U
#define SRT_NX51_handshake_arm_irq_masked_hsc2   10
#define MSK_NX51_handshake_arm_irq_masked_hsc3   0x00000800U
#define SRT_NX51_handshake_arm_irq_masked_hsc3   11
#define MSK_NX51_handshake_arm_irq_masked_hsc4   0x00001000U
#define SRT_NX51_handshake_arm_irq_masked_hsc4   12
#define MSK_NX51_handshake_arm_irq_masked_hsc5   0x00002000U
#define SRT_NX51_handshake_arm_irq_masked_hsc5   13
#define MSK_NX51_handshake_arm_irq_masked_hsc6   0x00004000U
#define SRT_NX51_handshake_arm_irq_masked_hsc6   14
#define MSK_NX51_handshake_arm_irq_masked_hsc7   0x00008000U
#define SRT_NX51_handshake_arm_irq_masked_hsc7   15
#define MSK_NX51_handshake_arm_irq_masked_hsc8   0x00010000U
#define SRT_NX51_handshake_arm_irq_masked_hsc8   16
#define MSK_NX51_handshake_arm_irq_masked_hsc9   0x00020000U
#define SRT_NX51_handshake_arm_irq_masked_hsc9   17
#define MSK_NX51_handshake_arm_irq_masked_hsc10  0x00040000U
#define SRT_NX51_handshake_arm_irq_masked_hsc10  18
#define MSK_NX51_handshake_arm_irq_masked_hsc11  0x00080000U
#define SRT_NX51_handshake_arm_irq_masked_hsc11  19
#define MSK_NX51_handshake_arm_irq_masked_hsc12  0x00100000U
#define SRT_NX51_handshake_arm_irq_masked_hsc12  20
#define MSK_NX51_handshake_arm_irq_masked_hsc13  0x00200000U
#define SRT_NX51_handshake_arm_irq_masked_hsc13  21
#define MSK_NX51_handshake_arm_irq_masked_hsc14  0x00400000U
#define SRT_NX51_handshake_arm_irq_masked_hsc14  22
#define MSK_NX51_handshake_arm_irq_masked_hsc15  0x00800000U
#define SRT_NX51_handshake_arm_irq_masked_hsc15  23

/* all used bits of 'NX51_handshake_arm_irq_masked': */
#define MSK_USED_BITS_NX51_handshake_arm_irq_masked 0x00ffffffU

enum {
	BFW_NX51_handshake_arm_irq_masked_vector    = 8, /* [7:0] */
	BFW_NX51_handshake_arm_irq_masked_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_arm_irq_masked_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_arm_irq_masked_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_arm_irq_masked_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_arm_irq_masked_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_arm_irq_masked_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_arm_irq_masked_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_arm_irq_masked_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_arm_irq_masked_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_arm_irq_masked_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_arm_irq_masked_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_arm_irq_masked_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_arm_irq_masked_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_arm_irq_masked_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_arm_irq_masked_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_arm_irq_masked_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_arm_irq_masked_reserved1 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_ARM_IRQ_MASKED_BIT_Ttag {
	unsigned int vector    : BFW_NX51_handshake_arm_irq_masked_vector;    /* Interrupt Vector generated by masked ARM IRQ flags.                  */
	                                                                      /* Priority and Coding is compliant to netx50 HIF Handshake IRQ Vector: */
	                                                                      /* 0x00 : No IRQ.                                                       */
	                                                                      /* 0x10 : Handshake Cell 0  IRQ.                                        */
	                                                                      /* 0x11 : Handshake Cell 1  IRQ.                                        */
	                                                                      /* 0x12 : Handshake Cell 2  IRQ.                                        */
	                                                                      /* 0x13 : Handshake Cell 3  IRQ.                                        */
	                                                                      /* 0x14 : Handshake Cell 4  IRQ.                                        */
	                                                                      /* 0x15 : Handshake Cell 5  IRQ.                                        */
	                                                                      /* 0x16 : Handshake Cell 6  IRQ.                                        */
	                                                                      /* 0x17 : Handshake Cell 7  IRQ.                                        */
	                                                                      /* 0x18 : Handshake Cell 8  IRQ.                                        */
	                                                                      /* 0x19 : Handshake Cell 9  IRQ.                                        */
	                                                                      /* 0x1a : Handshake Cell 10 IRQ.                                        */
	                                                                      /* 0x1b : Handshake Cell 11 IRQ.                                        */
	                                                                      /* 0x1c : Handshake Cell 12 IRQ.                                        */
	                                                                      /* 0x1d : Handshake Cell 13 IRQ.                                        */
	                                                                      /* 0x1e : Handshake Cell 14 IRQ.                                        */
	                                                                      /* 0x1f : Handshake Cell 15 IRQ.                                        */
	                                                                      /* 0x20..0xff : reserved.                                               */
	unsigned int hsc0      : BFW_NX51_handshake_arm_irq_masked_hsc0;      /* Handshake Cell 0  IRQ.                                               */
	unsigned int hsc1      : BFW_NX51_handshake_arm_irq_masked_hsc1;      /* Handshake Cell 1  IRQ.                                               */
	unsigned int hsc2      : BFW_NX51_handshake_arm_irq_masked_hsc2;      /* Handshake Cell 2  IRQ.                                               */
	unsigned int hsc3      : BFW_NX51_handshake_arm_irq_masked_hsc3;      /* Handshake Cell 3  IRQ.                                               */
	unsigned int hsc4      : BFW_NX51_handshake_arm_irq_masked_hsc4;      /* Handshake Cell 4  IRQ.                                               */
	unsigned int hsc5      : BFW_NX51_handshake_arm_irq_masked_hsc5;      /* Handshake Cell 5  IRQ.                                               */
	unsigned int hsc6      : BFW_NX51_handshake_arm_irq_masked_hsc6;      /* Handshake Cell 6  IRQ.                                               */
	unsigned int hsc7      : BFW_NX51_handshake_arm_irq_masked_hsc7;      /* Handshake Cell 7  IRQ.                                               */
	unsigned int hsc8      : BFW_NX51_handshake_arm_irq_masked_hsc8;      /* Handshake Cell 8  IRQ.                                               */
	unsigned int hsc9      : BFW_NX51_handshake_arm_irq_masked_hsc9;      /* Handshake Cell 9  IRQ.                                               */
	unsigned int hsc10     : BFW_NX51_handshake_arm_irq_masked_hsc10;     /* Handshake Cell 10 IRQ.                                               */
	unsigned int hsc11     : BFW_NX51_handshake_arm_irq_masked_hsc11;     /* Handshake Cell 11 IRQ.                                               */
	unsigned int hsc12     : BFW_NX51_handshake_arm_irq_masked_hsc12;     /* Handshake Cell 12 IRQ.                                               */
	unsigned int hsc13     : BFW_NX51_handshake_arm_irq_masked_hsc13;     /* Handshake Cell 13 IRQ.                                               */
	unsigned int hsc14     : BFW_NX51_handshake_arm_irq_masked_hsc14;     /* Handshake Cell 14 IRQ.                                               */
	unsigned int hsc15     : BFW_NX51_handshake_arm_irq_masked_hsc15;     /* Handshake Cell 15 IRQ.                                               */
	unsigned int reserved1 : BFW_NX51_handshake_arm_irq_masked_reserved1; /* reserved                                                             */
} NX51_HANDSHAKE_ARM_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_HANDSHAKE_ARM_IRQ_MASKED_BIT_T bf;
} NX51_HANDSHAKE_ARM_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register handshake_arm_irq_msk_set */
/* => Handshake Cell Interrupt Mask Enable for ARM register. */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_arm_irq_msk_set            0x00000028U
#define Adr_NX51_handshake_ctrl_handshake_arm_irq_msk_set 0x1018C328U
#define Adr_NX51_handshake_arm_irq_msk_set                0x1018C328U
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set           0x00000000U

#define MSK_NX51_handshake_arm_irq_msk_set_hsc0          0x00000100U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc0          8
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc0     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc0  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc1          0x00000200U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc1          9
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc1     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc1  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc2          0x00000400U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc2          10
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc2     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc2  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc3          0x00000800U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc3          11
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc3     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc3  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc4          0x00001000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc4          12
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc4     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc4  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc5          0x00002000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc5          13
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc5     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc5  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc6          0x00004000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc6          14
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc6     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc6  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc7          0x00008000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc7          15
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc7     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc7  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc8          0x00010000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc8          16
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc8     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc8  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc9          0x00020000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc9          17
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc9     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc9  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc10         0x00040000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc10         18
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc10    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc10 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc11         0x00080000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc11         19
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc11    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc11 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc12         0x00100000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc12         20
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc12    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc12 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc13         0x00200000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc13         21
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc13    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc13 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc14         0x00400000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc14         22
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc14    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc14 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_set_hsc15         0x00800000U
#define SRT_NX51_handshake_arm_irq_msk_set_hsc15         23
#define DFLT_VAL_NX51_handshake_arm_irq_msk_set_hsc15    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_set_hsc15 0x00000000U

/* all used bits of 'NX51_handshake_arm_irq_msk_set': */
#define MSK_USED_BITS_NX51_handshake_arm_irq_msk_set 0x00ffff00U

enum {
	BFW_NX51_handshake_arm_irq_msk_set_reserved1 = 8, /* [7:0] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_arm_irq_msk_set_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_arm_irq_msk_set_reserved2 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_ARM_IRQ_MSK_SET_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_handshake_arm_irq_msk_set_reserved1; /* reserved               */
	unsigned int hsc0      : BFW_NX51_handshake_arm_irq_msk_set_hsc0;      /* Handshake Cell 0  IRQ. */
	unsigned int hsc1      : BFW_NX51_handshake_arm_irq_msk_set_hsc1;      /* Handshake Cell 1  IRQ. */
	unsigned int hsc2      : BFW_NX51_handshake_arm_irq_msk_set_hsc2;      /* Handshake Cell 2  IRQ. */
	unsigned int hsc3      : BFW_NX51_handshake_arm_irq_msk_set_hsc3;      /* Handshake Cell 3  IRQ. */
	unsigned int hsc4      : BFW_NX51_handshake_arm_irq_msk_set_hsc4;      /* Handshake Cell 4  IRQ. */
	unsigned int hsc5      : BFW_NX51_handshake_arm_irq_msk_set_hsc5;      /* Handshake Cell 5  IRQ. */
	unsigned int hsc6      : BFW_NX51_handshake_arm_irq_msk_set_hsc6;      /* Handshake Cell 6  IRQ. */
	unsigned int hsc7      : BFW_NX51_handshake_arm_irq_msk_set_hsc7;      /* Handshake Cell 7  IRQ. */
	unsigned int hsc8      : BFW_NX51_handshake_arm_irq_msk_set_hsc8;      /* Handshake Cell 8  IRQ. */
	unsigned int hsc9      : BFW_NX51_handshake_arm_irq_msk_set_hsc9;      /* Handshake Cell 9  IRQ. */
	unsigned int hsc10     : BFW_NX51_handshake_arm_irq_msk_set_hsc10;     /* Handshake Cell 10 IRQ. */
	unsigned int hsc11     : BFW_NX51_handshake_arm_irq_msk_set_hsc11;     /* Handshake Cell 11 IRQ. */
	unsigned int hsc12     : BFW_NX51_handshake_arm_irq_msk_set_hsc12;     /* Handshake Cell 12 IRQ. */
	unsigned int hsc13     : BFW_NX51_handshake_arm_irq_msk_set_hsc13;     /* Handshake Cell 13 IRQ. */
	unsigned int hsc14     : BFW_NX51_handshake_arm_irq_msk_set_hsc14;     /* Handshake Cell 14 IRQ. */
	unsigned int hsc15     : BFW_NX51_handshake_arm_irq_msk_set_hsc15;     /* Handshake Cell 15 IRQ. */
	unsigned int reserved2 : BFW_NX51_handshake_arm_irq_msk_set_reserved2; /* reserved               */
} NX51_HANDSHAKE_ARM_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_HANDSHAKE_ARM_IRQ_MSK_SET_BIT_T bf;
} NX51_HANDSHAKE_ARM_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register handshake_arm_irq_msk_reset */
/* => Handshake Cell Interrupt Mask Disable for ARM register. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_arm_irq_msk_reset            0x0000002CU
#define Adr_NX51_handshake_ctrl_handshake_arm_irq_msk_reset 0x1018C32CU
#define Adr_NX51_handshake_arm_irq_msk_reset                0x1018C32CU
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset           0x00000000U

#define MSK_NX51_handshake_arm_irq_msk_reset_hsc0          0x00000100U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc0          8
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc0     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc0  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc1          0x00000200U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc1          9
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc1     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc1  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc2          0x00000400U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc2          10
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc2     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc2  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc3          0x00000800U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc3          11
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc3     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc3  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc4          0x00001000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc4          12
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc4     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc4  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc5          0x00002000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc5          13
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc5     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc5  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc6          0x00004000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc6          14
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc6     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc6  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc7          0x00008000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc7          15
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc7     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc7  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc8          0x00010000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc8          16
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc8     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc8  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc9          0x00020000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc9          17
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc9     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc9  0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc10         0x00040000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc10         18
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc10    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc10 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc11         0x00080000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc11         19
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc11    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc11 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc12         0x00100000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc12         20
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc12    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc12 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc13         0x00200000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc13         21
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc13    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc13 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc14         0x00400000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc14         22
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc14    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc14 0x00000000U
#define MSK_NX51_handshake_arm_irq_msk_reset_hsc15         0x00800000U
#define SRT_NX51_handshake_arm_irq_msk_reset_hsc15         23
#define DFLT_VAL_NX51_handshake_arm_irq_msk_reset_hsc15    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_arm_irq_msk_reset_hsc15 0x00000000U

/* all used bits of 'NX51_handshake_arm_irq_msk_reset': */
#define MSK_USED_BITS_NX51_handshake_arm_irq_msk_reset 0x00ffff00U

enum {
	BFW_NX51_handshake_arm_irq_msk_reset_reserved1 = 8, /* [7:0] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_arm_irq_msk_reset_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_arm_irq_msk_reset_reserved2 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_ARM_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_handshake_arm_irq_msk_reset_reserved1; /* reserved               */
	unsigned int hsc0      : BFW_NX51_handshake_arm_irq_msk_reset_hsc0;      /* Handshake Cell 0  IRQ. */
	unsigned int hsc1      : BFW_NX51_handshake_arm_irq_msk_reset_hsc1;      /* Handshake Cell 1  IRQ. */
	unsigned int hsc2      : BFW_NX51_handshake_arm_irq_msk_reset_hsc2;      /* Handshake Cell 2  IRQ. */
	unsigned int hsc3      : BFW_NX51_handshake_arm_irq_msk_reset_hsc3;      /* Handshake Cell 3  IRQ. */
	unsigned int hsc4      : BFW_NX51_handshake_arm_irq_msk_reset_hsc4;      /* Handshake Cell 4  IRQ. */
	unsigned int hsc5      : BFW_NX51_handshake_arm_irq_msk_reset_hsc5;      /* Handshake Cell 5  IRQ. */
	unsigned int hsc6      : BFW_NX51_handshake_arm_irq_msk_reset_hsc6;      /* Handshake Cell 6  IRQ. */
	unsigned int hsc7      : BFW_NX51_handshake_arm_irq_msk_reset_hsc7;      /* Handshake Cell 7  IRQ. */
	unsigned int hsc8      : BFW_NX51_handshake_arm_irq_msk_reset_hsc8;      /* Handshake Cell 8  IRQ. */
	unsigned int hsc9      : BFW_NX51_handshake_arm_irq_msk_reset_hsc9;      /* Handshake Cell 9  IRQ. */
	unsigned int hsc10     : BFW_NX51_handshake_arm_irq_msk_reset_hsc10;     /* Handshake Cell 10 IRQ. */
	unsigned int hsc11     : BFW_NX51_handshake_arm_irq_msk_reset_hsc11;     /* Handshake Cell 11 IRQ. */
	unsigned int hsc12     : BFW_NX51_handshake_arm_irq_msk_reset_hsc12;     /* Handshake Cell 12 IRQ. */
	unsigned int hsc13     : BFW_NX51_handshake_arm_irq_msk_reset_hsc13;     /* Handshake Cell 13 IRQ. */
	unsigned int hsc14     : BFW_NX51_handshake_arm_irq_msk_reset_hsc14;     /* Handshake Cell 14 IRQ. */
	unsigned int hsc15     : BFW_NX51_handshake_arm_irq_msk_reset_hsc15;     /* Handshake Cell 15 IRQ. */
	unsigned int reserved2 : BFW_NX51_handshake_arm_irq_msk_reset_reserved2; /* reserved               */
} NX51_HANDSHAKE_ARM_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_HANDSHAKE_ARM_IRQ_MSK_RESET_BIT_T bf;
} NX51_HANDSHAKE_ARM_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register handshake_xpic_irq_raw_clear */
/* => Handshake Cell Raw Interrupt for xPIC register. */
/*    Read access shows status of unmasked IRQs. */
/*    Write access with '1' clears the appropriate IRQ. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_xpic_irq_raw_clear            0x00000030U
#define Adr_NX51_handshake_ctrl_handshake_xpic_irq_raw_clear 0x1018C330U
#define Adr_NX51_handshake_xpic_irq_raw_clear                0x1018C330U
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear           0x00000000U

#define MSK_NX51_handshake_xpic_irq_raw_clear_vector         0x000000ffU
#define SRT_NX51_handshake_xpic_irq_raw_clear_vector         0
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_vector    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_vector 0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc0           0x00000100U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc0           8
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc0      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc0   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc1           0x00000200U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc1           9
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc1      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc1   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc2           0x00000400U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc2           10
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc2      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc2   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc3           0x00000800U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc3           11
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc3      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc3   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc4           0x00001000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc4           12
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc4      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc4   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc5           0x00002000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc5           13
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc5      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc5   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc6           0x00004000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc6           14
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc6      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc6   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc7           0x00008000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc7           15
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc7      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc7   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc8           0x00010000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc8           16
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc8      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc8   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc9           0x00020000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc9           17
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc9      0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc9   0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc10          0x00040000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc10          18
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc10     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc10  0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc11          0x00080000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc11          19
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc11     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc11  0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc12          0x00100000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc12          20
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc12     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc12  0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc13          0x00200000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc13          21
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc13     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc13  0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc14          0x00400000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc14          22
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc14     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc14  0x00000000U
#define MSK_NX51_handshake_xpic_irq_raw_clear_hsc15          0x00800000U
#define SRT_NX51_handshake_xpic_irq_raw_clear_hsc15          23
#define DFLT_VAL_NX51_handshake_xpic_irq_raw_clear_hsc15     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_raw_clear_hsc15  0x00000000U

/* all used bits of 'NX51_handshake_xpic_irq_raw_clear': */
#define MSK_USED_BITS_NX51_handshake_xpic_irq_raw_clear 0x00ffffffU

enum {
	BFW_NX51_handshake_xpic_irq_raw_clear_vector    = 8, /* [7:0] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_xpic_irq_raw_clear_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_xpic_irq_raw_clear_reserved1 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_XPIC_IRQ_RAW_CLEAR_BIT_Ttag {
	unsigned int vector    : BFW_NX51_handshake_xpic_irq_raw_clear_vector;    /* Interrupt Vector generated by masked xPIC IRQ flags.                 */
	                                                                          /* These bits are mirrored from handshake_xpic_irq_masked register.     */
	                                                                          /* Priority and Coding is compliant to netx50 HIF Handshake IRQ Vector: */
	                                                                          /* 0x00 : No IRQ.                                                       */
	                                                                          /* 0x10 : Handshake Cell 0  IRQ.                                        */
	                                                                          /* 0x11 : Handshake Cell 1  IRQ.                                        */
	                                                                          /* 0x12 : Handshake Cell 2  IRQ.                                        */
	                                                                          /* 0x13 : Handshake Cell 3  IRQ.                                        */
	                                                                          /* 0x14 : Handshake Cell 4  IRQ.                                        */
	                                                                          /* 0x15 : Handshake Cell 5  IRQ.                                        */
	                                                                          /* 0x16 : Handshake Cell 6  IRQ.                                        */
	                                                                          /* 0x17 : Handshake Cell 7  IRQ.                                        */
	                                                                          /* 0x18 : Handshake Cell 8  IRQ.                                        */
	                                                                          /* 0x19 : Handshake Cell 9  IRQ.                                        */
	                                                                          /* 0x1a : Handshake Cell 10 IRQ.                                        */
	                                                                          /* 0x1b : Handshake Cell 11 IRQ.                                        */
	                                                                          /* 0x1c : Handshake Cell 12 IRQ.                                        */
	                                                                          /* 0x1d : Handshake Cell 13 IRQ.                                        */
	                                                                          /* 0x1e : Handshake Cell 14 IRQ.                                        */
	                                                                          /* 0x1f : Handshake Cell 15 IRQ.                                        */
	                                                                          /* 0x20..0xff : reserved.                                               */
	unsigned int hsc0      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc0;      /* Handshake Cell 0  IRQ.                                               */
	unsigned int hsc1      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc1;      /* Handshake Cell 1  IRQ.                                               */
	unsigned int hsc2      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc2;      /* Handshake Cell 2  IRQ.                                               */
	unsigned int hsc3      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc3;      /* Handshake Cell 3  IRQ.                                               */
	unsigned int hsc4      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc4;      /* Handshake Cell 4  IRQ.                                               */
	unsigned int hsc5      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc5;      /* Handshake Cell 5  IRQ.                                               */
	unsigned int hsc6      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc6;      /* Handshake Cell 6  IRQ.                                               */
	unsigned int hsc7      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc7;      /* Handshake Cell 7  IRQ.                                               */
	unsigned int hsc8      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc8;      /* Handshake Cell 8  IRQ.                                               */
	unsigned int hsc9      : BFW_NX51_handshake_xpic_irq_raw_clear_hsc9;      /* Handshake Cell 9  IRQ.                                               */
	unsigned int hsc10     : BFW_NX51_handshake_xpic_irq_raw_clear_hsc10;     /* Handshake Cell 10 IRQ.                                               */
	unsigned int hsc11     : BFW_NX51_handshake_xpic_irq_raw_clear_hsc11;     /* Handshake Cell 11 IRQ.                                               */
	unsigned int hsc12     : BFW_NX51_handshake_xpic_irq_raw_clear_hsc12;     /* Handshake Cell 12 IRQ.                                               */
	unsigned int hsc13     : BFW_NX51_handshake_xpic_irq_raw_clear_hsc13;     /* Handshake Cell 13 IRQ.                                               */
	unsigned int hsc14     : BFW_NX51_handshake_xpic_irq_raw_clear_hsc14;     /* Handshake Cell 14 IRQ.                                               */
	unsigned int hsc15     : BFW_NX51_handshake_xpic_irq_raw_clear_hsc15;     /* Handshake Cell 15 IRQ.                                               */
	unsigned int reserved1 : BFW_NX51_handshake_xpic_irq_raw_clear_reserved1; /* reserved                                                             */
} NX51_HANDSHAKE_XPIC_IRQ_RAW_CLEAR_BIT_T;

typedef union {
	unsigned int                            val;
	NX51_HANDSHAKE_XPIC_IRQ_RAW_CLEAR_BIT_T bf;
} NX51_HANDSHAKE_XPIC_IRQ_RAW_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register handshake_xpic_irq_masked */
/* => Handshake Cell Masked Interrupt for xPIC register. */
/*    Shows status of masked IRQs (as connected to ARM/xPIC). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_xpic_irq_masked            0x00000034U
#define Adr_NX51_handshake_ctrl_handshake_xpic_irq_masked 0x1018C334U
#define Adr_NX51_handshake_xpic_irq_masked                0x1018C334U

#define MSK_NX51_handshake_xpic_irq_masked_vector 0x000000ffU
#define SRT_NX51_handshake_xpic_irq_masked_vector 0
#define MSK_NX51_handshake_xpic_irq_masked_hsc0   0x00000100U
#define SRT_NX51_handshake_xpic_irq_masked_hsc0   8
#define MSK_NX51_handshake_xpic_irq_masked_hsc1   0x00000200U
#define SRT_NX51_handshake_xpic_irq_masked_hsc1   9
#define MSK_NX51_handshake_xpic_irq_masked_hsc2   0x00000400U
#define SRT_NX51_handshake_xpic_irq_masked_hsc2   10
#define MSK_NX51_handshake_xpic_irq_masked_hsc3   0x00000800U
#define SRT_NX51_handshake_xpic_irq_masked_hsc3   11
#define MSK_NX51_handshake_xpic_irq_masked_hsc4   0x00001000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc4   12
#define MSK_NX51_handshake_xpic_irq_masked_hsc5   0x00002000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc5   13
#define MSK_NX51_handshake_xpic_irq_masked_hsc6   0x00004000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc6   14
#define MSK_NX51_handshake_xpic_irq_masked_hsc7   0x00008000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc7   15
#define MSK_NX51_handshake_xpic_irq_masked_hsc8   0x00010000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc8   16
#define MSK_NX51_handshake_xpic_irq_masked_hsc9   0x00020000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc9   17
#define MSK_NX51_handshake_xpic_irq_masked_hsc10  0x00040000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc10  18
#define MSK_NX51_handshake_xpic_irq_masked_hsc11  0x00080000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc11  19
#define MSK_NX51_handshake_xpic_irq_masked_hsc12  0x00100000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc12  20
#define MSK_NX51_handshake_xpic_irq_masked_hsc13  0x00200000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc13  21
#define MSK_NX51_handshake_xpic_irq_masked_hsc14  0x00400000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc14  22
#define MSK_NX51_handshake_xpic_irq_masked_hsc15  0x00800000U
#define SRT_NX51_handshake_xpic_irq_masked_hsc15  23

/* all used bits of 'NX51_handshake_xpic_irq_masked': */
#define MSK_USED_BITS_NX51_handshake_xpic_irq_masked 0x00ffffffU

enum {
	BFW_NX51_handshake_xpic_irq_masked_vector    = 8, /* [7:0] */
	BFW_NX51_handshake_xpic_irq_masked_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_xpic_irq_masked_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_xpic_irq_masked_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_xpic_irq_masked_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_xpic_irq_masked_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_xpic_irq_masked_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_xpic_irq_masked_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_xpic_irq_masked_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_xpic_irq_masked_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_xpic_irq_masked_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_xpic_irq_masked_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_xpic_irq_masked_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_xpic_irq_masked_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_xpic_irq_masked_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_xpic_irq_masked_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_xpic_irq_masked_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_xpic_irq_masked_reserved1 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_XPIC_IRQ_MASKED_BIT_Ttag {
	unsigned int vector    : BFW_NX51_handshake_xpic_irq_masked_vector;    /* Interrupt Vector generated by masked xPIC IRQ flags.                 */
	                                                                       /* Priority and Coding is compliant to netx50 HIF Handshake IRQ Vector: */
	                                                                       /* 0x00 : No IRQ.                                                       */
	                                                                       /* 0x10 : Handshake Cell 0  IRQ.                                        */
	                                                                       /* 0x11 : Handshake Cell 1  IRQ.                                        */
	                                                                       /* 0x12 : Handshake Cell 2  IRQ.                                        */
	                                                                       /* 0x13 : Handshake Cell 3  IRQ.                                        */
	                                                                       /* 0x14 : Handshake Cell 4  IRQ.                                        */
	                                                                       /* 0x15 : Handshake Cell 5  IRQ.                                        */
	                                                                       /* 0x16 : Handshake Cell 6  IRQ.                                        */
	                                                                       /* 0x17 : Handshake Cell 7  IRQ.                                        */
	                                                                       /* 0x18 : Handshake Cell 8  IRQ.                                        */
	                                                                       /* 0x19 : Handshake Cell 9  IRQ.                                        */
	                                                                       /* 0x1a : Handshake Cell 10 IRQ.                                        */
	                                                                       /* 0x1b : Handshake Cell 11 IRQ.                                        */
	                                                                       /* 0x1c : Handshake Cell 12 IRQ.                                        */
	                                                                       /* 0x1d : Handshake Cell 13 IRQ.                                        */
	                                                                       /* 0x1e : Handshake Cell 14 IRQ.                                        */
	                                                                       /* 0x1f : Handshake Cell 15 IRQ.                                        */
	                                                                       /* 0x20..0xff : reserved.                                               */
	unsigned int hsc0      : BFW_NX51_handshake_xpic_irq_masked_hsc0;      /* Handshake Cell 0  IRQ.                                               */
	unsigned int hsc1      : BFW_NX51_handshake_xpic_irq_masked_hsc1;      /* Handshake Cell 1  IRQ.                                               */
	unsigned int hsc2      : BFW_NX51_handshake_xpic_irq_masked_hsc2;      /* Handshake Cell 2  IRQ.                                               */
	unsigned int hsc3      : BFW_NX51_handshake_xpic_irq_masked_hsc3;      /* Handshake Cell 3  IRQ.                                               */
	unsigned int hsc4      : BFW_NX51_handshake_xpic_irq_masked_hsc4;      /* Handshake Cell 4  IRQ.                                               */
	unsigned int hsc5      : BFW_NX51_handshake_xpic_irq_masked_hsc5;      /* Handshake Cell 5  IRQ.                                               */
	unsigned int hsc6      : BFW_NX51_handshake_xpic_irq_masked_hsc6;      /* Handshake Cell 6  IRQ.                                               */
	unsigned int hsc7      : BFW_NX51_handshake_xpic_irq_masked_hsc7;      /* Handshake Cell 7  IRQ.                                               */
	unsigned int hsc8      : BFW_NX51_handshake_xpic_irq_masked_hsc8;      /* Handshake Cell 8  IRQ.                                               */
	unsigned int hsc9      : BFW_NX51_handshake_xpic_irq_masked_hsc9;      /* Handshake Cell 9  IRQ.                                               */
	unsigned int hsc10     : BFW_NX51_handshake_xpic_irq_masked_hsc10;     /* Handshake Cell 10 IRQ.                                               */
	unsigned int hsc11     : BFW_NX51_handshake_xpic_irq_masked_hsc11;     /* Handshake Cell 11 IRQ.                                               */
	unsigned int hsc12     : BFW_NX51_handshake_xpic_irq_masked_hsc12;     /* Handshake Cell 12 IRQ.                                               */
	unsigned int hsc13     : BFW_NX51_handshake_xpic_irq_masked_hsc13;     /* Handshake Cell 13 IRQ.                                               */
	unsigned int hsc14     : BFW_NX51_handshake_xpic_irq_masked_hsc14;     /* Handshake Cell 14 IRQ.                                               */
	unsigned int hsc15     : BFW_NX51_handshake_xpic_irq_masked_hsc15;     /* Handshake Cell 15 IRQ.                                               */
	unsigned int reserved1 : BFW_NX51_handshake_xpic_irq_masked_reserved1; /* reserved                                                             */
} NX51_HANDSHAKE_XPIC_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_HANDSHAKE_XPIC_IRQ_MASKED_BIT_T bf;
} NX51_HANDSHAKE_XPIC_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register handshake_xpic_irq_msk_set */
/* => Handshake Cell Interrupt Mask Enable for xPIC register. */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_xpic_irq_msk_set            0x00000038U
#define Adr_NX51_handshake_ctrl_handshake_xpic_irq_msk_set 0x1018C338U
#define Adr_NX51_handshake_xpic_irq_msk_set                0x1018C338U
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set           0x00000000U

#define MSK_NX51_handshake_xpic_irq_msk_set_hsc0          0x00000100U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc0          8
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc0     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc0  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc1          0x00000200U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc1          9
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc1     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc1  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc2          0x00000400U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc2          10
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc2     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc2  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc3          0x00000800U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc3          11
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc3     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc3  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc4          0x00001000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc4          12
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc4     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc4  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc5          0x00002000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc5          13
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc5     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc5  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc6          0x00004000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc6          14
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc6     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc6  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc7          0x00008000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc7          15
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc7     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc7  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc8          0x00010000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc8          16
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc8     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc8  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc9          0x00020000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc9          17
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc9     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc9  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc10         0x00040000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc10         18
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc10    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc10 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc11         0x00080000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc11         19
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc11    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc11 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc12         0x00100000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc12         20
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc12    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc12 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc13         0x00200000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc13         21
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc13    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc13 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc14         0x00400000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc14         22
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc14    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc14 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_set_hsc15         0x00800000U
#define SRT_NX51_handshake_xpic_irq_msk_set_hsc15         23
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_set_hsc15    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_set_hsc15 0x00000000U

/* all used bits of 'NX51_handshake_xpic_irq_msk_set': */
#define MSK_USED_BITS_NX51_handshake_xpic_irq_msk_set 0x00ffff00U

enum {
	BFW_NX51_handshake_xpic_irq_msk_set_reserved1 = 8, /* [7:0] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_xpic_irq_msk_set_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_xpic_irq_msk_set_reserved2 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_XPIC_IRQ_MSK_SET_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_handshake_xpic_irq_msk_set_reserved1; /* reserved               */
	unsigned int hsc0      : BFW_NX51_handshake_xpic_irq_msk_set_hsc0;      /* Handshake Cell 0  IRQ. */
	unsigned int hsc1      : BFW_NX51_handshake_xpic_irq_msk_set_hsc1;      /* Handshake Cell 1  IRQ. */
	unsigned int hsc2      : BFW_NX51_handshake_xpic_irq_msk_set_hsc2;      /* Handshake Cell 2  IRQ. */
	unsigned int hsc3      : BFW_NX51_handshake_xpic_irq_msk_set_hsc3;      /* Handshake Cell 3  IRQ. */
	unsigned int hsc4      : BFW_NX51_handshake_xpic_irq_msk_set_hsc4;      /* Handshake Cell 4  IRQ. */
	unsigned int hsc5      : BFW_NX51_handshake_xpic_irq_msk_set_hsc5;      /* Handshake Cell 5  IRQ. */
	unsigned int hsc6      : BFW_NX51_handshake_xpic_irq_msk_set_hsc6;      /* Handshake Cell 6  IRQ. */
	unsigned int hsc7      : BFW_NX51_handshake_xpic_irq_msk_set_hsc7;      /* Handshake Cell 7  IRQ. */
	unsigned int hsc8      : BFW_NX51_handshake_xpic_irq_msk_set_hsc8;      /* Handshake Cell 8  IRQ. */
	unsigned int hsc9      : BFW_NX51_handshake_xpic_irq_msk_set_hsc9;      /* Handshake Cell 9  IRQ. */
	unsigned int hsc10     : BFW_NX51_handshake_xpic_irq_msk_set_hsc10;     /* Handshake Cell 10 IRQ. */
	unsigned int hsc11     : BFW_NX51_handshake_xpic_irq_msk_set_hsc11;     /* Handshake Cell 11 IRQ. */
	unsigned int hsc12     : BFW_NX51_handshake_xpic_irq_msk_set_hsc12;     /* Handshake Cell 12 IRQ. */
	unsigned int hsc13     : BFW_NX51_handshake_xpic_irq_msk_set_hsc13;     /* Handshake Cell 13 IRQ. */
	unsigned int hsc14     : BFW_NX51_handshake_xpic_irq_msk_set_hsc14;     /* Handshake Cell 14 IRQ. */
	unsigned int hsc15     : BFW_NX51_handshake_xpic_irq_msk_set_hsc15;     /* Handshake Cell 15 IRQ. */
	unsigned int reserved2 : BFW_NX51_handshake_xpic_irq_msk_set_reserved2; /* reserved               */
} NX51_HANDSHAKE_XPIC_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                          val;
	NX51_HANDSHAKE_XPIC_IRQ_MSK_SET_BIT_T bf;
} NX51_HANDSHAKE_XPIC_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register handshake_xpic_irq_msk_reset */
/* => Handshake Cell Interrupt Mask Disable for xPIC register. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_xpic_irq_msk_reset            0x0000003CU
#define Adr_NX51_handshake_ctrl_handshake_xpic_irq_msk_reset 0x1018C33CU
#define Adr_NX51_handshake_xpic_irq_msk_reset                0x1018C33CU
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset           0x00000000U

#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc0          0x00000100U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc0          8
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc0     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc0  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc1          0x00000200U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc1          9
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc1     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc1  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc2          0x00000400U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc2          10
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc2     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc2  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc3          0x00000800U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc3          11
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc3     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc3  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc4          0x00001000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc4          12
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc4     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc4  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc5          0x00002000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc5          13
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc5     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc5  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc6          0x00004000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc6          14
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc6     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc6  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc7          0x00008000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc7          15
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc7     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc7  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc8          0x00010000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc8          16
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc8     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc8  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc9          0x00020000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc9          17
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc9     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc9  0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc10         0x00040000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc10         18
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc10    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc10 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc11         0x00080000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc11         19
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc11    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc11 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc12         0x00100000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc12         20
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc12    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc12 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc13         0x00200000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc13         21
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc13    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc13 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc14         0x00400000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc14         22
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc14    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc14 0x00000000U
#define MSK_NX51_handshake_xpic_irq_msk_reset_hsc15         0x00800000U
#define SRT_NX51_handshake_xpic_irq_msk_reset_hsc15         23
#define DFLT_VAL_NX51_handshake_xpic_irq_msk_reset_hsc15    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_xpic_irq_msk_reset_hsc15 0x00000000U

/* all used bits of 'NX51_handshake_xpic_irq_msk_reset': */
#define MSK_USED_BITS_NX51_handshake_xpic_irq_msk_reset 0x00ffff00U

enum {
	BFW_NX51_handshake_xpic_irq_msk_reset_reserved1 = 8, /* [7:0] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc0      = 1, /* [8] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc1      = 1, /* [9] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc2      = 1, /* [10] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc3      = 1, /* [11] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc4      = 1, /* [12] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc5      = 1, /* [13] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc6      = 1, /* [14] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc7      = 1, /* [15] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc8      = 1, /* [16] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc9      = 1, /* [17] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc10     = 1, /* [18] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc11     = 1, /* [19] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc12     = 1, /* [20] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc13     = 1, /* [21] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc14     = 1, /* [22] */
	BFW_NX51_handshake_xpic_irq_msk_reset_hsc15     = 1, /* [23] */
	BFW_NX51_handshake_xpic_irq_msk_reset_reserved2 = 8  /* [31:24] */
};

typedef struct NX51_HANDSHAKE_XPIC_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_handshake_xpic_irq_msk_reset_reserved1; /* reserved               */
	unsigned int hsc0      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc0;      /* Handshake Cell 0  IRQ. */
	unsigned int hsc1      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc1;      /* Handshake Cell 1  IRQ. */
	unsigned int hsc2      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc2;      /* Handshake Cell 2  IRQ. */
	unsigned int hsc3      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc3;      /* Handshake Cell 3  IRQ. */
	unsigned int hsc4      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc4;      /* Handshake Cell 4  IRQ. */
	unsigned int hsc5      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc5;      /* Handshake Cell 5  IRQ. */
	unsigned int hsc6      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc6;      /* Handshake Cell 6  IRQ. */
	unsigned int hsc7      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc7;      /* Handshake Cell 7  IRQ. */
	unsigned int hsc8      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc8;      /* Handshake Cell 8  IRQ. */
	unsigned int hsc9      : BFW_NX51_handshake_xpic_irq_msk_reset_hsc9;      /* Handshake Cell 9  IRQ. */
	unsigned int hsc10     : BFW_NX51_handshake_xpic_irq_msk_reset_hsc10;     /* Handshake Cell 10 IRQ. */
	unsigned int hsc11     : BFW_NX51_handshake_xpic_irq_msk_reset_hsc11;     /* Handshake Cell 11 IRQ. */
	unsigned int hsc12     : BFW_NX51_handshake_xpic_irq_msk_reset_hsc12;     /* Handshake Cell 12 IRQ. */
	unsigned int hsc13     : BFW_NX51_handshake_xpic_irq_msk_reset_hsc13;     /* Handshake Cell 13 IRQ. */
	unsigned int hsc14     : BFW_NX51_handshake_xpic_irq_msk_reset_hsc14;     /* Handshake Cell 14 IRQ. */
	unsigned int hsc15     : BFW_NX51_handshake_xpic_irq_msk_reset_hsc15;     /* Handshake Cell 15 IRQ. */
	unsigned int reserved2 : BFW_NX51_handshake_xpic_irq_msk_reset_reserved2; /* reserved               */
} NX51_HANDSHAKE_XPIC_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                            val;
	NX51_HANDSHAKE_XPIC_IRQ_MSK_RESET_BIT_T bf;
} NX51_HANDSHAKE_XPIC_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc0_ctrl */
/* => Handshake Cell 0 Control Register. */
/*    Handshake data width can be configured individually for each Handshake Cell. */
/*    In the 'mode' bit field each Handshake Cell can be enabled or disabled and a handshake */
/*    path (i.e. participating masters) can be configured individually. */
/*    When a Handshake Cell is enabled there are certain bytes writable only by certain related masters (view 'mode' description). */
/*    Handshake Cell data mapping and read-only behavior is netx50 compatible. Handshake Cell IRQ generation can */
/*    be done netx50 or netx10 compatible by programming the 'netx50_comp' bit inside the 'handshake_base_addr' register. */
/*    Default is netx50 behavior. */
/*    Handshake Cell IRQ behavior of netx10: */
/*       A Handshake Cell IRQ will always be generated when data is written */
/*       to any part (byte, 16bit or 32bit word) of the 32bit area the related Handshake Cell is */
/*       located (inside INTRAMHS). I.e. an IRQ is also generated when data is written to read-only */
/*       or data-memory parts of the 32bit Handshake Cell area. */
/*       A Handshake Cell IRQ will always be cleared when data is read from any part of the 32bit */
/*       Handshake Cell area. */
/*    Handshake Cell IRQ behavior of netx50: */
/*       A Handshake Cell IRQ will only be generated when data is written to the participating */
/*       part (8bit Handshake Cell: byte, 16bit Handshake Cell: 16bit word) of the 32bit area */
/*       the related Handshake Cell is located (inside INTRAMHS) which is not read-only. I.e. an IRQ */
/*       is not generated when data is written to read-only or data-memory parts of the 32bit */
/*       Handshake Cell area. */
/*       A Handshake Cell IRQ will only be cleared when data is read from any participating */
/*       read-only part of the 32bit Handshake Cell area. I.e. also a byte-read from a 16bit */
/*       Handshake Cell read-only part will clear the related IRQ. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc0_ctrl            0x00000080U
#define Adr_NX51_handshake_ctrl_handshake_hsc0_ctrl 0x1018C380U
#define Adr_NX51_handshake_hsc0_ctrl                0x1018C380U
#define DFLT_VAL_NX51_handshake_hsc0_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc0_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc0_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc0_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc0_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc0_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc0_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc0_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc0_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc0_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc0_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc0_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc0_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc0_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc0_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC0_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc0_ctrl_mode;      /* Handshake Cell 0 Mode.                                                                                 */
	                                                                 /* Coding:                                                                                                */
	                                                                 /*  00: Handshake Cell 0 is disabled                                                                      */
	                                                                 /*      Related memory data is accessible without any restriction; no IRQs are generated at any access.   */
	                                                                 /*  01: Use Handshake Cell 0 for handshaking between DPM and ARM                                          */
	                                                                 /*      8bit handshaking ('width' configuration is 0):                                                    */
	                                                                 /*          DPM write data in data bits 31..24, bits 23..16 are read-only.                                */
	                                                                 /*          ARM write data in data bits 23..16, bits 31..24 are read-only.                                */
	                                                                 /*          Data bits 15..0 are standard data memory.                                                     */
	                                                                 /*      16bit handshaking ('width' configuration is 1):                                                   */
	                                                                 /*          DPM write data in data bits 31..16, bits 15..0 are read-only.                                 */
	                                                                 /*          ARM write data in data bits 15..0, bits 31..16 are read-only.                                 */
	                                                                 /*  10: Use Handshake Cell 0 for handshaking between DPM and xPIC                                         */
	                                                                 /*      8bit handshaking ('width' configuration is 0):                                                    */
	                                                                 /*          DPM write data in data bits 31..24, bits 23..16 are read-only, 15..0 is standard data memory  */
	                                                                 /*          xPIC write data in data bits 23..16, bits 31..24 are read-only, 15..0 is standard data memory */
	                                                                 /*          Data bits 15..0 are standard data memory.                                                     */
	                                                                 /*      16bit handshaking ('width' configuration is 1):                                                   */
	                                                                 /*          DPM write data in data bits 31..16, bits 15..0 are read-only.                                 */
	                                                                 /*          xPIC write data in data bits 15..0, bits 31..16 are read-only.                                */
	                                                                 /*  11: Use Handshake Cell 0 for handshaking between ARM and xPIC                                         */
	                                                                 /*      8bit handshaking ('width' configuration is 0):                                                    */
	                                                                 /*          ARM write data in data bits 31..24, bits 23..16 are read-only, 15..0 is standard data memory  */
	                                                                 /*          xPIC write data in data bits 23..16, bits 31..24 are read-only, 15..0 is standard data memory */
	                                                                 /*          Data bits 15..0 are standard data memory.                                                     */
	                                                                 /*      16bit handshaking ('width' configuration is 1):                                                   */
	                                                                 /*          ARM write data in data bits 31..16, bits 15..0 are read-only.                                 */
	                                                                 /*          xPIC write data in data bits 15..0, bits 31..16 are read-only.                                */
	unsigned int reserved1 : BFW_NX51_handshake_hsc0_ctrl_reserved1; /* reserved                                                                                               */
	unsigned int width     : BFW_NX51_handshake_hsc0_ctrl_width;     /* Handshake Cell 0 Width.                                                                                */
	                                                                 /* Coding:                                                                                                */
	                                                                 /*  0: 8 bit handshake width.                                                                             */
	                                                                 /*  1: 16 bit handshake width.                                                                            */
	unsigned int reserved2 : BFW_NX51_handshake_hsc0_ctrl_reserved2; /* reserved                                                                                               */
} NX51_HANDSHAKE_HSC0_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC0_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc1_ctrl */
/* => Handshake Cell 1 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc1_ctrl            0x00000084U
#define Adr_NX51_handshake_ctrl_handshake_hsc1_ctrl 0x1018C384U
#define Adr_NX51_handshake_hsc1_ctrl                0x1018C384U
#define DFLT_VAL_NX51_handshake_hsc1_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc1_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc1_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc1_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc1_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc1_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc1_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc1_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc1_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc1_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc1_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc1_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc1_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc1_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc1_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC1_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc1_ctrl_mode;      /* Handshake Cell 1 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc1_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc1_ctrl_width;     /* Handshake Cell 1 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc1_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC1_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC1_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc2_ctrl */
/* => Handshake Cell 2 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc2_ctrl            0x00000088U
#define Adr_NX51_handshake_ctrl_handshake_hsc2_ctrl 0x1018C388U
#define Adr_NX51_handshake_hsc2_ctrl                0x1018C388U
#define DFLT_VAL_NX51_handshake_hsc2_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc2_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc2_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc2_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc2_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc2_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc2_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc2_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc2_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc2_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc2_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc2_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc2_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc2_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc2_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC2_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc2_ctrl_mode;      /* Handshake Cell 2 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc2_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc2_ctrl_width;     /* Handshake Cell 2 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc2_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC2_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC2_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC2_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc3_ctrl */
/* => Handshake Cell 3 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc3_ctrl            0x0000008CU
#define Adr_NX51_handshake_ctrl_handshake_hsc3_ctrl 0x1018C38CU
#define Adr_NX51_handshake_hsc3_ctrl                0x1018C38CU
#define DFLT_VAL_NX51_handshake_hsc3_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc3_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc3_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc3_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc3_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc3_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc3_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc3_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc3_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc3_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc3_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc3_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc3_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc3_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc3_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC3_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc3_ctrl_mode;      /* Handshake Cell 3 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc3_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc3_ctrl_width;     /* Handshake Cell 3 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc3_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC3_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC3_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC3_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc4_ctrl */
/* => Handshake Cell 4 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc4_ctrl            0x00000090U
#define Adr_NX51_handshake_ctrl_handshake_hsc4_ctrl 0x1018C390U
#define Adr_NX51_handshake_hsc4_ctrl                0x1018C390U
#define DFLT_VAL_NX51_handshake_hsc4_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc4_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc4_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc4_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc4_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc4_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc4_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc4_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc4_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc4_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc4_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc4_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc4_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc4_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc4_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC4_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc4_ctrl_mode;      /* Handshake Cell 4 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc4_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc4_ctrl_width;     /* Handshake Cell 4 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc4_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC4_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC4_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC4_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc5_ctrl */
/* => Handshake Cell 5 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc5_ctrl            0x00000094U
#define Adr_NX51_handshake_ctrl_handshake_hsc5_ctrl 0x1018C394U
#define Adr_NX51_handshake_hsc5_ctrl                0x1018C394U
#define DFLT_VAL_NX51_handshake_hsc5_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc5_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc5_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc5_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc5_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc5_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc5_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc5_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc5_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc5_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc5_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc5_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc5_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc5_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc5_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC5_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc5_ctrl_mode;      /* Handshake Cell 5 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc5_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc5_ctrl_width;     /* Handshake Cell 5 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc5_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC5_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC5_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC5_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc6_ctrl */
/* => Handshake Cell 6 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc6_ctrl            0x00000098U
#define Adr_NX51_handshake_ctrl_handshake_hsc6_ctrl 0x1018C398U
#define Adr_NX51_handshake_hsc6_ctrl                0x1018C398U
#define DFLT_VAL_NX51_handshake_hsc6_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc6_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc6_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc6_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc6_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc6_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc6_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc6_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc6_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc6_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc6_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc6_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc6_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc6_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc6_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC6_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc6_ctrl_mode;      /* Handshake Cell 6 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc6_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc6_ctrl_width;     /* Handshake Cell 6 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc6_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC6_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC6_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC6_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc7_ctrl */
/* => Handshake Cell 7 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc7_ctrl            0x0000009CU
#define Adr_NX51_handshake_ctrl_handshake_hsc7_ctrl 0x1018C39CU
#define Adr_NX51_handshake_hsc7_ctrl                0x1018C39CU
#define DFLT_VAL_NX51_handshake_hsc7_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc7_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc7_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc7_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc7_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc7_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc7_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc7_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc7_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc7_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc7_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc7_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc7_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc7_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc7_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC7_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc7_ctrl_mode;      /* Handshake Cell 7 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc7_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc7_ctrl_width;     /* Handshake Cell 7 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc7_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC7_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC7_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC7_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc8_ctrl */
/* => Handshake Cell 8 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc8_ctrl            0x000000A0U
#define Adr_NX51_handshake_ctrl_handshake_hsc8_ctrl 0x1018C3A0U
#define Adr_NX51_handshake_hsc8_ctrl                0x1018C3A0U
#define DFLT_VAL_NX51_handshake_hsc8_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc8_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc8_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc8_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc8_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc8_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc8_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc8_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc8_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc8_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc8_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc8_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc8_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc8_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc8_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC8_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc8_ctrl_mode;      /* Handshake Cell 8 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc8_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc8_ctrl_width;     /* Handshake Cell 8 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc8_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC8_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC8_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC8_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc9_ctrl */
/* => Handshake Cell 9 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc9_ctrl            0x000000A4U
#define Adr_NX51_handshake_ctrl_handshake_hsc9_ctrl 0x1018C3A4U
#define Adr_NX51_handshake_hsc9_ctrl                0x1018C3A4U
#define DFLT_VAL_NX51_handshake_hsc9_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc9_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc9_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc9_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc9_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc9_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc9_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc9_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc9_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc9_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc9_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc9_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc9_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc9_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc9_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC9_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc9_ctrl_mode;      /* Handshake Cell 9 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc9_ctrl_reserved1; /* reserved                                                        */
	unsigned int width     : BFW_NX51_handshake_hsc9_ctrl_width;     /* Handshake Cell 9 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc9_ctrl_reserved2; /* reserved                                                        */
} NX51_HANDSHAKE_HSC9_CTRL_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_HANDSHAKE_HSC9_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC9_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc10_ctrl */
/* => Handshake Cell 10 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc10_ctrl            0x000000A8U
#define Adr_NX51_handshake_ctrl_handshake_hsc10_ctrl 0x1018C3A8U
#define Adr_NX51_handshake_hsc10_ctrl                0x1018C3A8U
#define DFLT_VAL_NX51_handshake_hsc10_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc10_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc10_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc10_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc10_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc10_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc10_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc10_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc10_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc10_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc10_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc10_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc10_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc10_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc10_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC10_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc10_ctrl_mode;      /* Handshake Cell 10 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc10_ctrl_reserved1; /* reserved                                                         */
	unsigned int width     : BFW_NX51_handshake_hsc10_ctrl_width;     /* Handshake Cell 10 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc10_ctrl_reserved2; /* reserved                                                         */
} NX51_HANDSHAKE_HSC10_CTRL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_HANDSHAKE_HSC10_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC10_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc11_ctrl */
/* => Handshake Cell 11 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc11_ctrl            0x000000ACU
#define Adr_NX51_handshake_ctrl_handshake_hsc11_ctrl 0x1018C3ACU
#define Adr_NX51_handshake_hsc11_ctrl                0x1018C3ACU
#define DFLT_VAL_NX51_handshake_hsc11_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc11_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc11_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc11_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc11_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc11_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc11_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc11_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc11_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc11_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc11_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc11_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc11_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc11_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc11_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC11_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc11_ctrl_mode;      /* Handshake Cell 11 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc11_ctrl_reserved1; /* reserved                                                         */
	unsigned int width     : BFW_NX51_handshake_hsc11_ctrl_width;     /* Handshake Cell 11 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc11_ctrl_reserved2; /* reserved                                                         */
} NX51_HANDSHAKE_HSC11_CTRL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_HANDSHAKE_HSC11_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC11_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc12_ctrl */
/* => Handshake Cell 12 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc12_ctrl            0x000000B0U
#define Adr_NX51_handshake_ctrl_handshake_hsc12_ctrl 0x1018C3B0U
#define Adr_NX51_handshake_hsc12_ctrl                0x1018C3B0U
#define DFLT_VAL_NX51_handshake_hsc12_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc12_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc12_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc12_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc12_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc12_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc12_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc12_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc12_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc12_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc12_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc12_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc12_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc12_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc12_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC12_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc12_ctrl_mode;      /* Handshake Cell 12 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc12_ctrl_reserved1; /* reserved                                                         */
	unsigned int width     : BFW_NX51_handshake_hsc12_ctrl_width;     /* Handshake Cell 12 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc12_ctrl_reserved2; /* reserved                                                         */
} NX51_HANDSHAKE_HSC12_CTRL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_HANDSHAKE_HSC12_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC12_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc13_ctrl */
/* => Handshake Cell 13 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc13_ctrl            0x000000B4U
#define Adr_NX51_handshake_ctrl_handshake_hsc13_ctrl 0x1018C3B4U
#define Adr_NX51_handshake_hsc13_ctrl                0x1018C3B4U
#define DFLT_VAL_NX51_handshake_hsc13_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc13_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc13_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc13_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc13_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc13_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc13_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc13_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc13_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc13_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc13_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc13_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc13_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc13_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc13_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC13_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc13_ctrl_mode;      /* Handshake Cell 13 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc13_ctrl_reserved1; /* reserved                                                         */
	unsigned int width     : BFW_NX51_handshake_hsc13_ctrl_width;     /* Handshake Cell 13 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc13_ctrl_reserved2; /* reserved                                                         */
} NX51_HANDSHAKE_HSC13_CTRL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_HANDSHAKE_HSC13_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC13_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc14_ctrl */
/* => Handshake Cell 14 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc14_ctrl            0x000000B8U
#define Adr_NX51_handshake_ctrl_handshake_hsc14_ctrl 0x1018C3B8U
#define Adr_NX51_handshake_hsc14_ctrl                0x1018C3B8U
#define DFLT_VAL_NX51_handshake_hsc14_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc14_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc14_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc14_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc14_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc14_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc14_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc14_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc14_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc14_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc14_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc14_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc14_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc14_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc14_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC14_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc14_ctrl_mode;      /* Handshake Cell 14 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc14_ctrl_reserved1; /* reserved                                                         */
	unsigned int width     : BFW_NX51_handshake_hsc14_ctrl_width;     /* Handshake Cell 14 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc14_ctrl_reserved2; /* reserved                                                         */
} NX51_HANDSHAKE_HSC14_CTRL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_HANDSHAKE_HSC14_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC14_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_hsc15_ctrl */
/* => Handshake Cell 15 Control Register. */
/*    For detailed information view handshake_hsc0_ctrl documentation. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_hsc15_ctrl            0x000000BCU
#define Adr_NX51_handshake_ctrl_handshake_hsc15_ctrl 0x1018C3BCU
#define Adr_NX51_handshake_hsc15_ctrl                0x1018C3BCU
#define DFLT_VAL_NX51_handshake_hsc15_ctrl           0x00000000U

#define MSK_NX51_handshake_hsc15_ctrl_mode          0x00000003U
#define SRT_NX51_handshake_hsc15_ctrl_mode          0
#define DFLT_VAL_NX51_handshake_hsc15_ctrl_mode     0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc15_ctrl_mode  0x00000000U
#define MSK_NX51_handshake_hsc15_ctrl_width         0x00000010U
#define SRT_NX51_handshake_hsc15_ctrl_width         4
#define DFLT_VAL_NX51_handshake_hsc15_ctrl_width    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_hsc15_ctrl_width 0x00000000U

/* all used bits of 'NX51_handshake_hsc15_ctrl': */
#define MSK_USED_BITS_NX51_handshake_hsc15_ctrl 0x00000013U

enum {
	BFW_NX51_handshake_hsc15_ctrl_mode      = 2,  /* [1:0] */
	BFW_NX51_handshake_hsc15_ctrl_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_hsc15_ctrl_width     = 1,  /* [4] */
	BFW_NX51_handshake_hsc15_ctrl_reserved2 = 27  /* [31:5] */
};

typedef struct NX51_HANDSHAKE_HSC15_CTRL_BIT_Ttag {
	unsigned int mode      : BFW_NX51_handshake_hsc15_ctrl_mode;      /* Handshake Cell 15 Mode (view handshake_hsc0_ctrl documentation). */
	unsigned int reserved1 : BFW_NX51_handshake_hsc15_ctrl_reserved1; /* reserved                                                         */
	unsigned int width     : BFW_NX51_handshake_hsc15_ctrl_width;     /* Handshake Cell 15 Width.                                         */
	unsigned int reserved2 : BFW_NX51_handshake_hsc15_ctrl_reserved2; /* reserved                                                         */
} NX51_HANDSHAKE_HSC15_CTRL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_HANDSHAKE_HSC15_CTRL_BIT_T bf;
} NX51_HANDSHAKE_HSC15_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man0_ctrl */
/* => Handshake Triple Buffer Manager 0 Control register. */
/*    Handshake Triple Buffer Manager 0 can be associated to Handshake Cell 2 HCF_PD_OUT_CMD/NCF_PD_OUT_ACK-bits */
/*    for Host controlled DPM output data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man0_ctrl            0x000000C0U
#define Adr_NX51_handshake_ctrl_handshake_buf_man0_ctrl 0x1018C3C0U
#define Adr_NX51_handshake_buf_man0_ctrl                0x1018C3C0U
#define DFLT_VAL_NX51_handshake_buf_man0_ctrl           0x00000000U

#define MSK_NX51_handshake_buf_man0_ctrl_hsc2_auto_PD_OUT         0x00000001U
#define SRT_NX51_handshake_buf_man0_ctrl_hsc2_auto_PD_OUT         0
#define DFLT_VAL_NX51_handshake_buf_man0_ctrl_hsc2_auto_PD_OUT    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man0_ctrl_hsc2_auto_PD_OUT 0x00000000U
#define MSK_NX51_handshake_buf_man0_ctrl_reset                    0x00000002U
#define SRT_NX51_handshake_buf_man0_ctrl_reset                    1
#define DFLT_VAL_NX51_handshake_buf_man0_ctrl_reset               0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man0_ctrl_reset            0x00000000U
#define MSK_NX51_handshake_buf_man0_ctrl_buf_dam_cfg              0x0000000cU
#define SRT_NX51_handshake_buf_man0_ctrl_buf_dam_cfg              2
#define DFLT_VAL_NX51_handshake_buf_man0_ctrl_buf_dam_cfg         0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man0_ctrl_buf_dam_cfg      0x00000000U

/* all used bits of 'NX51_handshake_buf_man0_ctrl': */
#define MSK_USED_BITS_NX51_handshake_buf_man0_ctrl 0x0000000fU

enum {
	BFW_NX51_handshake_buf_man0_ctrl_hsc2_auto_PD_OUT = 1,  /* [0] */
	BFW_NX51_handshake_buf_man0_ctrl_reset            = 1,  /* [1] */
	BFW_NX51_handshake_buf_man0_ctrl_buf_dam_cfg      = 2,  /* [3:2] */
	BFW_NX51_handshake_buf_man0_ctrl_reserved1        = 28  /* [31:4] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN0_CTRL_BIT_Ttag {
	unsigned int hsc2_auto_PD_OUT : BFW_NX51_handshake_buf_man0_ctrl_hsc2_auto_PD_OUT; /* Handshake Cell 2 Handshake Triple Buffer Manager 0 action enable for HCF_PD_OUT_CMD/NCF_PD_OUT_ACK.         */
	                                                                                   /* If this bit is set, Triple Buffer Manager 0 is used for Host controlled DPM output                          */
	                                                                                   /* data handling and DPM auto buffer window change. NCF_PD_OUT_ACK-bit of Handshake Cell 2                     */
	                                                                                   /* is then controlled by Hardware and read-only for software.                                                  */
	                                                                                   /* The following steps will be performed automatically by hardware after                                       */
	                                                                                   /* buffer change was requested by host:                                                                        */
	                                                                                   /* 1. Current host write buffer is released and a new host write buffer is requested.                          */
	                                                                                   /*    DPM window mapping is changed according to new host write buffer (must be enabled in DPM address area).  */
	                                                                                   /* 2. Handshake Cell 2 NCF_PD_OUT_ACK-bit is changed to state of Handshake Cell 2 HCF_PD_OUT_CMD-bit.          */
	                                                                                   /*    to confirm new valid write buffer for host.                                                              */
	                                                                                   /* Buffer change request event triggering this process:                                                        */
	                                                                                   /*    Host writes Handshake Cell 2 and host written data HCF_PD_OUT_CMD-bit 6                                  */
	                                                                                   /*    is not equal to current Handshake Cell 2 NCF_PD_OUT_ACK-bit (netX writable bit).                         */
	                                                                                   /* Note:                                                                                                       */
	                                                                                   /*    Location of HCF_PD_OUT_CMD/NCF_PD_OUT_ACK bits inside the 32 bit Handshake DWord depends on programmed   */
	                                                                                   /*    width of Handshake Cell 2 ('adr_handshake_hsc2_ctrl.width'):                                             */
	                                                                                   /*    - 16 bit handshake width of Handshake Cell 2:                                                            */
	                                                                                   /*         HCF_PD_OUT_CMD: located in bit 22 (6+16) of HS DWord.                                               */
	                                                                                   /*         HCF_PD_OUT_ACK: located in bit 6 (6+0) of HS DWord.                                                 */
	                                                                                   /*    - 8 bit handshake width of Handshake Cell 2:                                                             */
	                                                                                   /*         HCF_PD_OUT_CMD: located in bit 30 (6+24) of HS DWord.                                               */
	                                                                                   /*         HCF_PD_OUT_ACK: located in bit 22 (6+16) of HS DWord.                                               */
	                                                                                   /* Note:                                                                                                       */
	                                                                                   /*    IRQ generation of Handshake Cell 2 for ARM and xPIC is not affected by this bit. ARM or xPIC receive IRQ */
	                                                                                   /*    when DPM/host requests output buffer change and Handshake Cell 2 IRQ is enabled for DPM and ARM or xPIC  */
	                                                                                   /*    (handshake_hsc2_ctrl.mode is '01' or '10').                                                              */
	                                                                                   /*    DPM/host receives IRQ after buffer change is performed by Handshake Triple Buffer Manager 1              */
	                                                                                   /*    if Handshake Cell 2 IRQ is enabled for DPM (handshake_hsc2_ctrl.mode is '01' or '10').                   */
	unsigned int reset            : BFW_NX51_handshake_buf_man0_ctrl_reset;            /* Handshake Triple Buffer Manager 0 FSM Reset.                                                                */
	                                                                                   /* Note:                                                                                                       */
	                                                                                   /*    This bit is cleared automatically (it is writable but can also be changed by hardware).                  */
	unsigned int buf_dam_cfg      : BFW_NX51_handshake_buf_man0_ctrl_buf_dam_cfg;      /* Handshake Triple Buffer Manager 0 DPM Address Mapping Configuration.                                        */
	                                                                                   /* This bit field can be used to select DPM address mapping value manually or controlled by current            */
	                                                                                   /* buffer state of Handshake Triple Buffer Manager 0.                                                          */
	                                                                                   /* Current buffer state of Handshake Triple Buffer Manager 0 can be determined and controlled                  */
	                                                                                   /* in 'handshake_buf_man0_status_ctrl_netx' and 'handshake_buf_man0_status_ctrl_host' register.                */
	                                                                                   /* Coding:                                                                                                     */
	                                                                                   /*  00 : Use mapping value programmed in DPM configuration registers (i.e. buffer 0)                           */
	                                                                                   /*  01 : Use alternative mapping 1 value programmed in 'handshake_buf_man0_win_map.win_map_buf1'.              */
	                                                                                   /*  10 : Use alternative mapping 2 value programmed in 'handshake_buf_man0_win_map.win_map_buf2'.              */
	                                                                                   /*  11 : Generate window mapping by current buffer state of Handshake Triple Buffer Manager 0.                 */
	                                                                                   /* Note:                                                                                                       */
	                                                                                   /*     Settings 00..10 can be used to control Window mapping manually.                                         */
	unsigned int reserved1        : BFW_NX51_handshake_buf_man0_ctrl_reserved1;        /* reserved                                                                                                    */
} NX51_HANDSHAKE_BUF_MAN0_CTRL_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_HANDSHAKE_BUF_MAN0_CTRL_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man0_status_ctrl_netx */
/* => Handshake Triple Buffer Manager 0 netX Status and Control Register. */
/*    On read this register provides current status of netX side of Handshake Triple Buffer Manager 0. Buffer */
/*    requests can be done by writing this register. */
/*    Handshake Triple Buffer Manager 0 can be associated to Handshake Cell 2 Bits 6 and 22 (16+6) */
/*    for Host controlled DPM output data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man0_status_ctrl_netx            0x000000C4U
#define Adr_NX51_handshake_ctrl_handshake_buf_man0_status_ctrl_netx 0x1018C3C4U
#define Adr_NX51_handshake_buf_man0_status_ctrl_netx                0x1018C3C4U
#define DFLT_VAL_NX51_handshake_buf_man0_status_ctrl_netx           0x00000003U

#define MSK_NX51_handshake_buf_man0_status_ctrl_netx_buf_ro         0x00000003U
#define SRT_NX51_handshake_buf_man0_status_ctrl_netx_buf_ro         0
#define DFLT_VAL_NX51_handshake_buf_man0_status_ctrl_netx_buf_ro    0x00000003U
#define DFLT_BF_VAL_NX51_handshake_buf_man0_status_ctrl_netx_buf_ro 0x00000003U
#define MSK_NX51_handshake_buf_man0_status_ctrl_netx_cmd            0x00000030U
#define SRT_NX51_handshake_buf_man0_status_ctrl_netx_cmd            4
#define DFLT_VAL_NX51_handshake_buf_man0_status_ctrl_netx_cmd       0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man0_status_ctrl_netx_cmd    0x00000000U

/* all used bits of 'NX51_handshake_buf_man0_status_ctrl_netx': */
#define MSK_USED_BITS_NX51_handshake_buf_man0_status_ctrl_netx 0x00000033U

enum {
	BFW_NX51_handshake_buf_man0_status_ctrl_netx_buf_ro    = 2,  /* [1:0] */
	BFW_NX51_handshake_buf_man0_status_ctrl_netx_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_buf_man0_status_ctrl_netx_cmd       = 2,  /* [5:4] */
	BFW_NX51_handshake_buf_man0_status_ctrl_netx_reserved2 = 26  /* [31:6] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_NETX_BIT_Ttag {
	unsigned int buf_ro    : BFW_NX51_handshake_buf_man0_status_ctrl_netx_buf_ro;    /* Handshake Triple Buffer Manager 0 valid netX Buffer.                    */
	                                                                                 /* Coding:                                                                 */
	                                                                                 /*  00 : Buffer 0 valid.                                                   */
	                                                                                 /*  01 : Buffer 1 valid.                                                   */
	                                                                                 /*  10 : Buffer 2 valid.                                                   */
	                                                                                 /*  11 : No buffer is valid.                                               */
	                                                                                 /* Note:                                                                   */
	                                                                                 /*    This bit field is read only accessible.                              */
	unsigned int reserved1 : BFW_NX51_handshake_buf_man0_status_ctrl_netx_reserved1; /* reserved                                                                */
	unsigned int cmd       : BFW_NX51_handshake_buf_man0_status_ctrl_netx_cmd;       /* Handshake Triple Buffer Manager 0 Command for netX buffer.              */
	                                                                                 /* Command coding:                                                         */
	                                                                                 /*  00 : nop/idle                                                          */
	                                                                                 /*  01 : request new read buffer                                           */
	                                                                                 /*  10 : request new write buffer                                          */
	                                                                                 /*  11 : release current buffer                                            */
	                                                                                 /* Note:                                                                   */
	                                                                                 /*    This bit field will be reset to nop/idle automatically after command */
	                                                                                 /*    was performed (it is writable but can also be changed by hardware).  */
	unsigned int reserved2 : BFW_NX51_handshake_buf_man0_status_ctrl_netx_reserved2; /* reserved                                                                */
} NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_NETX_BIT_T;

typedef union {
	unsigned int                                   val;
	NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_NETX_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_NETX_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man0_status_ctrl_host */
/* => Handshake Triple Buffer Manager 0 Host Status register. */
/*    On read this register provides current status of host side of Handshake Triple Buffer Manager 0. Buffer */
/*    requests can be done by writing this register. */
/*    Handshake Triple Buffer Manager 0 can be associated to Handshake Cell 2 Bits 6 and 22 (16+6) */
/*    for Host controlled DPM output data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man0_status_ctrl_host            0x000000C8U
#define Adr_NX51_handshake_ctrl_handshake_buf_man0_status_ctrl_host 0x1018C3C8U
#define Adr_NX51_handshake_buf_man0_status_ctrl_host                0x1018C3C8U

#define MSK_NX51_handshake_buf_man0_status_ctrl_host_buf_ro 0x00000003U
#define SRT_NX51_handshake_buf_man0_status_ctrl_host_buf_ro 0
#define MSK_NX51_handshake_buf_man0_status_ctrl_host_cmd    0x00000030U
#define SRT_NX51_handshake_buf_man0_status_ctrl_host_cmd    4

/* all used bits of 'NX51_handshake_buf_man0_status_ctrl_host': */
#define MSK_USED_BITS_NX51_handshake_buf_man0_status_ctrl_host 0x00000033U

enum {
	BFW_NX51_handshake_buf_man0_status_ctrl_host_buf_ro    = 2,  /* [1:0] */
	BFW_NX51_handshake_buf_man0_status_ctrl_host_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_buf_man0_status_ctrl_host_cmd       = 2,  /* [5:4] */
	BFW_NX51_handshake_buf_man0_status_ctrl_host_reserved2 = 26  /* [31:6] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_HOST_BIT_Ttag {
	unsigned int buf_ro    : BFW_NX51_handshake_buf_man0_status_ctrl_host_buf_ro;    /* Handshake Triple Buffer Manager 0 valid Host Buffer.                                                                                      */
	                                                                                 /* If DPM auto buffer window change for host controlled DPM input data handling is enabled,                                                  */
	                                                                                 /* this bit field defines which mapping value is used.                                                                                       */
	                                                                                 /* Coding:                                                                                                                                   */
	                                                                                 /*  00 : Buffer 0 valid (mapping value programmed inside DPM module is used if auto window mapping is enabled).                              */
	                                                                                 /*  01 : Buffer 1 valid (mapping value programmed from 'handshake_buf_man1_win_map.win_map_buf1' is used if auto window mapping is enabled). */
	                                                                                 /*  10 : Buffer 2 valid (mapping value programmed from 'handshake_buf_man1_win_map.win_map_buf2' is used if auto window mapping is enabled). */
	                                                                                 /*  11 : No buffer is valid (mapping value programmed inside DPM module is used if auto window mapping is enabled).                          */
	                                                                                 /* Note:                                                                                                                                     */
	                                                                                 /*    This bit field is read only accessible.                                                                                                */
	unsigned int reserved1 : BFW_NX51_handshake_buf_man0_status_ctrl_host_reserved1; /* reserved                                                                                                                                  */
	unsigned int cmd       : BFW_NX51_handshake_buf_man0_status_ctrl_host_cmd;       /* Handshake Triple Buffer Manager 1 Command for host buffer.                                                                                */
	                                                                                 /* Command coding:                                                                                                                           */
	                                                                                 /*  00 : nop/idle                                                                                                                            */
	                                                                                 /*  01 : request new read buffer                                                                                                             */
	                                                                                 /*  10 : request new write buffer                                                                                                            */
	                                                                                 /*  11 : release current buffer                                                                                                              */
	                                                                                 /* Note:                                                                                                                                     */
	                                                                                 /*    This bit field will be reset to nop/idle automatically after command                                                                   */
	                                                                                 /*    was performed (it is writable but can also be changed by hardware).                                                                    */
	unsigned int reserved2 : BFW_NX51_handshake_buf_man0_status_ctrl_host_reserved2; /* reserved                                                                                                                                  */
} NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_HOST_BIT_T;

typedef union {
	unsigned int                                   val;
	NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_HOST_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN0_STATUS_CTRL_HOST_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man0_win_map */
/* => DPM Window Address Map Alternative Configuration Register for Handshake Triple Buffer Manager 0. */
/*    Handshake Triple Buffer Manager 0 can be associated to Handshake Cell 2 Bits 6 and 22 (16+6) */
/*    for Host controlled DPM output data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/*      If DPM auto buffer window change is enabled, buffer 0 related DPM window mapping is window mapping programmed */
/*      for related window in DPM address are. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man0_win_map            0x000000CCU
#define Adr_NX51_handshake_ctrl_handshake_buf_man0_win_map 0x1018C3CCU
#define Adr_NX51_handshake_buf_man0_win_map                0x1018C3CCU
#define DFLT_VAL_NX51_handshake_buf_man0_win_map           0x00000000U

#define MSK_NX51_handshake_buf_man0_win_map_win_map_buf1         0x00001fffU
#define SRT_NX51_handshake_buf_man0_win_map_win_map_buf1         0
#define DFLT_VAL_NX51_handshake_buf_man0_win_map_win_map_buf1    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man0_win_map_win_map_buf1 0x00000000U
#define MSK_NX51_handshake_buf_man0_win_map_win_map_buf2         0x1fff0000U
#define SRT_NX51_handshake_buf_man0_win_map_win_map_buf2         16
#define DFLT_VAL_NX51_handshake_buf_man0_win_map_win_map_buf2    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man0_win_map_win_map_buf2 0x00000000U

/* all used bits of 'NX51_handshake_buf_man0_win_map': */
#define MSK_USED_BITS_NX51_handshake_buf_man0_win_map 0x1fff1fffU

enum {
	BFW_NX51_handshake_buf_man0_win_map_win_map_buf1 = 13, /* [12:0] */
	BFW_NX51_handshake_buf_man0_win_map_reserved1    = 3,  /* [15:13] */
	BFW_NX51_handshake_buf_man0_win_map_win_map_buf2 = 13, /* [28:16] */
	BFW_NX51_handshake_buf_man0_win_map_reserved2    = 3   /* [31:29] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN0_WIN_MAP_BIT_Ttag {
	unsigned int win_map_buf1 : BFW_NX51_handshake_buf_man0_win_map_win_map_buf1; /* Buffer 1 of Handshake Triple Buffer Manager 0 Alternative DPM Window Address Map. */
	                                                                              /* This win_map entry is used if DPM auto buffer window                              */
	                                                                              /* change is enabled and if Buffer 1 of Handshake Triple Buffer Manager 0 is valid.  */
	unsigned int reserved1    : BFW_NX51_handshake_buf_man0_win_map_reserved1;    /* reserved                                                                          */
	unsigned int win_map_buf2 : BFW_NX51_handshake_buf_man0_win_map_win_map_buf2; /* Buffer 2 of Handshake Triple Buffer Manager 0 Alternative DPM Window Address Map. */
	                                                                              /* This win_map entry is used if DPM auto buffer window                              */
	                                                                              /* change is enabled and if Buffer 2 of Handshake Triple Buffer Manager 0 is valid.  */
	unsigned int reserved2    : BFW_NX51_handshake_buf_man0_win_map_reserved2;    /* reserved                                                                          */
} NX51_HANDSHAKE_BUF_MAN0_WIN_MAP_BIT_T;

typedef union {
	unsigned int                          val;
	NX51_HANDSHAKE_BUF_MAN0_WIN_MAP_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN0_WIN_MAP_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man1_ctrl */
/* => Handshake Triple Buffer Manager 1 Control register. */
/*    Handshake Triple Buffer Manager 1 can be associated to Handshake Cell 2 HCF_PD_IN_CMD/NCF_PD_IN_ACK-bits */
/*    for Host controlled DPM input data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man1_ctrl            0x000000D0U
#define Adr_NX51_handshake_ctrl_handshake_buf_man1_ctrl 0x1018C3D0U
#define Adr_NX51_handshake_buf_man1_ctrl                0x1018C3D0U
#define DFLT_VAL_NX51_handshake_buf_man1_ctrl           0x00000000U

#define MSK_NX51_handshake_buf_man1_ctrl_hsc2_auto_PD_IN         0x00000001U
#define SRT_NX51_handshake_buf_man1_ctrl_hsc2_auto_PD_IN         0
#define DFLT_VAL_NX51_handshake_buf_man1_ctrl_hsc2_auto_PD_IN    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man1_ctrl_hsc2_auto_PD_IN 0x00000000U
#define MSK_NX51_handshake_buf_man1_ctrl_reset                   0x00000002U
#define SRT_NX51_handshake_buf_man1_ctrl_reset                   1
#define DFLT_VAL_NX51_handshake_buf_man1_ctrl_reset              0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man1_ctrl_reset           0x00000000U
#define MSK_NX51_handshake_buf_man1_ctrl_buf_dam_cfg             0x0000000cU
#define SRT_NX51_handshake_buf_man1_ctrl_buf_dam_cfg             2
#define DFLT_VAL_NX51_handshake_buf_man1_ctrl_buf_dam_cfg        0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man1_ctrl_buf_dam_cfg     0x00000000U

/* all used bits of 'NX51_handshake_buf_man1_ctrl': */
#define MSK_USED_BITS_NX51_handshake_buf_man1_ctrl 0x0000000fU

enum {
	BFW_NX51_handshake_buf_man1_ctrl_hsc2_auto_PD_IN = 1,  /* [0] */
	BFW_NX51_handshake_buf_man1_ctrl_reset           = 1,  /* [1] */
	BFW_NX51_handshake_buf_man1_ctrl_buf_dam_cfg     = 2,  /* [3:2] */
	BFW_NX51_handshake_buf_man1_ctrl_reserved1       = 28  /* [31:4] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN1_CTRL_BIT_Ttag {
	unsigned int hsc2_auto_PD_IN : BFW_NX51_handshake_buf_man1_ctrl_hsc2_auto_PD_IN; /* Handshake Cell 2 Handshake Triple Buffer Manager 1 action enable for HCF_PD_IN_CMD/NCF_PD_IN_ACK.           */
	                                                                                 /* If this bit is set, Triple Buffer Manager 1 is used for Host controlled DPM input                           */
	                                                                                 /* data handling and DPM auto buffer window change. NCF_PD_IN_ACK-bit of Handshake Cell 2                      */
	                                                                                 /* is then controlled by Hardware and read-only for software.                                                  */
	                                                                                 /* The following steps will be performed automatically by hardware after                                       */
	                                                                                 /* buffer change was requested by host:                                                                        */
	                                                                                 /* 1. New read buffer (last ARM written buffer) is requested for host. DPM window                              */
	                                                                                 /*    mapping is changed according to new host read buffer (must be enabled in DPM address area).              */
	                                                                                 /* 2. Handshake Cell 2 NCF_PD_IN_ACK-bit is changed to state of Handshake Cell 2 HCF_PD_IN_CMD-bit             */
	                                                                                 /*    to confirm new valid read data for host.                                                                 */
	                                                                                 /* Buffer change request event triggering this process:                                                        */
	                                                                                 /*    Host writes Handshake Cell 2 and host written data HCF_PD_IN_CMD-bit                                     */
	                                                                                 /*    is not equal to current Handshake Cell 2 HCF_PD_IN_ACK-bit.                                              */
	                                                                                 /* Note:                                                                                                       */
	                                                                                 /*    Location of HCF_PD_IN_CMD/NCF_PD_IN_ACK bits inside the 32 bit Handshake DWord depends on programmed     */
	                                                                                 /*    width of Handshake Cell 2 ('adr_handshake_hsc2_ctrl.width'):                                             */
	                                                                                 /*    - 16 bit handshake width of Handshake Cell 2:                                                            */
	                                                                                 /*         HCF_PD_IN_CMD: located in bit 23 (7+16) of HS DWord.                                                */
	                                                                                 /*         HCF_PD_IN_ACK: located in bit 7 (7+0) of HS DWord.                                                  */
	                                                                                 /*    - 8 bit handshake width of Handshake Cell 2:                                                             */
	                                                                                 /*         HCF_PD_IN_CMD: located in bit 31 (7+24) of HS DWord.                                                */
	                                                                                 /*         HCF_PD_IN_ACK: located in bit 23 (7+16) of HS DWord.                                                */
	                                                                                 /* Note:                                                                                                       */
	                                                                                 /*    IRQ generation of Handshake Cell 2 for ARM and xPIC is not affected by this bit. ARM or xPIC receive IRQ */
	                                                                                 /*    when DPM/host requests input buffer change and Handshake Cell 2 IRQ is enabled for DPM and ARM or xPIC   */
	                                                                                 /*    (handshake_hsc2_ctrl.mode is '01' or '10').                                                              */
	                                                                                 /*    DPM/host receives IRQ after buffer change is performed by Handshake Triple Buffer Manager 1              */
	                                                                                 /*    if Handshake Cell 2 IRQ is enabled for DPM (handshake_hsc2_ctrl.mode is '01' or '10').                   */
	unsigned int reset           : BFW_NX51_handshake_buf_man1_ctrl_reset;           /* Handshake Triple Buffer Manager 1 FSM Reset.                                                                */
	                                                                                 /* Note:                                                                                                       */
	                                                                                 /*    This bit is cleared automatically (it is writable but can also be changed by hardware).                  */
	unsigned int buf_dam_cfg     : BFW_NX51_handshake_buf_man1_ctrl_buf_dam_cfg;     /* Handshake Triple Buffer Manager 1 DPM Address Mapping Configuration.                                        */
	                                                                                 /* This bit field can be used to select DPM address mapping value manually or controlled by current            */
	                                                                                 /* buffer state of Handshake Triple Buffer Manager 1.                                                          */
	                                                                                 /* Current buffer state of Handshake Triple Buffer Manager 1 can be determined and controlled                  */
	                                                                                 /* in 'handshake_buf_man1_status_ctrl_netx' and 'handshake_buf_man1_status_ctrl_host' register.                */
	                                                                                 /* Coding:                                                                                                     */
	                                                                                 /*  00 : Use mapping value programmed in DPM configuration registers (i.e. buffer 0)                           */
	                                                                                 /*  01 : Use alternative mapping 1 value programmed in 'handshake_buf_man1_win_map.win_map_buf1'.              */
	                                                                                 /*  10 : Use alternative mapping 2 value programmed in 'handshake_buf_man1_win_map.win_map_buf2'.              */
	                                                                                 /*  11 : Generate window mapping by current buffer state of Handshake Triple Buffer Manager 1.                 */
	                                                                                 /* Note:                                                                                                       */
	                                                                                 /*     Settings 00..10 can be used to control Window mapping manually.                                         */
	unsigned int reserved1       : BFW_NX51_handshake_buf_man1_ctrl_reserved1;       /* reserved                                                                                                    */
} NX51_HANDSHAKE_BUF_MAN1_CTRL_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_HANDSHAKE_BUF_MAN1_CTRL_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man1_status_ctrl_netx */
/* => Handshake Triple Buffer Manager 1 netX Status and Control Register. */
/*    On read this register provides current status of netX side of Handshake Triple Buffer Manager 1. Buffer */
/*    requests can be done by writing this register. */
/*    Handshake Triple Buffer Manager 1 can be associated to Handshake Cell 2 Bits 6 and 22 (16+6) */
/*    for Host controlled DPM input data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man1_status_ctrl_netx            0x000000D4U
#define Adr_NX51_handshake_ctrl_handshake_buf_man1_status_ctrl_netx 0x1018C3D4U
#define Adr_NX51_handshake_buf_man1_status_ctrl_netx                0x1018C3D4U
#define DFLT_VAL_NX51_handshake_buf_man1_status_ctrl_netx           0x00000003U

#define MSK_NX51_handshake_buf_man1_status_ctrl_netx_buf_ro         0x00000003U
#define SRT_NX51_handshake_buf_man1_status_ctrl_netx_buf_ro         0
#define DFLT_VAL_NX51_handshake_buf_man1_status_ctrl_netx_buf_ro    0x00000003U
#define DFLT_BF_VAL_NX51_handshake_buf_man1_status_ctrl_netx_buf_ro 0x00000003U
#define MSK_NX51_handshake_buf_man1_status_ctrl_netx_cmd            0x00000030U
#define SRT_NX51_handshake_buf_man1_status_ctrl_netx_cmd            4
#define DFLT_VAL_NX51_handshake_buf_man1_status_ctrl_netx_cmd       0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man1_status_ctrl_netx_cmd    0x00000000U

/* all used bits of 'NX51_handshake_buf_man1_status_ctrl_netx': */
#define MSK_USED_BITS_NX51_handshake_buf_man1_status_ctrl_netx 0x00000033U

enum {
	BFW_NX51_handshake_buf_man1_status_ctrl_netx_buf_ro    = 2,  /* [1:0] */
	BFW_NX51_handshake_buf_man1_status_ctrl_netx_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_buf_man1_status_ctrl_netx_cmd       = 2,  /* [5:4] */
	BFW_NX51_handshake_buf_man1_status_ctrl_netx_reserved2 = 26  /* [31:6] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_NETX_BIT_Ttag {
	unsigned int buf_ro    : BFW_NX51_handshake_buf_man1_status_ctrl_netx_buf_ro;    /* Handshake Triple Buffer Manager 1 valid netX Buffer.                    */
	                                                                                 /* Coding:                                                                 */
	                                                                                 /*  00 : Buffer 0 valid.                                                   */
	                                                                                 /*  01 : Buffer 1 valid.                                                   */
	                                                                                 /*  10 : Buffer 2 valid.                                                   */
	                                                                                 /*  11 : No buffer is valid.                                               */
	                                                                                 /* Note:                                                                   */
	                                                                                 /*    This bit field is read only accessible.                              */
	unsigned int reserved1 : BFW_NX51_handshake_buf_man1_status_ctrl_netx_reserved1; /* reserved                                                                */
	unsigned int cmd       : BFW_NX51_handshake_buf_man1_status_ctrl_netx_cmd;       /* Handshake Triple Buffer Manager 1 Command for netX buffer.              */
	                                                                                 /* Command coding:                                                         */
	                                                                                 /*  00 : nop/idle                                                          */
	                                                                                 /*  01 : request new read buffer                                           */
	                                                                                 /*  10 : request new write buffer                                          */
	                                                                                 /*  11 : release current buffer                                            */
	                                                                                 /* Note:                                                                   */
	                                                                                 /*    This bit field will be reset to nop/idle automatically after command */
	                                                                                 /*    was performed (it is writable but can also be changed by hardware).  */
	unsigned int reserved2 : BFW_NX51_handshake_buf_man1_status_ctrl_netx_reserved2; /* reserved                                                                */
} NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_NETX_BIT_T;

typedef union {
	unsigned int                                   val;
	NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_NETX_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_NETX_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man1_status_ctrl_host */
/* => Handshake Triple Buffer Manager 1 Host Status register. */
/*    On read this register provides current status of host side of Handshake Triple Buffer Manager 1. Buffer */
/*    requests can be done by writing this register. */
/*    Handshake Triple Buffer Manager 1 can be associated to Handshake Cell 2 Bits 6 and 22 (16+6) */
/*    for host controlled DPM input data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man1_status_ctrl_host            0x000000D8U
#define Adr_NX51_handshake_ctrl_handshake_buf_man1_status_ctrl_host 0x1018C3D8U
#define Adr_NX51_handshake_buf_man1_status_ctrl_host                0x1018C3D8U

#define MSK_NX51_handshake_buf_man1_status_ctrl_host_buf_ro 0x00000003U
#define SRT_NX51_handshake_buf_man1_status_ctrl_host_buf_ro 0
#define MSK_NX51_handshake_buf_man1_status_ctrl_host_cmd    0x00000030U
#define SRT_NX51_handshake_buf_man1_status_ctrl_host_cmd    4

/* all used bits of 'NX51_handshake_buf_man1_status_ctrl_host': */
#define MSK_USED_BITS_NX51_handshake_buf_man1_status_ctrl_host 0x00000033U

enum {
	BFW_NX51_handshake_buf_man1_status_ctrl_host_buf_ro    = 2,  /* [1:0] */
	BFW_NX51_handshake_buf_man1_status_ctrl_host_reserved1 = 2,  /* [3:2] */
	BFW_NX51_handshake_buf_man1_status_ctrl_host_cmd       = 2,  /* [5:4] */
	BFW_NX51_handshake_buf_man1_status_ctrl_host_reserved2 = 26  /* [31:6] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_HOST_BIT_Ttag {
	unsigned int buf_ro    : BFW_NX51_handshake_buf_man1_status_ctrl_host_buf_ro;    /* Handshake Triple Buffer Manager 1 valid Host Buffer.                                                                                      */
	                                                                                 /* If DPM auto buffer window change for host controlled DPM input data handling is enabled,                                                  */
	                                                                                 /* this bit field defines which mapping value is used.                                                                                       */
	                                                                                 /* Coding:                                                                                                                                   */
	                                                                                 /*  00 : Buffer 0 valid (mapping value programmed inside DPM module is used if auto window mapping is enabled).                              */
	                                                                                 /*  01 : Buffer 1 valid (mapping value programmed from 'handshake_buf_man1_win_map.win_map_buf1' is used if auto window mapping is enabled). */
	                                                                                 /*  10 : Buffer 2 valid (mapping value programmed from 'handshake_buf_man1_win_map.win_map_buf2' is used if auto window mapping is enabled). */
	                                                                                 /*  11 : No buffer is valid (mapping value programmed inside DPM module is used if auto window mapping is enabled).                          */
	                                                                                 /* Note:                                                                                                                                     */
	                                                                                 /*    This bit field is read only accessible.                                                                                                */
	unsigned int reserved1 : BFW_NX51_handshake_buf_man1_status_ctrl_host_reserved1; /* reserved                                                                                                                                  */
	unsigned int cmd       : BFW_NX51_handshake_buf_man1_status_ctrl_host_cmd;       /* Handshake Triple Buffer Manager 1 Command for host buffer.                                                                                */
	                                                                                 /* Command coding:                                                                                                                           */
	                                                                                 /*  00 : nop/idle                                                                                                                            */
	                                                                                 /*  01 : request new read buffer                                                                                                             */
	                                                                                 /*  10 : request new write buffer                                                                                                            */
	                                                                                 /*  11 : release current buffer                                                                                                              */
	                                                                                 /* Note:                                                                                                                                     */
	                                                                                 /*    This bit field will be reset to nop/idle automatically after command                                                                   */
	                                                                                 /*    was performed (it is writable but can also be changed by hardware).                                                                    */
	unsigned int reserved2 : BFW_NX51_handshake_buf_man1_status_ctrl_host_reserved2; /* reserved                                                                                                                                  */
} NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_HOST_BIT_T;

typedef union {
	unsigned int                                   val;
	NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_HOST_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN1_STATUS_CTRL_HOST_T;

/* --------------------------------------------------------------------- */
/* Register handshake_buf_man1_win_map */
/* => DPM Window Address Map Alternative Configuration Register for Handshake Triple Buffer Manager 1. */
/*    Handshake Triple Buffer Manager 1 can be associated to Handshake Cell 2 Bits 7 and 23 (16+7) */
/*    for Host controlled DPM input data handling and DPM auto buffer window change. */
/*    Note: */
/*      DPM auto buffer window change configuration is controlled inside DPM address area at window map registers. */
/*      If DPM auto buffer window change is enabled, buffer 1 related DPM window mapping is window mapping programmed */
/*      for related window in DPM address are. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_handshake_buf_man1_win_map            0x000000DCU
#define Adr_NX51_handshake_ctrl_handshake_buf_man1_win_map 0x1018C3DCU
#define Adr_NX51_handshake_buf_man1_win_map                0x1018C3DCU
#define DFLT_VAL_NX51_handshake_buf_man1_win_map           0x00000000U

#define MSK_NX51_handshake_buf_man1_win_map_win_map_buf1         0x00001fffU
#define SRT_NX51_handshake_buf_man1_win_map_win_map_buf1         0
#define DFLT_VAL_NX51_handshake_buf_man1_win_map_win_map_buf1    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man1_win_map_win_map_buf1 0x00000000U
#define MSK_NX51_handshake_buf_man1_win_map_win_map_buf2         0x1fff0000U
#define SRT_NX51_handshake_buf_man1_win_map_win_map_buf2         16
#define DFLT_VAL_NX51_handshake_buf_man1_win_map_win_map_buf2    0x00000000U
#define DFLT_BF_VAL_NX51_handshake_buf_man1_win_map_win_map_buf2 0x00000000U

/* all used bits of 'NX51_handshake_buf_man1_win_map': */
#define MSK_USED_BITS_NX51_handshake_buf_man1_win_map 0x1fff1fffU

enum {
	BFW_NX51_handshake_buf_man1_win_map_win_map_buf1 = 13, /* [12:0] */
	BFW_NX51_handshake_buf_man1_win_map_reserved1    = 3,  /* [15:13] */
	BFW_NX51_handshake_buf_man1_win_map_win_map_buf2 = 13, /* [28:16] */
	BFW_NX51_handshake_buf_man1_win_map_reserved2    = 3   /* [31:29] */
};

typedef struct NX51_HANDSHAKE_BUF_MAN1_WIN_MAP_BIT_Ttag {
	unsigned int win_map_buf1 : BFW_NX51_handshake_buf_man1_win_map_win_map_buf1; /* Buffer 1 of Handshake Triple Buffer Manager 1 Alternative DPM Window Address Map. */
	                                                                              /* This win_map entry is used if DPM auto buffer window                              */
	                                                                              /* change is enabled and if Buffer 1 of Handshake Triple Buffer Manager 1 is valid.  */
	unsigned int reserved1    : BFW_NX51_handshake_buf_man1_win_map_reserved1;    /* reserved                                                                          */
	unsigned int win_map_buf2 : BFW_NX51_handshake_buf_man1_win_map_win_map_buf2; /* Buffer 2 of Handshake Triple Buffer Manager 1 Alternative DPM Window Address Map. */
	                                                                              /* This win_map entry is used if DPM auto buffer window                              */
	                                                                              /* change is enabled and if Buffer 2 of Handshake Triple Buffer Manager 1 is valid.  */
	unsigned int reserved2    : BFW_NX51_handshake_buf_man1_win_map_reserved2;    /* reserved                                                                          */
} NX51_HANDSHAKE_BUF_MAN1_WIN_MAP_BIT_T;

typedef union {
	unsigned int                          val;
	NX51_HANDSHAKE_BUF_MAN1_WIN_MAP_BIT_T bf;
} NX51_HANDSHAKE_BUF_MAN1_WIN_MAP_T;


/* ===================================================================== */

/* AREA xpic */
/* Area of xpic_regs */

/* ===================================================================== */

#define Addr_NX51_xpic_regs 0x1018C400U

/* --------------------------------------------------------------------- */
/* Register xpic_r0 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r0       0x00000000U
#define Adr_NX51_xpic_regs_xpic_r0 0x1018C400U
#define Adr_NX51_xpic_r0           0x1018C400U
#define DFLT_VAL_NX51_xpic_r0      0x00000000U

#define MSK_NX51_xpic_r0_r0         0xffffffffU
#define SRT_NX51_xpic_r0_r0         0
#define DFLT_VAL_NX51_xpic_r0_r0    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r0_r0 0x00000000U

/* all used bits of 'NX51_xpic_r0': */
#define MSK_USED_BITS_NX51_xpic_r0 0xffffffffU

enum {
	BFW_NX51_xpic_r0_r0 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R0_BIT_Ttag {
	unsigned int r0 : BFW_NX51_xpic_r0_r0; /* Work Register 0 */
} NX51_XPIC_R0_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R0_BIT_T bf;
} NX51_XPIC_R0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r1 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r1       0x00000004U
#define Adr_NX51_xpic_regs_xpic_r1 0x1018C404U
#define Adr_NX51_xpic_r1           0x1018C404U
#define DFLT_VAL_NX51_xpic_r1      0x00000000U

#define MSK_NX51_xpic_r1_r1         0xffffffffU
#define SRT_NX51_xpic_r1_r1         0
#define DFLT_VAL_NX51_xpic_r1_r1    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r1_r1 0x00000000U

/* all used bits of 'NX51_xpic_r1': */
#define MSK_USED_BITS_NX51_xpic_r1 0xffffffffU

enum {
	BFW_NX51_xpic_r1_r1 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R1_BIT_Ttag {
	unsigned int r1 : BFW_NX51_xpic_r1_r1; /* Work Register 1 */
} NX51_XPIC_R1_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R1_BIT_T bf;
} NX51_XPIC_R1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r2 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r2       0x00000008U
#define Adr_NX51_xpic_regs_xpic_r2 0x1018C408U
#define Adr_NX51_xpic_r2           0x1018C408U
#define DFLT_VAL_NX51_xpic_r2      0x00000000U

#define MSK_NX51_xpic_r2_r2         0xffffffffU
#define SRT_NX51_xpic_r2_r2         0
#define DFLT_VAL_NX51_xpic_r2_r2    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r2_r2 0x00000000U

/* all used bits of 'NX51_xpic_r2': */
#define MSK_USED_BITS_NX51_xpic_r2 0xffffffffU

enum {
	BFW_NX51_xpic_r2_r2 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R2_BIT_Ttag {
	unsigned int r2 : BFW_NX51_xpic_r2_r2; /* Work Register 2 */
} NX51_XPIC_R2_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R2_BIT_T bf;
} NX51_XPIC_R2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r3 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r3       0x0000000CU
#define Adr_NX51_xpic_regs_xpic_r3 0x1018C40CU
#define Adr_NX51_xpic_r3           0x1018C40CU
#define DFLT_VAL_NX51_xpic_r3      0x00000000U

#define MSK_NX51_xpic_r3_r3         0xffffffffU
#define SRT_NX51_xpic_r3_r3         0
#define DFLT_VAL_NX51_xpic_r3_r3    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r3_r3 0x00000000U

/* all used bits of 'NX51_xpic_r3': */
#define MSK_USED_BITS_NX51_xpic_r3 0xffffffffU

enum {
	BFW_NX51_xpic_r3_r3 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R3_BIT_Ttag {
	unsigned int r3 : BFW_NX51_xpic_r3_r3; /* Work Register 3 */
} NX51_XPIC_R3_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R3_BIT_T bf;
} NX51_XPIC_R3_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r4 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r4       0x00000010U
#define Adr_NX51_xpic_regs_xpic_r4 0x1018C410U
#define Adr_NX51_xpic_r4           0x1018C410U
#define DFLT_VAL_NX51_xpic_r4      0x00000000U

#define MSK_NX51_xpic_r4_r4         0xffffffffU
#define SRT_NX51_xpic_r4_r4         0
#define DFLT_VAL_NX51_xpic_r4_r4    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r4_r4 0x00000000U

/* all used bits of 'NX51_xpic_r4': */
#define MSK_USED_BITS_NX51_xpic_r4 0xffffffffU

enum {
	BFW_NX51_xpic_r4_r4 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R4_BIT_Ttag {
	unsigned int r4 : BFW_NX51_xpic_r4_r4; /* Work Register 4 */
} NX51_XPIC_R4_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R4_BIT_T bf;
} NX51_XPIC_R4_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r5 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r5       0x00000014U
#define Adr_NX51_xpic_regs_xpic_r5 0x1018C414U
#define Adr_NX51_xpic_r5           0x1018C414U
#define DFLT_VAL_NX51_xpic_r5      0x00000000U

#define MSK_NX51_xpic_r5_r5         0xffffffffU
#define SRT_NX51_xpic_r5_r5         0
#define DFLT_VAL_NX51_xpic_r5_r5    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r5_r5 0x00000000U

/* all used bits of 'NX51_xpic_r5': */
#define MSK_USED_BITS_NX51_xpic_r5 0xffffffffU

enum {
	BFW_NX51_xpic_r5_r5 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R5_BIT_Ttag {
	unsigned int r5 : BFW_NX51_xpic_r5_r5; /* Work Register 5 */
} NX51_XPIC_R5_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R5_BIT_T bf;
} NX51_XPIC_R5_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r6 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r6       0x00000018U
#define Adr_NX51_xpic_regs_xpic_r6 0x1018C418U
#define Adr_NX51_xpic_r6           0x1018C418U
#define DFLT_VAL_NX51_xpic_r6      0x00000000U

#define MSK_NX51_xpic_r6_r6         0xffffffffU
#define SRT_NX51_xpic_r6_r6         0
#define DFLT_VAL_NX51_xpic_r6_r6    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r6_r6 0x00000000U

/* all used bits of 'NX51_xpic_r6': */
#define MSK_USED_BITS_NX51_xpic_r6 0xffffffffU

enum {
	BFW_NX51_xpic_r6_r6 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R6_BIT_Ttag {
	unsigned int r6 : BFW_NX51_xpic_r6_r6; /* Work Register 6 */
} NX51_XPIC_R6_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R6_BIT_T bf;
} NX51_XPIC_R6_T;

/* --------------------------------------------------------------------- */
/* Register xpic_r7 */
/* => xPIC work register for indirect addressing */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_r7       0x0000001CU
#define Adr_NX51_xpic_regs_xpic_r7 0x1018C41CU
#define Adr_NX51_xpic_r7           0x1018C41CU
#define DFLT_VAL_NX51_xpic_r7      0x00000000U

#define MSK_NX51_xpic_r7_r7         0xffffffffU
#define SRT_NX51_xpic_r7_r7         0
#define DFLT_VAL_NX51_xpic_r7_r7    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_r7_r7 0x00000000U

/* all used bits of 'NX51_xpic_r7': */
#define MSK_USED_BITS_NX51_xpic_r7 0xffffffffU

enum {
	BFW_NX51_xpic_r7_r7 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_R7_BIT_Ttag {
	unsigned int r7 : BFW_NX51_xpic_r7_r7; /* Work Register 7 */
} NX51_XPIC_R7_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_R7_BIT_T bf;
} NX51_XPIC_R7_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr0 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_usr0       0x00000020U
#define Adr_NX51_xpic_regs_xpic_usr0 0x1018C420U
#define Adr_NX51_xpic_usr0           0x1018C420U
#define DFLT_VAL_NX51_xpic_usr0      0x00000000U

#define MSK_NX51_xpic_usr0_usr0         0xffffffffU
#define SRT_NX51_xpic_usr0_usr0         0
#define DFLT_VAL_NX51_xpic_usr0_usr0    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_usr0_usr0 0x00000000U

/* all used bits of 'NX51_xpic_usr0': */
#define MSK_USED_BITS_NX51_xpic_usr0 0xffffffffU

enum {
	BFW_NX51_xpic_usr0_usr0 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_USR0_BIT_Ttag {
	unsigned int usr0 : BFW_NX51_xpic_usr0_usr0; /* User Register 0 */
} NX51_XPIC_USR0_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPIC_USR0_BIT_T bf;
} NX51_XPIC_USR0_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr1 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_usr1       0x00000024U
#define Adr_NX51_xpic_regs_xpic_usr1 0x1018C424U
#define Adr_NX51_xpic_usr1           0x1018C424U
#define DFLT_VAL_NX51_xpic_usr1      0x00000000U

#define MSK_NX51_xpic_usr1_usr1         0xffffffffU
#define SRT_NX51_xpic_usr1_usr1         0
#define DFLT_VAL_NX51_xpic_usr1_usr1    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_usr1_usr1 0x00000000U

/* all used bits of 'NX51_xpic_usr1': */
#define MSK_USED_BITS_NX51_xpic_usr1 0xffffffffU

enum {
	BFW_NX51_xpic_usr1_usr1 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_USR1_BIT_Ttag {
	unsigned int usr1 : BFW_NX51_xpic_usr1_usr1; /* User Register 1 */
} NX51_XPIC_USR1_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPIC_USR1_BIT_T bf;
} NX51_XPIC_USR1_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr2 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_usr2       0x00000028U
#define Adr_NX51_xpic_regs_xpic_usr2 0x1018C428U
#define Adr_NX51_xpic_usr2           0x1018C428U
#define DFLT_VAL_NX51_xpic_usr2      0x00000000U

#define MSK_NX51_xpic_usr2_usr2         0xffffffffU
#define SRT_NX51_xpic_usr2_usr2         0
#define DFLT_VAL_NX51_xpic_usr2_usr2    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_usr2_usr2 0x00000000U

/* all used bits of 'NX51_xpic_usr2': */
#define MSK_USED_BITS_NX51_xpic_usr2 0xffffffffU

enum {
	BFW_NX51_xpic_usr2_usr2 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_USR2_BIT_Ttag {
	unsigned int usr2 : BFW_NX51_xpic_usr2_usr2; /* User Register 2 */
} NX51_XPIC_USR2_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPIC_USR2_BIT_T bf;
} NX51_XPIC_USR2_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr3 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_usr3       0x0000002CU
#define Adr_NX51_xpic_regs_xpic_usr3 0x1018C42CU
#define Adr_NX51_xpic_usr3           0x1018C42CU
#define DFLT_VAL_NX51_xpic_usr3      0x00000000U

#define MSK_NX51_xpic_usr3_usr3         0xffffffffU
#define SRT_NX51_xpic_usr3_usr3         0
#define DFLT_VAL_NX51_xpic_usr3_usr3    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_usr3_usr3 0x00000000U

/* all used bits of 'NX51_xpic_usr3': */
#define MSK_USED_BITS_NX51_xpic_usr3 0xffffffffU

enum {
	BFW_NX51_xpic_usr3_usr3 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_USR3_BIT_Ttag {
	unsigned int usr3 : BFW_NX51_xpic_usr3_usr3; /* User Register 3 */
} NX51_XPIC_USR3_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPIC_USR3_BIT_T bf;
} NX51_XPIC_USR3_T;

/* --------------------------------------------------------------------- */
/* Register xpic_usr4 */
/* => xPIC user Register additional work register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_usr4       0x00000030U
#define Adr_NX51_xpic_regs_xpic_usr4 0x1018C430U
#define Adr_NX51_xpic_usr4           0x1018C430U
#define DFLT_VAL_NX51_xpic_usr4      0x00000000U

#define MSK_NX51_xpic_usr4_usr4         0xffffffffU
#define SRT_NX51_xpic_usr4_usr4         0
#define DFLT_VAL_NX51_xpic_usr4_usr4    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_usr4_usr4 0x00000000U

/* all used bits of 'NX51_xpic_usr4': */
#define MSK_USED_BITS_NX51_xpic_usr4 0xffffffffU

enum {
	BFW_NX51_xpic_usr4_usr4 = 32  /* [31:0] */
};

typedef struct NX51_XPIC_USR4_BIT_Ttag {
	unsigned int usr4 : BFW_NX51_xpic_usr4_usr4; /* User Register 4 */
} NX51_XPIC_USR4_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPIC_USR4_BIT_T bf;
} NX51_XPIC_USR4_T;

/* --------------------------------------------------------------------- */
/* Register xpic_pc */
/* => xPIC Program Counter */
/*    Shared in xPIC 64_BIT_MUL_TARGET mode with usr32 (w mode) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_pc       0x00000034U
#define Adr_NX51_xpic_regs_xpic_pc 0x1018C434U
#define Adr_NX51_xpic_pc           0x1018C434U
#define DFLT_VAL_NX51_xpic_pc      0xfffffffcU

#define MSK_NX51_xpic_pc_pc         0x000007ffU
#define SRT_NX51_xpic_pc_pc         0
#define DFLT_VAL_NX51_xpic_pc_pc    0xfffffffcU
#define DFLT_BF_VAL_NX51_xpic_pc_pc 0xfffffffcU

/* all used bits of 'NX51_xpic_pc': */
#define MSK_USED_BITS_NX51_xpic_pc 0x000007ffU

enum {
	BFW_NX51_xpic_pc_pc        = 11, /* [10:0] */
	BFW_NX51_xpic_pc_reserved1 = 21  /* [31:11] */
};

typedef struct NX51_XPIC_PC_BIT_Ttag {
	unsigned int pc        : BFW_NX51_xpic_pc_pc;        /* Program Counter (dword address inside DPRAM) */
	unsigned int reserved1 : BFW_NX51_xpic_pc_reserved1; /* reserved                                     */
} NX51_XPIC_PC_BIT_T;

typedef union {
	unsigned int       val;
	NX51_XPIC_PC_BIT_T bf;
} NX51_XPIC_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_stat */
/* => Processor Status Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_stat       0x00000038U
#define Adr_NX51_xpic_regs_xpic_stat 0x1018C438U
#define Adr_NX51_xpic_stat           0x1018C438U
#define DFLT_VAL_NX51_xpic_stat      0x00000000U

#define MSK_NX51_xpic_stat_stat         0xffffffffU
#define SRT_NX51_xpic_stat_stat         0
#define DFLT_VAL_NX51_xpic_stat_stat    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_stat_stat 0x00000000U

/* all used bits of 'NX51_xpic_stat': */
#define MSK_USED_BITS_NX51_xpic_stat 0xffffffffU

enum {
	BFW_NX51_xpic_stat_stat = 32  /* [31:0] */
};

typedef struct NX51_XPIC_STAT_BIT_Ttag {
	unsigned int stat : BFW_NX51_xpic_stat_stat; /*  */
} NX51_XPIC_STAT_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPIC_STAT_BIT_T bf;
} NX51_XPIC_STAT_T;

/* --------------------------------------------------------------------- */
/* Register xpic_zero */
/* => Zero Register */
/*    Shared in xPIC 64_BIT_MUL_TARGET mode with usr10 (w mode) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_zero       0x0000003CU
#define Adr_NX51_xpic_regs_xpic_zero 0x1018C43CU
#define Adr_NX51_xpic_zero           0x1018C43CU
#define DFLT_VAL_NX51_xpic_zero      0x00000000U

#define MSK_NX51_xpic_zero_zero         0xffffffffU
#define SRT_NX51_xpic_zero_zero         0
#define DFLT_VAL_NX51_xpic_zero_zero    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_zero_zero 0x00000000U

/* all used bits of 'NX51_xpic_zero': */
#define MSK_USED_BITS_NX51_xpic_zero 0xffffffffU

enum {
	BFW_NX51_xpic_zero_zero = 32  /* [31:0] */
};

typedef struct NX51_XPIC_ZERO_BIT_Ttag {
	unsigned int zero : BFW_NX51_xpic_zero_zero; /* Always Zero */
} NX51_XPIC_ZERO_BIT_T;

typedef union {
	unsigned int         val;
	NX51_XPIC_ZERO_BIT_T bf;
} NX51_XPIC_ZERO_T;


/* ===================================================================== */

/* Area of xpic_debug */

/* ===================================================================== */

#define Addr_NX51_xpic_debug 0x1018C480U

/* --------------------------------------------------------------------- */
/* Register xpic_hold_pc */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_hold_pc        0x00000000U
#define Adr_NX51_xpic_debug_xpic_hold_pc 0x1018C480U
#define Adr_NX51_xpic_hold_pc            0x1018C480U
#define DFLT_VAL_NX51_xpic_hold_pc       0x00000001U

#define MSK_NX51_xpic_hold_pc_hold                      0x00000001U
#define SRT_NX51_xpic_hold_pc_hold                      0
#define DFLT_VAL_NX51_xpic_hold_pc_hold                 0x00000001U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_hold              0x00000001U
#define MSK_NX51_xpic_hold_pc_single_step               0x00000002U
#define SRT_NX51_xpic_hold_pc_single_step               1
#define DFLT_VAL_NX51_xpic_hold_pc_single_step          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_single_step       0x00000000U
#define MSK_NX51_xpic_hold_pc_monitor_mode              0x00000004U
#define SRT_NX51_xpic_hold_pc_monitor_mode              2
#define DFLT_VAL_NX51_xpic_hold_pc_monitor_mode         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_monitor_mode      0x00000000U
#define MSK_NX51_xpic_hold_pc_disable_int               0x00000008U
#define SRT_NX51_xpic_hold_pc_disable_int               3
#define DFLT_VAL_NX51_xpic_hold_pc_disable_int          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_disable_int       0x00000000U
#define MSK_NX51_xpic_hold_pc_misalignment_hold         0x00000010U
#define SRT_NX51_xpic_hold_pc_misalignment_hold         4
#define DFLT_VAL_NX51_xpic_hold_pc_misalignment_hold    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_misalignment_hold 0x00000000U
#define MSK_NX51_xpic_hold_pc_bank_select               0x00000020U
#define SRT_NX51_xpic_hold_pc_bank_select               5
#define DFLT_VAL_NX51_xpic_hold_pc_bank_select          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_bank_select       0x00000000U
#define MSK_NX51_xpic_hold_pc_bank_control              0x00000040U
#define SRT_NX51_xpic_hold_pc_bank_control              6
#define DFLT_VAL_NX51_xpic_hold_pc_bank_control         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_bank_control      0x00000000U
#define MSK_NX51_xpic_hold_pc_reset_xpic                0x00000080U
#define SRT_NX51_xpic_hold_pc_reset_xpic                7
#define DFLT_VAL_NX51_xpic_hold_pc_reset_xpic           0x00000000U
#define DFLT_BF_VAL_NX51_xpic_hold_pc_reset_xpic        0x00000000U

/* all used bits of 'NX51_xpic_hold_pc': */
#define MSK_USED_BITS_NX51_xpic_hold_pc 0x000000ffU

enum {
	BFW_NX51_xpic_hold_pc_hold              = 1,  /* [0] */
	BFW_NX51_xpic_hold_pc_single_step       = 1,  /* [1] */
	BFW_NX51_xpic_hold_pc_monitor_mode      = 1,  /* [2] */
	BFW_NX51_xpic_hold_pc_disable_int       = 1,  /* [3] */
	BFW_NX51_xpic_hold_pc_misalignment_hold = 1,  /* [4] */
	BFW_NX51_xpic_hold_pc_bank_select       = 1,  /* [5] */
	BFW_NX51_xpic_hold_pc_bank_control      = 1,  /* [6] */
	BFW_NX51_xpic_hold_pc_reset_xpic        = 1,  /* [7] */
	BFW_NX51_xpic_hold_pc_reserved1         = 24  /* [31:8] */
};

typedef struct NX51_XPIC_HOLD_PC_BIT_Ttag {
	unsigned int hold              : BFW_NX51_xpic_hold_pc_hold;              /* 0: Start xPIC                                                                                                                                        */
	                                                                          /* 1: Hold xPIC                                                                                                                                         */
	unsigned int single_step       : BFW_NX51_xpic_hold_pc_single_step;       /* 0: Disable single step mode                                                                                                                          */
	                                                                          /* 1: xPIC processes a single pipeline step then stops and triggers the single_step_irq. Write '1' into xpic_break_irq_raw.single_step_irq to continue. */
	unsigned int monitor_mode      : BFW_NX51_xpic_hold_pc_monitor_mode;      /* 0: xPIC stops when hardware breakpoint is triggered. Write '1' into xpic_break_irq_raw.break0_irq or break1_irq to continue.                         */
	                                                                          /* 1: Hardware breakpoints still generate irqs but do not stop the xPIC.                                                                                */
	unsigned int disable_int       : BFW_NX51_xpic_hold_pc_disable_int;       /* disable interrupts                                                                                                                                   */
	unsigned int misalignment_hold : BFW_NX51_xpic_hold_pc_misalignment_hold; /* 0: xPIC triggers misalignment_irq on misaligned memory accesses but does not stop.                                                                   */
	                                                                          /* 1: xPIC stops after a misaligned memory accesses and triggers misalignment_irq. Write '1' into xpic_break_irq_raw.misalignment_irq to continue.      */
	unsigned int bank_select       : BFW_NX51_xpic_hold_pc_bank_select;       /* Select register bank (0: default bank, 1: fiq bank)                                                                                                  */
	                                                                          /* Access registers in xpic_regs area (xpic_r0 .. xpic_r7, xpic_stat)                                                                                   */
	unsigned int bank_control      : BFW_NX51_xpic_hold_pc_bank_control;      /* control over the register bank selection                                                                                                             */
	                                                                          /* WARNING: reset this BIT to 0 BEFORE start xPIC (clear hold bits)                                                                                     */
	unsigned int reset_xpic        : BFW_NX51_xpic_hold_pc_reset_xpic;        /* REQUEST reset all internal internal states and the pipeline                                                                                          */
	                                                                          /* EXCEPT: the internal register (r0-r7, usr0-4), bank0 and bank1 reset this registers manually                                                         */
	                                                                          /* EXCEPT: xpic hard_breaker/debug registers                                                                                                            */
	                                                                          /* 1 - xPIC reset request                                                                                                                               */
	unsigned int reserved1         : BFW_NX51_xpic_hold_pc_reserved1;         /* reserved                                                                                                                                             */
} NX51_XPIC_HOLD_PC_BIT_T;

typedef union {
	unsigned int            val;
	NX51_XPIC_HOLD_PC_BIT_T bf;
} NX51_XPIC_HOLD_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_addr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break0_addr        0x00000004U
#define Adr_NX51_xpic_debug_xpic_break0_addr 0x1018C484U
#define Adr_NX51_xpic_break0_addr            0x1018C484U
#define DFLT_VAL_NX51_xpic_break0_addr       0x00000000U

#define MSK_NX51_xpic_break0_addr_val         0xffffffffU
#define SRT_NX51_xpic_break0_addr_val         0
#define DFLT_VAL_NX51_xpic_break0_addr_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_addr_val 0x00000000U

/* all used bits of 'NX51_xpic_break0_addr': */
#define MSK_USED_BITS_NX51_xpic_break0_addr 0xffffffffU

enum {
	BFW_NX51_xpic_break0_addr_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK0_ADDR_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break0_addr_val; /* Breakpoint 0 address value */
} NX51_XPIC_BREAK0_ADDR_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XPIC_BREAK0_ADDR_BIT_T bf;
} NX51_XPIC_BREAK0_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_addr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break0_addr_mask        0x00000008U
#define Adr_NX51_xpic_debug_xpic_break0_addr_mask 0x1018C488U
#define Adr_NX51_xpic_break0_addr_mask            0x1018C488U
#define DFLT_VAL_NX51_xpic_break0_addr_mask       0x00000000U

#define MSK_NX51_xpic_break0_addr_mask_val         0xffffffffU
#define SRT_NX51_xpic_break0_addr_mask_val         0
#define DFLT_VAL_NX51_xpic_break0_addr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_addr_mask_val 0x00000000U

/* all used bits of 'NX51_xpic_break0_addr_mask': */
#define MSK_USED_BITS_NX51_xpic_break0_addr_mask 0xffffffffU

enum {
	BFW_NX51_xpic_break0_addr_mask_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK0_ADDR_MASK_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break0_addr_mask_val; /* Breakpoint 0 address mask */
} NX51_XPIC_BREAK0_ADDR_MASK_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_BREAK0_ADDR_MASK_BIT_T bf;
} NX51_XPIC_BREAK0_ADDR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_data */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break0_data        0x0000000CU
#define Adr_NX51_xpic_debug_xpic_break0_data 0x1018C48CU
#define Adr_NX51_xpic_break0_data            0x1018C48CU
#define DFLT_VAL_NX51_xpic_break0_data       0x00000000U

#define MSK_NX51_xpic_break0_data_val         0xffffffffU
#define SRT_NX51_xpic_break0_data_val         0
#define DFLT_VAL_NX51_xpic_break0_data_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_data_val 0x00000000U

/* all used bits of 'NX51_xpic_break0_data': */
#define MSK_USED_BITS_NX51_xpic_break0_data 0xffffffffU

enum {
	BFW_NX51_xpic_break0_data_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK0_DATA_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break0_data_val; /* Breakpoint 0 data value   (for data access only) */
} NX51_XPIC_BREAK0_DATA_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XPIC_BREAK0_DATA_BIT_T bf;
} NX51_XPIC_BREAK0_DATA_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_data_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break0_data_mask        0x00000010U
#define Adr_NX51_xpic_debug_xpic_break0_data_mask 0x1018C490U
#define Adr_NX51_xpic_break0_data_mask            0x1018C490U
#define DFLT_VAL_NX51_xpic_break0_data_mask       0x00000000U

#define MSK_NX51_xpic_break0_data_mask_val         0xffffffffU
#define SRT_NX51_xpic_break0_data_mask_val         0
#define DFLT_VAL_NX51_xpic_break0_data_mask_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_data_mask_val 0x00000000U

/* all used bits of 'NX51_xpic_break0_data_mask': */
#define MSK_USED_BITS_NX51_xpic_break0_data_mask 0xffffffffU

enum {
	BFW_NX51_xpic_break0_data_mask_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK0_DATA_MASK_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break0_data_mask_val; /* Breakpoint 0 data mask    (for data access only) */
} NX51_XPIC_BREAK0_DATA_MASK_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_BREAK0_DATA_MASK_BIT_T bf;
} NX51_XPIC_BREAK0_DATA_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_contr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break0_contr        0x00000014U
#define Adr_NX51_xpic_debug_xpic_break0_contr 0x1018C494U
#define Adr_NX51_xpic_break0_contr            0x1018C494U
#define DFLT_VAL_NX51_xpic_break0_contr       0x00000000U

#define MSK_NX51_xpic_break0_contr_write               0x00000001U
#define SRT_NX51_xpic_break0_contr_write               0
#define DFLT_VAL_NX51_xpic_break0_contr_write          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_write       0x00000000U
#define MSK_NX51_xpic_break0_contr_mas                 0x00000006U
#define SRT_NX51_xpic_break0_contr_mas                 1
#define DFLT_VAL_NX51_xpic_break0_contr_mas            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_mas         0x00000000U
#define MSK_NX51_xpic_break0_contr_data_access         0x00000008U
#define SRT_NX51_xpic_break0_contr_data_access         3
#define DFLT_VAL_NX51_xpic_break0_contr_data_access    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_data_access 0x00000000U
#define MSK_NX51_xpic_break0_contr_fiq_mode            0x00000010U
#define SRT_NX51_xpic_break0_contr_fiq_mode            4
#define DFLT_VAL_NX51_xpic_break0_contr_fiq_mode       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_fiq_mode    0x00000000U
#define MSK_NX51_xpic_break0_contr_irq_mode            0x00000020U
#define SRT_NX51_xpic_break0_contr_irq_mode            5
#define DFLT_VAL_NX51_xpic_break0_contr_irq_mode       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_irq_mode    0x00000000U
#define MSK_NX51_xpic_break0_contr_chain               0x00000040U
#define SRT_NX51_xpic_break0_contr_chain               6
#define DFLT_VAL_NX51_xpic_break0_contr_chain          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_chain       0x00000000U
#define MSK_NX51_xpic_break0_contr_range               0x00000080U
#define SRT_NX51_xpic_break0_contr_range               7
#define DFLT_VAL_NX51_xpic_break0_contr_range          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_range       0x00000000U
#define MSK_NX51_xpic_break0_contr_enable              0x00000100U
#define SRT_NX51_xpic_break0_contr_enable              8
#define DFLT_VAL_NX51_xpic_break0_contr_enable         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_enable      0x00000000U

/* all used bits of 'NX51_xpic_break0_contr': */
#define MSK_USED_BITS_NX51_xpic_break0_contr 0x000001ffU

enum {
	BFW_NX51_xpic_break0_contr_write       = 1,  /* [0] */
	BFW_NX51_xpic_break0_contr_mas         = 2,  /* [2:1] */
	BFW_NX51_xpic_break0_contr_data_access = 1,  /* [3] */
	BFW_NX51_xpic_break0_contr_fiq_mode    = 1,  /* [4] */
	BFW_NX51_xpic_break0_contr_irq_mode    = 1,  /* [5] */
	BFW_NX51_xpic_break0_contr_chain       = 1,  /* [6] */
	BFW_NX51_xpic_break0_contr_range       = 1,  /* [7] */
	BFW_NX51_xpic_break0_contr_enable      = 1,  /* [8] */
	BFW_NX51_xpic_break0_contr_reserved1   = 23  /* [31:9] */
};

typedef struct NX51_XPIC_BREAK0_CONTR_BIT_Ttag {
	unsigned int write       : BFW_NX51_xpic_break0_contr_write;       /* Breakpoint 0  write/read access                                              */
	unsigned int mas         : BFW_NX51_xpic_break0_contr_mas;         /* Breakpoint 0  memory access size (00: byte. 01: word, 10 dword, 11 reserved) */
	unsigned int data_access : BFW_NX51_xpic_break0_contr_data_access; /* Breakpoint 0  (1: data access, 0: instruction fetch)                         */
	unsigned int fiq_mode    : BFW_NX51_xpic_break0_contr_fiq_mode;    /* Breakpoint 0  xPIC in FIQ Mode                                               */
	unsigned int irq_mode    : BFW_NX51_xpic_break0_contr_irq_mode;    /* Breakpoint 0  xPIC in IRQ Mode                                               */
	unsigned int chain       : BFW_NX51_xpic_break0_contr_chain;       /* Breakpoint 0 input from Breakpoint 1                                         */
	unsigned int range       : BFW_NX51_xpic_break0_contr_range;       /* Breakpoint 0 input from Breakpoint 1                                         */
	unsigned int enable      : BFW_NX51_xpic_break0_contr_enable;      /* Breakpoint 0                                                                 */
	unsigned int reserved1   : BFW_NX51_xpic_break0_contr_reserved1;   /* reserved                                                                     */
} NX51_XPIC_BREAK0_CONTR_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_BREAK0_CONTR_BIT_T bf;
} NX51_XPIC_BREAK0_CONTR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break0_contr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break0_contr_mask        0x00000018U
#define Adr_NX51_xpic_debug_xpic_break0_contr_mask 0x1018C498U
#define Adr_NX51_xpic_break0_contr_mask            0x1018C498U
#define DFLT_VAL_NX51_xpic_break0_contr_mask       0x00000000U

#define MSK_NX51_xpic_break0_contr_mask_val         0x000000ffU
#define SRT_NX51_xpic_break0_contr_mask_val         0
#define DFLT_VAL_NX51_xpic_break0_contr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break0_contr_mask_val 0x00000000U

/* all used bits of 'NX51_xpic_break0_contr_mask': */
#define MSK_USED_BITS_NX51_xpic_break0_contr_mask 0x000000ffU

enum {
	BFW_NX51_xpic_break0_contr_mask_val       = 8,  /* [7:0] */
	BFW_NX51_xpic_break0_contr_mask_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_XPIC_BREAK0_CONTR_MASK_BIT_Ttag {
	unsigned int val       : BFW_NX51_xpic_break0_contr_mask_val;       /* Breakpoint 0 control mask */
	unsigned int reserved1 : BFW_NX51_xpic_break0_contr_mask_reserved1; /* reserved                  */
} NX51_XPIC_BREAK0_CONTR_MASK_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_BREAK0_CONTR_MASK_BIT_T bf;
} NX51_XPIC_BREAK0_CONTR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_addr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break1_addr        0x0000001CU
#define Adr_NX51_xpic_debug_xpic_break1_addr 0x1018C49CU
#define Adr_NX51_xpic_break1_addr            0x1018C49CU
#define DFLT_VAL_NX51_xpic_break1_addr       0x00000000U

#define MSK_NX51_xpic_break1_addr_val         0xffffffffU
#define SRT_NX51_xpic_break1_addr_val         0
#define DFLT_VAL_NX51_xpic_break1_addr_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_addr_val 0x00000000U

/* all used bits of 'NX51_xpic_break1_addr': */
#define MSK_USED_BITS_NX51_xpic_break1_addr 0xffffffffU

enum {
	BFW_NX51_xpic_break1_addr_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK1_ADDR_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break1_addr_val; /* Breakpoint 1 address value */
} NX51_XPIC_BREAK1_ADDR_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XPIC_BREAK1_ADDR_BIT_T bf;
} NX51_XPIC_BREAK1_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_addr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break1_addr_mask        0x00000020U
#define Adr_NX51_xpic_debug_xpic_break1_addr_mask 0x1018C4A0U
#define Adr_NX51_xpic_break1_addr_mask            0x1018C4A0U
#define DFLT_VAL_NX51_xpic_break1_addr_mask       0x00000000U

#define MSK_NX51_xpic_break1_addr_mask_val         0xffffffffU
#define SRT_NX51_xpic_break1_addr_mask_val         0
#define DFLT_VAL_NX51_xpic_break1_addr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_addr_mask_val 0x00000000U

/* all used bits of 'NX51_xpic_break1_addr_mask': */
#define MSK_USED_BITS_NX51_xpic_break1_addr_mask 0xffffffffU

enum {
	BFW_NX51_xpic_break1_addr_mask_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK1_ADDR_MASK_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break1_addr_mask_val; /* Breakpoint 1 address mask */
} NX51_XPIC_BREAK1_ADDR_MASK_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_BREAK1_ADDR_MASK_BIT_T bf;
} NX51_XPIC_BREAK1_ADDR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_data */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break1_data        0x00000024U
#define Adr_NX51_xpic_debug_xpic_break1_data 0x1018C4A4U
#define Adr_NX51_xpic_break1_data            0x1018C4A4U
#define DFLT_VAL_NX51_xpic_break1_data       0x00000000U

#define MSK_NX51_xpic_break1_data_val         0xffffffffU
#define SRT_NX51_xpic_break1_data_val         0
#define DFLT_VAL_NX51_xpic_break1_data_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_data_val 0x00000000U

/* all used bits of 'NX51_xpic_break1_data': */
#define MSK_USED_BITS_NX51_xpic_break1_data 0xffffffffU

enum {
	BFW_NX51_xpic_break1_data_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK1_DATA_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break1_data_val; /* Breakpoint 1 data value   (for data access only) */
} NX51_XPIC_BREAK1_DATA_BIT_T;

typedef union {
	unsigned int                val;
	NX51_XPIC_BREAK1_DATA_BIT_T bf;
} NX51_XPIC_BREAK1_DATA_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_data_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break1_data_mask        0x00000028U
#define Adr_NX51_xpic_debug_xpic_break1_data_mask 0x1018C4A8U
#define Adr_NX51_xpic_break1_data_mask            0x1018C4A8U
#define DFLT_VAL_NX51_xpic_break1_data_mask       0x00000000U

#define MSK_NX51_xpic_break1_data_mask_val         0xffffffffU
#define SRT_NX51_xpic_break1_data_mask_val         0
#define DFLT_VAL_NX51_xpic_break1_data_mask_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_data_mask_val 0x00000000U

/* all used bits of 'NX51_xpic_break1_data_mask': */
#define MSK_USED_BITS_NX51_xpic_break1_data_mask 0xffffffffU

enum {
	BFW_NX51_xpic_break1_data_mask_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK1_DATA_MASK_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break1_data_mask_val; /* Breakpoint 1 data mask   (for data access only) */
} NX51_XPIC_BREAK1_DATA_MASK_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_BREAK1_DATA_MASK_BIT_T bf;
} NX51_XPIC_BREAK1_DATA_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_contr */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break1_contr        0x0000002CU
#define Adr_NX51_xpic_debug_xpic_break1_contr 0x1018C4ACU
#define Adr_NX51_xpic_break1_contr            0x1018C4ACU
#define DFLT_VAL_NX51_xpic_break1_contr       0x00000000U

#define MSK_NX51_xpic_break1_contr_write               0x00000001U
#define SRT_NX51_xpic_break1_contr_write               0
#define DFLT_VAL_NX51_xpic_break1_contr_write          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_write       0x00000000U
#define MSK_NX51_xpic_break1_contr_mas                 0x00000006U
#define SRT_NX51_xpic_break1_contr_mas                 1
#define DFLT_VAL_NX51_xpic_break1_contr_mas            0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_mas         0x00000000U
#define MSK_NX51_xpic_break1_contr_data_access         0x00000008U
#define SRT_NX51_xpic_break1_contr_data_access         3
#define DFLT_VAL_NX51_xpic_break1_contr_data_access    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_data_access 0x00000000U
#define MSK_NX51_xpic_break1_contr_fiq_mode            0x00000010U
#define SRT_NX51_xpic_break1_contr_fiq_mode            4
#define DFLT_VAL_NX51_xpic_break1_contr_fiq_mode       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_fiq_mode    0x00000000U
#define MSK_NX51_xpic_break1_contr_irq_mode            0x00000020U
#define SRT_NX51_xpic_break1_contr_irq_mode            5
#define DFLT_VAL_NX51_xpic_break1_contr_irq_mode       0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_irq_mode    0x00000000U
#define MSK_NX51_xpic_break1_contr_chain               0x00000040U
#define SRT_NX51_xpic_break1_contr_chain               6
#define DFLT_VAL_NX51_xpic_break1_contr_chain          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_chain       0x00000000U
#define MSK_NX51_xpic_break1_contr_range               0x00000080U
#define SRT_NX51_xpic_break1_contr_range               7
#define DFLT_VAL_NX51_xpic_break1_contr_range          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_range       0x00000000U
#define MSK_NX51_xpic_break1_contr_enable              0x00000100U
#define SRT_NX51_xpic_break1_contr_enable              8
#define DFLT_VAL_NX51_xpic_break1_contr_enable         0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_enable      0x00000000U

/* all used bits of 'NX51_xpic_break1_contr': */
#define MSK_USED_BITS_NX51_xpic_break1_contr 0x000001ffU

enum {
	BFW_NX51_xpic_break1_contr_write       = 1,  /* [0] */
	BFW_NX51_xpic_break1_contr_mas         = 2,  /* [2:1] */
	BFW_NX51_xpic_break1_contr_data_access = 1,  /* [3] */
	BFW_NX51_xpic_break1_contr_fiq_mode    = 1,  /* [4] */
	BFW_NX51_xpic_break1_contr_irq_mode    = 1,  /* [5] */
	BFW_NX51_xpic_break1_contr_chain       = 1,  /* [6] */
	BFW_NX51_xpic_break1_contr_range       = 1,  /* [7] */
	BFW_NX51_xpic_break1_contr_enable      = 1,  /* [8] */
	BFW_NX51_xpic_break1_contr_reserved1   = 23  /* [31:9] */
};

typedef struct NX51_XPIC_BREAK1_CONTR_BIT_Ttag {
	unsigned int write       : BFW_NX51_xpic_break1_contr_write;       /* Breakpoint 1  write/read access                                              */
	unsigned int mas         : BFW_NX51_xpic_break1_contr_mas;         /* Breakpoint 1  memory access size (00: byte. 01: word, 10 dword, 11 reserved) */
	unsigned int data_access : BFW_NX51_xpic_break1_contr_data_access; /* Breakpoint 1  (1: data access, 0: instruction fetch)                         */
	unsigned int fiq_mode    : BFW_NX51_xpic_break1_contr_fiq_mode;    /* Breakpoint 1  xPIC in FIQ Mode                                               */
	unsigned int irq_mode    : BFW_NX51_xpic_break1_contr_irq_mode;    /* Breakpoint 1  xPIC in IRQ Mode                                               */
	unsigned int chain       : BFW_NX51_xpic_break1_contr_chain;       /* reserved                                                                     */
	unsigned int range       : BFW_NX51_xpic_break1_contr_range;       /* reserved                                                                     */
	unsigned int enable      : BFW_NX51_xpic_break1_contr_enable;      /* Breakpoint 1                                                                 */
	unsigned int reserved1   : BFW_NX51_xpic_break1_contr_reserved1;   /* reserved                                                                     */
} NX51_XPIC_BREAK1_CONTR_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_BREAK1_CONTR_BIT_T bf;
} NX51_XPIC_BREAK1_CONTR_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break1_contr_mask */
/* =>  */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break1_contr_mask        0x00000030U
#define Adr_NX51_xpic_debug_xpic_break1_contr_mask 0x1018C4B0U
#define Adr_NX51_xpic_break1_contr_mask            0x1018C4B0U
#define DFLT_VAL_NX51_xpic_break1_contr_mask       0x00000000U

#define MSK_NX51_xpic_break1_contr_mask_val         0x000000ffU
#define SRT_NX51_xpic_break1_contr_mask_val         0
#define DFLT_VAL_NX51_xpic_break1_contr_mask_val    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break1_contr_mask_val 0x00000000U

/* all used bits of 'NX51_xpic_break1_contr_mask': */
#define MSK_USED_BITS_NX51_xpic_break1_contr_mask 0x000000ffU

enum {
	BFW_NX51_xpic_break1_contr_mask_val       = 8,  /* [7:0] */
	BFW_NX51_xpic_break1_contr_mask_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_XPIC_BREAK1_CONTR_MASK_BIT_Ttag {
	unsigned int val       : BFW_NX51_xpic_break1_contr_mask_val;       /* Breakpoint 1 control mask */
	unsigned int reserved1 : BFW_NX51_xpic_break1_contr_mask_reserved1; /* reserved                  */
} NX51_XPIC_BREAK1_CONTR_MASK_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_BREAK1_CONTR_MASK_BIT_T bf;
} NX51_XPIC_BREAK1_CONTR_MASK_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_last_pc */
/* =>  */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_last_pc        0x00000034U
#define Adr_NX51_xpic_debug_xpic_break_last_pc 0x1018C4B4U
#define Adr_NX51_xpic_break_last_pc            0x1018C4B4U

#define MSK_NX51_xpic_break_last_pc_val 0xffffffffU
#define SRT_NX51_xpic_break_last_pc_val 0

/* all used bits of 'NX51_xpic_break_last_pc': */
#define MSK_USED_BITS_NX51_xpic_break_last_pc 0xffffffffU

enum {
	BFW_NX51_xpic_break_last_pc_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK_LAST_PC_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break_last_pc_val; /* last PC */
} NX51_XPIC_BREAK_LAST_PC_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XPIC_BREAK_LAST_PC_BIT_T bf;
} NX51_XPIC_BREAK_LAST_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_status */
/* => Read access shows the reason why xPIC is in HOLD / BREAK */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_status        0x00000038U
#define Adr_NX51_xpic_debug_xpic_break_status 0x1018C4B8U
#define Adr_NX51_xpic_break_status            0x1018C4B8U

#define MSK_NX51_xpic_break_status_xpic_in_hold      0x00000001U
#define SRT_NX51_xpic_break_status_xpic_in_hold      0
#define MSK_NX51_xpic_break_status_hold              0x00000002U
#define SRT_NX51_xpic_break_status_hold              1
#define MSK_NX51_xpic_break_status_break0            0x00000004U
#define SRT_NX51_xpic_break_status_break0            2
#define MSK_NX51_xpic_break_status_break1            0x00000008U
#define SRT_NX51_xpic_break_status_break1            3
#define MSK_NX51_xpic_break_status_soft_break        0x00000010U
#define SRT_NX51_xpic_break_status_soft_break        4
#define MSK_NX51_xpic_break_status_single_step       0x00000020U
#define SRT_NX51_xpic_break_status_single_step       5
#define MSK_NX51_xpic_break_status_data_misalignment 0x00000040U
#define SRT_NX51_xpic_break_status_data_misalignment 6
#define MSK_NX51_xpic_break_status_break0_read_data  0x00000080U
#define SRT_NX51_xpic_break_status_break0_read_data  7
#define MSK_NX51_xpic_break_status_break1_read_data  0x00000100U
#define SRT_NX51_xpic_break_status_break1_read_data  8
#define MSK_NX51_xpic_break_status_xpic_reset_status 0x00000200U
#define SRT_NX51_xpic_break_status_xpic_reset_status 9

/* all used bits of 'NX51_xpic_break_status': */
#define MSK_USED_BITS_NX51_xpic_break_status 0x000003ffU

enum {
	BFW_NX51_xpic_break_status_xpic_in_hold      = 1,  /* [0] */
	BFW_NX51_xpic_break_status_hold              = 1,  /* [1] */
	BFW_NX51_xpic_break_status_break0            = 1,  /* [2] */
	BFW_NX51_xpic_break_status_break1            = 1,  /* [3] */
	BFW_NX51_xpic_break_status_soft_break        = 1,  /* [4] */
	BFW_NX51_xpic_break_status_single_step       = 1,  /* [5] */
	BFW_NX51_xpic_break_status_data_misalignment = 1,  /* [6] */
	BFW_NX51_xpic_break_status_break0_read_data  = 1,  /* [7] */
	BFW_NX51_xpic_break_status_break1_read_data  = 1,  /* [8] */
	BFW_NX51_xpic_break_status_xpic_reset_status = 1,  /* [9] */
	BFW_NX51_xpic_break_status_reserved1         = 22  /* [31:10] */
};

typedef struct NX51_XPIC_BREAK_STATUS_BIT_Ttag {
	unsigned int xpic_in_hold      : BFW_NX51_xpic_break_status_xpic_in_hold;      /* xPIC is in Break or Hold (read only)                           */
	unsigned int hold              : BFW_NX51_xpic_break_status_hold;              /* global HOLD BIT status 0- start xPIC, 1- hold xPIC (read only) */
	unsigned int break0            : BFW_NX51_xpic_break_status_break0;            /* Breakpoint 0 is active(read only)                              */
	unsigned int break1            : BFW_NX51_xpic_break_status_break1;            /* Breakpoint 1 is active(read only)                              */
	unsigned int soft_break        : BFW_NX51_xpic_break_status_soft_break;        /* Software Break is active(read only)                            */
	unsigned int single_step       : BFW_NX51_xpic_break_status_single_step;       /* Single Step Break is active(read only)                         */
	unsigned int data_misalignment : BFW_NX51_xpic_break_status_data_misalignment; /* Data Misaligment is active(read only)                          */
	unsigned int break0_read_data  : BFW_NX51_xpic_break_status_break0_read_data;  /* Breakpoint 0 last load access (read only)                      */
	unsigned int break1_read_data  : BFW_NX51_xpic_break_status_break1_read_data;  /* Breakpoint 1 last load access (read only)                      */
	unsigned int xpic_reset_status : BFW_NX51_xpic_break_status_xpic_reset_status; /* 1 = XPIC ist in Reset(read only)                               */
	unsigned int reserved1         : BFW_NX51_xpic_break_status_reserved1;         /* reserved                                                       */
} NX51_XPIC_BREAK_STATUS_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_XPIC_BREAK_STATUS_BIT_T bf;
} NX51_XPIC_BREAK_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_raw */
/* => xPIC_DEBUG Raw IRQ register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_irq_raw        0x0000003CU
#define Adr_NX51_xpic_debug_xpic_break_irq_raw 0x1018C4BCU
#define Adr_NX51_xpic_break_irq_raw            0x1018C4BCU
#define DFLT_VAL_NX51_xpic_break_irq_raw       0x00000000U

#define MSK_NX51_xpic_break_irq_raw_break0_irq               0x00000001U
#define SRT_NX51_xpic_break_irq_raw_break0_irq               0
#define DFLT_VAL_NX51_xpic_break_irq_raw_break0_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_raw_break0_irq       0x00000000U
#define MSK_NX51_xpic_break_irq_raw_break1_irq               0x00000002U
#define SRT_NX51_xpic_break_irq_raw_break1_irq               1
#define DFLT_VAL_NX51_xpic_break_irq_raw_break1_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_raw_break1_irq       0x00000000U
#define MSK_NX51_xpic_break_irq_raw_soft_break_irq           0x00000004U
#define SRT_NX51_xpic_break_irq_raw_soft_break_irq           2
#define DFLT_VAL_NX51_xpic_break_irq_raw_soft_break_irq      0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_raw_soft_break_irq   0x00000000U
#define MSK_NX51_xpic_break_irq_raw_single_step_irq          0x00000008U
#define SRT_NX51_xpic_break_irq_raw_single_step_irq          3
#define DFLT_VAL_NX51_xpic_break_irq_raw_single_step_irq     0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_raw_single_step_irq  0x00000000U
#define MSK_NX51_xpic_break_irq_raw_misalignment_irq         0x00000010U
#define SRT_NX51_xpic_break_irq_raw_misalignment_irq         4
#define DFLT_VAL_NX51_xpic_break_irq_raw_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_raw_misalignment_irq 0x00000000U

/* all used bits of 'NX51_xpic_break_irq_raw': */
#define MSK_USED_BITS_NX51_xpic_break_irq_raw 0x0000001fU

enum {
	BFW_NX51_xpic_break_irq_raw_break0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_break_irq_raw_break1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_break_irq_raw_soft_break_irq   = 1,  /* [2] */
	BFW_NX51_xpic_break_irq_raw_single_step_irq  = 1,  /* [3] */
	BFW_NX51_xpic_break_irq_raw_misalignment_irq = 1,  /* [4] */
	BFW_NX51_xpic_break_irq_raw_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_BREAK_IRQ_RAW_BIT_Ttag {
	unsigned int break0_irq       : BFW_NX51_xpic_break_irq_raw_break0_irq;       /* Breakpoint 0 Interrupt            */
	unsigned int break1_irq       : BFW_NX51_xpic_break_irq_raw_break1_irq;       /* Breakpoint 1 Interrupt            */
	unsigned int soft_break_irq   : BFW_NX51_xpic_break_irq_raw_soft_break_irq;   /* Software Breakpoint Interrupt     */
	unsigned int single_step_irq  : BFW_NX51_xpic_break_irq_raw_single_step_irq;  /* single step Breakpoint Interrupt  */
	unsigned int misalignment_irq : BFW_NX51_xpic_break_irq_raw_misalignment_irq; /* Data Misalignment Error Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_break_irq_raw_reserved1;        /* reserved                          */
} NX51_XPIC_BREAK_IRQ_RAW_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XPIC_BREAK_IRQ_RAW_BIT_T bf;
} NX51_XPIC_BREAK_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_masked */
/* => xPIC_DEBUG Masked IRQ register for other CPU (ARM): */
/*    Shows status of masked IRQs (as connected to ARM) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_irq_masked        0x00000040U
#define Adr_NX51_xpic_debug_xpic_break_irq_masked 0x1018C4C0U
#define Adr_NX51_xpic_break_irq_masked            0x1018C4C0U

#define MSK_NX51_xpic_break_irq_masked_break0_irq       0x00000001U
#define SRT_NX51_xpic_break_irq_masked_break0_irq       0
#define MSK_NX51_xpic_break_irq_masked_break1_irq       0x00000002U
#define SRT_NX51_xpic_break_irq_masked_break1_irq       1
#define MSK_NX51_xpic_break_irq_masked_soft_break_irq   0x00000004U
#define SRT_NX51_xpic_break_irq_masked_soft_break_irq   2
#define MSK_NX51_xpic_break_irq_masked_single_step_irq  0x00000008U
#define SRT_NX51_xpic_break_irq_masked_single_step_irq  3
#define MSK_NX51_xpic_break_irq_masked_misalignment_irq 0x00000010U
#define SRT_NX51_xpic_break_irq_masked_misalignment_irq 4

/* all used bits of 'NX51_xpic_break_irq_masked': */
#define MSK_USED_BITS_NX51_xpic_break_irq_masked 0x0000001fU

enum {
	BFW_NX51_xpic_break_irq_masked_break0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_break_irq_masked_break1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_break_irq_masked_soft_break_irq   = 1,  /* [2] */
	BFW_NX51_xpic_break_irq_masked_single_step_irq  = 1,  /* [3] */
	BFW_NX51_xpic_break_irq_masked_misalignment_irq = 1,  /* [4] */
	BFW_NX51_xpic_break_irq_masked_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_BREAK_IRQ_MASKED_BIT_Ttag {
	unsigned int break0_irq       : BFW_NX51_xpic_break_irq_masked_break0_irq;       /* Breakpoint 0 Interrupt            */
	unsigned int break1_irq       : BFW_NX51_xpic_break_irq_masked_break1_irq;       /* Breakpoint 1 Interrupt            */
	unsigned int soft_break_irq   : BFW_NX51_xpic_break_irq_masked_soft_break_irq;   /* Software Breakpoint Interrupt     */
	unsigned int single_step_irq  : BFW_NX51_xpic_break_irq_masked_single_step_irq;  /* single step Breakpoint Interrupt  */
	unsigned int misalignment_irq : BFW_NX51_xpic_break_irq_masked_misalignment_irq; /* Data Misalignment Error Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_break_irq_masked_reserved1;        /* reserved                          */
} NX51_XPIC_BREAK_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_XPIC_BREAK_IRQ_MASKED_BIT_T bf;
} NX51_XPIC_BREAK_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_msk_set */
/* => xPIC_DEBUG interrupt mask set for other CPU (ARM): */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to xpic_break_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_irq_msk_set        0x00000044U
#define Adr_NX51_xpic_debug_xpic_break_irq_msk_set 0x1018C4C4U
#define Adr_NX51_xpic_break_irq_msk_set            0x1018C4C4U
#define DFLT_VAL_NX51_xpic_break_irq_msk_set       0x00000000U

#define MSK_NX51_xpic_break_irq_msk_set_break0_irq               0x00000001U
#define SRT_NX51_xpic_break_irq_msk_set_break0_irq               0
#define DFLT_VAL_NX51_xpic_break_irq_msk_set_break0_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_set_break0_irq       0x00000000U
#define MSK_NX51_xpic_break_irq_msk_set_break1_irq               0x00000002U
#define SRT_NX51_xpic_break_irq_msk_set_break1_irq               1
#define DFLT_VAL_NX51_xpic_break_irq_msk_set_break1_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_set_break1_irq       0x00000000U
#define MSK_NX51_xpic_break_irq_msk_set_soft_break_irq           0x00000004U
#define SRT_NX51_xpic_break_irq_msk_set_soft_break_irq           2
#define DFLT_VAL_NX51_xpic_break_irq_msk_set_soft_break_irq      0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_set_soft_break_irq   0x00000000U
#define MSK_NX51_xpic_break_irq_msk_set_single_step_irq          0x00000008U
#define SRT_NX51_xpic_break_irq_msk_set_single_step_irq          3
#define DFLT_VAL_NX51_xpic_break_irq_msk_set_single_step_irq     0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_set_single_step_irq  0x00000000U
#define MSK_NX51_xpic_break_irq_msk_set_misalignment_irq         0x00000010U
#define SRT_NX51_xpic_break_irq_msk_set_misalignment_irq         4
#define DFLT_VAL_NX51_xpic_break_irq_msk_set_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_set_misalignment_irq 0x00000000U

/* all used bits of 'NX51_xpic_break_irq_msk_set': */
#define MSK_USED_BITS_NX51_xpic_break_irq_msk_set 0x0000001fU

enum {
	BFW_NX51_xpic_break_irq_msk_set_break0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_break_irq_msk_set_break1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_break_irq_msk_set_soft_break_irq   = 1,  /* [2] */
	BFW_NX51_xpic_break_irq_msk_set_single_step_irq  = 1,  /* [3] */
	BFW_NX51_xpic_break_irq_msk_set_misalignment_irq = 1,  /* [4] */
	BFW_NX51_xpic_break_irq_msk_set_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_BREAK_IRQ_MSK_SET_BIT_Ttag {
	unsigned int break0_irq       : BFW_NX51_xpic_break_irq_msk_set_break0_irq;       /* Breakpoint 0 Interrupt            */
	unsigned int break1_irq       : BFW_NX51_xpic_break_irq_msk_set_break1_irq;       /* Breakpoint 1 Interrupt            */
	unsigned int soft_break_irq   : BFW_NX51_xpic_break_irq_msk_set_soft_break_irq;   /* Software Breakpoint Interrupt     */
	unsigned int single_step_irq  : BFW_NX51_xpic_break_irq_msk_set_single_step_irq;  /* single step Breakpoint Interrupt  */
	unsigned int misalignment_irq : BFW_NX51_xpic_break_irq_msk_set_misalignment_irq; /* Data Misalignment Error Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_break_irq_msk_set_reserved1;        /* reserved                          */
} NX51_XPIC_BREAK_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_XPIC_BREAK_IRQ_MSK_SET_BIT_T bf;
} NX51_XPIC_BREAK_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_irq_msk_reset */
/* => xPIC_DEBUG interrupt mask reset for other CPU (ARM): */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_irq_msk_reset        0x00000048U
#define Adr_NX51_xpic_debug_xpic_break_irq_msk_reset 0x1018C4C8U
#define Adr_NX51_xpic_break_irq_msk_reset            0x1018C4C8U
#define DFLT_VAL_NX51_xpic_break_irq_msk_reset       0x00000000U

#define MSK_NX51_xpic_break_irq_msk_reset_break0_irq               0x00000001U
#define SRT_NX51_xpic_break_irq_msk_reset_break0_irq               0
#define DFLT_VAL_NX51_xpic_break_irq_msk_reset_break0_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_reset_break0_irq       0x00000000U
#define MSK_NX51_xpic_break_irq_msk_reset_break1_irq               0x00000002U
#define SRT_NX51_xpic_break_irq_msk_reset_break1_irq               1
#define DFLT_VAL_NX51_xpic_break_irq_msk_reset_break1_irq          0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_reset_break1_irq       0x00000000U
#define MSK_NX51_xpic_break_irq_msk_reset_soft_break_irq           0x00000004U
#define SRT_NX51_xpic_break_irq_msk_reset_soft_break_irq           2
#define DFLT_VAL_NX51_xpic_break_irq_msk_reset_soft_break_irq      0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_reset_soft_break_irq   0x00000000U
#define MSK_NX51_xpic_break_irq_msk_reset_single_step_irq          0x00000008U
#define SRT_NX51_xpic_break_irq_msk_reset_single_step_irq          3
#define DFLT_VAL_NX51_xpic_break_irq_msk_reset_single_step_irq     0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_reset_single_step_irq  0x00000000U
#define MSK_NX51_xpic_break_irq_msk_reset_misalignment_irq         0x00000010U
#define SRT_NX51_xpic_break_irq_msk_reset_misalignment_irq         4
#define DFLT_VAL_NX51_xpic_break_irq_msk_reset_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_irq_msk_reset_misalignment_irq 0x00000000U

/* all used bits of 'NX51_xpic_break_irq_msk_reset': */
#define MSK_USED_BITS_NX51_xpic_break_irq_msk_reset 0x0000001fU

enum {
	BFW_NX51_xpic_break_irq_msk_reset_break0_irq       = 1,  /* [0] */
	BFW_NX51_xpic_break_irq_msk_reset_break1_irq       = 1,  /* [1] */
	BFW_NX51_xpic_break_irq_msk_reset_soft_break_irq   = 1,  /* [2] */
	BFW_NX51_xpic_break_irq_msk_reset_single_step_irq  = 1,  /* [3] */
	BFW_NX51_xpic_break_irq_msk_reset_misalignment_irq = 1,  /* [4] */
	BFW_NX51_xpic_break_irq_msk_reset_reserved1        = 27  /* [31:5] */
};

typedef struct NX51_XPIC_BREAK_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int break0_irq       : BFW_NX51_xpic_break_irq_msk_reset_break0_irq;       /* Breakpoint 0 Interrupt            */
	unsigned int break1_irq       : BFW_NX51_xpic_break_irq_msk_reset_break1_irq;       /* Breakpoint 1 Interrupt            */
	unsigned int soft_break_irq   : BFW_NX51_xpic_break_irq_msk_reset_soft_break_irq;   /* Software Breakpoint Interrupt     */
	unsigned int single_step_irq  : BFW_NX51_xpic_break_irq_msk_reset_single_step_irq;  /* single step Breakpoint Interrupt  */
	unsigned int misalignment_irq : BFW_NX51_xpic_break_irq_msk_reset_misalignment_irq; /* Data Misalignment Error Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_break_irq_msk_reset_reserved1;        /* reserved                          */
} NX51_XPIC_BREAK_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_BREAK_IRQ_MSK_RESET_BIT_T bf;
} NX51_XPIC_BREAK_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_own_irq_masked */
/* => xPIC_DEBUG own Masked IRQ register (for xPIC): */
/*    Shows status of masked IRQs (as connected to xPIC) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_own_irq_masked        0x0000004CU
#define Adr_NX51_xpic_debug_xpic_break_own_irq_masked 0x1018C4CCU
#define Adr_NX51_xpic_break_own_irq_masked            0x1018C4CCU

#define MSK_NX51_xpic_break_own_irq_masked_misalignment_irq 0x00000001U
#define SRT_NX51_xpic_break_own_irq_masked_misalignment_irq 0

/* all used bits of 'NX51_xpic_break_own_irq_masked': */
#define MSK_USED_BITS_NX51_xpic_break_own_irq_masked 0x00000001U

enum {
	BFW_NX51_xpic_break_own_irq_masked_misalignment_irq = 1,  /* [0] */
	BFW_NX51_xpic_break_own_irq_masked_reserved1        = 31  /* [31:1] */
};

typedef struct NX51_XPIC_BREAK_OWN_IRQ_MASKED_BIT_Ttag {
	unsigned int misalignment_irq : BFW_NX51_xpic_break_own_irq_masked_misalignment_irq; /* Data Misalignment Error Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_break_own_irq_masked_reserved1;        /* reserved                          */
} NX51_XPIC_BREAK_OWN_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_XPIC_BREAK_OWN_IRQ_MASKED_BIT_T bf;
} NX51_XPIC_BREAK_OWN_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_own_irq_msk_set */
/* => xPIC_DEBUG own interrupt mask set (for xPIC): */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to xpic_break_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_own_irq_msk_set        0x00000050U
#define Adr_NX51_xpic_debug_xpic_break_own_irq_msk_set 0x1018C4D0U
#define Adr_NX51_xpic_break_own_irq_msk_set            0x1018C4D0U
#define DFLT_VAL_NX51_xpic_break_own_irq_msk_set       0x00000000U

#define MSK_NX51_xpic_break_own_irq_msk_set_misalignment_irq         0x00000001U
#define SRT_NX51_xpic_break_own_irq_msk_set_misalignment_irq         0
#define DFLT_VAL_NX51_xpic_break_own_irq_msk_set_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_own_irq_msk_set_misalignment_irq 0x00000000U

/* all used bits of 'NX51_xpic_break_own_irq_msk_set': */
#define MSK_USED_BITS_NX51_xpic_break_own_irq_msk_set 0x00000001U

enum {
	BFW_NX51_xpic_break_own_irq_msk_set_misalignment_irq = 1,  /* [0] */
	BFW_NX51_xpic_break_own_irq_msk_set_reserved1        = 31  /* [31:1] */
};

typedef struct NX51_XPIC_BREAK_OWN_IRQ_MSK_SET_BIT_Ttag {
	unsigned int misalignment_irq : BFW_NX51_xpic_break_own_irq_msk_set_misalignment_irq; /* Data Misalignment Error Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_break_own_irq_msk_set_reserved1;        /* reserved                          */
} NX51_XPIC_BREAK_OWN_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                          val;
	NX51_XPIC_BREAK_OWN_IRQ_MSK_SET_BIT_T bf;
} NX51_XPIC_BREAK_OWN_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_own_irq_msk_reset */
/* => xPIC_DEBUG own interrupt mask reset (for XPIC): */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_own_irq_msk_reset        0x00000054U
#define Adr_NX51_xpic_debug_xpic_break_own_irq_msk_reset 0x1018C4D4U
#define Adr_NX51_xpic_break_own_irq_msk_reset            0x1018C4D4U
#define DFLT_VAL_NX51_xpic_break_own_irq_msk_reset       0x00000000U

#define MSK_NX51_xpic_break_own_irq_msk_reset_misalignment_irq         0x00000001U
#define SRT_NX51_xpic_break_own_irq_msk_reset_misalignment_irq         0
#define DFLT_VAL_NX51_xpic_break_own_irq_msk_reset_misalignment_irq    0x00000000U
#define DFLT_BF_VAL_NX51_xpic_break_own_irq_msk_reset_misalignment_irq 0x00000000U

/* all used bits of 'NX51_xpic_break_own_irq_msk_reset': */
#define MSK_USED_BITS_NX51_xpic_break_own_irq_msk_reset 0x00000001U

enum {
	BFW_NX51_xpic_break_own_irq_msk_reset_misalignment_irq = 1,  /* [0] */
	BFW_NX51_xpic_break_own_irq_msk_reset_reserved1        = 31  /* [31:1] */
};

typedef struct NX51_XPIC_BREAK_OWN_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int misalignment_irq : BFW_NX51_xpic_break_own_irq_msk_reset_misalignment_irq; /* Data Misalignment Error Interrupt */
	unsigned int reserved1        : BFW_NX51_xpic_break_own_irq_msk_reset_reserved1;        /* reserved                          */
} NX51_XPIC_BREAK_OWN_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                            val;
	NX51_XPIC_BREAK_OWN_IRQ_MSK_RESET_BIT_T bf;
} NX51_XPIC_BREAK_OWN_IRQ_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_return_fiq_pc */
/* => xPIC_DEBUG information FIQ return PC value */
/*    valid if xPIC is in FIQ */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_return_fiq_pc        0x00000058U
#define Adr_NX51_xpic_debug_xpic_break_return_fiq_pc 0x1018C4D8U
#define Adr_NX51_xpic_break_return_fiq_pc            0x1018C4D8U

#define MSK_NX51_xpic_break_return_fiq_pc_val 0xffffffffU
#define SRT_NX51_xpic_break_return_fiq_pc_val 0

/* all used bits of 'NX51_xpic_break_return_fiq_pc': */
#define MSK_USED_BITS_NX51_xpic_break_return_fiq_pc 0xffffffffU

enum {
	BFW_NX51_xpic_break_return_fiq_pc_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK_RETURN_FIQ_PC_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break_return_fiq_pc_val; /* xPIC FIQ return value */
} NX51_XPIC_BREAK_RETURN_FIQ_PC_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_BREAK_RETURN_FIQ_PC_BIT_T bf;
} NX51_XPIC_BREAK_RETURN_FIQ_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_break_return_irq_pc */
/* => xPIC_DEBUG information last IRQ return PC value */
/*    valid if xPIC is in IRQ */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_break_return_irq_pc        0x0000005CU
#define Adr_NX51_xpic_debug_xpic_break_return_irq_pc 0x1018C4DCU
#define Adr_NX51_xpic_break_return_irq_pc            0x1018C4DCU

#define MSK_NX51_xpic_break_return_irq_pc_val 0xffffffffU
#define SRT_NX51_xpic_break_return_irq_pc_val 0

/* all used bits of 'NX51_xpic_break_return_irq_pc': */
#define MSK_USED_BITS_NX51_xpic_break_return_irq_pc 0xffffffffU

enum {
	BFW_NX51_xpic_break_return_irq_pc_val = 32  /* [31:0] */
};

typedef struct NX51_XPIC_BREAK_RETURN_IRQ_PC_BIT_Ttag {
	unsigned int val : BFW_NX51_xpic_break_return_irq_pc_val; /* xPIC last IRQ return value */
} NX51_XPIC_BREAK_RETURN_IRQ_PC_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_XPIC_BREAK_RETURN_IRQ_PC_BIT_T bf;
} NX51_XPIC_BREAK_RETURN_IRQ_PC_T;

/* --------------------------------------------------------------------- */
/* Register xpic_irq_status */
/* => Read access shows the xpic irq status and the xpic irq enable bits */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xpic_irq_status        0x00000060U
#define Adr_NX51_xpic_debug_xpic_irq_status 0x1018C4E0U
#define Adr_NX51_xpic_irq_status            0x1018C4E0U

#define MSK_NX51_xpic_irq_status_irq_status 0x00000001U
#define SRT_NX51_xpic_irq_status_irq_status 0
#define MSK_NX51_xpic_irq_status_fiq_status 0x00000002U
#define SRT_NX51_xpic_irq_status_fiq_status 1
#define MSK_NX51_xpic_irq_status_irq_enable 0x00000004U
#define SRT_NX51_xpic_irq_status_irq_enable 2
#define MSK_NX51_xpic_irq_status_fiq_enable 0x00000008U
#define SRT_NX51_xpic_irq_status_fiq_enable 3

/* all used bits of 'NX51_xpic_irq_status': */
#define MSK_USED_BITS_NX51_xpic_irq_status 0x0000000fU

enum {
	BFW_NX51_xpic_irq_status_irq_status = 1,  /* [0] */
	BFW_NX51_xpic_irq_status_fiq_status = 1,  /* [1] */
	BFW_NX51_xpic_irq_status_irq_enable = 1,  /* [2] */
	BFW_NX51_xpic_irq_status_fiq_enable = 1,  /* [3] */
	BFW_NX51_xpic_irq_status_reserved1  = 28  /* [31:4] */
};

typedef struct NX51_XPIC_IRQ_STATUS_BIT_Ttag {
	unsigned int irq_status : BFW_NX51_xpic_irq_status_irq_status; /* IRQ status     */
	unsigned int fiq_status : BFW_NX51_xpic_irq_status_fiq_status; /* FIQ status     */
	unsigned int irq_enable : BFW_NX51_xpic_irq_status_irq_enable; /* IRQ enable bit */
	unsigned int fiq_enable : BFW_NX51_xpic_irq_status_fiq_enable; /* FIQ enable bit */
	unsigned int reserved1  : BFW_NX51_xpic_irq_status_reserved1;  /* reserved       */
} NX51_XPIC_IRQ_STATUS_BIT_T;

typedef union {
	unsigned int               val;
	NX51_XPIC_IRQ_STATUS_BIT_T bf;
} NX51_XPIC_IRQ_STATUS_T;


/* ===================================================================== */

/* AREA int_phy_ctrl */
/* Area of int_phy_ctrl0, int_phy_ctrl1 */

/* ===================================================================== */

#define Addr_NX51_int_phy_ctrl0 0x1018C500U
#define Addr_NX51_int_phy_ctrl1 0x1018C510U

/* --------------------------------------------------------------------- */
/* Register int_phy_ctrl_miimu */
/* => MDIO FSM interface controlling for netX internal PHY. */
/*    Note: */
/*       Function is similar to old MIIMU unit register 'miimu_reg'. */
/*    Note: */
/*       MDC period changed from 800/400ns to 400/220ns since netx51. */
/*    Note: */
/*       Loopback for purpose is provided by miimu_sw register and also performed */
/*       in non-software-mode when enabled. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_int_phy_ctrl_miimu           0x00000000U
#define Adr_NX51_int_phy_ctrl0_int_phy_ctrl_miimu 0x1018C500U
#define Adr_NX51_int_phy_ctrl1_int_phy_ctrl_miimu 0x1018C510U
#define DFLT_VAL_NX51_int_phy_ctrl_miimu          0x00000000U

#define MSK_NX51_int_phy_ctrl_miimu_snrdy              0x00000001U
#define SRT_NX51_int_phy_ctrl_miimu_snrdy              0
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_snrdy         0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_snrdy      0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_preamble           0x00000002U
#define SRT_NX51_int_phy_ctrl_miimu_preamble           1
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_preamble      0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_preamble   0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_opmode             0x00000004U
#define SRT_NX51_int_phy_ctrl_miimu_opmode             2
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_opmode        0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_opmode     0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_mdc_period         0x00000008U
#define SRT_NX51_int_phy_ctrl_miimu_mdc_period         3
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_mdc_period    0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_mdc_period 0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_rta                0x00000020U
#define SRT_NX51_int_phy_ctrl_miimu_rta                5
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_rta           0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_rta        0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_regaddr            0x000007c0U
#define SRT_NX51_int_phy_ctrl_miimu_regaddr            6
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_regaddr       0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_regaddr    0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_phyaddr            0x0000f800U
#define SRT_NX51_int_phy_ctrl_miimu_phyaddr            11
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_phyaddr       0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_phyaddr    0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_data               0xffff0000U
#define SRT_NX51_int_phy_ctrl_miimu_data               16
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_data          0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_data       0x00000000U

/* all used bits of 'NX51_int_phy_ctrl_miimu': */
#define MSK_USED_BITS_NX51_int_phy_ctrl_miimu 0xffffffefU

enum {
	BFW_NX51_int_phy_ctrl_miimu_snrdy      = 1,  /* [0] */
	BFW_NX51_int_phy_ctrl_miimu_preamble   = 1,  /* [1] */
	BFW_NX51_int_phy_ctrl_miimu_opmode     = 1,  /* [2] */
	BFW_NX51_int_phy_ctrl_miimu_mdc_period = 1,  /* [3] */
	BFW_NX51_int_phy_ctrl_miimu_reserved1  = 1,  /* [4] */
	BFW_NX51_int_phy_ctrl_miimu_rta        = 1,  /* [5] */
	BFW_NX51_int_phy_ctrl_miimu_regaddr    = 5,  /* [10:6] */
	BFW_NX51_int_phy_ctrl_miimu_phyaddr    = 5,  /* [15:11] */
	BFW_NX51_int_phy_ctrl_miimu_data       = 16  /* [31:16] */
};

typedef struct NX51_INT_PHY_CTRL_MIIMU_BIT_Ttag {
	unsigned int snrdy      : BFW_NX51_int_phy_ctrl_miimu_snrdy;      /* Start not ready                                                              */
	unsigned int preamble   : BFW_NX51_int_phy_ctrl_miimu_preamble;   /* Send preamble                                                                */
	unsigned int opmode     : BFW_NX51_int_phy_ctrl_miimu_opmode;     /* Operation mode:                                                              */
	                                                                  /* 0: read                                                                      */
	                                                                  /* 1: write                                                                     */
	unsigned int mdc_period : BFW_NX51_int_phy_ctrl_miimu_mdc_period; /* MDC period:                                                                  */
	                                                                  /* 0: 220ns                                                                     */
	                                                                  /* 1: 400ns                                                                     */
	                                                                  /* Note:                                                                        */
	                                                                  /*    Renesas PHY MDIO clock frequency is specified 5MHz max. However           */
	                                                                  /*    set MDIO clock period to 220ns to guarante function under all conditions. */
	unsigned int reserved1  : BFW_NX51_int_phy_ctrl_miimu_reserved1;  /* reserved                                                                     */
	unsigned int rta        : BFW_NX51_int_phy_ctrl_miimu_rta;        /* Read Turn Around field:                                                      */
	                                                                  /* 0: one bit                                                                   */
	                                                                  /* 1: two bits                                                                  */
	unsigned int regaddr    : BFW_NX51_int_phy_ctrl_miimu_regaddr;    /* Register address                                                             */
	unsigned int phyaddr    : BFW_NX51_int_phy_ctrl_miimu_phyaddr;    /* PHY address                                                                  */
	unsigned int data       : BFW_NX51_int_phy_ctrl_miimu_data;       /* Data to or from PHY register                                                 */
} NX51_INT_PHY_CTRL_MIIMU_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_INT_PHY_CTRL_MIIMU_BIT_T bf;
} NX51_INT_PHY_CTRL_MIIMU_T;

/* --------------------------------------------------------------------- */
/* Register int_phy_ctrl_miimu_sw */
/* => MDIO software interface controlling for netX internal PHY. */
/*    Note: */
/*       Function is similar to old MIIMU unit register 'miimu_sw', however data output */
/*       enable was removed as it is not necessary for MDIO interface to internal PHY (due */
/*       to non-bidirectional data signal). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_int_phy_ctrl_miimu_sw           0x00000004U
#define Adr_NX51_int_phy_ctrl0_int_phy_ctrl_miimu_sw 0x1018C504U
#define Adr_NX51_int_phy_ctrl1_int_phy_ctrl_miimu_sw 0x1018C514U
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_sw          0x00000000U

#define MSK_NX51_int_phy_ctrl_miimu_sw_enable           0x00000001U
#define SRT_NX51_int_phy_ctrl_miimu_sw_enable           0
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_sw_enable      0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_sw_enable   0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_sw_mdc              0x00000010U
#define SRT_NX51_int_phy_ctrl_miimu_sw_mdc              4
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_sw_mdc         0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_sw_mdc      0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_sw_mdo              0x00000020U
#define SRT_NX51_int_phy_ctrl_miimu_sw_mdo              5
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_sw_mdo         0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_sw_mdo      0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_sw_mdi_ro           0x00000080U
#define SRT_NX51_int_phy_ctrl_miimu_sw_mdi_ro           7
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_sw_mdi_ro      0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_sw_mdi_ro   0x00000000U
#define MSK_NX51_int_phy_ctrl_miimu_sw_loopback         0x00000100U
#define SRT_NX51_int_phy_ctrl_miimu_sw_loopback         8
#define DFLT_VAL_NX51_int_phy_ctrl_miimu_sw_loopback    0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_miimu_sw_loopback 0x00000000U

/* all used bits of 'NX51_int_phy_ctrl_miimu_sw': */
#define MSK_USED_BITS_NX51_int_phy_ctrl_miimu_sw 0x000001b1U

enum {
	BFW_NX51_int_phy_ctrl_miimu_sw_enable    = 1,  /* [0] */
	BFW_NX51_int_phy_ctrl_miimu_sw_reserved1 = 3,  /* [3:1] */
	BFW_NX51_int_phy_ctrl_miimu_sw_mdc       = 1,  /* [4] */
	BFW_NX51_int_phy_ctrl_miimu_sw_mdo       = 1,  /* [5] */
	BFW_NX51_int_phy_ctrl_miimu_sw_reserved2 = 1,  /* [6] */
	BFW_NX51_int_phy_ctrl_miimu_sw_mdi_ro    = 1,  /* [7] */
	BFW_NX51_int_phy_ctrl_miimu_sw_loopback  = 1,  /* [8] */
	BFW_NX51_int_phy_ctrl_miimu_sw_reserved3 = 23  /* [31:9] */
};

typedef struct NX51_INT_PHY_CTRL_MIIMU_SW_BIT_Ttag {
	unsigned int enable    : BFW_NX51_int_phy_ctrl_miimu_sw_enable;    /* Enables software mode:                                      */
	                                                                   /* MDC, MDO and MDOE are set by software.                      */
	unsigned int reserved1 : BFW_NX51_int_phy_ctrl_miimu_sw_reserved1; /* reserved                                                    */
	unsigned int mdc       : BFW_NX51_int_phy_ctrl_miimu_sw_mdc;       /* MDC value for software mode                                 */
	unsigned int mdo       : BFW_NX51_int_phy_ctrl_miimu_sw_mdo;       /* MDO value for software mode                                 */
	unsigned int reserved2 : BFW_NX51_int_phy_ctrl_miimu_sw_reserved2; /* reserved                                                    */
	unsigned int mdi_ro    : BFW_NX51_int_phy_ctrl_miimu_sw_mdi_ro;    /* current MDI value                                           */
	unsigned int loopback  : BFW_NX51_int_phy_ctrl_miimu_sw_loopback;  /* MDIO-data-out to data-in loopback for test purpose.         */
	                                                                   /* 0: no loopback, MDIO-data-in comes from internal PHY.       */
	                                                                   /* 1: loopback, MDIO-data-in comes from current MDIO-data-out. */
	                                                                   /* Note:                                                       */
	                                                                   /*    Loopback can also be used in non-software-mode.          */
	unsigned int reserved3 : BFW_NX51_int_phy_ctrl_miimu_sw_reserved3; /* reserved                                                    */
} NX51_INT_PHY_CTRL_MIIMU_SW_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_INT_PHY_CTRL_MIIMU_SW_BIT_T bf;
} NX51_INT_PHY_CTRL_MIIMU_SW_T;

/* --------------------------------------------------------------------- */
/* Register int_phy_ctrl_led */
/* => PHY0 LED config and status register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_int_phy_ctrl_led           0x00000008U
#define Adr_NX51_int_phy_ctrl0_int_phy_ctrl_led 0x1018C508U
#define Adr_NX51_int_phy_ctrl1_int_phy_ctrl_led 0x1018C518U
#define DFLT_VAL_NX51_int_phy_ctrl_led          0x00004000U

#define MSK_NX51_int_phy_ctrl_led_rx_active_ro         0x00000001U
#define SRT_NX51_int_phy_ctrl_led_rx_active_ro         0
#define DFLT_VAL_NX51_int_phy_ctrl_led_rx_active_ro    0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_rx_active_ro 0x00000000U
#define MSK_NX51_int_phy_ctrl_led_tx_active_ro         0x00000002U
#define SRT_NX51_int_phy_ctrl_led_tx_active_ro         1
#define DFLT_VAL_NX51_int_phy_ctrl_led_tx_active_ro    0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_tx_active_ro 0x00000000U
#define MSK_NX51_int_phy_ctrl_led_duplex_ro            0x00000004U
#define SRT_NX51_int_phy_ctrl_led_duplex_ro            2
#define DFLT_VAL_NX51_int_phy_ctrl_led_duplex_ro       0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_duplex_ro    0x00000000U
#define MSK_NX51_int_phy_ctrl_led_link_ro              0x00000008U
#define SRT_NX51_int_phy_ctrl_led_link_ro              3
#define DFLT_VAL_NX51_int_phy_ctrl_led_link_ro         0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_link_ro      0x00000000U
#define MSK_NX51_int_phy_ctrl_led_speed10_ro           0x00000010U
#define SRT_NX51_int_phy_ctrl_led_speed10_ro           4
#define DFLT_VAL_NX51_int_phy_ctrl_led_speed10_ro      0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_speed10_ro   0x00000000U
#define MSK_NX51_int_phy_ctrl_led_speed100_ro          0x00000020U
#define SRT_NX51_int_phy_ctrl_led_speed100_ro          5
#define DFLT_VAL_NX51_int_phy_ctrl_led_speed100_ro     0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_speed100_ro  0x00000000U
#define MSK_NX51_int_phy_ctrl_led_led0                 0x00000040U
#define SRT_NX51_int_phy_ctrl_led_led0                 6
#define DFLT_VAL_NX51_int_phy_ctrl_led_led0            0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_led0         0x00000000U
#define MSK_NX51_int_phy_ctrl_led_led1                 0x00000080U
#define SRT_NX51_int_phy_ctrl_led_led1                 7
#define DFLT_VAL_NX51_int_phy_ctrl_led_led1            0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_led1         0x00000000U
#define MSK_NX51_int_phy_ctrl_led_mode                 0x00000300U
#define SRT_NX51_int_phy_ctrl_led_mode                 8
#define DFLT_VAL_NX51_int_phy_ctrl_led_mode            0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_mode         0x00000000U
#define MSK_NX51_int_phy_ctrl_led_interval             0x0000f000U
#define SRT_NX51_int_phy_ctrl_led_interval             12
#define DFLT_VAL_NX51_int_phy_ctrl_led_interval        0x00004000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_led_interval     0x00000004U

/* all used bits of 'NX51_int_phy_ctrl_led': */
#define MSK_USED_BITS_NX51_int_phy_ctrl_led 0x0000f3ffU

enum {
	BFW_NX51_int_phy_ctrl_led_rx_active_ro = 1,  /* [0] */
	BFW_NX51_int_phy_ctrl_led_tx_active_ro = 1,  /* [1] */
	BFW_NX51_int_phy_ctrl_led_duplex_ro    = 1,  /* [2] */
	BFW_NX51_int_phy_ctrl_led_link_ro      = 1,  /* [3] */
	BFW_NX51_int_phy_ctrl_led_speed10_ro   = 1,  /* [4] */
	BFW_NX51_int_phy_ctrl_led_speed100_ro  = 1,  /* [5] */
	BFW_NX51_int_phy_ctrl_led_led0         = 1,  /* [6] */
	BFW_NX51_int_phy_ctrl_led_led1         = 1,  /* [7] */
	BFW_NX51_int_phy_ctrl_led_mode         = 2,  /* [9:8] */
	BFW_NX51_int_phy_ctrl_led_reserved1    = 2,  /* [11:10] */
	BFW_NX51_int_phy_ctrl_led_interval     = 4,  /* [15:12] */
	BFW_NX51_int_phy_ctrl_led_reserved2    = 16  /* [31:16] */
};

typedef struct NX51_INT_PHY_CTRL_LED_BIT_Ttag {
	unsigned int rx_active_ro : BFW_NX51_int_phy_ctrl_led_rx_active_ro; /* Read only: Inverted state of low active PHY output PxRXLED.                                             */
	                                                                    /* It shows that CRS is active at receive.                                                                 */
	                                                                    /* When CRS becomes inactive, the signal output is extended by 128 ms.                                     */
	unsigned int tx_active_ro : BFW_NX51_int_phy_ctrl_led_tx_active_ro; /* Read only: Inverted state of low active PHY output PxTXLED.                                             */
	                                                                    /* It shows that CRS is active at transmit.                                                                */
	                                                                    /* When CRS becomes inactive, the signal output is extended by 128 ms.                                     */
	unsigned int duplex_ro    : BFW_NX51_int_phy_ctrl_led_duplex_ro;    /* Read only: Inverted state of low active PHY output PxDUPLEXLED.                                         */
	                                                                    /* It shows that link is operating in full-duplex mode.                                                    */
	unsigned int link_ro      : BFW_NX51_int_phy_ctrl_led_link_ro;      /* Read only: Inverted state of low active PHY output PxLINKLED.                                           */
	                                                                    /* It shows that PHY detects a valid link.                                                                 */
	unsigned int speed10_ro   : BFW_NX51_int_phy_ctrl_led_speed10_ro;   /* Read only: Inverted state of low active PHY output PxSPEED10LED.                                        */
	                                                                    /* It shows that operation speed is 10Mbps.                                                                */
	unsigned int speed100_ro  : BFW_NX51_int_phy_ctrl_led_speed100_ro;  /* Read only: Inverted state of low active PHY output PxSPEED100LED.                                       */
	                                                                    /* It shows that operation speed is 100Mbps or during Auto-Negotiation.                                    */
	                                                                    /* The signal will go inactive when operating  speed is 10Mbps or                                          */
	                                                                    /* during line isolation.                                                                                  */
	unsigned int led0         : BFW_NX51_int_phy_ctrl_led_led0;         /* Same as led1 for LED0.                                                                                  */
	unsigned int led1         : BFW_NX51_int_phy_ctrl_led_led1;         /* In mode '00' this bit can be used to control LED1 manually (0:off, 1:on).                               */
	                                                                    /* In other modes this bit is not writable and shows calculated signal from PHY_LED statemachine for LED1. */
	unsigned int mode         : BFW_NX51_int_phy_ctrl_led_mode;         /* flashing mode:                                                                                          */
	                                                                    /*  00: Disabled                                                                                           */
	                                                                    /*      LED0/1: programmable by led0,led1 bits. Default: Off.                                              */
	                                                                    /*  01: Static                                                                                             */
	                                                                    /*      LED0=PHY.link_status                                                                               */
	                                                                    /*      LED1=PHY.receive_activity | PHY.transmit_activity                                                  */
	                                                                    /*  10: Flashing                                                                                           */
	                                                                    /*      LED0=PHY.link                                                                                      */
	                                                                    /*      LED1=PHY.receive_activity | PHY.transmit_activity,                                                 */
	                                                                    /*      if (PHY.receive_activity | transmit_activity)==1 then LED1 is inverted in flash intervals).        */
	                                                                    /*  11: Combined                                                                                           */
	                                                                    /*      LED0=off: no link, LED0=on: link, no activity, LED0 toggeling: link, activity                      */
	                                                                    /*      LED1=off                                                                                           */
	                                                                    /* Note:                                                                                                   */
	                                                                    /*    On means high-driven.                                                                                */
	                                                                    /*    Off means low-driven.                                                                                */
	unsigned int reserved1    : BFW_NX51_int_phy_ctrl_led_reserved1;    /* reserved                                                                                                */
	unsigned int interval     : BFW_NX51_int_phy_ctrl_led_interval;     /* flashing interval in 10 ms steps, only valid in modes b10 and  b11                                      */
	                                                                    /* 0..15 = 10..160 ms                                                                                      */
	                                                                    /* Note:                                                                                                   */
	                                                                    /*    For simulation and test purpose interval step is 1us instead of 10ms when                            */
	                                                                    /*    quick_count is used.                                                                                 */
	unsigned int reserved2    : BFW_NX51_int_phy_ctrl_led_reserved2;    /* reserved                                                                                                */
} NX51_INT_PHY_CTRL_LED_BIT_T;

typedef union {
	unsigned int                val;
	NX51_INT_PHY_CTRL_LED_BIT_T bf;
} NX51_INT_PHY_CTRL_LED_T;

/* --------------------------------------------------------------------- */
/* Register int_phy_ctrl_enhanced_link_detection */
/* => Enhanced link detection config register: */
/*    Enhanced link detection is necessary with old PHYs, that do not support proper link down detection. */
/*    At these PHYs a broken link can be detected according to mii_rxerr signal. */
/*    New Renesas PHYs (Nephrite) should already support proper link detection. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_int_phy_ctrl_enhanced_link_detection           0x0000000CU
#define Adr_NX51_int_phy_ctrl0_int_phy_ctrl_enhanced_link_detection 0x1018C50CU
#define Adr_NX51_int_phy_ctrl1_int_phy_ctrl_enhanced_link_detection 0x1018C51CU
#define DFLT_VAL_NX51_int_phy_ctrl_enhanced_link_detection          0x00040030U

#define MSK_NX51_int_phy_ctrl_enhanced_link_detection_add                     0x0000001fU
#define SRT_NX51_int_phy_ctrl_enhanced_link_detection_add                     0
#define DFLT_VAL_NX51_int_phy_ctrl_enhanced_link_detection_add                0x00000010U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_enhanced_link_detection_add             0x00000010U
#define MSK_NX51_int_phy_ctrl_enhanced_link_detection_sub                     0x00000060U
#define SRT_NX51_int_phy_ctrl_enhanced_link_detection_sub                     5
#define DFLT_VAL_NX51_int_phy_ctrl_enhanced_link_detection_sub                0x00000020U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_enhanced_link_detection_sub             0x00000001U
#define MSK_NX51_int_phy_ctrl_enhanced_link_detection_threshold               0x0007ff80U
#define SRT_NX51_int_phy_ctrl_enhanced_link_detection_threshold               7
#define DFLT_VAL_NX51_int_phy_ctrl_enhanced_link_detection_threshold          0x00040000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_enhanced_link_detection_threshold       0x00000800U
#define MSK_NX51_int_phy_ctrl_enhanced_link_detection_counter_ro              0x7ff80000U
#define SRT_NX51_int_phy_ctrl_enhanced_link_detection_counter_ro              19
#define DFLT_VAL_NX51_int_phy_ctrl_enhanced_link_detection_counter_ro         0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_enhanced_link_detection_counter_ro      0x00000000U
#define MSK_NX51_int_phy_ctrl_enhanced_link_detection_eld_bad_link_ro         0x80000000U
#define SRT_NX51_int_phy_ctrl_enhanced_link_detection_eld_bad_link_ro         31
#define DFLT_VAL_NX51_int_phy_ctrl_enhanced_link_detection_eld_bad_link_ro    0x00000000U
#define DFLT_BF_VAL_NX51_int_phy_ctrl_enhanced_link_detection_eld_bad_link_ro 0x00000000U

/* all used bits of 'NX51_int_phy_ctrl_enhanced_link_detection': */
#define MSK_USED_BITS_NX51_int_phy_ctrl_enhanced_link_detection 0xffffffffU

enum {
	BFW_NX51_int_phy_ctrl_enhanced_link_detection_add             = 5,  /* [4:0] */
	BFW_NX51_int_phy_ctrl_enhanced_link_detection_sub             = 2,  /* [6:5] */
	BFW_NX51_int_phy_ctrl_enhanced_link_detection_threshold       = 12, /* [18:7] */
	BFW_NX51_int_phy_ctrl_enhanced_link_detection_counter_ro      = 12, /* [30:19] */
	BFW_NX51_int_phy_ctrl_enhanced_link_detection_eld_bad_link_ro = 1   /* [31] */
};

typedef struct NX51_INT_PHY_CTRL_ENHANCED_LINK_DETECTION_BIT_Ttag {
	unsigned int add             : BFW_NX51_int_phy_ctrl_enhanced_link_detection_add;             /* Value added in case of mii_rx_err=1                                                */
	unsigned int sub             : BFW_NX51_int_phy_ctrl_enhanced_link_detection_sub;             /* Value substraced in case of mii_rx_err=0                                           */
	unsigned int threshold       : BFW_NX51_int_phy_ctrl_enhanced_link_detection_threshold;       /* Threshold to compare with counter:                                                 */
	                                                                                              /* Set bad_link if counter>threshold, reset bad_link by XC-software.                  */
	unsigned int counter_ro      : BFW_NX51_int_phy_ctrl_enhanced_link_detection_counter_ro;      /* Actual ehl-counter value (read only):                                              */
	                                                                                              /* Once per mii_rxclk incoming mii_rxerr signal is evaluated and                      */
	                                                                                              /* counter is increased by add in case of mii_rx_err=1 or decreased by sub otherwise. */
	                                                                                              /* Counter can by reset by xPEC using xpec_statcfg or xmac_config_shared register.    */
	unsigned int eld_bad_link_ro : BFW_NX51_int_phy_ctrl_enhanced_link_detection_eld_bad_link_ro; /* status of enhanced link detection (read only)                                      */
	                                                                                              /* This bit is a copy of xmac_status_shared-eld_bad_link.                             */
} NX51_INT_PHY_CTRL_ENHANCED_LINK_DETECTION_BIT_T;

typedef union {
	unsigned int                                    val;
	NX51_INT_PHY_CTRL_ENHANCED_LINK_DETECTION_BIT_T bf;
} NX51_INT_PHY_CTRL_ENHANCED_LINK_DETECTION_T;


/* ===================================================================== */

/* Area of miimu */

/* ===================================================================== */

#define Addr_NX51_miimu 0x1018C520U

/* --------------------------------------------------------------------- */
/* Register miimu */
/* => MDIO FSM interface controlling for netX external PHY. */
/*    Note: */
/*       Loopback for purpose is provided by miimu_sw register and also performed */
/*       in non-software-mode when enabled. */
/*    Note: */
/*       Prior phy_nres-bit was removed. PHY reset must be done by register ASIC_CTRL.phy_control. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_miimu   0x00000000U
#define Adr_NX51_miimu_miimu 0x1018C520U
#define Adr_NX51_miimu       0x1018C520U
#define DFLT_VAL_NX51_miimu  0x00000000U

#define MSK_NX51_miimu_snrdy              0x00000001U
#define SRT_NX51_miimu_snrdy              0
#define DFLT_VAL_NX51_miimu_snrdy         0x00000000U
#define DFLT_BF_VAL_NX51_miimu_snrdy      0x00000000U
#define MSK_NX51_miimu_preamble           0x00000002U
#define SRT_NX51_miimu_preamble           1
#define DFLT_VAL_NX51_miimu_preamble      0x00000000U
#define DFLT_BF_VAL_NX51_miimu_preamble   0x00000000U
#define MSK_NX51_miimu_opmode             0x00000004U
#define SRT_NX51_miimu_opmode             2
#define DFLT_VAL_NX51_miimu_opmode        0x00000000U
#define DFLT_BF_VAL_NX51_miimu_opmode     0x00000000U
#define MSK_NX51_miimu_mdc_period         0x00000008U
#define SRT_NX51_miimu_mdc_period         3
#define DFLT_VAL_NX51_miimu_mdc_period    0x00000000U
#define DFLT_BF_VAL_NX51_miimu_mdc_period 0x00000000U
#define MSK_NX51_miimu_rta                0x00000020U
#define SRT_NX51_miimu_rta                5
#define DFLT_VAL_NX51_miimu_rta           0x00000000U
#define DFLT_BF_VAL_NX51_miimu_rta        0x00000000U
#define MSK_NX51_miimu_regaddr            0x000007c0U
#define SRT_NX51_miimu_regaddr            6
#define DFLT_VAL_NX51_miimu_regaddr       0x00000000U
#define DFLT_BF_VAL_NX51_miimu_regaddr    0x00000000U
#define MSK_NX51_miimu_phyaddr            0x0000f800U
#define SRT_NX51_miimu_phyaddr            11
#define DFLT_VAL_NX51_miimu_phyaddr       0x00000000U
#define DFLT_BF_VAL_NX51_miimu_phyaddr    0x00000000U
#define MSK_NX51_miimu_data               0xffff0000U
#define SRT_NX51_miimu_data               16
#define DFLT_VAL_NX51_miimu_data          0x00000000U
#define DFLT_BF_VAL_NX51_miimu_data       0x00000000U

/* all used bits of 'NX51_miimu': */
#define MSK_USED_BITS_NX51_miimu 0xffffffefU

enum {
	BFW_NX51_miimu_snrdy      = 1,  /* [0] */
	BFW_NX51_miimu_preamble   = 1,  /* [1] */
	BFW_NX51_miimu_opmode     = 1,  /* [2] */
	BFW_NX51_miimu_mdc_period = 1,  /* [3] */
	BFW_NX51_miimu_reserved1  = 1,  /* [4] */
	BFW_NX51_miimu_rta        = 1,  /* [5] */
	BFW_NX51_miimu_regaddr    = 5,  /* [10:6] */
	BFW_NX51_miimu_phyaddr    = 5,  /* [15:11] */
	BFW_NX51_miimu_data       = 16  /* [31:16] */
};

typedef struct NX51_MIIMU_BIT_Ttag {
	unsigned int snrdy      : BFW_NX51_miimu_snrdy;      /* Start not ready              */
	unsigned int preamble   : BFW_NX51_miimu_preamble;   /* Send preamble                */
	unsigned int opmode     : BFW_NX51_miimu_opmode;     /* Operation mode:              */
	                                                     /* 1: write                     */
	                                                     /* 0: read                      */
	unsigned int mdc_period : BFW_NX51_miimu_mdc_period; /* MDC period:                  */
	                                                     /* 1: 800ns                     */
	                                                     /* 0: 400ns                     */
	unsigned int reserved1  : BFW_NX51_miimu_reserved1;  /* reserved                     */
	unsigned int rta        : BFW_NX51_miimu_rta;        /* Read Turn Around field:      */
	                                                     /* 0: one bit                   */
	                                                     /* 1: two bits                  */
	unsigned int regaddr    : BFW_NX51_miimu_regaddr;    /* Register address             */
	unsigned int phyaddr    : BFW_NX51_miimu_phyaddr;    /* PHY address                  */
	unsigned int data       : BFW_NX51_miimu_data;       /* Data to or from PHY register */
} NX51_MIIMU_BIT_T;

typedef union {
	unsigned int     val;
	NX51_MIIMU_BIT_T bf;
} NX51_MIIMU_T;

/* --------------------------------------------------------------------- */
/* Register miimu_sw */
/* => MDIO software interface controlling for netX internal PHY. */
/*    Note: */
/*       Function is similar to old MIIMU unit register 'miimu_sw', however data output */
/*       enable was removed as it is not necessary for MDIO interface to internal PHY (due */
/*       to non-bidirectional data signal). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_miimu_sw   0x00000004U
#define Adr_NX51_miimu_miimu_sw 0x1018C524U
#define Adr_NX51_miimu_sw       0x1018C524U
#define DFLT_VAL_NX51_miimu_sw  0x00000000U

#define MSK_NX51_miimu_sw_enable           0x00000001U
#define SRT_NX51_miimu_sw_enable           0
#define DFLT_VAL_NX51_miimu_sw_enable      0x00000000U
#define DFLT_BF_VAL_NX51_miimu_sw_enable   0x00000000U
#define MSK_NX51_miimu_sw_mdc              0x00000010U
#define SRT_NX51_miimu_sw_mdc              4
#define DFLT_VAL_NX51_miimu_sw_mdc         0x00000000U
#define DFLT_BF_VAL_NX51_miimu_sw_mdc      0x00000000U
#define MSK_NX51_miimu_sw_mdo              0x00000020U
#define SRT_NX51_miimu_sw_mdo              5
#define DFLT_VAL_NX51_miimu_sw_mdo         0x00000000U
#define DFLT_BF_VAL_NX51_miimu_sw_mdo      0x00000000U
#define MSK_NX51_miimu_sw_mdoe             0x00000040U
#define SRT_NX51_miimu_sw_mdoe             6
#define DFLT_VAL_NX51_miimu_sw_mdoe        0x00000000U
#define DFLT_BF_VAL_NX51_miimu_sw_mdoe     0x00000000U
#define MSK_NX51_miimu_sw_mdi_ro           0x00000080U
#define SRT_NX51_miimu_sw_mdi_ro           7
#define DFLT_VAL_NX51_miimu_sw_mdi_ro      0x00000000U
#define DFLT_BF_VAL_NX51_miimu_sw_mdi_ro   0x00000000U
#define MSK_NX51_miimu_sw_loopback         0x00000100U
#define SRT_NX51_miimu_sw_loopback         8
#define DFLT_VAL_NX51_miimu_sw_loopback    0x00000000U
#define DFLT_BF_VAL_NX51_miimu_sw_loopback 0x00000000U

/* all used bits of 'NX51_miimu_sw': */
#define MSK_USED_BITS_NX51_miimu_sw 0x000001f1U

enum {
	BFW_NX51_miimu_sw_enable    = 1,  /* [0] */
	BFW_NX51_miimu_sw_reserved1 = 3,  /* [3:1] */
	BFW_NX51_miimu_sw_mdc       = 1,  /* [4] */
	BFW_NX51_miimu_sw_mdo       = 1,  /* [5] */
	BFW_NX51_miimu_sw_mdoe      = 1,  /* [6] */
	BFW_NX51_miimu_sw_mdi_ro    = 1,  /* [7] */
	BFW_NX51_miimu_sw_loopback  = 1,  /* [8] */
	BFW_NX51_miimu_sw_reserved2 = 23  /* [31:9] */
};

typedef struct NX51_MIIMU_SW_BIT_Ttag {
	unsigned int enable    : BFW_NX51_miimu_sw_enable;    /* Enables software mode:                                      */
	                                                      /* MDC, MDO and MDOE are set by software.                      */
	unsigned int reserved1 : BFW_NX51_miimu_sw_reserved1; /* reserved                                                    */
	unsigned int mdc       : BFW_NX51_miimu_sw_mdc;       /* MDC value for software mode                                 */
	unsigned int mdo       : BFW_NX51_miimu_sw_mdo;       /* MDO value for software mode                                 */
	unsigned int mdoe      : BFW_NX51_miimu_sw_mdoe;      /* MDOE value for software mode                                */
	unsigned int mdi_ro    : BFW_NX51_miimu_sw_mdi_ro;    /* current MDI value                                           */
	unsigned int loopback  : BFW_NX51_miimu_sw_loopback;  /* MDIO-data-out to data-in loopback for test purpose.         */
	                                                      /* 0: no loopback, MDIO-data-in comes from internal PHY.       */
	                                                      /* 1: loopback, MDIO-data-in comes from current MDIO-data-out. */
	                                                      /* Note:                                                       */
	                                                      /*    Loopback can also be used in non-software-mode.          */
	unsigned int reserved2 : BFW_NX51_miimu_sw_reserved2; /* reserved                                                    */
} NX51_MIIMU_SW_BIT_T;

typedef union {
	unsigned int        val;
	NX51_MIIMU_SW_BIT_T bf;
} NX51_MIIMU_SW_T;


/* ===================================================================== */

/* Area of pio */

/* ===================================================================== */

#define Addr_NX51_pio 0x1018C530U

/* --------------------------------------------------------------------- */
/* Register pio_in */
/* => PIO input line status register. */
/*    Each PIO input status can also be read from dedicated PIOx input state register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pio_in 0x00000000U
#define Adr_NX51_pio_pio_in 0x1018C530U
#define Adr_NX51_pio_in     0x1018C530U

#define MSK_NX51_pio_in_val 0x000000ffU
#define SRT_NX51_pio_in_val 0

/* all used bits of 'NX51_pio_in': */
#define MSK_USED_BITS_NX51_pio_in 0x000000ffU

enum {
	BFW_NX51_pio_in_val       = 8,  /* [7:0] */
	BFW_NX51_pio_in_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_PIO_IN_BIT_Ttag {
	unsigned int val       : BFW_NX51_pio_in_val;       /* PIO input states (LSB: PIO0). */
	unsigned int reserved1 : BFW_NX51_pio_in_reserved1; /* reserved                      */
} NX51_PIO_IN_BIT_T;

typedef union {
	unsigned int      val;
	NX51_PIO_IN_BIT_T bf;
} NX51_PIO_IN_T;

/* --------------------------------------------------------------------- */
/* Register pio_out */
/* => PIO output drive level line register. */
/*    Each PIOs output drive level can also be programmed by dedicated PIOx output drive level register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pio_out  0x00000004U
#define Adr_NX51_pio_pio_out  0x1018C534U
#define Adr_NX51_pio_out      0x1018C534U
#define DFLT_VAL_NX51_pio_out 0x00000000U

#define MSK_NX51_pio_out_val         0x000000ffU
#define SRT_NX51_pio_out_val         0
#define DFLT_VAL_NX51_pio_out_val    0x00000000U
#define DFLT_BF_VAL_NX51_pio_out_val 0x00000000U

/* all used bits of 'NX51_pio_out': */
#define MSK_USED_BITS_NX51_pio_out 0x000000ffU

enum {
	BFW_NX51_pio_out_val       = 8,  /* [7:0] */
	BFW_NX51_pio_out_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_PIO_OUT_BIT_Ttag {
	unsigned int val       : BFW_NX51_pio_out_val;       /* PIO output drive levels (LSB: PIO0). */
	unsigned int reserved1 : BFW_NX51_pio_out_reserved1; /* reserved                             */
} NX51_PIO_OUT_BIT_T;

typedef union {
	unsigned int       val;
	NX51_PIO_OUT_BIT_T bf;
} NX51_PIO_OUT_T;

/* --------------------------------------------------------------------- */
/* Register pio_oe */
/* => PIO output enable line register. */
/*    Each PIOs output enable can also be programmed by dedicated PIOx output enable register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_pio_oe  0x00000008U
#define Adr_NX51_pio_pio_oe  0x1018C538U
#define Adr_NX51_pio_oe      0x1018C538U
#define DFLT_VAL_NX51_pio_oe 0x00000000U

#define MSK_NX51_pio_oe_val         0x000000ffU
#define SRT_NX51_pio_oe_val         0
#define DFLT_VAL_NX51_pio_oe_val    0x00000000U
#define DFLT_BF_VAL_NX51_pio_oe_val 0x00000000U

/* all used bits of 'NX51_pio_oe': */
#define MSK_USED_BITS_NX51_pio_oe 0x000000ffU

enum {
	BFW_NX51_pio_oe_val       = 8,  /* [7:0] */
	BFW_NX51_pio_oe_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_PIO_OE_BIT_Ttag {
	unsigned int val       : BFW_NX51_pio_oe_val;       /* PIO output enables (LSB: PIO0). */
	unsigned int reserved1 : BFW_NX51_pio_oe_reserved1; /* reserved                        */
} NX51_PIO_OE_BIT_T;

typedef union {
	unsigned int      val;
	NX51_PIO_OE_BIT_T bf;
} NX51_PIO_OE_T;


/* ===================================================================== */

/* Area of hif_io_ctrl */

/* ===================================================================== */

#define Addr_NX51_hif_io_ctrl 0x1018C540U

/* --------------------------------------------------------------------- */
/* Register hif_io_cfg */
/* => IO Config Register: */
/*    Selects of HIF pin multiplexing. */
/*    See Excel pinning sheet for details. */
/*    This configuration must be set up according to external netX connection before any access to external logic. */
/*    This register is protected by the netX access key mechanism; changing this register is only possible by the following sequence: */
/*    1.: read out access key from ACCESS_KEY register (ASIC_CTRL address area) */
/*    2.: write back access key to ACCESS_KEY register (ASIC_CTRL address area) */
/*    3.: write desired value to this register (ASIC_CTRL address area) */
/*    Attention: Be very careful programming this register. False settings may cause permanent damage on netX or devices connected */
/*               to HIF-IOs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_io_cfg         0x00000000U
#define Adr_NX51_hif_io_ctrl_hif_io_cfg 0x1018C540U
#define Adr_NX51_hif_io_cfg             0x1018C540U
#define DFLT_VAL_NX51_hif_io_cfg        0x01000030U

#define MSK_NX51_hif_io_cfg_sel_hif_dpm                    0x00000001U
#define SRT_NX51_hif_io_cfg_sel_hif_dpm                    0
#define DFLT_VAL_NX51_hif_io_cfg_sel_hif_dpm               0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_sel_hif_dpm            0x00000000U
#define MSK_NX51_hif_io_cfg_sel_dpm_serial                 0x00000002U
#define SRT_NX51_hif_io_cfg_sel_dpm_serial                 1
#define DFLT_VAL_NX51_hif_io_cfg_sel_dpm_serial            0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_sel_dpm_serial         0x00000000U
#define MSK_NX51_hif_io_cfg_sel_dpm_serial_sph             0x00000004U
#define SRT_NX51_hif_io_cfg_sel_dpm_serial_sph             2
#define DFLT_VAL_NX51_hif_io_cfg_sel_dpm_serial_sph        0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_sel_dpm_serial_sph     0x00000000U
#define MSK_NX51_hif_io_cfg_sel_dpm_serial_spo             0x00000008U
#define SRT_NX51_hif_io_cfg_sel_dpm_serial_spo             3
#define DFLT_VAL_NX51_hif_io_cfg_sel_dpm_serial_spo        0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_sel_dpm_serial_spo     0x00000000U
#define MSK_NX51_hif_io_cfg_hif_mi_cfg                     0x00000030U
#define SRT_NX51_hif_io_cfg_hif_mi_cfg                     4
#define DFLT_VAL_NX51_hif_io_cfg_hif_mi_cfg                0x00000030U
#define DFLT_BF_VAL_NX51_hif_io_cfg_hif_mi_cfg             0x00000003U
#define MSK_NX51_hif_io_cfg_en_hif_sdram_mi                0x00000040U
#define SRT_NX51_hif_io_cfg_en_hif_sdram_mi                6
#define DFLT_VAL_NX51_hif_io_cfg_en_hif_sdram_mi           0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_en_hif_sdram_mi        0x00000000U
#define MSK_NX51_hif_io_cfg_sel_hif_a_width                0x00000f00U
#define SRT_NX51_hif_io_cfg_sel_hif_a_width                8
#define DFLT_VAL_NX51_hif_io_cfg_sel_hif_a_width           0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_sel_hif_a_width        0x00000000U
#define MSK_NX51_hif_io_cfg_en_hif_rdy_pio_mi              0x01000000U
#define SRT_NX51_hif_io_cfg_en_hif_rdy_pio_mi              24
#define DFLT_VAL_NX51_hif_io_cfg_en_hif_rdy_pio_mi         0x01000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_en_hif_rdy_pio_mi      0x00000001U
#define MSK_NX51_hif_io_cfg_en_hif_wdg_sys_hif_d19         0x02000000U
#define SRT_NX51_hif_io_cfg_en_hif_wdg_sys_hif_d19         25
#define DFLT_VAL_NX51_hif_io_cfg_en_hif_wdg_sys_hif_d19    0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_en_hif_wdg_sys_hif_d19 0x00000000U
#define MSK_NX51_hif_io_cfg_netx50_io_comp_ro              0x80000000U
#define SRT_NX51_hif_io_cfg_netx50_io_comp_ro              31
#define DFLT_VAL_NX51_hif_io_cfg_netx50_io_comp_ro         0x00000000U
#define DFLT_BF_VAL_NX51_hif_io_cfg_netx50_io_comp_ro      0x00000000U

/* all used bits of 'NX51_hif_io_cfg': */
#define MSK_USED_BITS_NX51_hif_io_cfg 0x83000f7fU

enum {
	BFW_NX51_hif_io_cfg_sel_hif_dpm            = 1,  /* [0] */
	BFW_NX51_hif_io_cfg_sel_dpm_serial         = 1,  /* [1] */
	BFW_NX51_hif_io_cfg_sel_dpm_serial_sph     = 1,  /* [2] */
	BFW_NX51_hif_io_cfg_sel_dpm_serial_spo     = 1,  /* [3] */
	BFW_NX51_hif_io_cfg_hif_mi_cfg             = 2,  /* [5:4] */
	BFW_NX51_hif_io_cfg_en_hif_sdram_mi        = 1,  /* [6] */
	BFW_NX51_hif_io_cfg_reserved1              = 1,  /* [7] */
	BFW_NX51_hif_io_cfg_sel_hif_a_width        = 4,  /* [11:8] */
	BFW_NX51_hif_io_cfg_reserved2              = 12, /* [23:12] */
	BFW_NX51_hif_io_cfg_en_hif_rdy_pio_mi      = 1,  /* [24] */
	BFW_NX51_hif_io_cfg_en_hif_wdg_sys_hif_d19 = 1,  /* [25] */
	BFW_NX51_hif_io_cfg_reserved3              = 5,  /* [30:26] */
	BFW_NX51_hif_io_cfg_netx50_io_comp_ro      = 1   /* [31] */
};

typedef struct NX51_HIF_IO_CFG_BIT_Ttag {
	unsigned int sel_hif_dpm            : BFW_NX51_hif_io_cfg_sel_hif_dpm;            /* select HIF pins for DPM                                                                                                              */
	                                                                                  /* Note: For parallel DPM IO configuration use config registers in address area DPM.                                                    */
	                                                                                  /* Note: Parallel DPM fast/service IRQ functionallity (SIRQ/FIQ) on HIF_SDCLK is controlled by                                          */
	                                                                                  /*       en_hif_sdram_mi bit                                                                                                            */
	                                                                                  /* Note: For parallel DPM host IRQs can be generated on HIF_DIRQ and HIF_SDCLK IOs.                                                     */
	                                                                                  /* Note: For parallel DPM HIF PIO function muse be configured inside 'dpm_pio_cfg'                                                      */
	                                                                                  /*       registers for all HIF IOs.                                                                                                     */
	unsigned int sel_dpm_serial         : BFW_NX51_hif_io_cfg_sel_dpm_serial;         /* Select serial (SPI) DPM mode (ignored if sel_hif_dpm not set).                                                                       */
	                                                                                  /* Note: Serial DPM is mapped to HIF_D8..11 with optional IRQs on HIF_D12..15. It can be used together                                  */
	                                                                                  /*       with 8 or 16 bit Memory Interface or Ethernet on HIF IOs but not with 32bit                                                    */
	                                                                                  /*       HIF MI (hif_mi_cfg) or HIF-MMIOs (serial DPM: MMIO40..43, serial DPM IRQs: MMIO44, 45).                                        */
	                                                                                  /*       PIO usage of HIF_D12..15 is configured inside DPM 'dpm_pio_cfg' registers. PIO function                                        */
	                                                                                  /*       of all other HIF IOs result from other bit fields of 'hif_io_cfg' register.                                                    */
	                                                                                  /* Note: For serial DPM host IRQs can be generated on HIF_D30 and HIF_D31 IOs.                                                          */
	unsigned int sel_dpm_serial_sph     : BFW_NX51_hif_io_cfg_sel_dpm_serial_sph;     /* select serial DPM mode SPI clock phase (sel_hif_dpm and sel_dpm_serial must be set).                                                 */
	                                                                                  /*  0: Serial data sampling on first serial clock edge.                                                                                 */
	                                                                                  /*  1: Serial data sampling on second serial clock edge.                                                                                */
	unsigned int sel_dpm_serial_spo     : BFW_NX51_hif_io_cfg_sel_dpm_serial_spo;     /* select serial DPM mode SPI clock polarity (sel_hif_dpm and sel_dpm_serial must be set).                                              */
	                                                                                  /*  0: Serial clock idle state is low.                                                                                                  */
	                                                                                  /*  1: Serial clock idle state is high.                                                                                                 */
	unsigned int hif_mi_cfg             : BFW_NX51_hif_io_cfg_hif_mi_cfg;             /*   Global HIF IO Memory Interface usage configuration.                                                                                */
	                                                                                  /*   Extensionbus/HIF-Memory-Interface and must be enabled and data width selected here before                                          */
	                                                                                  /*   memory devices like SRAM/FLASH/SDRAM-lite can be used on HIF.                                                                      */
	                                                                                  /*   Settings:                                                                                                                          */
	                                                                                  /*   {   |                                                                                                                              */
	                                                                                  /*    00: HIF IOs are used as 8 bit MI.                                                                                                 */
	                                                                                  /*        Used HIF IOs: HIF_D7..0, HIF_A10..0, HIF_RDN, HIF_WRN.                                                                        */
	                                                                                  /*        Other HIF IOs can be used as PIOs, serial DPM or Ethernet MAC simultaneously. SDRAM function                                  */
	                                                                                  /*        is not available as SDRAM always requires 16 or 32 data lines.                                                                */
	                                                                                  /*        Up to 4 Chip-Selects are provided (they are PIO by default, view notes):                                                      */
	                                                                                  /*        Ready (HIF_RDY) and IRQ (HIF_DIRQ) input can be used optionally.                                                              */
	                                                                                  /*    01: HIF IOs are used as 16 bit MI (together with serial DPM possible).                                                            */
	                                                                                  /*        Used HIF IOs: Same as in 8 bit mode (setting '00') plus D15..8 and HIF_BHE1. However location                                 */
	                                                                                  /*        of data line 8 to 15 depends on setting of netX50 compatibility (view table above).                                           */
	                                                                                  /*        SDRAM function is available when netX50 compatibility is disabled.                                                            */
	                                                                                  /*    10: HIF IOs are used as 32 bit MI (no DPM and no Ethernet possible).                                                              */
	                                                                                  /*        Used HIF IOs: HIF_D31..0, HIF_A10..0, HIF_RDN, HIF_WRN, HIF_BHE1, HIF_BHE3. All others can be used as PIOs.                   */
	                                                                                  /*        Only 2 Chip-Selects are provided in 32bit data mode (CS2 and CS3 are not available):                                          */
	                                                                                  /*        CS0: HIF_CS0N (SDRAM or ExtBus CS0)                                                                                           */
	                                                                                  /*        CS1: HIF_DIRQ (ExtBus CS1)                                                                                                    */
	                                                                                  /*    11: No MI usage. HIF IOs can be used as PIOs or for parallel DPM. }                                                               */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   HIF Extension-bus signal mapping for SRAM/FLASH or SDRAM function depends on current netX50-compatibility                          */
	                                                                                  /*   setting and data width selection of this bit-field:                                                                                */
	                                                                                  /*   {           |                 |                 |                 |                 |       |                  |       |           */
	                                                                                  /*     netx51 IO      8 bit data        16 bit data         8 bit data       16 bit data   SDRAM        32 bit data   SDRAM   comment   */
	                                                                                  /*                    netX50 comp.      netX50 comp.        not netX50        not netX50   16bit         not netX50.  32bit             */
	                                                                                  /*        HIF_A0                A0            BE0/A0                A0            BE0/A0      A0                BE0      A0             */
	                                                                                  /*        HIF_A1                A1                A1                A1                A1    (n4)                BE2      A1             */
	                                                                                  /*        HIF_A2                A2                A2                A2                A2    (n4)                 A2    (n4)             */
	                                                                                  /*        HIF_A3                A3                A3                A3                A3    (n4)                 A3    (n4)             */
	                                                                                  /*        HIF_A4                A4                A4                A4                A4    (n4)                 A4    (n4)             */
	                                                                                  /*        HIF_A5                A5                A5                A5                A5    (n4)                 A5    (n4)             */
	                                                                                  /*        HIF_A6                A6                A6                A6                A6    (n4)                 A6    (n4)             */
	                                                                                  /*        HIF_A7                A7                A7                A7                A7    (n4)                 A7    (n4)             */
	                                                                                  /*        HIF_A8                A8                A8                A8                A8    (n4)                 A8    (n4)             */
	                                                                                  /*        HIF_A9                A9                A9                A9                A9    (n4)                 A9    (n4)             */
	                                                                                  /*       HIF_A10               A10               A10               A10               A10    (n4)                A10    (n4)             */
	                                                                                  /*       HIF_A11               A11               A11               A11               A11    (n4)                A11    (n4)             */
	                                                                                  /*       HIF_A12       (n2)    A12       (n2)    A12        (n2)   A12       (n2)    A12    (n4)        (n2)    A12    (n4)             */
	                                                                                  /*       HIF_A13       (n2)    A13       (n2)    A13        (n2)   A13       (n2)    A13    DQM0        (n2)    A13    DQM0             */
	                                                                                  /*       HIF_A14       (n2)    A14       (n2)    A14        (n2)   A14       (n2)    A14     BA0        (n2)    A14     BA0             */
	                                                                                  /*       HIF_A15       (n2)    A15       (n2)    A15        (n2)   A15       (n2)    A15     BA1        (n2)    A15     BA1             */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*      HIF_AHI0                 -                 -               A22               A22     RAS                A16     RAS             */
	                                                                                  /*      HIF_AHI1                 -                 -               A23               A23     CAS                A17     CAS             */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*        HIF_D0                D0                D0                D0                D0    (n4)                 D0    (n4)             */
	                                                                                  /*        HIF_D1                D1                D1                D1                D1    (n4)                 D1    (n4)             */
	                                                                                  /*        HIF_D2                D2                D2                D2                D2    (n4)                 D2    (n4)             */
	                                                                                  /*        HIF_D3                D3                D3                D3                D3    (n4)                 D3    (n4)             */
	                                                                                  /*        HIF_D4                D4                D4                D4                D4    (n4)                 D4    (n4)             */
	                                                                                  /*        HIF_D5                D5                D5                D5                D5    (n4)                 D5    (n4)             */
	                                                                                  /*        HIF_D6                D6                D6                D6                D6    (n4)                 D6    (n4)             */
	                                                                                  /*        HIF_D7                D7                D7                D7                D7    (n4)                 D7    (n4)             */
	                                                                                  /*        HIF_D8                                  D8        (n1)             (n1)                               D16    (n4)   (n3)      */
	                                                                                  /*        HIF_D9                                  D9        (n1)             (n1)                               D17    (n4)   (n3)      */
	                                                                                  /*       HIF_D10                                 D10        (n1)             (n1)                               D18    (n4)   (n3)      */
	                                                                                  /*       HIF_D11                                 D11        (n1)             (n1)                               D19    (n4)   (n3)      */
	                                                                                  /*       HIF_D12                                 D12        (n1)             (n1)                               D26    (n4)   (n3)      */
	                                                                                  /*       HIF_D13                                 D13        (n1)             (n1)                               D27    (n4)   (n3)      */
	                                                                                  /*       HIF_D14                                 D14        (n1)             (n1)                               D30    (n4)   (n3)      */
	                                                                                  /*       HIF_D15                                 D15        (n1)             (n1)                               D31    (n4)   (n3)      */
	                                                                                  /*       HIF_D16                                                                      D8    (n4)                 D8    (n4)   (n3)      */
	                                                                                  /*       HIF_D17                                                                      D9    (n4)                 D9    (n4)   (n3)      */
	                                                                                  /*       HIF_D18       (n2)    A24                                                   D10    (n4)                D10    (n4)   (n3)      */
	                                                                                  /*       HIF_D19                                                                     D11    (n4)                D11    (n4)   (n3)      */
	                                                                                  /*       HIF_D20       (n2)    A16       (n2)    A16        (n2)   A16       (n2)    A16                        D20    (n4)             */
	                                                                                  /*       HIF_D21       (n2)    A17       (n2)    A17        (n2)   A17       (n2)    A17                        D21    (n4)             */
	                                                                                  /*       HIF_D22       (n2)    A18       (n2)    A18        (n2)   A18       (n2)    A18                        D22    (n4)             */
	                                                                                  /*       HIF_D23       (n2)    A19       (n2)    A19        (n2)   A19       (n2)    A19                        D23    (n4)             */
	                                                                                  /*       HIF_D24       (n2)    A20       (n2)    A20        (n2)   A20       (n2)    A20                        D24    (n4)             */
	                                                                                  /*       HIF_D25       (n2)    A21       (n2)    A21        (n2)   A21       (n2)    A21                        D25    (n4)             */
	                                                                                  /*       HIF_D26       (n2)    A22       (n2)    A22                                 D12    (n4)                D12    (n4)   (n3)      */
	                                                                                  /*       HIF_D27       (n2)    A23       (n2)    A23                                 D13    (n4)                D13    (n4)   (n3)      */
	                                                                                  /*       HIF_D28               CS2               CS2               CS2               CS2                        D28    (n4)             */
	                                                                                  /*       HIF_D29               CS1               CS1               CS1               CS1                        D29    (n4)             */
	                                                                                  /*       HIF_D30               CS3               CS3                                 D14    (n4)                D14    (n4)   (n3)      */
	                                                                                  /*       HIF_D31                                                                     D15    (n4)                D15    (n4)   (n3)      */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*      HIF_BHE1                             BHE/BE1                             BHE/BE1    DQM1            BHE/BE1    DQM1   (n3)      */
	                                                                                  /*      HIF_BHE3                                           (n6)A24/CS3       (n6)A24/CS3                        BE3    DQM3   (n3)      */
	                                                                                  /*       HIF_CSN               CS0               CS0               CS0               CS0     CSN                CS0     CSN   (n3)      */
	                                                                                  /*       HIF_RDN               RDN               RDN               RDN               RDN                        RDN    DQM2   (n3)      */
	                                                                                  /*       HIF_WRN               WRN               WRN               WRN               WRN     WEN                WRN     WEN   (n3)      */
	                                                                                  /*       HIF_RDY       (n2)    RDY       (n2)    RDY       (n2)    RDY       (n2)    RDY     CKE        (n2)    RDY     CKE   (n3)      */
	                                                                                  /*      HIF_DIRQ                                                                                                CS1           (n3)      */
	                                                                                  /*     HIF_SDCLK                                                                             CLK                        CLK   (n3)      */
	                                                                                  /*    ----------- ----------------- ----------------- ----------------- ----------------- ------- ------------------ ------- --------   */
	                                                                                  /*       comment   Should only be\   Should only be\   sDPM, MMIO or\    sDPM, MMIO or\    word\       all IOs used\  word              */
	                                                                                  /*                 used for netX50\  used for netX50\  HIF-ETH can be\   HIF-ETH can be\   addr.\      no sDPM, no\   addr.             */
	                                                                                  /*                 drop-in-re-\      drop-in-re-\      used with this    used with this\   no RDY      MMIO, no ETH\  no RDY            */
	                                                                                  /*                 placement         placement.\                         byte address                  byte address                     */
	                                                                                  /*                                   Byte address                                                      only 2 CS                      } */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Table Notes:                                                                                                                       */
	                                                                                  /*   (n1): IOs could be used for serial DPM, MMIO or as part of HIF-Ethernet MAC in current mode.                                       */
	                                                                                  /*   (n2): Optional, (depends on further configuration, e.g. 'sel_hif_a_width' bit-field).                                              */
	                                                                                  /*   (n3): Attention: Mapping of data-lines is reorderd and does not match Naming of HIF_D IOs.                                         */
	                                                                                  /*   (n4): for SDRAM same function like '16 bit data not netX50' column.                                                                */
	                                                                                  /*   (n5): for SDRAM same function like '32 bit data not netX50' column.                                                                */
	                                                                                  /*   (n6): Must be configured for one of these functions. Not possible at the same time.                                                */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Note: When netX50 compatible, 8 and 16 bit devices can be shared.                                                                  */
	                                                                                  /*         When not netX50 compatible, 8 and 16 and 32 bit devices can be shared.                                                       */
	                                                                                  /*   Note: Configuration of single SRAM/FLASH Chip-Select usage must be done additionally in                                            */
	                                                                                  /*         HIF related ASYNCMEM_CTRL address area. By default, all Chip-Selects are disabled and                                        */
	                                                                                  /*         available for PIO usage. If any external memory is used, Chip-Select configuration must be done                              */
	                                                                                  /*         before the first access to external memory. Otherwise netX or memory                                                         */
	                                                                                  /*         devices could be damaged. In HIF related ASYNCMEM_CTRL no data width must be configured which                                */
	                                                                                  /*         exceeds globally enabled data width of this bit-field.                                                                       */
	                                                                                  /*   Note: If upper address lines above HIF_A10 are not used as PIOs, this must be configured in                                        */
	                                                                                  /*         bits 'sel_hif_a_width'.                                                                                                      */
	                                                                                  /*   Note: If HIF is configured as parallel DPM ('sel_hif_dpm' set and 'sel_dpm_serial' not set), HIF IOs are                           */
	                                                                                  /*         not available for Memory Interface usage and programmed value of 'hif_mi_cfg'-bits is ignored.                               */
	                                                                                  /*   Note: If HIF is configured as serial DPM ('sel_hif_dpm' set and 'sel_dpm_serial' set), HIF IOs are                                 */
	                                                                                  /*         not available for 32 bit Memory Interface. Programmed value '10' will be ignored in this case.                               */
	                                                                                  /*   Note: SDRAM Chip-Select is multiplext with SRAM/FLASH Chip-Select 0 on HIF_CSN. If 'en_hif_sdram_mi'                               */
	                                                                                  /*         is set and SRAM/FLASH Chip-Select 0 enabled in HIF related ASYNCMEM_CTRL address area, SDRAM Chip-Select                     */
	                                                                                  /*         gains priority and SRAM/FLASH Chip-Select 0 will not be available.                                                           */
	unsigned int en_hif_sdram_mi        : BFW_NX51_hif_io_cfg_en_hif_sdram_mi;        /*   Enable HIF IOs for SDRAM Memory Interface configuration.                                                                           */
	                                                                                  /*   The netX50 compatibility mode must be disable before SDRAM can be used on HIF IOs.                                                 */
	                                                                                  /*   HIF-SDRAM Chip-Select is generated on HIF_CS0N when this bit is set. ExtBus Chip-Select area                                       */
	                                                                                  /*   0 is not available then. Ready-Signal for ExtBus is never available when SDRAM is enabled here.                                    */
	                                                                                  /*   If enabled following IOs are used as outputs for SDRAM (netx51, partial shared with SRAM/FLASH ctrl signals):                      */
	                                                                                  /*   {            |          |                                                                                                          */
	                                                                                  /*     netX51 IO    Function   Comment                                                                                                  */
	                                                                                  /*      HIF_A0..12  SD_A0..12  Shared SDRAM/FLASH/SRAM address lines, small SDRAM devices do not need all lines.                        */
	                                                                                  /*      HIF_D0..31  SD_D0..31  Shared SDRAM/FLASH/SRAM data lines. Detailed data signal mapping depends                                 */
	                                                                                  /*                             on selected data width. View table at hif_mi_cfg for details.                                            */
	                                                                                  /*      HIF_A14     SD_BA0     Only during SDRAM access, usable as FLASH/SRAM A14 simultaneously.                                       */
	                                                                                  /*      HIF_A15     SD_BA1     Only during SDRAM access, usable as FLASH/SRAM A15 simultaneously.                                       */
	                                                                                  /*      HIF_AHI0    SD_RASN    Only during SDRAM access, usable as FLASH/SRAM A16 simultaneously.                                       */
	                                                                                  /*      HIF_AHI1    SD_CASN    Only during SDRAM access, usable as FLASH/SRAM A17 simultaneously.                                       */
	                                                                                  /*      HIF_A13     SD_DQM0N   Only during SDRAM access, usable as FLASH/SRAM A13 simultaneously.                                       */
	                                                                                  /*      HIF_BHE1    SD_DQM1N   Only during SDRAM access, usable as FLASH/SRAM BHE1 simultaneously.                                      */
	                                                                                  /*      HIF_RDN     SD_DQM2N   Only for 32bit data during SDRAM access, usable as FLASH/SRAM nRD simultaneously.                        */
	                                                                                  /*      HIF_BHE3    SD_DQM3N   Only for 32bit data during SDRAM access, usable as FLASH/SRAM BHE3 simultaneously.                       */
	                                                                                  /*      HIF_WRN     SD_WEN     Only during SDRAM access, usable as FLASH/SRAM nWR simultaneously.                                       */
	                                                                                  /*      HIF_CS0N    SD_CSN     ExtBus CS0 not available                                                                                 */
	                                                                                  /*      HIF_RDY     SD_CKE     ExtBus Ready never available when SDRAM enabled                                                          */
	                                                                                  /*      HIF_SDCLK   SD_CLK     HIF SDRAM clock }                                                                                        */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Note: For SDRAM usage, 'hif_mi_cfg' must be configured for 16 or 32 bit MI. SDRAM is not available                                 */
	                                                                                  /*         when set to 8bit MI.                                                                                                         */
	                                                                                  /*   Note: HIF_A lines used for SDRAM will always be driven when this bit is set. This does not depend                                  */
	                                                                                  /*         on programmed value of 'sel_hif_a_width' bit field. However 'sel_hif_a_width' must be set                                    */
	                                                                                  /*         wide enough for SDRAM row and column addressing (depending on used SDRAM device).                                            */
	unsigned int reserved1              : BFW_NX51_hif_io_cfg_reserved1;              /* reserved                                                                                                                             */
	unsigned int sel_hif_a_width        : BFW_NX51_hif_io_cfg_sel_hif_a_width;        /*   Select HIF MI address width.                                                                                                       */
	                                                                                  /*   Selecting smaller address bus width will allow PIO usage on related IOs when not used                                              */
	                                                                                  /*   otherwise (e.g. as SDRAM control signals, see en_hif_sdram_mi). HIF-MI address lines above A15                                     */
	                                                                                  /*   are shared on high data lines. They are only available when hif_mi_cfg is set for 8 or 16                                          */
	                                                                                  /*   bit data MI, not for 32 bit data interface. Additionally address signal mapping depends                                            */
	                                                                                  /*   on programmed netX50 compatibility setting (netx50_io_comp_ro):  netX50b IOs HIF_AHI0,1 are not                                    */
	                                                                                  /*   available in netX50 compatibility mode.                                                                                            */
	                                                                                  /*   Following settings are valid for all modes:                                                                                        */
	                                                                                  /*   {    |       |       |               |          |                                                                                  */
	                                                                                  /*          Lines   Range   netX50b IOs     Function   Comment                                                                          */
	                                                                                  /*    0000:    11      2k   HIF_A0..10      A0..A10    ext_a0..ext_a10                                                                  */
	                                                                                  /*    0001:    12      4k   HIF_A0..11      A0..A11    + ext_a11                                                                        */
	                                                                                  /*    0010:    13      8k   HIF_A0..12      A0..A12    + ext_a12                                                                        */
	                                                                                  /*    0011:    14     16k   HIF_A0..13      A0..A13    + ext_a13                                                                        */
	                                                                                  /*    0100:    15     32k   HIF_A0..14      A0..A14    + ext_a14                                                                        */
	                                                                                  /*    0101:    16     64k   HIF_A0..15      A0..A15    + ext_a15}                                                                       */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Following settings are only for 32 bit data when netX50 compatibility is disabled (A0,1                                            */
	                                                                                  /*   are rather byte-enable signals BE0 and BE2 than address lines here):                                                               */
	                                                                                  /*   {    |       |       |               |          |                                                                                  */
	                                                                                  /*          Lines   Range   netX50b IOs     Function   Comment                                                                          */
	                                                                                  /*    0110:    17    128k   HIF_A0..15      A0..A15    ext_a0..ext_a15                                                                  */
	                                                                                  /*                          HIF_AHI0        A16        + ext_a16_d32                                                                    */
	                                                                                  /*    0111:    18    256k   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_AHI0,1      A16,A17    + ext_a17_d32 }                                                                  */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Following settings are valid for all 8 or 16 bit data modes but not for 32 bit data                                                */
	                                                                                  /*   and do not depend on netX50 compatibility setting:                                                                                 */
	                                                                                  /*   {    |       |       |               |          |                                                                                  */
	                                                                                  /*          Lines   Range   netX50b IOs     Function   Comment                                                                          */
	                                                                                  /*    0110:    17    128k   HIF_A0..15      A0..A15    ext_a0..ext_a15                                                                  */
	                                                                                  /*                          HIF_D20         A16        + ext_a16                                                                        */
	                                                                                  /*    0111:    18    256k   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20,21      A16,A17    + ext_a17                                                                        */
	                                                                                  /*    1000:    19    512k   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..22     A16..18    + ext_a18                                                                        */
	                                                                                  /*    1001:    20      1M   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..23     A16..19    + ext_a19                                                                        */
	                                                                                  /*    1010:    21      2M   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..24     A16..20    + ext_a20                                                                        */
	                                                                                  /*    1011:    22      4M   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..25     A16..21    + ext_a21 }                                                                      */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Following settings are valid for 8 or 16 bit data mode when netX50-compatibility                                                   */
	                                                                                  /*   is activated:                                                                                                                      */
	                                                                                  /*   {    |       |       |               |          |                                                                                  */
	                                                                                  /*          Lines   Range   netX50b IOs     Function   Comment                                                                          */
	                                                                                  /*    1100:    23      8M   HIF_A0..15      A0..A15    ext_a0..ext_a15                                                                  */
	                                                                                  /*                          HIF_D20..25     A16..21    ext_a16..ext_a21                                                                 */
	                                                                                  /*                          HIF_D26         A22        + ext_a22_nx50                                                                   */
	                                                                                  /*    1101:    24     16M   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..25     A16..21                                                                                     */
	                                                                                  /*                          HIF_D26,27      A22,A23    + ext_a23_nx50                                                                   */
	                                                                                  /*    1110:    25     32M   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..25     A16..21                                                                                     */
	                                                                                  /*                          HIF_D26,27      A22,A23                                                                                     */
	                                                                                  /*                          HIF_D18         A24        + ext_a24_nx50 }                                                                 */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Following settings are valid for 8 or 16 bit data mode when not in netX50-compatibility mode:                                      */
	                                                                                  /*   {    |       |       |               |          |                                                                                  */
	                                                                                  /*          Lines   Range   netX50b IOs     Function   Comment                                                                          */
	                                                                                  /*    1100:    23      8M   HIF_A0..15      A0..A15    ext_a0..ext_a15                                                                  */
	                                                                                  /*                          HIF_D20..25     A16..21    ext_a16..ext_a21                                                                 */
	                                                                                  /*                          HIF_AHI0        A22        + ext_a22                                                                        */
	                                                                                  /*    1101:    24     16M   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..25     A16..21                                                                                     */
	                                                                                  /*                          HIF_AHI0,1      A22,A23    + ext_a23                                                                        */
	                                                                                  /*    1110:    25     32M   HIF_A0..15      A0..A15                                                                                     */
	                                                                                  /*                          HIF_D20..25     A16..21                                                                                     */
	                                                                                  /*                          HIF_AHI0,1      A22,A23                                                                                     */
	                                                                                  /*                          HIF_BHE3        A24        + ext_a24 }                                                                      */
	                                                                                  /*                                                                                                                                      */
	                                                                                  /*   Note: CS3 and A24 are shared on HIF_BHE3 when not in netX50-compatibility mode. CS3 must be disabled                               */
	                                                                                  /*         when A24 shall be used. If CS3 shall be used, A24 must not be used (i.e. 1110 is forbidden) and                              */
	                                                                                  /*         HIF_BHE3 must be programmed as high driven output by PIO registers additionally (to ensure                                   */
	                                                                                  /*         inactive signal state when CS3 is used as chip-select but not enabled by software yet).                                      */
	                                                                                  /*   Note: To use high HIF_D lines as PIOs, select non-32bit HIF MI (hif_mi_cfg) and limit                                              */
	                                                                                  /*         address width here.                                                                                                          */
	                                                                                  /*   Note: When 'en_hif_sdram_mi' bit is set, HIF_A13..15 and HIF_AHI0,1 are not available as PIOs even                                 */
	                                                                                  /*         if according bits are set here. They are used for SDRAM controlling.                                                         */
	                                                                                  /*   Note: For parallel DPM, address line PIO usage depends on programmed DPM address range (config inside area DPM).                   */
	                                                                                  /*   Note: To use all address lines as PIOs, MI function can be disabled (set 'hif_mi_cfg' to '11').                                    */
	unsigned int reserved2              : BFW_NX51_hif_io_cfg_reserved2;              /* reserved                                                                                                                             */
	unsigned int en_hif_rdy_pio_mi      : BFW_NX51_hif_io_cfg_en_hif_rdy_pio_mi;      /* Enable HIF_RDY for PIO usage.                                                                                                        */
	                                                                                  /* Note: This bit must be disabled if HIF_RDY is used as EXT_BUS RDY (extension bus ready input).                                       */
	                                                                                  /* Note: This bit is ignored if HIF is DPM. Use DPM RDY configuration if HIF_RDY should                                                 */
	                                                                                  /*       be used as PIO together with DPM functionallity.                                                                               */
	unsigned int en_hif_wdg_sys_hif_d19 : BFW_NX51_hif_io_cfg_en_hif_wdg_sys_hif_d19; /* Enable 'wdg_active'/'WDGACT'-signal of netx system watchdog on HIF_D19.                                                              */
	                                                                                  /* When this bit is set HIF_D19 will be set to output mode and provide watchdog-active signal. However                                  */
	                                                                                  /* this will have no effect when HIF_D19 is used for another function. For parallel                                                     */
	                                                                                  /* DPM with watchdog HIF_D19 must be set to PIO mode inside DPM module.                                                                 */
	                                                                                  /* Note: netX system watch can be programmed inside address area 'WATCHDOG'/'NETX_WDG_AREA'.                                            */
	unsigned int reserved3              : BFW_NX51_hif_io_cfg_reserved3;              /* reserved                                                                                                                             */
	unsigned int netx50_io_comp_ro      : BFW_NX51_hif_io_cfg_netx50_io_comp_ro;      /* Status (read-only) of current netx50-IO-compatibility setting.                                                                       */
	                                                                                  /* netX50 compatibility setting basically protects netx51 IOs HIF_AHI0 and HIF_AHI1 when used                                           */
	                                                                                  /* for netX50-drop-in-replacement of existing netX50 designs. False programming could                                                   */
	                                                                                  /* cause permanent damage to netx51.                                                                                                    */
	                                                                                  /* State of net50 IO comptibility setting affects HIF IO signal mapping. IO compatibility                                               */
	                                                                                  /* setting can be changed inside 'misc_asic_ctrl' register of ASIC_CTRL address area. For                                               */
	                                                                                  /* further details view 'misc_asic_ctrl' register description.                                                                          */
} NX51_HIF_IO_CFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_HIF_IO_CFG_BIT_T bf;
} NX51_HIF_IO_CFG_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_cfg */
/* => HIF PIO Mode configuration register. */
/*    Note: MMIO40..47 are shared with HIF IOs. For details view description of 'io_config2' register inside ASIC_CTRL address area. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_cfg         0x00000004U
#define Adr_NX51_hif_io_ctrl_hif_pio_cfg 0x1018C544U
#define Adr_NX51_hif_pio_cfg             0x1018C544U
#define DFLT_VAL_NX51_hif_pio_cfg        0x88000008U

#define MSK_NX51_hif_pio_cfg_in_ctrl                     0x00000003U
#define SRT_NX51_hif_pio_cfg_in_ctrl                     0
#define DFLT_VAL_NX51_hif_pio_cfg_in_ctrl                0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_in_ctrl             0x00000000U
#define MSK_NX51_hif_pio_cfg_sel_en_in                   0x00000004U
#define SRT_NX51_hif_pio_cfg_sel_en_in                   2
#define DFLT_VAL_NX51_hif_pio_cfg_sel_en_in              0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_sel_en_in           0x00000000U
#define MSK_NX51_hif_pio_cfg_filter_en_in                0x00000008U
#define SRT_NX51_hif_pio_cfg_filter_en_in                3
#define DFLT_VAL_NX51_hif_pio_cfg_filter_en_in           0x00000008U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_filter_en_in        0x00000001U
#define MSK_NX51_hif_pio_cfg_irq_pio35_cfg               0x00030000U
#define SRT_NX51_hif_pio_cfg_irq_pio35_cfg               16
#define DFLT_VAL_NX51_hif_pio_cfg_irq_pio35_cfg          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_irq_pio35_cfg       0x00000000U
#define MSK_NX51_hif_pio_cfg_irq_pio36_cfg               0x000c0000U
#define SRT_NX51_hif_pio_cfg_irq_pio36_cfg               18
#define DFLT_VAL_NX51_hif_pio_cfg_irq_pio36_cfg          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_irq_pio36_cfg       0x00000000U
#define MSK_NX51_hif_pio_cfg_irq_pio40_cfg               0x00300000U
#define SRT_NX51_hif_pio_cfg_irq_pio40_cfg               20
#define DFLT_VAL_NX51_hif_pio_cfg_irq_pio40_cfg          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_irq_pio40_cfg       0x00000000U
#define MSK_NX51_hif_pio_cfg_irq_pio47_cfg               0x00c00000U
#define SRT_NX51_hif_pio_cfg_irq_pio47_cfg               22
#define DFLT_VAL_NX51_hif_pio_cfg_irq_pio47_cfg          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_irq_pio47_cfg       0x00000000U
#define MSK_NX51_hif_pio_cfg_irq_pio72_cfg               0x03000000U
#define SRT_NX51_hif_pio_cfg_irq_pio72_cfg               24
#define DFLT_VAL_NX51_hif_pio_cfg_irq_pio72_cfg          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_irq_pio72_cfg       0x00000000U
#define MSK_NX51_hif_pio_cfg_filter_irqs                 0x08000000U
#define SRT_NX51_hif_pio_cfg_filter_irqs                 27
#define DFLT_VAL_NX51_hif_pio_cfg_filter_irqs            0x08000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_filter_irqs         0x00000001U
#define MSK_NX51_hif_pio_cfg_netX50_pio_reg_comp         0x80000000U
#define SRT_NX51_hif_pio_cfg_netX50_pio_reg_comp         31
#define DFLT_VAL_NX51_hif_pio_cfg_netX50_pio_reg_comp    0x80000000U
#define DFLT_BF_VAL_NX51_hif_pio_cfg_netX50_pio_reg_comp 0x00000001U

/* all used bits of 'NX51_hif_pio_cfg': */
#define MSK_USED_BITS_NX51_hif_pio_cfg 0x8bff000fU

enum {
	BFW_NX51_hif_pio_cfg_in_ctrl             = 2,  /* [1:0] */
	BFW_NX51_hif_pio_cfg_sel_en_in           = 1,  /* [2] */
	BFW_NX51_hif_pio_cfg_filter_en_in        = 1,  /* [3] */
	BFW_NX51_hif_pio_cfg_reserved1           = 12, /* [15:4] */
	BFW_NX51_hif_pio_cfg_irq_pio35_cfg       = 2,  /* [17:16] */
	BFW_NX51_hif_pio_cfg_irq_pio36_cfg       = 2,  /* [19:18] */
	BFW_NX51_hif_pio_cfg_irq_pio40_cfg       = 2,  /* [21:20] */
	BFW_NX51_hif_pio_cfg_irq_pio47_cfg       = 2,  /* [23:22] */
	BFW_NX51_hif_pio_cfg_irq_pio72_cfg       = 2,  /* [25:24] */
	BFW_NX51_hif_pio_cfg_reserved2           = 1,  /* [26] */
	BFW_NX51_hif_pio_cfg_filter_irqs         = 1,  /* [27] */
	BFW_NX51_hif_pio_cfg_reserved3           = 3,  /* [30:28] */
	BFW_NX51_hif_pio_cfg_netX50_pio_reg_comp = 1   /* [31] */
};

typedef struct NX51_HIF_PIO_CFG_BIT_Ttag {
	unsigned int in_ctrl             : BFW_NX51_hif_pio_cfg_in_ctrl;             /* HIF PIO Input sampling mode.                                                                       */
	                                                                             /* HIF input status registers hif_pio_in0,1 can be configured by programming these bits.              */
	                                                                             /* {        |                                                                                         */
	                                                                             /*     Mode   Function                                                                                */
	                                                                             /*       00   pio_in registers show HIF IO states sampled at power-on-reset release.                  */
	                                                                             /*       01   HIF IO states are sampled continuously (each netX system clock cycle)                   */
	                                                                             /*       10   HIF IO states are sampling is done each system clock cycle when enable signal           */
	                                                                             /*            EN_IN(selected by sel_en_in bit) level is low.                                          */
	                                                                             /*       11   HIF IO states are sampling is done each system clock cycle when enable signal           */
	                                                                             /*            EN_IN(selected by sel_en_in bit) level is high.                                         */
	                                                                             /*   others   reserved }                                                                              */
	                                                                             /* Note:                                                                                              */
	                                                                             /*    Settings 00 to 11 are netX 50 compatible (netX 50 register DPM_ARM_IO_MODE1.IN_CONTROL).        */
	                                                                             /* Note:                                                                                              */
	                                                                             /*    Power-on-reset states will not be lost when 'in_ctrl' is set to a value not 0.                  */
	                                                                             /* Note:                                                                                              */
	                                                                             /*     Power-on-reset states can be used to read pullup/down configuration of HIF-IOs.                */
	                                                                             /*     However, be careful using reset sampled values of HIF data lines when SDRAM is                 */
	                                                                             /*     connected: When Reset is done during SDRAM read access, SDRAM device will keep                 */
	                                                                             /*     driving data bus. Pull-up/down values will be overdriven by that.                              */
	                                                                             /* Note:                                                                                              */
	                                                                             /*    netx51 MEM IOs are also sampled at nres. Related registers are located in ASIC_CTRL             */
	                                                                             /*    address area.                                                                                   */
	unsigned int sel_en_in           : BFW_NX51_hif_pio_cfg_sel_en_in;           /* HIF PIO Input sampling enable select.                                                              */
	                                                                             /*  0: HIF_D16/PIO36 is HIF PIO sample enable signal EN_IN                                            */
	                                                                             /*  1: HIF_D4/PIO77 is HIF PIO sample enable signal EN_IN                                             */
	unsigned int filter_en_in        : BFW_NX51_hif_pio_cfg_filter_en_in;        /* HIF PIO Input sampling enable (EN_IN) filter.                                                      */
	                                                                             /*  0 Spikes will not be supressed for EN_IN.                                                         */
	                                                                             /*  1 Spikes up tp 10ns will be suppressed by HIF PIO EN_IN sample stages.                            */
	                                                                             /* Note:                                                                                              */
	                                                                             /*    Spike supression can only done for EN_IN input (HIF_D16/PIO36 or HIF_D4/PIO77).                 */
	                                                                             /*    There is no spike supression for data inputs of 'hif_pio_in0,1' registers.                      */
	unsigned int reserved1           : BFW_NX51_hif_pio_cfg_reserved1;           /* reserved                                                                                           */
	unsigned int irq_pio35_cfg       : BFW_NX51_hif_pio_cfg_irq_pio35_cfg;       /* HIF PIO35 configuration (netx51: HIF_D17) IRQ (coding like irq_pio72_cfg bit field)                */
	unsigned int irq_pio36_cfg       : BFW_NX51_hif_pio_cfg_irq_pio36_cfg;       /* HIF PIO36 configuration (netx51: HIF_D16) IRQ (coding like irq_pio72_cfg bit field)                */
	unsigned int irq_pio40_cfg       : BFW_NX51_hif_pio_cfg_irq_pio40_cfg;       /* HIF PIO40 configuration (netx51: HIF_D18) IRQ (coding like irq_pio72_cfg bit field)                */
	unsigned int irq_pio47_cfg       : BFW_NX51_hif_pio_cfg_irq_pio47_cfg;       /* HIF PIO47 configuration (netx51: HIF_DIRQ) IRQ (coding like irq_pio72_cfg bit field)               */
	unsigned int irq_pio72_cfg       : BFW_NX51_hif_pio_cfg_irq_pio72_cfg;       /* HIF PIO72 configuration (netx51: HIF_D27) IRQ                                                      */
	                                                                             /* {        |                                                                                         */
	                                                                             /*     Mode   Function                                                                                */
	                                                                             /*       00   low level active IRQ                                                                    */
	                                                                             /*       01   high level active IRQ                                                                   */
	                                                                             /*       10   falling edge active IRQ                                                                 */
	                                                                             /*       11   rising edge active IRQ }                                                                */
	                                                                             /* For IRQ usage the related IO should be in PIO input mode (i.e. unused in current HIF configuration */
	                                                                             /* programmed in 'hif_io_cfg' register and related PIO output enable must be '0').                    */
	                                                                             /* Spikes on related PIO can be suppressed by 'filter_irqs' bit.                                      */
	                                                                             /* Note: HIF PIO IRQs can be assigned and monitored in hif_pio_irq registers further down.            */
	unsigned int reserved2           : BFW_NX51_hif_pio_cfg_reserved2;           /* reserved                                                                                           */
	unsigned int filter_irqs         : BFW_NX51_hif_pio_cfg_filter_irqs;         /* Filtering of HIF PIO inputs for IRQ generation.                                                    */
	                                                                             /* By default filtering is applied on HIF PIO inputs before IRQ generation.                           */
	                                                                             /*  0 Spikes on PIOs will not be supressed for HIF PIO IRQ generation.                                */
	                                                                             /*  1 Spikes up to 10ns on HIF PIOs will be suppressed by sample stages for HIF PIO                   */
	                                                                             /*    IRQ generation. That causes 10ns additionally IRQ latency.                                      */
	unsigned int reserved3           : BFW_NX51_hif_pio_cfg_reserved3;           /* reserved                                                                                           */
	unsigned int netX50_pio_reg_comp : BFW_NX51_hif_pio_cfg_netX50_pio_reg_comp; /* netX50 HIF-PIO configuration register compatibility.                                               */
	                                                                             /* This bit controlles netX50 compatibility for HIF PIO programming. When this bit is set             */
	                                                                             /* hif_pio_out and hif_pio_oe registers are in netX50 compatibility mode.                             */
	                                                                             /* {                 |                   |                                                            */
	                                                                             /*   netx51 register   netX50 compatible   function                                                   */
	                                                                             /*      hif_pio_out0     DPM_ARM_IO_DATA0  write: output level, read: IO input state of HIF-PIO63..32 */
	                                                                             /*      hif_pio_out1     DPM_ARM_IO_DATA1  write: output level, read: IO input state of HIF-PIO85..64 */
	                                                                             /*       hif_pio_oe0   DPM_ARM_IO_DRV_EN0  output driver for HIF-PIO63..32                            */
	                                                                             /*       hif_pio_oe1   DPM_ARM_IO_DRV_EN1  output driver for HIF-PIO85..64 }                          */
	                                                                             /* Note:                                                                                              */
	                                                                             /*    hif_pio_in0/1 are not supported in netx50-PIO-compatibility mode. These registers do not        */
	                                                                             /*    exist in netX50.                                                                                */
	                                                                             /* Note:                                                                                              */
	                                                                             /*    For further details see hif_pio_out and hif_pio_oe registers descriptions.                      */
	                                                                             /* Note:                                                                                              */
	                                                                             /*    netX50 PIO configuration register compatibility is not effected by global netx50_io_comp        */
	                                                                             /*    setting. PIO programming can even be done netx50 compatible when  netx50_io_comp is disabled.   */
} NX51_HIF_PIO_CFG_BIT_T;

typedef union {
	unsigned int           val;
	NX51_HIF_PIO_CFG_BIT_T bf;
} NX51_HIF_PIO_CFG_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_out0 */
/* => HIF PIO Output State Configuration Register 0. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the programmed state if appropriate enable bit */
/*    is set in hif_pio_oe0 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    This register can be programmed in netX50 compatibility mode depending on current setting of hif_pio_cfg.netX50_pio_reg_comp */
/*    bit. When netX50 compatibility mode is enabled (this is default), this register behaves like netX50 DPM_ARM_IO_DATA0 */
/*    register and controlles HIF PIO63 to PIO32. */
/*    The function is then: */
/*       Input or Output Data of each I/O Pin */
/*       Read: */
/*       0 : Physical Input Level is 0 */
/*       1 : Physical Input Level is 1 */
/*       Write: */
/*       0 : Sets the output pin level to 0 when configured as output */
/*       1 : Sets the output pin level to 1 when configured as output */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access for netx50-compatibility. */
/*    The following bit-description is for disabled netX50 PIO programming compatibility. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_out0         0x00000008U
#define Adr_NX51_hif_io_ctrl_hif_pio_out0 0x1018C548U
#define Adr_NX51_hif_pio_out0             0x1018C548U
#define DFLT_VAL_NX51_hif_pio_out0        0x00000000U

#define MSK_NX51_hif_pio_out0_hif_d0          0x00000001U
#define SRT_NX51_hif_pio_out0_hif_d0          0
#define DFLT_VAL_NX51_hif_pio_out0_hif_d0     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d0  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d1          0x00000002U
#define SRT_NX51_hif_pio_out0_hif_d1          1
#define DFLT_VAL_NX51_hif_pio_out0_hif_d1     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d1  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d2          0x00000004U
#define SRT_NX51_hif_pio_out0_hif_d2          2
#define DFLT_VAL_NX51_hif_pio_out0_hif_d2     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d2  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d3          0x00000008U
#define SRT_NX51_hif_pio_out0_hif_d3          3
#define DFLT_VAL_NX51_hif_pio_out0_hif_d3     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d3  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d4          0x00000010U
#define SRT_NX51_hif_pio_out0_hif_d4          4
#define DFLT_VAL_NX51_hif_pio_out0_hif_d4     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d4  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d5          0x00000020U
#define SRT_NX51_hif_pio_out0_hif_d5          5
#define DFLT_VAL_NX51_hif_pio_out0_hif_d5     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d5  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d6          0x00000040U
#define SRT_NX51_hif_pio_out0_hif_d6          6
#define DFLT_VAL_NX51_hif_pio_out0_hif_d6     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d6  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d7          0x00000080U
#define SRT_NX51_hif_pio_out0_hif_d7          7
#define DFLT_VAL_NX51_hif_pio_out0_hif_d7     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d7  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d8          0x00000100U
#define SRT_NX51_hif_pio_out0_hif_d8          8
#define DFLT_VAL_NX51_hif_pio_out0_hif_d8     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d8  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d9          0x00000200U
#define SRT_NX51_hif_pio_out0_hif_d9          9
#define DFLT_VAL_NX51_hif_pio_out0_hif_d9     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d9  0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d10         0x00000400U
#define SRT_NX51_hif_pio_out0_hif_d10         10
#define DFLT_VAL_NX51_hif_pio_out0_hif_d10    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d10 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d11         0x00000800U
#define SRT_NX51_hif_pio_out0_hif_d11         11
#define DFLT_VAL_NX51_hif_pio_out0_hif_d11    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d11 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d12         0x00001000U
#define SRT_NX51_hif_pio_out0_hif_d12         12
#define DFLT_VAL_NX51_hif_pio_out0_hif_d12    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d12 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d13         0x00002000U
#define SRT_NX51_hif_pio_out0_hif_d13         13
#define DFLT_VAL_NX51_hif_pio_out0_hif_d13    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d13 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d14         0x00004000U
#define SRT_NX51_hif_pio_out0_hif_d14         14
#define DFLT_VAL_NX51_hif_pio_out0_hif_d14    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d14 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d15         0x00008000U
#define SRT_NX51_hif_pio_out0_hif_d15         15
#define DFLT_VAL_NX51_hif_pio_out0_hif_d15    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d15 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d16         0x00010000U
#define SRT_NX51_hif_pio_out0_hif_d16         16
#define DFLT_VAL_NX51_hif_pio_out0_hif_d16    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d16 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d17         0x00020000U
#define SRT_NX51_hif_pio_out0_hif_d17         17
#define DFLT_VAL_NX51_hif_pio_out0_hif_d17    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d17 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d18         0x00040000U
#define SRT_NX51_hif_pio_out0_hif_d18         18
#define DFLT_VAL_NX51_hif_pio_out0_hif_d18    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d18 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d19         0x00080000U
#define SRT_NX51_hif_pio_out0_hif_d19         19
#define DFLT_VAL_NX51_hif_pio_out0_hif_d19    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d19 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d20         0x00100000U
#define SRT_NX51_hif_pio_out0_hif_d20         20
#define DFLT_VAL_NX51_hif_pio_out0_hif_d20    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d20 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d21         0x00200000U
#define SRT_NX51_hif_pio_out0_hif_d21         21
#define DFLT_VAL_NX51_hif_pio_out0_hif_d21    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d21 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d22         0x00400000U
#define SRT_NX51_hif_pio_out0_hif_d22         22
#define DFLT_VAL_NX51_hif_pio_out0_hif_d22    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d22 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d23         0x00800000U
#define SRT_NX51_hif_pio_out0_hif_d23         23
#define DFLT_VAL_NX51_hif_pio_out0_hif_d23    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d23 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d24         0x01000000U
#define SRT_NX51_hif_pio_out0_hif_d24         24
#define DFLT_VAL_NX51_hif_pio_out0_hif_d24    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d24 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d25         0x02000000U
#define SRT_NX51_hif_pio_out0_hif_d25         25
#define DFLT_VAL_NX51_hif_pio_out0_hif_d25    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d25 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d26         0x04000000U
#define SRT_NX51_hif_pio_out0_hif_d26         26
#define DFLT_VAL_NX51_hif_pio_out0_hif_d26    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d26 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d27         0x08000000U
#define SRT_NX51_hif_pio_out0_hif_d27         27
#define DFLT_VAL_NX51_hif_pio_out0_hif_d27    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d27 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d28         0x10000000U
#define SRT_NX51_hif_pio_out0_hif_d28         28
#define DFLT_VAL_NX51_hif_pio_out0_hif_d28    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d28 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d29         0x20000000U
#define SRT_NX51_hif_pio_out0_hif_d29         29
#define DFLT_VAL_NX51_hif_pio_out0_hif_d29    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d29 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d30         0x40000000U
#define SRT_NX51_hif_pio_out0_hif_d30         30
#define DFLT_VAL_NX51_hif_pio_out0_hif_d30    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d30 0x00000000U
#define MSK_NX51_hif_pio_out0_hif_d31         0x80000000U
#define SRT_NX51_hif_pio_out0_hif_d31         31
#define DFLT_VAL_NX51_hif_pio_out0_hif_d31    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out0_hif_d31 0x00000000U

/* all used bits of 'NX51_hif_pio_out0': */
#define MSK_USED_BITS_NX51_hif_pio_out0 0xffffffffU

enum {
	BFW_NX51_hif_pio_out0_hif_d0  = 1, /* [0] */
	BFW_NX51_hif_pio_out0_hif_d1  = 1, /* [1] */
	BFW_NX51_hif_pio_out0_hif_d2  = 1, /* [2] */
	BFW_NX51_hif_pio_out0_hif_d3  = 1, /* [3] */
	BFW_NX51_hif_pio_out0_hif_d4  = 1, /* [4] */
	BFW_NX51_hif_pio_out0_hif_d5  = 1, /* [5] */
	BFW_NX51_hif_pio_out0_hif_d6  = 1, /* [6] */
	BFW_NX51_hif_pio_out0_hif_d7  = 1, /* [7] */
	BFW_NX51_hif_pio_out0_hif_d8  = 1, /* [8] */
	BFW_NX51_hif_pio_out0_hif_d9  = 1, /* [9] */
	BFW_NX51_hif_pio_out0_hif_d10 = 1, /* [10] */
	BFW_NX51_hif_pio_out0_hif_d11 = 1, /* [11] */
	BFW_NX51_hif_pio_out0_hif_d12 = 1, /* [12] */
	BFW_NX51_hif_pio_out0_hif_d13 = 1, /* [13] */
	BFW_NX51_hif_pio_out0_hif_d14 = 1, /* [14] */
	BFW_NX51_hif_pio_out0_hif_d15 = 1, /* [15] */
	BFW_NX51_hif_pio_out0_hif_d16 = 1, /* [16] */
	BFW_NX51_hif_pio_out0_hif_d17 = 1, /* [17] */
	BFW_NX51_hif_pio_out0_hif_d18 = 1, /* [18] */
	BFW_NX51_hif_pio_out0_hif_d19 = 1, /* [19] */
	BFW_NX51_hif_pio_out0_hif_d20 = 1, /* [20] */
	BFW_NX51_hif_pio_out0_hif_d21 = 1, /* [21] */
	BFW_NX51_hif_pio_out0_hif_d22 = 1, /* [22] */
	BFW_NX51_hif_pio_out0_hif_d23 = 1, /* [23] */
	BFW_NX51_hif_pio_out0_hif_d24 = 1, /* [24] */
	BFW_NX51_hif_pio_out0_hif_d25 = 1, /* [25] */
	BFW_NX51_hif_pio_out0_hif_d26 = 1, /* [26] */
	BFW_NX51_hif_pio_out0_hif_d27 = 1, /* [27] */
	BFW_NX51_hif_pio_out0_hif_d28 = 1, /* [28] */
	BFW_NX51_hif_pio_out0_hif_d29 = 1, /* [29] */
	BFW_NX51_hif_pio_out0_hif_d30 = 1, /* [30] */
	BFW_NX51_hif_pio_out0_hif_d31 = 1  /* [31] */
};

typedef struct NX51_HIF_PIO_OUT0_BIT_Ttag {
	unsigned int hif_d0  : BFW_NX51_hif_pio_out0_hif_d0;  /* PIO output drive level of HIF_D0 signal or PIO32 in netx50-PIO-comp. mode.  */
	unsigned int hif_d1  : BFW_NX51_hif_pio_out0_hif_d1;  /* PIO output drive level of HIF_D1 signal or PIO33 in netx50-PIO-comp. mode.  */
	unsigned int hif_d2  : BFW_NX51_hif_pio_out0_hif_d2;  /* PIO output drive level of HIF_D2 signal or PIO34 in netx50-PIO-comp. mode.  */
	unsigned int hif_d3  : BFW_NX51_hif_pio_out0_hif_d3;  /* PIO output drive level of HIF_D3 signal or PIO35 in netx50-PIO-comp. mode.  */
	unsigned int hif_d4  : BFW_NX51_hif_pio_out0_hif_d4;  /* PIO output drive level of HIF_D4 signal or PIO36 in netx50-PIO-comp. mode.  */
	unsigned int hif_d5  : BFW_NX51_hif_pio_out0_hif_d5;  /* PIO output drive level of HIF_D5 signal or PIO37 in netx50-PIO-comp. mode.  */
	unsigned int hif_d6  : BFW_NX51_hif_pio_out0_hif_d6;  /* PIO output drive level of HIF_D6 signal or PIO38 in netx50-PIO-comp. mode.  */
	unsigned int hif_d7  : BFW_NX51_hif_pio_out0_hif_d7;  /* PIO output drive level of HIF_D7 signal or PIO39 in netx50-PIO-comp. mode.  */
	unsigned int hif_d8  : BFW_NX51_hif_pio_out0_hif_d8;  /* PIO output drive level of HIF_D8 signal or PIO40 in netx50-PIO-comp. mode.  */
	unsigned int hif_d9  : BFW_NX51_hif_pio_out0_hif_d9;  /* PIO output drive level of HIF_D9 signal or PIO41 in netx50-PIO-comp. mode.  */
	unsigned int hif_d10 : BFW_NX51_hif_pio_out0_hif_d10; /* PIO output drive level of HIF_D10 signal or PIO42 in netx50-PIO-comp. mode. */
	unsigned int hif_d11 : BFW_NX51_hif_pio_out0_hif_d11; /* PIO output drive level of HIF_D11 signal or PIO43 in netx50-PIO-comp. mode. */
	unsigned int hif_d12 : BFW_NX51_hif_pio_out0_hif_d12; /* PIO output drive level of HIF_D12 signal or PIO44 in netx50-PIO-comp. mode. */
	unsigned int hif_d13 : BFW_NX51_hif_pio_out0_hif_d13; /* PIO output drive level of HIF_D13 signal or PIO45 in netx50-PIO-comp. mode. */
	unsigned int hif_d14 : BFW_NX51_hif_pio_out0_hif_d14; /* PIO output drive level of HIF_D14 signal or PIO46 in netx50-PIO-comp. mode. */
	unsigned int hif_d15 : BFW_NX51_hif_pio_out0_hif_d15; /* PIO output drive level of HIF_D15 signal or PIO47 in netx50-PIO-comp. mode. */
	unsigned int hif_d16 : BFW_NX51_hif_pio_out0_hif_d16; /* PIO output drive level of HIF_D16 signal or PIO48 in netx50-PIO-comp. mode. */
	unsigned int hif_d17 : BFW_NX51_hif_pio_out0_hif_d17; /* PIO output drive level of HIF_D17 signal or PIO49 in netx50-PIO-comp. mode. */
	unsigned int hif_d18 : BFW_NX51_hif_pio_out0_hif_d18; /* PIO output drive level of HIF_D18 signal or PIO50 in netx50-PIO-comp. mode. */
	unsigned int hif_d19 : BFW_NX51_hif_pio_out0_hif_d19; /* PIO output drive level of HIF_D19 signal or PIO51 in netx50-PIO-comp. mode. */
	unsigned int hif_d20 : BFW_NX51_hif_pio_out0_hif_d20; /* PIO output drive level of HIF_D20 signal or PIO52 in netx50-PIO-comp. mode. */
	unsigned int hif_d21 : BFW_NX51_hif_pio_out0_hif_d21; /* PIO output drive level of HIF_D21 signal or PIO53 in netx50-PIO-comp. mode. */
	unsigned int hif_d22 : BFW_NX51_hif_pio_out0_hif_d22; /* PIO output drive level of HIF_D22 signal or PIO54 in netx50-PIO-comp. mode. */
	unsigned int hif_d23 : BFW_NX51_hif_pio_out0_hif_d23; /* PIO output drive level of HIF_D23 signal or PIO55 in netx50-PIO-comp. mode. */
	unsigned int hif_d24 : BFW_NX51_hif_pio_out0_hif_d24; /* PIO output drive level of HIF_D24 signal or PIO56 in netx50-PIO-comp. mode. */
	unsigned int hif_d25 : BFW_NX51_hif_pio_out0_hif_d25; /* PIO output drive level of HIF_D25 signal or PIO57 in netx50-PIO-comp. mode. */
	unsigned int hif_d26 : BFW_NX51_hif_pio_out0_hif_d26; /* PIO output drive level of HIF_D26 signal or PIO58 in netx50-PIO-comp. mode. */
	unsigned int hif_d27 : BFW_NX51_hif_pio_out0_hif_d27; /* PIO output drive level of HIF_D27 signal or PIO59 in netx50-PIO-comp. mode. */
	unsigned int hif_d28 : BFW_NX51_hif_pio_out0_hif_d28; /* PIO output drive level of HIF_D28 signal or PIO60 in netx50-PIO-comp. mode. */
	unsigned int hif_d29 : BFW_NX51_hif_pio_out0_hif_d29; /* PIO output drive level of HIF_D29 signal or PIO61 in netx50-PIO-comp. mode. */
	unsigned int hif_d30 : BFW_NX51_hif_pio_out0_hif_d30; /* PIO output drive level of HIF_D30 signal or PIO62 in netx50-PIO-comp. mode. */
	unsigned int hif_d31 : BFW_NX51_hif_pio_out0_hif_d31; /* PIO output drive level of HIF_D31 signal or PIO63 in netx50-PIO-comp. mode. */
} NX51_HIF_PIO_OUT0_BIT_T;

typedef union {
	unsigned int            val;
	NX51_HIF_PIO_OUT0_BIT_T bf;
} NX51_HIF_PIO_OUT0_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_out1 */
/* => HIF PIO Output State Configuration Register 1. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the programmed state if appropriate enable bit */
/*    is set in hif_pio_oe1 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    This register can be programmed in netX50 compatibility mode depending on current setting of hif_pio_cfg.netX50_pio_reg_comp */
/*    bit. When netX50 compatibility mode is enabled (this is default), this register behaves like netX50 DPM_ARM_IO_DATA1 */
/*    register and controlles HIF PIO85 to PIO64 (only register bits 21 to 0 are valid then). */
/*    The function is then: */
/*       Input or Output Data of each I/O Pin */
/*       Read: */
/*       0 : Physical Input Level is 0 */
/*       1 : Physical Input Level is 1 */
/*       Write: */
/*       0 : Sets the output pin level to 0 when configured as output */
/*       1 : Sets the output pin level to 1 when configured as output */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access for netx50-compatibility. */
/*    The following bit-description is for disabled netX50 PIO programming compatibility. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_out1         0x0000000CU
#define Adr_NX51_hif_io_ctrl_hif_pio_out1 0x1018C54CU
#define Adr_NX51_hif_pio_out1             0x1018C54CU
#define DFLT_VAL_NX51_hif_pio_out1        0x00000000U

#define MSK_NX51_hif_pio_out1_hif_a0                 0x00000001U
#define SRT_NX51_hif_pio_out1_hif_a0                 0
#define DFLT_VAL_NX51_hif_pio_out1_hif_a0            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a0         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a1                 0x00000002U
#define SRT_NX51_hif_pio_out1_hif_a1                 1
#define DFLT_VAL_NX51_hif_pio_out1_hif_a1            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a1         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a2                 0x00000004U
#define SRT_NX51_hif_pio_out1_hif_a2                 2
#define DFLT_VAL_NX51_hif_pio_out1_hif_a2            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a2         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a3                 0x00000008U
#define SRT_NX51_hif_pio_out1_hif_a3                 3
#define DFLT_VAL_NX51_hif_pio_out1_hif_a3            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a3         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a4                 0x00000010U
#define SRT_NX51_hif_pio_out1_hif_a4                 4
#define DFLT_VAL_NX51_hif_pio_out1_hif_a4            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a4         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a5                 0x00000020U
#define SRT_NX51_hif_pio_out1_hif_a5                 5
#define DFLT_VAL_NX51_hif_pio_out1_hif_a5            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a5         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a6                 0x00000040U
#define SRT_NX51_hif_pio_out1_hif_a6                 6
#define DFLT_VAL_NX51_hif_pio_out1_hif_a6            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a6         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a7                 0x00000080U
#define SRT_NX51_hif_pio_out1_hif_a7                 7
#define DFLT_VAL_NX51_hif_pio_out1_hif_a7            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a7         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a8                 0x00000100U
#define SRT_NX51_hif_pio_out1_hif_a8                 8
#define DFLT_VAL_NX51_hif_pio_out1_hif_a8            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a8         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a9                 0x00000200U
#define SRT_NX51_hif_pio_out1_hif_a9                 9
#define DFLT_VAL_NX51_hif_pio_out1_hif_a9            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a9         0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a10                0x00000400U
#define SRT_NX51_hif_pio_out1_hif_a10                10
#define DFLT_VAL_NX51_hif_pio_out1_hif_a10           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a10        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a11                0x00000800U
#define SRT_NX51_hif_pio_out1_hif_a11                11
#define DFLT_VAL_NX51_hif_pio_out1_hif_a11           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a11        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a12                0x00001000U
#define SRT_NX51_hif_pio_out1_hif_a12                12
#define DFLT_VAL_NX51_hif_pio_out1_hif_a12           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a12        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a13                0x00002000U
#define SRT_NX51_hif_pio_out1_hif_a13                13
#define DFLT_VAL_NX51_hif_pio_out1_hif_a13           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a13        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a14                0x00004000U
#define SRT_NX51_hif_pio_out1_hif_a14                14
#define DFLT_VAL_NX51_hif_pio_out1_hif_a14           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a14        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_a15                0x00008000U
#define SRT_NX51_hif_pio_out1_hif_a15                15
#define DFLT_VAL_NX51_hif_pio_out1_hif_a15           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_a15        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_ahi0               0x00010000U
#define SRT_NX51_hif_pio_out1_hif_ahi0               16
#define DFLT_VAL_NX51_hif_pio_out1_hif_ahi0          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_ahi0       0x00000000U
#define MSK_NX51_hif_pio_out1_hif_ahi1               0x00020000U
#define SRT_NX51_hif_pio_out1_hif_ahi1               17
#define DFLT_VAL_NX51_hif_pio_out1_hif_ahi1          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_ahi1       0x00000000U
#define MSK_NX51_hif_pio_out1_nx50_pio85to82         0x003c0000U
#define SRT_NX51_hif_pio_out1_nx50_pio85to82         18
#define DFLT_VAL_NX51_hif_pio_out1_nx50_pio85to82    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_nx50_pio85to82 0x00000000U
#define MSK_NX51_hif_pio_out1_hif_bhe3               0x01000000U
#define SRT_NX51_hif_pio_out1_hif_bhe3               24
#define DFLT_VAL_NX51_hif_pio_out1_hif_bhe3          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_bhe3       0x00000000U
#define MSK_NX51_hif_pio_out1_hif_bhe1               0x02000000U
#define SRT_NX51_hif_pio_out1_hif_bhe1               25
#define DFLT_VAL_NX51_hif_pio_out1_hif_bhe1          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_bhe1       0x00000000U
#define MSK_NX51_hif_pio_out1_hif_rdn                0x04000000U
#define SRT_NX51_hif_pio_out1_hif_rdn                26
#define DFLT_VAL_NX51_hif_pio_out1_hif_rdn           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_rdn        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_wrn                0x08000000U
#define SRT_NX51_hif_pio_out1_hif_wrn                27
#define DFLT_VAL_NX51_hif_pio_out1_hif_wrn           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_wrn        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_csn                0x10000000U
#define SRT_NX51_hif_pio_out1_hif_csn                28
#define DFLT_VAL_NX51_hif_pio_out1_hif_csn           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_csn        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_rdy                0x20000000U
#define SRT_NX51_hif_pio_out1_hif_rdy                29
#define DFLT_VAL_NX51_hif_pio_out1_hif_rdy           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_rdy        0x00000000U
#define MSK_NX51_hif_pio_out1_hif_dirq               0x40000000U
#define SRT_NX51_hif_pio_out1_hif_dirq               30
#define DFLT_VAL_NX51_hif_pio_out1_hif_dirq          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_dirq       0x00000000U
#define MSK_NX51_hif_pio_out1_hif_sdclk              0x80000000U
#define SRT_NX51_hif_pio_out1_hif_sdclk              31
#define DFLT_VAL_NX51_hif_pio_out1_hif_sdclk         0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_out1_hif_sdclk      0x00000000U

/* all used bits of 'NX51_hif_pio_out1': */
#define MSK_USED_BITS_NX51_hif_pio_out1 0xff3fffffU

enum {
	BFW_NX51_hif_pio_out1_hif_a0         = 1, /* [0] */
	BFW_NX51_hif_pio_out1_hif_a1         = 1, /* [1] */
	BFW_NX51_hif_pio_out1_hif_a2         = 1, /* [2] */
	BFW_NX51_hif_pio_out1_hif_a3         = 1, /* [3] */
	BFW_NX51_hif_pio_out1_hif_a4         = 1, /* [4] */
	BFW_NX51_hif_pio_out1_hif_a5         = 1, /* [5] */
	BFW_NX51_hif_pio_out1_hif_a6         = 1, /* [6] */
	BFW_NX51_hif_pio_out1_hif_a7         = 1, /* [7] */
	BFW_NX51_hif_pio_out1_hif_a8         = 1, /* [8] */
	BFW_NX51_hif_pio_out1_hif_a9         = 1, /* [9] */
	BFW_NX51_hif_pio_out1_hif_a10        = 1, /* [10] */
	BFW_NX51_hif_pio_out1_hif_a11        = 1, /* [11] */
	BFW_NX51_hif_pio_out1_hif_a12        = 1, /* [12] */
	BFW_NX51_hif_pio_out1_hif_a13        = 1, /* [13] */
	BFW_NX51_hif_pio_out1_hif_a14        = 1, /* [14] */
	BFW_NX51_hif_pio_out1_hif_a15        = 1, /* [15] */
	BFW_NX51_hif_pio_out1_hif_ahi0       = 1, /* [16] */
	BFW_NX51_hif_pio_out1_hif_ahi1       = 1, /* [17] */
	BFW_NX51_hif_pio_out1_nx50_pio85to82 = 4, /* [21:18] */
	BFW_NX51_hif_pio_out1_reserved1      = 2, /* [23:22] */
	BFW_NX51_hif_pio_out1_hif_bhe3       = 1, /* [24] */
	BFW_NX51_hif_pio_out1_hif_bhe1       = 1, /* [25] */
	BFW_NX51_hif_pio_out1_hif_rdn        = 1, /* [26] */
	BFW_NX51_hif_pio_out1_hif_wrn        = 1, /* [27] */
	BFW_NX51_hif_pio_out1_hif_csn        = 1, /* [28] */
	BFW_NX51_hif_pio_out1_hif_rdy        = 1, /* [29] */
	BFW_NX51_hif_pio_out1_hif_dirq       = 1, /* [30] */
	BFW_NX51_hif_pio_out1_hif_sdclk      = 1  /* [31] */
};

typedef struct NX51_HIF_PIO_OUT1_BIT_Ttag {
	unsigned int hif_a0         : BFW_NX51_hif_pio_out1_hif_a0;         /* PIO output drive level of HIF_A0 signal or PIO64 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a1         : BFW_NX51_hif_pio_out1_hif_a1;         /* PIO output drive level of HIF_A1 signal or PIO65 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a2         : BFW_NX51_hif_pio_out1_hif_a2;         /* PIO output drive level of HIF_A2 signal or PIO66 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a3         : BFW_NX51_hif_pio_out1_hif_a3;         /* PIO output drive level of HIF_A3 signal or PIO67 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a4         : BFW_NX51_hif_pio_out1_hif_a4;         /* PIO output drive level of HIF_A4 signal or PIO68 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a5         : BFW_NX51_hif_pio_out1_hif_a5;         /* PIO output drive level of HIF_A5 signal or PIO69 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a6         : BFW_NX51_hif_pio_out1_hif_a6;         /* PIO output drive level of HIF_A6 signal or PIO70 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a7         : BFW_NX51_hif_pio_out1_hif_a7;         /* PIO output drive level of HIF_A7 signal or PIO71 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a8         : BFW_NX51_hif_pio_out1_hif_a8;         /* PIO output drive level of HIF_A8 signal or PIO72 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a9         : BFW_NX51_hif_pio_out1_hif_a9;         /* PIO output drive level of HIF_A9 signal or PIO73 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a10        : BFW_NX51_hif_pio_out1_hif_a10;        /* PIO output drive level of HIF_A10 signal or PIO74 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a11        : BFW_NX51_hif_pio_out1_hif_a11;        /* PIO output drive level of HIF_A11 signal or PIO75 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a12        : BFW_NX51_hif_pio_out1_hif_a12;        /* PIO output drive level of HIF_A12 signal or PIO76 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a13        : BFW_NX51_hif_pio_out1_hif_a13;        /* PIO output drive level of HIF_A13 signal or PIO77 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a14        : BFW_NX51_hif_pio_out1_hif_a14;        /* PIO output drive level of HIF_A14 signal or PIO78 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a15        : BFW_NX51_hif_pio_out1_hif_a15;        /* PIO output drive level of HIF_A15 signal or PIO79 in netx50-PIO-comp. mode.                                */
	unsigned int hif_ahi0       : BFW_NX51_hif_pio_out1_hif_ahi0;       /* PIO output drive level of HIF_AHI0 signal when netx50-IO-comp. disabled or PIO80 in netx50-PIO-comp. mode. */
	unsigned int hif_ahi1       : BFW_NX51_hif_pio_out1_hif_ahi1;       /* PIO output drive level of HIF_AHI1 signal when netx50-IO-comp. disabled or PIO81 in netx50-PIO-comp. mode. */
	unsigned int nx50_pio85to82 : BFW_NX51_hif_pio_out1_nx50_pio85to82; /* Output drive leve of HIF PIO85 to 82 in netx50-PIO-comp. mode signal (not available for netx51 PIO mode).  */
	unsigned int reserved1      : BFW_NX51_hif_pio_out1_reserved1;      /* reserved                                                                                                   */
	unsigned int hif_bhe3       : BFW_NX51_hif_pio_out1_hif_bhe3;       /* PIO output drive level of HIF_BHE3 signals (not available in netx50-PIO-comp. mode).                       */
	unsigned int hif_bhe1       : BFW_NX51_hif_pio_out1_hif_bhe1;       /* PIO output drive level of HIF_BHE1 signals (not available in netx50-PIO-comp. mode).                       */
	unsigned int hif_rdn        : BFW_NX51_hif_pio_out1_hif_rdn;        /* PIO output drive level of HIF_RDN signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_wrn        : BFW_NX51_hif_pio_out1_hif_wrn;        /* PIO output drive level of HIF_WRN signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_csn        : BFW_NX51_hif_pio_out1_hif_csn;        /* PIO output drive level of HIF_CSN signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_rdy        : BFW_NX51_hif_pio_out1_hif_rdy;        /* PIO output drive level of HIF_RDY signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_dirq       : BFW_NX51_hif_pio_out1_hif_dirq;       /* PIO output drive level of HIF_DIRQ signal (not available in netx50-PIO-comp. mode).                        */
	unsigned int hif_sdclk      : BFW_NX51_hif_pio_out1_hif_sdclk;      /* PIO output drive level of HIF_SDCLK signal (not available in netx50-PIO-comp. mode).                       */
} NX51_HIF_PIO_OUT1_BIT_T;

typedef union {
	unsigned int            val;
	NX51_HIF_PIO_OUT1_BIT_T bf;
} NX51_HIF_PIO_OUT1_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_oe0 */
/* => HIF PIO Output Enable Configuration Register 0. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the output state */
/*    programmed in in hif_pio_out0 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    This register can be programmed in netX50 compatibility mode depending on current setting of hif_pio_cfg.netX50_pio_reg_comp */
/*    bit. When netX50 compatibility mode is enabled (this is default), this register behaves like netX50 DPM_ARM_IO_DRV_EN0 */
/*    register and controlles HIF PIO63 to PIO32. */
/*    The function is then: */
/*       Driver output enable of each I/O Pin */
/*       0 : Output driver disabled */
/*       1 : Output driver enabled */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access for netx50-compatibility. */
/*    The following bit-description is for disabled netX50 PIO programming compatibility. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_oe0         0x00000010U
#define Adr_NX51_hif_io_ctrl_hif_pio_oe0 0x1018C550U
#define Adr_NX51_hif_pio_oe0             0x1018C550U
#define DFLT_VAL_NX51_hif_pio_oe0        0x00000000U

#define MSK_NX51_hif_pio_oe0_hif_d0          0x00000001U
#define SRT_NX51_hif_pio_oe0_hif_d0          0
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d0     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d0  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d1          0x00000002U
#define SRT_NX51_hif_pio_oe0_hif_d1          1
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d1     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d1  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d2          0x00000004U
#define SRT_NX51_hif_pio_oe0_hif_d2          2
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d2     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d2  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d3          0x00000008U
#define SRT_NX51_hif_pio_oe0_hif_d3          3
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d3     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d3  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d4          0x00000010U
#define SRT_NX51_hif_pio_oe0_hif_d4          4
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d4     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d4  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d5          0x00000020U
#define SRT_NX51_hif_pio_oe0_hif_d5          5
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d5     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d5  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d6          0x00000040U
#define SRT_NX51_hif_pio_oe0_hif_d6          6
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d6     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d6  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d7          0x00000080U
#define SRT_NX51_hif_pio_oe0_hif_d7          7
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d7     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d7  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d8          0x00000100U
#define SRT_NX51_hif_pio_oe0_hif_d8          8
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d8     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d8  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d9          0x00000200U
#define SRT_NX51_hif_pio_oe0_hif_d9          9
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d9     0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d9  0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d10         0x00000400U
#define SRT_NX51_hif_pio_oe0_hif_d10         10
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d10    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d10 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d11         0x00000800U
#define SRT_NX51_hif_pio_oe0_hif_d11         11
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d11    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d11 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d12         0x00001000U
#define SRT_NX51_hif_pio_oe0_hif_d12         12
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d12    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d12 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d13         0x00002000U
#define SRT_NX51_hif_pio_oe0_hif_d13         13
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d13    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d13 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d14         0x00004000U
#define SRT_NX51_hif_pio_oe0_hif_d14         14
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d14    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d14 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d15         0x00008000U
#define SRT_NX51_hif_pio_oe0_hif_d15         15
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d15    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d15 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d16         0x00010000U
#define SRT_NX51_hif_pio_oe0_hif_d16         16
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d16    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d16 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d17         0x00020000U
#define SRT_NX51_hif_pio_oe0_hif_d17         17
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d17    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d17 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d18         0x00040000U
#define SRT_NX51_hif_pio_oe0_hif_d18         18
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d18    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d18 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d19         0x00080000U
#define SRT_NX51_hif_pio_oe0_hif_d19         19
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d19    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d19 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d20         0x00100000U
#define SRT_NX51_hif_pio_oe0_hif_d20         20
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d20    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d20 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d21         0x00200000U
#define SRT_NX51_hif_pio_oe0_hif_d21         21
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d21    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d21 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d22         0x00400000U
#define SRT_NX51_hif_pio_oe0_hif_d22         22
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d22    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d22 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d23         0x00800000U
#define SRT_NX51_hif_pio_oe0_hif_d23         23
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d23    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d23 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d24         0x01000000U
#define SRT_NX51_hif_pio_oe0_hif_d24         24
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d24    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d24 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d25         0x02000000U
#define SRT_NX51_hif_pio_oe0_hif_d25         25
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d25    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d25 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d26         0x04000000U
#define SRT_NX51_hif_pio_oe0_hif_d26         26
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d26    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d26 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d27         0x08000000U
#define SRT_NX51_hif_pio_oe0_hif_d27         27
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d27    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d27 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d28         0x10000000U
#define SRT_NX51_hif_pio_oe0_hif_d28         28
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d28    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d28 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d29         0x20000000U
#define SRT_NX51_hif_pio_oe0_hif_d29         29
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d29    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d29 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d30         0x40000000U
#define SRT_NX51_hif_pio_oe0_hif_d30         30
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d30    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d30 0x00000000U
#define MSK_NX51_hif_pio_oe0_hif_d31         0x80000000U
#define SRT_NX51_hif_pio_oe0_hif_d31         31
#define DFLT_VAL_NX51_hif_pio_oe0_hif_d31    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe0_hif_d31 0x00000000U

/* all used bits of 'NX51_hif_pio_oe0': */
#define MSK_USED_BITS_NX51_hif_pio_oe0 0xffffffffU

enum {
	BFW_NX51_hif_pio_oe0_hif_d0  = 1, /* [0] */
	BFW_NX51_hif_pio_oe0_hif_d1  = 1, /* [1] */
	BFW_NX51_hif_pio_oe0_hif_d2  = 1, /* [2] */
	BFW_NX51_hif_pio_oe0_hif_d3  = 1, /* [3] */
	BFW_NX51_hif_pio_oe0_hif_d4  = 1, /* [4] */
	BFW_NX51_hif_pio_oe0_hif_d5  = 1, /* [5] */
	BFW_NX51_hif_pio_oe0_hif_d6  = 1, /* [6] */
	BFW_NX51_hif_pio_oe0_hif_d7  = 1, /* [7] */
	BFW_NX51_hif_pio_oe0_hif_d8  = 1, /* [8] */
	BFW_NX51_hif_pio_oe0_hif_d9  = 1, /* [9] */
	BFW_NX51_hif_pio_oe0_hif_d10 = 1, /* [10] */
	BFW_NX51_hif_pio_oe0_hif_d11 = 1, /* [11] */
	BFW_NX51_hif_pio_oe0_hif_d12 = 1, /* [12] */
	BFW_NX51_hif_pio_oe0_hif_d13 = 1, /* [13] */
	BFW_NX51_hif_pio_oe0_hif_d14 = 1, /* [14] */
	BFW_NX51_hif_pio_oe0_hif_d15 = 1, /* [15] */
	BFW_NX51_hif_pio_oe0_hif_d16 = 1, /* [16] */
	BFW_NX51_hif_pio_oe0_hif_d17 = 1, /* [17] */
	BFW_NX51_hif_pio_oe0_hif_d18 = 1, /* [18] */
	BFW_NX51_hif_pio_oe0_hif_d19 = 1, /* [19] */
	BFW_NX51_hif_pio_oe0_hif_d20 = 1, /* [20] */
	BFW_NX51_hif_pio_oe0_hif_d21 = 1, /* [21] */
	BFW_NX51_hif_pio_oe0_hif_d22 = 1, /* [22] */
	BFW_NX51_hif_pio_oe0_hif_d23 = 1, /* [23] */
	BFW_NX51_hif_pio_oe0_hif_d24 = 1, /* [24] */
	BFW_NX51_hif_pio_oe0_hif_d25 = 1, /* [25] */
	BFW_NX51_hif_pio_oe0_hif_d26 = 1, /* [26] */
	BFW_NX51_hif_pio_oe0_hif_d27 = 1, /* [27] */
	BFW_NX51_hif_pio_oe0_hif_d28 = 1, /* [28] */
	BFW_NX51_hif_pio_oe0_hif_d29 = 1, /* [29] */
	BFW_NX51_hif_pio_oe0_hif_d30 = 1, /* [30] */
	BFW_NX51_hif_pio_oe0_hif_d31 = 1  /* [31] */
};

typedef struct NX51_HIF_PIO_OE0_BIT_Ttag {
	unsigned int hif_d0  : BFW_NX51_hif_pio_oe0_hif_d0;  /* PIO output enable of HIF_D0 signal or PIO32 in netx50-PIO-comp. mode.  */
	unsigned int hif_d1  : BFW_NX51_hif_pio_oe0_hif_d1;  /* PIO output enable of HIF_D1 signal or PIO33 in netx50-PIO-comp. mode.  */
	unsigned int hif_d2  : BFW_NX51_hif_pio_oe0_hif_d2;  /* PIO output enable of HIF_D2 signal or PIO34 in netx50-PIO-comp. mode.  */
	unsigned int hif_d3  : BFW_NX51_hif_pio_oe0_hif_d3;  /* PIO output enable of HIF_D3 signal or PIO35 in netx50-PIO-comp. mode.  */
	unsigned int hif_d4  : BFW_NX51_hif_pio_oe0_hif_d4;  /* PIO output enable of HIF_D4 signal or PIO36 in netx50-PIO-comp. mode.  */
	unsigned int hif_d5  : BFW_NX51_hif_pio_oe0_hif_d5;  /* PIO output enable of HIF_D5 signal or PIO37 in netx50-PIO-comp. mode.  */
	unsigned int hif_d6  : BFW_NX51_hif_pio_oe0_hif_d6;  /* PIO output enable of HIF_D6 signal or PIO38 in netx50-PIO-comp. mode.  */
	unsigned int hif_d7  : BFW_NX51_hif_pio_oe0_hif_d7;  /* PIO output enable of HIF_D7 signal or PIO39 in netx50-PIO-comp. mode.  */
	unsigned int hif_d8  : BFW_NX51_hif_pio_oe0_hif_d8;  /* PIO output enable of HIF_D8 signal or PIO40 in netx50-PIO-comp. mode.  */
	unsigned int hif_d9  : BFW_NX51_hif_pio_oe0_hif_d9;  /* PIO output enable of HIF_D9 signal or PIO41 in netx50-PIO-comp. mode.  */
	unsigned int hif_d10 : BFW_NX51_hif_pio_oe0_hif_d10; /* PIO output enable of HIF_D10 signal or PIO42 in netx50-PIO-comp. mode. */
	unsigned int hif_d11 : BFW_NX51_hif_pio_oe0_hif_d11; /* PIO output enable of HIF_D11 signal or PIO43 in netx50-PIO-comp. mode. */
	unsigned int hif_d12 : BFW_NX51_hif_pio_oe0_hif_d12; /* PIO output enable of HIF_D12 signal or PIO44 in netx50-PIO-comp. mode. */
	unsigned int hif_d13 : BFW_NX51_hif_pio_oe0_hif_d13; /* PIO output enable of HIF_D13 signal or PIO45 in netx50-PIO-comp. mode. */
	unsigned int hif_d14 : BFW_NX51_hif_pio_oe0_hif_d14; /* PIO output enable of HIF_D14 signal or PIO46 in netx50-PIO-comp. mode. */
	unsigned int hif_d15 : BFW_NX51_hif_pio_oe0_hif_d15; /* PIO output enable of HIF_D15 signal or PIO47 in netx50-PIO-comp. mode. */
	unsigned int hif_d16 : BFW_NX51_hif_pio_oe0_hif_d16; /* PIO output enable of HIF_D16 signal or PIO48 in netx50-PIO-comp. mode. */
	unsigned int hif_d17 : BFW_NX51_hif_pio_oe0_hif_d17; /* PIO output enable of HIF_D17 signal or PIO49 in netx50-PIO-comp. mode. */
	unsigned int hif_d18 : BFW_NX51_hif_pio_oe0_hif_d18; /* PIO output enable of HIF_D18 signal or PIO50 in netx50-PIO-comp. mode. */
	unsigned int hif_d19 : BFW_NX51_hif_pio_oe0_hif_d19; /* PIO output enable of HIF_D19 signal or PIO51 in netx50-PIO-comp. mode. */
	unsigned int hif_d20 : BFW_NX51_hif_pio_oe0_hif_d20; /* PIO output enable of HIF_D20 signal or PIO52 in netx50-PIO-comp. mode. */
	unsigned int hif_d21 : BFW_NX51_hif_pio_oe0_hif_d21; /* PIO output enable of HIF_D21 signal or PIO53 in netx50-PIO-comp. mode. */
	unsigned int hif_d22 : BFW_NX51_hif_pio_oe0_hif_d22; /* PIO output enable of HIF_D22 signal or PIO54 in netx50-PIO-comp. mode. */
	unsigned int hif_d23 : BFW_NX51_hif_pio_oe0_hif_d23; /* PIO output enable of HIF_D23 signal or PIO55 in netx50-PIO-comp. mode. */
	unsigned int hif_d24 : BFW_NX51_hif_pio_oe0_hif_d24; /* PIO output enable of HIF_D24 signal or PIO56 in netx50-PIO-comp. mode. */
	unsigned int hif_d25 : BFW_NX51_hif_pio_oe0_hif_d25; /* PIO output enable of HIF_D25 signal or PIO57 in netx50-PIO-comp. mode. */
	unsigned int hif_d26 : BFW_NX51_hif_pio_oe0_hif_d26; /* PIO output enable of HIF_D26 signal or PIO58 in netx50-PIO-comp. mode. */
	unsigned int hif_d27 : BFW_NX51_hif_pio_oe0_hif_d27; /* PIO output enable of HIF_D27 signal or PIO59 in netx50-PIO-comp. mode. */
	unsigned int hif_d28 : BFW_NX51_hif_pio_oe0_hif_d28; /* PIO output enable of HIF_D28 signal or PIO60 in netx50-PIO-comp. mode. */
	unsigned int hif_d29 : BFW_NX51_hif_pio_oe0_hif_d29; /* PIO output enable of HIF_D29 signal or PIO61 in netx50-PIO-comp. mode. */
	unsigned int hif_d30 : BFW_NX51_hif_pio_oe0_hif_d30; /* PIO output enable of HIF_D30 signal or PIO62 in netx50-PIO-comp. mode. */
	unsigned int hif_d31 : BFW_NX51_hif_pio_oe0_hif_d31; /* PIO output enable of HIF_D31 signal or PIO63 in netx50-PIO-comp. mode. */
} NX51_HIF_PIO_OE0_BIT_T;

typedef union {
	unsigned int           val;
	NX51_HIF_PIO_OE0_BIT_T bf;
} NX51_HIF_PIO_OE0_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_oe1 */
/* => HIF PIO Output Enable Configuration Register 1. */
/*    All unused HIF signals can be used as PIOs. IOs will be driven to the output state */
/*    programmed in in hif_pio_out1 register. */
/*    PIO mode driving of HIF-IOs used in current HIF/EXT_BUS Memory Interface configuration is not possible. */
/*    ----------------------- */
/*    This register can be programmed in netX50 compatibility mode depending on current setting of hif_pio_cfg.netX50_pio_reg_comp */
/*    bit. When netX50 compatibility mode is enabled (this is default), this register behaves like netX50 DPM_ARM_IO_DRV_EN1 */
/*    register and controlles HIF PIO85 to PIO64 (only register bits 21 to 0 are valid then). */
/*    The function is then: */
/*       Driver output enable of each I/O Pin */
/*       0 : Output driver disabled */
/*       1 : Output driver enabled */
/*    ----------------------- */
/*    Note: */
/*       This register can be read or written by 8, 16 or 32 bit access for netx50-compatibility. */
/*    The following bit-description is for disabled netX50 PIO programming compatibility. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_oe1         0x00000014U
#define Adr_NX51_hif_io_ctrl_hif_pio_oe1 0x1018C554U
#define Adr_NX51_hif_pio_oe1             0x1018C554U
#define DFLT_VAL_NX51_hif_pio_oe1        0x00000000U

#define MSK_NX51_hif_pio_oe1_hif_a0                 0x00000001U
#define SRT_NX51_hif_pio_oe1_hif_a0                 0
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a0            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a0         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a1                 0x00000002U
#define SRT_NX51_hif_pio_oe1_hif_a1                 1
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a1            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a1         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a2                 0x00000004U
#define SRT_NX51_hif_pio_oe1_hif_a2                 2
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a2            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a2         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a3                 0x00000008U
#define SRT_NX51_hif_pio_oe1_hif_a3                 3
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a3            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a3         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a4                 0x00000010U
#define SRT_NX51_hif_pio_oe1_hif_a4                 4
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a4            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a4         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a5                 0x00000020U
#define SRT_NX51_hif_pio_oe1_hif_a5                 5
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a5            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a5         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a6                 0x00000040U
#define SRT_NX51_hif_pio_oe1_hif_a6                 6
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a6            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a6         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a7                 0x00000080U
#define SRT_NX51_hif_pio_oe1_hif_a7                 7
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a7            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a7         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a8                 0x00000100U
#define SRT_NX51_hif_pio_oe1_hif_a8                 8
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a8            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a8         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a9                 0x00000200U
#define SRT_NX51_hif_pio_oe1_hif_a9                 9
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a9            0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a9         0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a10                0x00000400U
#define SRT_NX51_hif_pio_oe1_hif_a10                10
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a10           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a10        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a11                0x00000800U
#define SRT_NX51_hif_pio_oe1_hif_a11                11
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a11           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a11        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a12                0x00001000U
#define SRT_NX51_hif_pio_oe1_hif_a12                12
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a12           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a12        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a13                0x00002000U
#define SRT_NX51_hif_pio_oe1_hif_a13                13
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a13           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a13        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a14                0x00004000U
#define SRT_NX51_hif_pio_oe1_hif_a14                14
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a14           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a14        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_a15                0x00008000U
#define SRT_NX51_hif_pio_oe1_hif_a15                15
#define DFLT_VAL_NX51_hif_pio_oe1_hif_a15           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_a15        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_ahi0               0x00010000U
#define SRT_NX51_hif_pio_oe1_hif_ahi0               16
#define DFLT_VAL_NX51_hif_pio_oe1_hif_ahi0          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_ahi0       0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_ahi1               0x00020000U
#define SRT_NX51_hif_pio_oe1_hif_ahi1               17
#define DFLT_VAL_NX51_hif_pio_oe1_hif_ahi1          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_ahi1       0x00000000U
#define MSK_NX51_hif_pio_oe1_nx50_pio85to82         0x003c0000U
#define SRT_NX51_hif_pio_oe1_nx50_pio85to82         18
#define DFLT_VAL_NX51_hif_pio_oe1_nx50_pio85to82    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_nx50_pio85to82 0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_bhe3               0x01000000U
#define SRT_NX51_hif_pio_oe1_hif_bhe3               24
#define DFLT_VAL_NX51_hif_pio_oe1_hif_bhe3          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_bhe3       0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_bhe1               0x02000000U
#define SRT_NX51_hif_pio_oe1_hif_bhe1               25
#define DFLT_VAL_NX51_hif_pio_oe1_hif_bhe1          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_bhe1       0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_rdn                0x04000000U
#define SRT_NX51_hif_pio_oe1_hif_rdn                26
#define DFLT_VAL_NX51_hif_pio_oe1_hif_rdn           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_rdn        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_wrn                0x08000000U
#define SRT_NX51_hif_pio_oe1_hif_wrn                27
#define DFLT_VAL_NX51_hif_pio_oe1_hif_wrn           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_wrn        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_csn                0x10000000U
#define SRT_NX51_hif_pio_oe1_hif_csn                28
#define DFLT_VAL_NX51_hif_pio_oe1_hif_csn           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_csn        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_rdy                0x20000000U
#define SRT_NX51_hif_pio_oe1_hif_rdy                29
#define DFLT_VAL_NX51_hif_pio_oe1_hif_rdy           0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_rdy        0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_dirq               0x40000000U
#define SRT_NX51_hif_pio_oe1_hif_dirq               30
#define DFLT_VAL_NX51_hif_pio_oe1_hif_dirq          0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_dirq       0x00000000U
#define MSK_NX51_hif_pio_oe1_hif_sdclk              0x80000000U
#define SRT_NX51_hif_pio_oe1_hif_sdclk              31
#define DFLT_VAL_NX51_hif_pio_oe1_hif_sdclk         0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_oe1_hif_sdclk      0x00000000U

/* all used bits of 'NX51_hif_pio_oe1': */
#define MSK_USED_BITS_NX51_hif_pio_oe1 0xff3fffffU

enum {
	BFW_NX51_hif_pio_oe1_hif_a0         = 1, /* [0] */
	BFW_NX51_hif_pio_oe1_hif_a1         = 1, /* [1] */
	BFW_NX51_hif_pio_oe1_hif_a2         = 1, /* [2] */
	BFW_NX51_hif_pio_oe1_hif_a3         = 1, /* [3] */
	BFW_NX51_hif_pio_oe1_hif_a4         = 1, /* [4] */
	BFW_NX51_hif_pio_oe1_hif_a5         = 1, /* [5] */
	BFW_NX51_hif_pio_oe1_hif_a6         = 1, /* [6] */
	BFW_NX51_hif_pio_oe1_hif_a7         = 1, /* [7] */
	BFW_NX51_hif_pio_oe1_hif_a8         = 1, /* [8] */
	BFW_NX51_hif_pio_oe1_hif_a9         = 1, /* [9] */
	BFW_NX51_hif_pio_oe1_hif_a10        = 1, /* [10] */
	BFW_NX51_hif_pio_oe1_hif_a11        = 1, /* [11] */
	BFW_NX51_hif_pio_oe1_hif_a12        = 1, /* [12] */
	BFW_NX51_hif_pio_oe1_hif_a13        = 1, /* [13] */
	BFW_NX51_hif_pio_oe1_hif_a14        = 1, /* [14] */
	BFW_NX51_hif_pio_oe1_hif_a15        = 1, /* [15] */
	BFW_NX51_hif_pio_oe1_hif_ahi0       = 1, /* [16] */
	BFW_NX51_hif_pio_oe1_hif_ahi1       = 1, /* [17] */
	BFW_NX51_hif_pio_oe1_nx50_pio85to82 = 4, /* [21:18] */
	BFW_NX51_hif_pio_oe1_reserved1      = 2, /* [23:22] */
	BFW_NX51_hif_pio_oe1_hif_bhe3       = 1, /* [24] */
	BFW_NX51_hif_pio_oe1_hif_bhe1       = 1, /* [25] */
	BFW_NX51_hif_pio_oe1_hif_rdn        = 1, /* [26] */
	BFW_NX51_hif_pio_oe1_hif_wrn        = 1, /* [27] */
	BFW_NX51_hif_pio_oe1_hif_csn        = 1, /* [28] */
	BFW_NX51_hif_pio_oe1_hif_rdy        = 1, /* [29] */
	BFW_NX51_hif_pio_oe1_hif_dirq       = 1, /* [30] */
	BFW_NX51_hif_pio_oe1_hif_sdclk      = 1  /* [31] */
};

typedef struct NX51_HIF_PIO_OE1_BIT_Ttag {
	unsigned int hif_a0         : BFW_NX51_hif_pio_oe1_hif_a0;         /* PIO output enable of HIF_A0 signal or PIO64 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a1         : BFW_NX51_hif_pio_oe1_hif_a1;         /* PIO output enable of HIF_A1 signal or PIO65 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a2         : BFW_NX51_hif_pio_oe1_hif_a2;         /* PIO output enable of HIF_A2 signal or PIO66 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a3         : BFW_NX51_hif_pio_oe1_hif_a3;         /* PIO output enable of HIF_A3 signal or PIO67 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a4         : BFW_NX51_hif_pio_oe1_hif_a4;         /* PIO output enable of HIF_A4 signal or PIO68 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a5         : BFW_NX51_hif_pio_oe1_hif_a5;         /* PIO output enable of HIF_A5 signal or PIO69 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a6         : BFW_NX51_hif_pio_oe1_hif_a6;         /* PIO output enable of HIF_A6 signal or PIO70 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a7         : BFW_NX51_hif_pio_oe1_hif_a7;         /* PIO output enable of HIF_A7 signal or PIO71 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a8         : BFW_NX51_hif_pio_oe1_hif_a8;         /* PIO output enable of HIF_A8 signal or PIO72 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a9         : BFW_NX51_hif_pio_oe1_hif_a9;         /* PIO output enable of HIF_A9 signal or PIO73 in netx50-PIO-comp. mode.                                 */
	unsigned int hif_a10        : BFW_NX51_hif_pio_oe1_hif_a10;        /* PIO output enable of HIF_A10 signal or PIO74 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a11        : BFW_NX51_hif_pio_oe1_hif_a11;        /* PIO output enable of HIF_A11 signal or PIO75 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a12        : BFW_NX51_hif_pio_oe1_hif_a12;        /* PIO output enable of HIF_A12 signal or PIO76 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a13        : BFW_NX51_hif_pio_oe1_hif_a13;        /* PIO output enable of HIF_A13 signal or PIO77 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a14        : BFW_NX51_hif_pio_oe1_hif_a14;        /* PIO output enable of HIF_A14 signal or PIO78 in netx50-PIO-comp. mode.                                */
	unsigned int hif_a15        : BFW_NX51_hif_pio_oe1_hif_a15;        /* PIO output enable of HIF_A15 signal or PIO79 in netx50-PIO-comp. mode.                                */
	unsigned int hif_ahi0       : BFW_NX51_hif_pio_oe1_hif_ahi0;       /* PIO output enable of HIF_AHI0 signal when netx50-IO-comp. disabled or PIO80 in netx50-PIO-comp. mode. */
	unsigned int hif_ahi1       : BFW_NX51_hif_pio_oe1_hif_ahi1;       /* PIO output enable of HIF_AHI1 signal when netx50-IO-comp. disabled or PIO81 in netx50-PIO-comp. mode. */
	unsigned int nx50_pio85to82 : BFW_NX51_hif_pio_oe1_nx50_pio85to82; /* Output enable of HIF PIO85 to 82 in netx50-PIO-comp. mode signal (not available for netx51 PIO mode). */
	unsigned int reserved1      : BFW_NX51_hif_pio_oe1_reserved1;      /* reserved                                                                                              */
	unsigned int hif_bhe3       : BFW_NX51_hif_pio_oe1_hif_bhe3;       /* PIO output enable of HIF_BHE3 signals (not available in netx50-PIO-comp. mode).                       */
	unsigned int hif_bhe1       : BFW_NX51_hif_pio_oe1_hif_bhe1;       /* PIO output enable of HIF_BHE1 signals (not available in netx50-PIO-comp. mode).                       */
	unsigned int hif_rdn        : BFW_NX51_hif_pio_oe1_hif_rdn;        /* PIO output enable of HIF_RDN signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_wrn        : BFW_NX51_hif_pio_oe1_hif_wrn;        /* PIO output enable of HIF_WRN signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_csn        : BFW_NX51_hif_pio_oe1_hif_csn;        /* PIO output enable of HIF_CSN signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_rdy        : BFW_NX51_hif_pio_oe1_hif_rdy;        /* PIO output enable of HIF_RDY signal (not available in netx50-PIO-comp. mode).                         */
	unsigned int hif_dirq       : BFW_NX51_hif_pio_oe1_hif_dirq;       /* PIO output enable of HIF_DIRQ signal (not available in netx50-PIO-comp. mode).                        */
	unsigned int hif_sdclk      : BFW_NX51_hif_pio_oe1_hif_sdclk;      /* PIO output enable of HIF_SDCLK signal (not available in netx50-PIO-comp. mode).                       */
} NX51_HIF_PIO_OE1_BIT_T;

typedef union {
	unsigned int           val;
	NX51_HIF_PIO_OE1_BIT_T bf;
} NX51_HIF_PIO_OE1_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_in0 */
/* => HIF PIO Input State Register 0. */
/*    IO input states can be read here regardless whether IO is used in current HIF/EXT_BUS Memory Interface configuration. */
/*    HIF IO sampling behaviour can be programmed by 'in_ctrl' bits of 'hif_pio_cfg' register. */
/*    Note: */
/*       netx50-PIO-compatibility mode does not cover this register. Input status will always be given as listed below. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_in0         0x00000018U
#define Adr_NX51_hif_io_ctrl_hif_pio_in0 0x1018C558U
#define Adr_NX51_hif_pio_in0             0x1018C558U

#define MSK_NX51_hif_pio_in0_hif_d0  0x00000001U
#define SRT_NX51_hif_pio_in0_hif_d0  0
#define MSK_NX51_hif_pio_in0_hif_d1  0x00000002U
#define SRT_NX51_hif_pio_in0_hif_d1  1
#define MSK_NX51_hif_pio_in0_hif_d2  0x00000004U
#define SRT_NX51_hif_pio_in0_hif_d2  2
#define MSK_NX51_hif_pio_in0_hif_d3  0x00000008U
#define SRT_NX51_hif_pio_in0_hif_d3  3
#define MSK_NX51_hif_pio_in0_hif_d4  0x00000010U
#define SRT_NX51_hif_pio_in0_hif_d4  4
#define MSK_NX51_hif_pio_in0_hif_d5  0x00000020U
#define SRT_NX51_hif_pio_in0_hif_d5  5
#define MSK_NX51_hif_pio_in0_hif_d6  0x00000040U
#define SRT_NX51_hif_pio_in0_hif_d6  6
#define MSK_NX51_hif_pio_in0_hif_d7  0x00000080U
#define SRT_NX51_hif_pio_in0_hif_d7  7
#define MSK_NX51_hif_pio_in0_hif_d8  0x00000100U
#define SRT_NX51_hif_pio_in0_hif_d8  8
#define MSK_NX51_hif_pio_in0_hif_d9  0x00000200U
#define SRT_NX51_hif_pio_in0_hif_d9  9
#define MSK_NX51_hif_pio_in0_hif_d10 0x00000400U
#define SRT_NX51_hif_pio_in0_hif_d10 10
#define MSK_NX51_hif_pio_in0_hif_d11 0x00000800U
#define SRT_NX51_hif_pio_in0_hif_d11 11
#define MSK_NX51_hif_pio_in0_hif_d12 0x00001000U
#define SRT_NX51_hif_pio_in0_hif_d12 12
#define MSK_NX51_hif_pio_in0_hif_d13 0x00002000U
#define SRT_NX51_hif_pio_in0_hif_d13 13
#define MSK_NX51_hif_pio_in0_hif_d14 0x00004000U
#define SRT_NX51_hif_pio_in0_hif_d14 14
#define MSK_NX51_hif_pio_in0_hif_d15 0x00008000U
#define SRT_NX51_hif_pio_in0_hif_d15 15
#define MSK_NX51_hif_pio_in0_hif_d16 0x00010000U
#define SRT_NX51_hif_pio_in0_hif_d16 16
#define MSK_NX51_hif_pio_in0_hif_d17 0x00020000U
#define SRT_NX51_hif_pio_in0_hif_d17 17
#define MSK_NX51_hif_pio_in0_hif_d18 0x00040000U
#define SRT_NX51_hif_pio_in0_hif_d18 18
#define MSK_NX51_hif_pio_in0_hif_d19 0x00080000U
#define SRT_NX51_hif_pio_in0_hif_d19 19
#define MSK_NX51_hif_pio_in0_hif_d20 0x00100000U
#define SRT_NX51_hif_pio_in0_hif_d20 20
#define MSK_NX51_hif_pio_in0_hif_d21 0x00200000U
#define SRT_NX51_hif_pio_in0_hif_d21 21
#define MSK_NX51_hif_pio_in0_hif_d22 0x00400000U
#define SRT_NX51_hif_pio_in0_hif_d22 22
#define MSK_NX51_hif_pio_in0_hif_d23 0x00800000U
#define SRT_NX51_hif_pio_in0_hif_d23 23
#define MSK_NX51_hif_pio_in0_hif_d24 0x01000000U
#define SRT_NX51_hif_pio_in0_hif_d24 24
#define MSK_NX51_hif_pio_in0_hif_d25 0x02000000U
#define SRT_NX51_hif_pio_in0_hif_d25 25
#define MSK_NX51_hif_pio_in0_hif_d26 0x04000000U
#define SRT_NX51_hif_pio_in0_hif_d26 26
#define MSK_NX51_hif_pio_in0_hif_d27 0x08000000U
#define SRT_NX51_hif_pio_in0_hif_d27 27
#define MSK_NX51_hif_pio_in0_hif_d28 0x10000000U
#define SRT_NX51_hif_pio_in0_hif_d28 28
#define MSK_NX51_hif_pio_in0_hif_d29 0x20000000U
#define SRT_NX51_hif_pio_in0_hif_d29 29
#define MSK_NX51_hif_pio_in0_hif_d30 0x40000000U
#define SRT_NX51_hif_pio_in0_hif_d30 30
#define MSK_NX51_hif_pio_in0_hif_d31 0x80000000U
#define SRT_NX51_hif_pio_in0_hif_d31 31

/* all used bits of 'NX51_hif_pio_in0': */
#define MSK_USED_BITS_NX51_hif_pio_in0 0xffffffffU

enum {
	BFW_NX51_hif_pio_in0_hif_d0  = 1, /* [0] */
	BFW_NX51_hif_pio_in0_hif_d1  = 1, /* [1] */
	BFW_NX51_hif_pio_in0_hif_d2  = 1, /* [2] */
	BFW_NX51_hif_pio_in0_hif_d3  = 1, /* [3] */
	BFW_NX51_hif_pio_in0_hif_d4  = 1, /* [4] */
	BFW_NX51_hif_pio_in0_hif_d5  = 1, /* [5] */
	BFW_NX51_hif_pio_in0_hif_d6  = 1, /* [6] */
	BFW_NX51_hif_pio_in0_hif_d7  = 1, /* [7] */
	BFW_NX51_hif_pio_in0_hif_d8  = 1, /* [8] */
	BFW_NX51_hif_pio_in0_hif_d9  = 1, /* [9] */
	BFW_NX51_hif_pio_in0_hif_d10 = 1, /* [10] */
	BFW_NX51_hif_pio_in0_hif_d11 = 1, /* [11] */
	BFW_NX51_hif_pio_in0_hif_d12 = 1, /* [12] */
	BFW_NX51_hif_pio_in0_hif_d13 = 1, /* [13] */
	BFW_NX51_hif_pio_in0_hif_d14 = 1, /* [14] */
	BFW_NX51_hif_pio_in0_hif_d15 = 1, /* [15] */
	BFW_NX51_hif_pio_in0_hif_d16 = 1, /* [16] */
	BFW_NX51_hif_pio_in0_hif_d17 = 1, /* [17] */
	BFW_NX51_hif_pio_in0_hif_d18 = 1, /* [18] */
	BFW_NX51_hif_pio_in0_hif_d19 = 1, /* [19] */
	BFW_NX51_hif_pio_in0_hif_d20 = 1, /* [20] */
	BFW_NX51_hif_pio_in0_hif_d21 = 1, /* [21] */
	BFW_NX51_hif_pio_in0_hif_d22 = 1, /* [22] */
	BFW_NX51_hif_pio_in0_hif_d23 = 1, /* [23] */
	BFW_NX51_hif_pio_in0_hif_d24 = 1, /* [24] */
	BFW_NX51_hif_pio_in0_hif_d25 = 1, /* [25] */
	BFW_NX51_hif_pio_in0_hif_d26 = 1, /* [26] */
	BFW_NX51_hif_pio_in0_hif_d27 = 1, /* [27] */
	BFW_NX51_hif_pio_in0_hif_d28 = 1, /* [28] */
	BFW_NX51_hif_pio_in0_hif_d29 = 1, /* [29] */
	BFW_NX51_hif_pio_in0_hif_d30 = 1, /* [30] */
	BFW_NX51_hif_pio_in0_hif_d31 = 1  /* [31] */
};

typedef struct NX51_HIF_PIO_IN0_BIT_Ttag {
	unsigned int hif_d0  : BFW_NX51_hif_pio_in0_hif_d0;  /* PIO input state of HIF_D0 signal.  */
	unsigned int hif_d1  : BFW_NX51_hif_pio_in0_hif_d1;  /* PIO input state of HIF_D1 signal.  */
	unsigned int hif_d2  : BFW_NX51_hif_pio_in0_hif_d2;  /* PIO input state of HIF_D2 signal.  */
	unsigned int hif_d3  : BFW_NX51_hif_pio_in0_hif_d3;  /* PIO input state of HIF_D3 signal.  */
	unsigned int hif_d4  : BFW_NX51_hif_pio_in0_hif_d4;  /* PIO input state of HIF_D4 signal.  */
	unsigned int hif_d5  : BFW_NX51_hif_pio_in0_hif_d5;  /* PIO input state of HIF_D5 signal.  */
	unsigned int hif_d6  : BFW_NX51_hif_pio_in0_hif_d6;  /* PIO input state of HIF_D6 signal.  */
	unsigned int hif_d7  : BFW_NX51_hif_pio_in0_hif_d7;  /* PIO input state of HIF_D7 signal.  */
	unsigned int hif_d8  : BFW_NX51_hif_pio_in0_hif_d8;  /* PIO input state of HIF_D8 signal.  */
	unsigned int hif_d9  : BFW_NX51_hif_pio_in0_hif_d9;  /* PIO input state of HIF_D9 signal.  */
	unsigned int hif_d10 : BFW_NX51_hif_pio_in0_hif_d10; /* PIO input state of HIF_D10 signal. */
	unsigned int hif_d11 : BFW_NX51_hif_pio_in0_hif_d11; /* PIO input state of HIF_D11 signal. */
	unsigned int hif_d12 : BFW_NX51_hif_pio_in0_hif_d12; /* PIO input state of HIF_D12 signal. */
	unsigned int hif_d13 : BFW_NX51_hif_pio_in0_hif_d13; /* PIO input state of HIF_D13 signal. */
	unsigned int hif_d14 : BFW_NX51_hif_pio_in0_hif_d14; /* PIO input state of HIF_D14 signal. */
	unsigned int hif_d15 : BFW_NX51_hif_pio_in0_hif_d15; /* PIO input state of HIF_D15 signal. */
	unsigned int hif_d16 : BFW_NX51_hif_pio_in0_hif_d16; /* PIO input state of HIF_D16 signal. */
	unsigned int hif_d17 : BFW_NX51_hif_pio_in0_hif_d17; /* PIO input state of HIF_D17 signal. */
	unsigned int hif_d18 : BFW_NX51_hif_pio_in0_hif_d18; /* PIO input state of HIF_D18 signal. */
	unsigned int hif_d19 : BFW_NX51_hif_pio_in0_hif_d19; /* PIO input state of HIF_D19 signal. */
	unsigned int hif_d20 : BFW_NX51_hif_pio_in0_hif_d20; /* PIO input state of HIF_D20 signal. */
	unsigned int hif_d21 : BFW_NX51_hif_pio_in0_hif_d21; /* PIO input state of HIF_D21 signal. */
	unsigned int hif_d22 : BFW_NX51_hif_pio_in0_hif_d22; /* PIO input state of HIF_D22 signal. */
	unsigned int hif_d23 : BFW_NX51_hif_pio_in0_hif_d23; /* PIO input state of HIF_D23 signal. */
	unsigned int hif_d24 : BFW_NX51_hif_pio_in0_hif_d24; /* PIO input state of HIF_D24 signal. */
	unsigned int hif_d25 : BFW_NX51_hif_pio_in0_hif_d25; /* PIO input state of HIF_D25 signal. */
	unsigned int hif_d26 : BFW_NX51_hif_pio_in0_hif_d26; /* PIO input state of HIF_D26 signal. */
	unsigned int hif_d27 : BFW_NX51_hif_pio_in0_hif_d27; /* PIO input state of HIF_D27 signal. */
	unsigned int hif_d28 : BFW_NX51_hif_pio_in0_hif_d28; /* PIO input state of HIF_D28 signal. */
	unsigned int hif_d29 : BFW_NX51_hif_pio_in0_hif_d29; /* PIO input state of HIF_D29 signal. */
	unsigned int hif_d30 : BFW_NX51_hif_pio_in0_hif_d30; /* PIO input state of HIF_D30 signal. */
	unsigned int hif_d31 : BFW_NX51_hif_pio_in0_hif_d31; /* PIO input state of HIF_D31 signal. */
} NX51_HIF_PIO_IN0_BIT_T;

typedef union {
	unsigned int           val;
	NX51_HIF_PIO_IN0_BIT_T bf;
} NX51_HIF_PIO_IN0_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_in1 */
/* => HIF PIO Input State Register 1. */
/*    IO input states can be read here regardless whether IO is used in current HIF/EXT_BUS Memory Interface configuration. */
/*    Note: */
/*       netx50-PIO-compatibility mode does not cover this register. Input status will always be given as listed below. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_in1         0x0000001CU
#define Adr_NX51_hif_io_ctrl_hif_pio_in1 0x1018C55CU
#define Adr_NX51_hif_pio_in1             0x1018C55CU

#define MSK_NX51_hif_pio_in1_hif_a0    0x00000001U
#define SRT_NX51_hif_pio_in1_hif_a0    0
#define MSK_NX51_hif_pio_in1_hif_a1    0x00000002U
#define SRT_NX51_hif_pio_in1_hif_a1    1
#define MSK_NX51_hif_pio_in1_hif_a2    0x00000004U
#define SRT_NX51_hif_pio_in1_hif_a2    2
#define MSK_NX51_hif_pio_in1_hif_a3    0x00000008U
#define SRT_NX51_hif_pio_in1_hif_a3    3
#define MSK_NX51_hif_pio_in1_hif_a4    0x00000010U
#define SRT_NX51_hif_pio_in1_hif_a4    4
#define MSK_NX51_hif_pio_in1_hif_a5    0x00000020U
#define SRT_NX51_hif_pio_in1_hif_a5    5
#define MSK_NX51_hif_pio_in1_hif_a6    0x00000040U
#define SRT_NX51_hif_pio_in1_hif_a6    6
#define MSK_NX51_hif_pio_in1_hif_a7    0x00000080U
#define SRT_NX51_hif_pio_in1_hif_a7    7
#define MSK_NX51_hif_pio_in1_hif_a8    0x00000100U
#define SRT_NX51_hif_pio_in1_hif_a8    8
#define MSK_NX51_hif_pio_in1_hif_a9    0x00000200U
#define SRT_NX51_hif_pio_in1_hif_a9    9
#define MSK_NX51_hif_pio_in1_hif_a10   0x00000400U
#define SRT_NX51_hif_pio_in1_hif_a10   10
#define MSK_NX51_hif_pio_in1_hif_a11   0x00000800U
#define SRT_NX51_hif_pio_in1_hif_a11   11
#define MSK_NX51_hif_pio_in1_hif_a12   0x00001000U
#define SRT_NX51_hif_pio_in1_hif_a12   12
#define MSK_NX51_hif_pio_in1_hif_a13   0x00002000U
#define SRT_NX51_hif_pio_in1_hif_a13   13
#define MSK_NX51_hif_pio_in1_hif_a14   0x00004000U
#define SRT_NX51_hif_pio_in1_hif_a14   14
#define MSK_NX51_hif_pio_in1_hif_a15   0x00008000U
#define SRT_NX51_hif_pio_in1_hif_a15   15
#define MSK_NX51_hif_pio_in1_hif_ahi0  0x00010000U
#define SRT_NX51_hif_pio_in1_hif_ahi0  16
#define MSK_NX51_hif_pio_in1_hif_ahi1  0x00020000U
#define SRT_NX51_hif_pio_in1_hif_ahi1  17
#define MSK_NX51_hif_pio_in1_hif_bhe3  0x01000000U
#define SRT_NX51_hif_pio_in1_hif_bhe3  24
#define MSK_NX51_hif_pio_in1_hif_bhe1  0x02000000U
#define SRT_NX51_hif_pio_in1_hif_bhe1  25
#define MSK_NX51_hif_pio_in1_hif_rdn   0x04000000U
#define SRT_NX51_hif_pio_in1_hif_rdn   26
#define MSK_NX51_hif_pio_in1_hif_wrn   0x08000000U
#define SRT_NX51_hif_pio_in1_hif_wrn   27
#define MSK_NX51_hif_pio_in1_hif_csn   0x10000000U
#define SRT_NX51_hif_pio_in1_hif_csn   28
#define MSK_NX51_hif_pio_in1_hif_rdy   0x20000000U
#define SRT_NX51_hif_pio_in1_hif_rdy   29
#define MSK_NX51_hif_pio_in1_hif_dirq  0x40000000U
#define SRT_NX51_hif_pio_in1_hif_dirq  30
#define MSK_NX51_hif_pio_in1_hif_sdclk 0x80000000U
#define SRT_NX51_hif_pio_in1_hif_sdclk 31

/* all used bits of 'NX51_hif_pio_in1': */
#define MSK_USED_BITS_NX51_hif_pio_in1 0xff03ffffU

enum {
	BFW_NX51_hif_pio_in1_hif_a0    = 1, /* [0] */
	BFW_NX51_hif_pio_in1_hif_a1    = 1, /* [1] */
	BFW_NX51_hif_pio_in1_hif_a2    = 1, /* [2] */
	BFW_NX51_hif_pio_in1_hif_a3    = 1, /* [3] */
	BFW_NX51_hif_pio_in1_hif_a4    = 1, /* [4] */
	BFW_NX51_hif_pio_in1_hif_a5    = 1, /* [5] */
	BFW_NX51_hif_pio_in1_hif_a6    = 1, /* [6] */
	BFW_NX51_hif_pio_in1_hif_a7    = 1, /* [7] */
	BFW_NX51_hif_pio_in1_hif_a8    = 1, /* [8] */
	BFW_NX51_hif_pio_in1_hif_a9    = 1, /* [9] */
	BFW_NX51_hif_pio_in1_hif_a10   = 1, /* [10] */
	BFW_NX51_hif_pio_in1_hif_a11   = 1, /* [11] */
	BFW_NX51_hif_pio_in1_hif_a12   = 1, /* [12] */
	BFW_NX51_hif_pio_in1_hif_a13   = 1, /* [13] */
	BFW_NX51_hif_pio_in1_hif_a14   = 1, /* [14] */
	BFW_NX51_hif_pio_in1_hif_a15   = 1, /* [15] */
	BFW_NX51_hif_pio_in1_hif_ahi0  = 1, /* [16] */
	BFW_NX51_hif_pio_in1_hif_ahi1  = 1, /* [17] */
	BFW_NX51_hif_pio_in1_reserved1 = 6, /* [23:18] */
	BFW_NX51_hif_pio_in1_hif_bhe3  = 1, /* [24] */
	BFW_NX51_hif_pio_in1_hif_bhe1  = 1, /* [25] */
	BFW_NX51_hif_pio_in1_hif_rdn   = 1, /* [26] */
	BFW_NX51_hif_pio_in1_hif_wrn   = 1, /* [27] */
	BFW_NX51_hif_pio_in1_hif_csn   = 1, /* [28] */
	BFW_NX51_hif_pio_in1_hif_rdy   = 1, /* [29] */
	BFW_NX51_hif_pio_in1_hif_dirq  = 1, /* [30] */
	BFW_NX51_hif_pio_in1_hif_sdclk = 1  /* [31] */
};

typedef struct NX51_HIF_PIO_IN1_BIT_Ttag {
	unsigned int hif_a0    : BFW_NX51_hif_pio_in1_hif_a0;    /* PIO input state of HIF_A0 signal.                                          */
	unsigned int hif_a1    : BFW_NX51_hif_pio_in1_hif_a1;    /* PIO input state of HIF_A1 signal.                                          */
	unsigned int hif_a2    : BFW_NX51_hif_pio_in1_hif_a2;    /* PIO input state of HIF_A2 signal.                                          */
	unsigned int hif_a3    : BFW_NX51_hif_pio_in1_hif_a3;    /* PIO input state of HIF_A3 signal.                                          */
	unsigned int hif_a4    : BFW_NX51_hif_pio_in1_hif_a4;    /* PIO input state of HIF_A4 signal.                                          */
	unsigned int hif_a5    : BFW_NX51_hif_pio_in1_hif_a5;    /* PIO input state of HIF_A5 signal.                                          */
	unsigned int hif_a6    : BFW_NX51_hif_pio_in1_hif_a6;    /* PIO input state of HIF_A6 signal.                                          */
	unsigned int hif_a7    : BFW_NX51_hif_pio_in1_hif_a7;    /* PIO input state of HIF_A7 signal.                                          */
	unsigned int hif_a8    : BFW_NX51_hif_pio_in1_hif_a8;    /* PIO input state of HIF_A8 signal.                                          */
	unsigned int hif_a9    : BFW_NX51_hif_pio_in1_hif_a9;    /* PIO input state of HIF_A9 signal.                                          */
	unsigned int hif_a10   : BFW_NX51_hif_pio_in1_hif_a10;   /* PIO input state of HIF_A10 signal.                                         */
	unsigned int hif_a11   : BFW_NX51_hif_pio_in1_hif_a11;   /* PIO input state of HIF_A11 signal.                                         */
	unsigned int hif_a12   : BFW_NX51_hif_pio_in1_hif_a12;   /* PIO input state of HIF_A12 signal.                                         */
	unsigned int hif_a13   : BFW_NX51_hif_pio_in1_hif_a13;   /* PIO input state of HIF_A13 signal.                                         */
	unsigned int hif_a14   : BFW_NX51_hif_pio_in1_hif_a14;   /* PIO input state of HIF_A14 signal.                                         */
	unsigned int hif_a15   : BFW_NX51_hif_pio_in1_hif_a15;   /* PIO input state of HIF_A15 signal.                                         */
	unsigned int hif_ahi0  : BFW_NX51_hif_pio_in1_hif_ahi0;  /* PIO input state of HIF_AHI0 signal (not available when netX50 compatible). */
	unsigned int hif_ahi1  : BFW_NX51_hif_pio_in1_hif_ahi1;  /* PIO input state of HIF_AHI1 signal (not available when netX50 compatible). */
	unsigned int reserved1 : BFW_NX51_hif_pio_in1_reserved1; /* reserved                                                                   */
	unsigned int hif_bhe3  : BFW_NX51_hif_pio_in1_hif_bhe3;  /* PIO input state of HIF_BHE3 signals.                                       */
	unsigned int hif_bhe1  : BFW_NX51_hif_pio_in1_hif_bhe1;  /* PIO input state of HIF_BHE1 signals.                                       */
	unsigned int hif_rdn   : BFW_NX51_hif_pio_in1_hif_rdn;   /* PIO input state of HIF_RDN signal.                                         */
	unsigned int hif_wrn   : BFW_NX51_hif_pio_in1_hif_wrn;   /* PIO input state of HIF_WRN signal.                                         */
	unsigned int hif_csn   : BFW_NX51_hif_pio_in1_hif_csn;   /* PIO input state of HIF_CSN signal.                                         */
	unsigned int hif_rdy   : BFW_NX51_hif_pio_in1_hif_rdy;   /* PIO input state of HIF_RDY signal.                                         */
	unsigned int hif_dirq  : BFW_NX51_hif_pio_in1_hif_dirq;  /* PIO input state of HIF_DIRQ signal.                                        */
	unsigned int hif_sdclk : BFW_NX51_hif_pio_in1_hif_sdclk; /* PIO input state of HIF_SDCLK signal.                                       */
} NX51_HIF_PIO_IN1_BIT_T;

typedef union {
	unsigned int           val;
	NX51_HIF_PIO_IN1_BIT_T bf;
} NX51_HIF_PIO_IN1_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_raw */
/* => HIF PIO Raw (before masking) IRQ Status Register. */
/*    If bit is set, the according interrupt is asserted. */
/*    Interrupt status can be cleared by writing ones to this register. */
/*    Each IRQ source can be assigned either to xPIC or to ARM (or to both) by the following registers. */
/*    IRQ clearing has lower priority than IRQ set when done simultanously. */
/*    Note: Spikes up tp 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_irq_raw         0x00000024U
#define Adr_NX51_hif_io_ctrl_hif_pio_irq_raw 0x1018C564U
#define Adr_NX51_hif_pio_irq_raw             0x1018C564U

#define MSK_NX51_hif_pio_irq_raw_irq_pio35 0x00000001U
#define SRT_NX51_hif_pio_irq_raw_irq_pio35 0
#define MSK_NX51_hif_pio_irq_raw_irq_pio36 0x00000002U
#define SRT_NX51_hif_pio_irq_raw_irq_pio36 1
#define MSK_NX51_hif_pio_irq_raw_irq_pio40 0x00000004U
#define SRT_NX51_hif_pio_irq_raw_irq_pio40 2
#define MSK_NX51_hif_pio_irq_raw_irq_pio47 0x00000008U
#define SRT_NX51_hif_pio_irq_raw_irq_pio47 3
#define MSK_NX51_hif_pio_irq_raw_irq_pio72 0x00000010U
#define SRT_NX51_hif_pio_irq_raw_irq_pio72 4

/* all used bits of 'NX51_hif_pio_irq_raw': */
#define MSK_USED_BITS_NX51_hif_pio_irq_raw 0x0000001fU

enum {
	BFW_NX51_hif_pio_irq_raw_irq_pio35 = 1,  /* [0] */
	BFW_NX51_hif_pio_irq_raw_irq_pio36 = 1,  /* [1] */
	BFW_NX51_hif_pio_irq_raw_irq_pio40 = 1,  /* [2] */
	BFW_NX51_hif_pio_irq_raw_irq_pio47 = 1,  /* [3] */
	BFW_NX51_hif_pio_irq_raw_irq_pio72 = 1,  /* [4] */
	BFW_NX51_hif_pio_irq_raw_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_HIF_PIO_IRQ_RAW_BIT_Ttag {
	unsigned int irq_pio35 : BFW_NX51_hif_pio_irq_raw_irq_pio35; /* HIF PIO35 (netx51: HIF_D17) IRQ  */
	unsigned int irq_pio36 : BFW_NX51_hif_pio_irq_raw_irq_pio36; /* HIF PIO36 (netx51: HIF_D16) IRQ  */
	unsigned int irq_pio40 : BFW_NX51_hif_pio_irq_raw_irq_pio40; /* HIF PIO40 (netx51: HIF_D18) IRQ  */
	unsigned int irq_pio47 : BFW_NX51_hif_pio_irq_raw_irq_pio47; /* HIF PIO47 (netx51: HIF_DIRQ) IRQ */
	unsigned int irq_pio72 : BFW_NX51_hif_pio_irq_raw_irq_pio72; /* HIF PIO72 (netx51: HIF_D27) IRQ  */
	unsigned int reserved1 : BFW_NX51_hif_pio_irq_raw_reserved1; /* reserved                         */
} NX51_HIF_PIO_IRQ_RAW_BIT_T;

typedef union {
	unsigned int               val;
	NX51_HIF_PIO_IRQ_RAW_BIT_T bf;
} NX51_HIF_PIO_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_arm_mask_set */
/* => HIF PIO Interrupt Mask Register for netX internal ARM. */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal ARM. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal ARM without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up tp 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_irq_arm_mask_set         0x00000028U
#define Adr_NX51_hif_io_ctrl_hif_pio_irq_arm_mask_set 0x1018C568U
#define Adr_NX51_hif_pio_irq_arm_mask_set             0x1018C568U
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_set        0x00000000U

#define MSK_NX51_hif_pio_irq_arm_mask_set_irq_pio35         0x00000001U
#define SRT_NX51_hif_pio_irq_arm_mask_set_irq_pio35         0
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio35    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio35 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_set_irq_pio36         0x00000002U
#define SRT_NX51_hif_pio_irq_arm_mask_set_irq_pio36         1
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio36    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio36 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_set_irq_pio40         0x00000004U
#define SRT_NX51_hif_pio_irq_arm_mask_set_irq_pio40         2
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio40    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio40 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_set_irq_pio47         0x00000008U
#define SRT_NX51_hif_pio_irq_arm_mask_set_irq_pio47         3
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio47    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio47 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_set_irq_pio72         0x00000010U
#define SRT_NX51_hif_pio_irq_arm_mask_set_irq_pio72         4
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio72    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_set_irq_pio72 0x00000000U

/* all used bits of 'NX51_hif_pio_irq_arm_mask_set': */
#define MSK_USED_BITS_NX51_hif_pio_irq_arm_mask_set 0x0000001fU

enum {
	BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio35 = 1,  /* [0] */
	BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio36 = 1,  /* [1] */
	BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio40 = 1,  /* [2] */
	BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio47 = 1,  /* [3] */
	BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio72 = 1,  /* [4] */
	BFW_NX51_hif_pio_irq_arm_mask_set_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_HIF_PIO_IRQ_ARM_MASK_SET_BIT_Ttag {
	unsigned int irq_pio35 : BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio35; /* HIF PIO35 (netx51: HIF_D17) IRQ  */
	unsigned int irq_pio36 : BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio36; /* HIF PIO36 (netx51: HIF_D16) IRQ  */
	unsigned int irq_pio40 : BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio40; /* HIF PIO40 (netx51: HIF_D18) IRQ  */
	unsigned int irq_pio47 : BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio47; /* HIF PIO47 (netx51: HIF_DIRQ) IRQ */
	unsigned int irq_pio72 : BFW_NX51_hif_pio_irq_arm_mask_set_irq_pio72; /* HIF PIO72 (netx51: HIF_D27) IRQ  */
	unsigned int reserved1 : BFW_NX51_hif_pio_irq_arm_mask_set_reserved1; /* reserved                         */
} NX51_HIF_PIO_IRQ_ARM_MASK_SET_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_HIF_PIO_IRQ_ARM_MASK_SET_BIT_T bf;
} NX51_HIF_PIO_IRQ_ARM_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_arm_mask_reset */
/* => HIF PIO Interrupt Mask Reset Register for netX internal ARM. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal ARM if asserted. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal ARM without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up tp 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_irq_arm_mask_reset         0x0000002CU
#define Adr_NX51_hif_io_ctrl_hif_pio_irq_arm_mask_reset 0x1018C56CU
#define Adr_NX51_hif_pio_irq_arm_mask_reset             0x1018C56CU
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_reset        0x00000000U

#define MSK_NX51_hif_pio_irq_arm_mask_reset_irq_pio35         0x00000001U
#define SRT_NX51_hif_pio_irq_arm_mask_reset_irq_pio35         0
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio35    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio35 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_reset_irq_pio36         0x00000002U
#define SRT_NX51_hif_pio_irq_arm_mask_reset_irq_pio36         1
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio36    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio36 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_reset_irq_pio40         0x00000004U
#define SRT_NX51_hif_pio_irq_arm_mask_reset_irq_pio40         2
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio40    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio40 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_reset_irq_pio47         0x00000008U
#define SRT_NX51_hif_pio_irq_arm_mask_reset_irq_pio47         3
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio47    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio47 0x00000000U
#define MSK_NX51_hif_pio_irq_arm_mask_reset_irq_pio72         0x00000010U
#define SRT_NX51_hif_pio_irq_arm_mask_reset_irq_pio72         4
#define DFLT_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio72    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_arm_mask_reset_irq_pio72 0x00000000U

/* all used bits of 'NX51_hif_pio_irq_arm_mask_reset': */
#define MSK_USED_BITS_NX51_hif_pio_irq_arm_mask_reset 0x0000001fU

enum {
	BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio35 = 1,  /* [0] */
	BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio36 = 1,  /* [1] */
	BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio40 = 1,  /* [2] */
	BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio47 = 1,  /* [3] */
	BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio72 = 1,  /* [4] */
	BFW_NX51_hif_pio_irq_arm_mask_reset_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_HIF_PIO_IRQ_ARM_MASK_RESET_BIT_Ttag {
	unsigned int irq_pio35 : BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio35; /* HIF PIO35 (netx51: HIF_D17) IRQ  */
	unsigned int irq_pio36 : BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio36; /* HIF PIO36 (netx51: HIF_D16) IRQ  */
	unsigned int irq_pio40 : BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio40; /* HIF PIO40 (netx51: HIF_D18) IRQ  */
	unsigned int irq_pio47 : BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio47; /* HIF PIO47 (netx51: HIF_DIRQ) IRQ */
	unsigned int irq_pio72 : BFW_NX51_hif_pio_irq_arm_mask_reset_irq_pio72; /* HIF PIO72 (netx51: HIF_D27) IRQ  */
	unsigned int reserved1 : BFW_NX51_hif_pio_irq_arm_mask_reset_reserved1; /* reserved                         */
} NX51_HIF_PIO_IRQ_ARM_MASK_RESET_BIT_T;

typedef union {
	unsigned int                          val;
	NX51_HIF_PIO_IRQ_ARM_MASK_RESET_BIT_T bf;
} NX51_HIF_PIO_IRQ_ARM_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_arm_masked */
/* => HIF PIO Masked Interrupt Status Register for netX internal ARM. */
/*    If bit is set, if the according mask bit is set in hif_pio_irq_arm_mask-register and the according interrupt is asserted. */
/*    IRQ for netX internal ARM signal is asserted if at least one bit is set here. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal ARM signal without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up tp 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_irq_arm_masked         0x00000030U
#define Adr_NX51_hif_io_ctrl_hif_pio_irq_arm_masked 0x1018C570U
#define Adr_NX51_hif_pio_irq_arm_masked             0x1018C570U

#define MSK_NX51_hif_pio_irq_arm_masked_irq_pio35 0x00000001U
#define SRT_NX51_hif_pio_irq_arm_masked_irq_pio35 0
#define MSK_NX51_hif_pio_irq_arm_masked_irq_pio36 0x00000002U
#define SRT_NX51_hif_pio_irq_arm_masked_irq_pio36 1
#define MSK_NX51_hif_pio_irq_arm_masked_irq_pio40 0x00000004U
#define SRT_NX51_hif_pio_irq_arm_masked_irq_pio40 2
#define MSK_NX51_hif_pio_irq_arm_masked_irq_pio47 0x00000008U
#define SRT_NX51_hif_pio_irq_arm_masked_irq_pio47 3
#define MSK_NX51_hif_pio_irq_arm_masked_irq_pio72 0x00000010U
#define SRT_NX51_hif_pio_irq_arm_masked_irq_pio72 4

/* all used bits of 'NX51_hif_pio_irq_arm_masked': */
#define MSK_USED_BITS_NX51_hif_pio_irq_arm_masked 0x0000001fU

enum {
	BFW_NX51_hif_pio_irq_arm_masked_irq_pio35 = 1,  /* [0] */
	BFW_NX51_hif_pio_irq_arm_masked_irq_pio36 = 1,  /* [1] */
	BFW_NX51_hif_pio_irq_arm_masked_irq_pio40 = 1,  /* [2] */
	BFW_NX51_hif_pio_irq_arm_masked_irq_pio47 = 1,  /* [3] */
	BFW_NX51_hif_pio_irq_arm_masked_irq_pio72 = 1,  /* [4] */
	BFW_NX51_hif_pio_irq_arm_masked_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_HIF_PIO_IRQ_ARM_MASKED_BIT_Ttag {
	unsigned int irq_pio35 : BFW_NX51_hif_pio_irq_arm_masked_irq_pio35; /* HIF PIO35 (netx51: HIF_D17) IRQ  */
	unsigned int irq_pio36 : BFW_NX51_hif_pio_irq_arm_masked_irq_pio36; /* HIF PIO36 (netx51: HIF_D16) IRQ  */
	unsigned int irq_pio40 : BFW_NX51_hif_pio_irq_arm_masked_irq_pio40; /* HIF PIO40 (netx51: HIF_D18) IRQ  */
	unsigned int irq_pio47 : BFW_NX51_hif_pio_irq_arm_masked_irq_pio47; /* HIF PIO47 (netx51: HIF_DIRQ) IRQ */
	unsigned int irq_pio72 : BFW_NX51_hif_pio_irq_arm_masked_irq_pio72; /* HIF PIO72 (netx51: HIF_D27) IRQ  */
	unsigned int reserved1 : BFW_NX51_hif_pio_irq_arm_masked_reserved1; /* reserved                         */
} NX51_HIF_PIO_IRQ_ARM_MASKED_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_HIF_PIO_IRQ_ARM_MASKED_BIT_T bf;
} NX51_HIF_PIO_IRQ_ARM_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_xpic_mask_set */
/* => HIF PIO Interrupt Mask Register for netX internal xPIC. */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal xPIC. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal xPIC without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up tp 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_irq_xpic_mask_set         0x00000034U
#define Adr_NX51_hif_io_ctrl_hif_pio_irq_xpic_mask_set 0x1018C574U
#define Adr_NX51_hif_pio_irq_xpic_mask_set             0x1018C574U
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_set        0x00000000U

#define MSK_NX51_hif_pio_irq_xpic_mask_set_irq_pio35         0x00000001U
#define SRT_NX51_hif_pio_irq_xpic_mask_set_irq_pio35         0
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio35    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio35 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_set_irq_pio36         0x00000002U
#define SRT_NX51_hif_pio_irq_xpic_mask_set_irq_pio36         1
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio36    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio36 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_set_irq_pio40         0x00000004U
#define SRT_NX51_hif_pio_irq_xpic_mask_set_irq_pio40         2
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio40    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio40 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_set_irq_pio47         0x00000008U
#define SRT_NX51_hif_pio_irq_xpic_mask_set_irq_pio47         3
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio47    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio47 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_set_irq_pio72         0x00000010U
#define SRT_NX51_hif_pio_irq_xpic_mask_set_irq_pio72         4
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio72    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_set_irq_pio72 0x00000000U

/* all used bits of 'NX51_hif_pio_irq_xpic_mask_set': */
#define MSK_USED_BITS_NX51_hif_pio_irq_xpic_mask_set 0x0000001fU

enum {
	BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio35 = 1,  /* [0] */
	BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio36 = 1,  /* [1] */
	BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio40 = 1,  /* [2] */
	BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio47 = 1,  /* [3] */
	BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio72 = 1,  /* [4] */
	BFW_NX51_hif_pio_irq_xpic_mask_set_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_HIF_PIO_IRQ_XPIC_MASK_SET_BIT_Ttag {
	unsigned int irq_pio35 : BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio35; /* HIF PIO35 (netx51: HIF_D17) IRQ  */
	unsigned int irq_pio36 : BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio36; /* HIF PIO36 (netx51: HIF_D16) IRQ  */
	unsigned int irq_pio40 : BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio40; /* HIF PIO40 (netx51: HIF_D18) IRQ  */
	unsigned int irq_pio47 : BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio47; /* HIF PIO47 (netx51: HIF_DIRQ) IRQ */
	unsigned int irq_pio72 : BFW_NX51_hif_pio_irq_xpic_mask_set_irq_pio72; /* HIF PIO72 (netx51: HIF_D27) IRQ  */
	unsigned int reserved1 : BFW_NX51_hif_pio_irq_xpic_mask_set_reserved1; /* reserved                         */
} NX51_HIF_PIO_IRQ_XPIC_MASK_SET_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_HIF_PIO_IRQ_XPIC_MASK_SET_BIT_T bf;
} NX51_HIF_PIO_IRQ_XPIC_MASK_SET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_xpic_mask_reset */
/* => HIF PIO Interrupt Mask Reset Register for netX internal xPIC. */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    If bit is set, the according interrupt will activate the IRQ for netX internal xPIC if asserted. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal xPIC without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up tp 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_irq_xpic_mask_reset         0x00000038U
#define Adr_NX51_hif_io_ctrl_hif_pio_irq_xpic_mask_reset 0x1018C578U
#define Adr_NX51_hif_pio_irq_xpic_mask_reset             0x1018C578U
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_reset        0x00000000U

#define MSK_NX51_hif_pio_irq_xpic_mask_reset_irq_pio35         0x00000001U
#define SRT_NX51_hif_pio_irq_xpic_mask_reset_irq_pio35         0
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio35    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio35 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_reset_irq_pio36         0x00000002U
#define SRT_NX51_hif_pio_irq_xpic_mask_reset_irq_pio36         1
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio36    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio36 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_reset_irq_pio40         0x00000004U
#define SRT_NX51_hif_pio_irq_xpic_mask_reset_irq_pio40         2
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio40    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio40 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_reset_irq_pio47         0x00000008U
#define SRT_NX51_hif_pio_irq_xpic_mask_reset_irq_pio47         3
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio47    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio47 0x00000000U
#define MSK_NX51_hif_pio_irq_xpic_mask_reset_irq_pio72         0x00000010U
#define SRT_NX51_hif_pio_irq_xpic_mask_reset_irq_pio72         4
#define DFLT_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio72    0x00000000U
#define DFLT_BF_VAL_NX51_hif_pio_irq_xpic_mask_reset_irq_pio72 0x00000000U

/* all used bits of 'NX51_hif_pio_irq_xpic_mask_reset': */
#define MSK_USED_BITS_NX51_hif_pio_irq_xpic_mask_reset 0x0000001fU

enum {
	BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio35 = 1,  /* [0] */
	BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio36 = 1,  /* [1] */
	BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio40 = 1,  /* [2] */
	BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio47 = 1,  /* [3] */
	BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio72 = 1,  /* [4] */
	BFW_NX51_hif_pio_irq_xpic_mask_reset_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_HIF_PIO_IRQ_XPIC_MASK_RESET_BIT_Ttag {
	unsigned int irq_pio35 : BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio35; /* HIF PIO35 (netx51: HIF_D17) IRQ  */
	unsigned int irq_pio36 : BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio36; /* HIF PIO36 (netx51: HIF_D16) IRQ  */
	unsigned int irq_pio40 : BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio40; /* HIF PIO40 (netx51: HIF_D18) IRQ  */
	unsigned int irq_pio47 : BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio47; /* HIF PIO47 (netx51: HIF_DIRQ) IRQ */
	unsigned int irq_pio72 : BFW_NX51_hif_pio_irq_xpic_mask_reset_irq_pio72; /* HIF PIO72 (netx51: HIF_D27) IRQ  */
	unsigned int reserved1 : BFW_NX51_hif_pio_irq_xpic_mask_reset_reserved1; /* reserved                         */
} NX51_HIF_PIO_IRQ_XPIC_MASK_RESET_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_HIF_PIO_IRQ_XPIC_MASK_RESET_BIT_T bf;
} NX51_HIF_PIO_IRQ_XPIC_MASK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register hif_pio_irq_xpic_masked */
/* => HIF PIO Masked Interrupt Status Register for netX internal xPIC. */
/*    If bit is set, if the according mask bit is set in hif_pio_irq_xpic_mask-register and the according interrupt is asserted. */
/*    IRQ for netX internal xPIC signal is asserted if at least one bit is set here. */
/*    Interrupt status can be cleared by writing ones to the hif_pio_irq_raw register. */
/*    To release IRQ for netX internal xPIC signal without clearing interrupt in module, reset according mask bit to 0. */
/*    Note: Spikes up tp 10ns will be suppressed by HIF PIO IRQ sample stages. */
/*    Note: HIF PIO interrupt function can be configured in the hif_pio_cfg register. */
/*    Note: HIF PIO IRQs are combined with DPM IRQs and Handshake-Cell (HANDSHACKE_CTRL) IRQs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_hif_pio_irq_xpic_masked         0x0000003CU
#define Adr_NX51_hif_io_ctrl_hif_pio_irq_xpic_masked 0x1018C57CU
#define Adr_NX51_hif_pio_irq_xpic_masked             0x1018C57CU

#define MSK_NX51_hif_pio_irq_xpic_masked_irq_pio35 0x00000001U
#define SRT_NX51_hif_pio_irq_xpic_masked_irq_pio35 0
#define MSK_NX51_hif_pio_irq_xpic_masked_irq_pio36 0x00000002U
#define SRT_NX51_hif_pio_irq_xpic_masked_irq_pio36 1
#define MSK_NX51_hif_pio_irq_xpic_masked_irq_pio40 0x00000004U
#define SRT_NX51_hif_pio_irq_xpic_masked_irq_pio40 2
#define MSK_NX51_hif_pio_irq_xpic_masked_irq_pio47 0x00000008U
#define SRT_NX51_hif_pio_irq_xpic_masked_irq_pio47 3
#define MSK_NX51_hif_pio_irq_xpic_masked_irq_pio72 0x00000010U
#define SRT_NX51_hif_pio_irq_xpic_masked_irq_pio72 4

/* all used bits of 'NX51_hif_pio_irq_xpic_masked': */
#define MSK_USED_BITS_NX51_hif_pio_irq_xpic_masked 0x0000001fU

enum {
	BFW_NX51_hif_pio_irq_xpic_masked_irq_pio35 = 1,  /* [0] */
	BFW_NX51_hif_pio_irq_xpic_masked_irq_pio36 = 1,  /* [1] */
	BFW_NX51_hif_pio_irq_xpic_masked_irq_pio40 = 1,  /* [2] */
	BFW_NX51_hif_pio_irq_xpic_masked_irq_pio47 = 1,  /* [3] */
	BFW_NX51_hif_pio_irq_xpic_masked_irq_pio72 = 1,  /* [4] */
	BFW_NX51_hif_pio_irq_xpic_masked_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_HIF_PIO_IRQ_XPIC_MASKED_BIT_Ttag {
	unsigned int irq_pio35 : BFW_NX51_hif_pio_irq_xpic_masked_irq_pio35; /* HIF PIO35 (netx51: HIF_D17) IRQ  */
	unsigned int irq_pio36 : BFW_NX51_hif_pio_irq_xpic_masked_irq_pio36; /* HIF PIO36 (netx51: HIF_D16) IRQ  */
	unsigned int irq_pio40 : BFW_NX51_hif_pio_irq_xpic_masked_irq_pio40; /* HIF PIO40 (netx51: HIF_D18) IRQ  */
	unsigned int irq_pio47 : BFW_NX51_hif_pio_irq_xpic_masked_irq_pio47; /* HIF PIO47 (netx51: HIF_DIRQ) IRQ */
	unsigned int irq_pio72 : BFW_NX51_hif_pio_irq_xpic_masked_irq_pio72; /* HIF PIO72 (netx51: HIF_D27) IRQ  */
	unsigned int reserved1 : BFW_NX51_hif_pio_irq_xpic_masked_reserved1; /* reserved                         */
} NX51_HIF_PIO_IRQ_XPIC_MASKED_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_HIF_PIO_IRQ_XPIC_MASKED_BIT_T bf;
} NX51_HIF_PIO_IRQ_XPIC_MASKED_T;


/* ===================================================================== */

/* Area of crc */

/* ===================================================================== */

#define Addr_NX51_crc      0x1018C580U
#define NX51_NETX_CRC_AREA 0x1018C580U

/* --------------------------------------------------------------------- */
/* Register crc_crc */
/* => CRC Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_crc_crc  0x00000000U
#define Adr_NX51_crc_crc_crc  0x1018C580U
#define Adr_NX51_crc_crc      0x1018C580U
#define DFLT_VAL_NX51_crc_crc 0x00000000U

#define MSK_NX51_crc_crc_crc_val         0xffffffffU
#define SRT_NX51_crc_crc_crc_val         0
#define DFLT_VAL_NX51_crc_crc_crc_val    0x00000000U
#define DFLT_BF_VAL_NX51_crc_crc_crc_val 0x00000000U

/* all used bits of 'NX51_crc_crc': */
#define MSK_USED_BITS_NX51_crc_crc 0xffffffffU

enum {
	BFW_NX51_crc_crc_crc_val = 32  /* [31:0] */
};

typedef struct NX51_CRC_CRC_BIT_Ttag {
	unsigned int crc_val : BFW_NX51_crc_crc_crc_val; /* CRC value                                          */
	                                                 /* Upper bits should be masked, if crc_len smaller 31 */
} NX51_CRC_CRC_BIT_T;

typedef union {
	unsigned int       val;
	NX51_CRC_CRC_BIT_T bf;
} NX51_CRC_CRC_T;

/* --------------------------------------------------------------------- */
/* Register crc_data_in */
/* => CRC data in Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_crc_data_in  0x00000004U
#define Adr_NX51_crc_crc_data_in  0x1018C584U
#define Adr_NX51_crc_data_in      0x1018C584U
#define DFLT_VAL_NX51_crc_data_in 0x00000000U

#define MSK_NX51_crc_data_in_crc_data_in         0x000000ffU
#define SRT_NX51_crc_data_in_crc_data_in         0
#define DFLT_VAL_NX51_crc_data_in_crc_data_in    0x00000000U
#define DFLT_BF_VAL_NX51_crc_data_in_crc_data_in 0x00000000U

/* all used bits of 'NX51_crc_data_in': */
#define MSK_USED_BITS_NX51_crc_data_in 0x000000ffU

enum {
	BFW_NX51_crc_data_in_crc_data_in = 8,  /* [7:0] */
	BFW_NX51_crc_data_in_reserved1   = 24  /* [31:8] */
};

typedef struct NX51_CRC_DATA_IN_BIT_Ttag {
	unsigned int crc_data_in : BFW_NX51_crc_data_in_crc_data_in; /* CRC input bits */
	unsigned int reserved1   : BFW_NX51_crc_data_in_reserved1;   /* reserved       */
} NX51_CRC_DATA_IN_BIT_T;

typedef union {
	unsigned int           val;
	NX51_CRC_DATA_IN_BIT_T bf;
} NX51_CRC_DATA_IN_T;

/* --------------------------------------------------------------------- */
/* Register crc_polynomial */
/* => CRC Polynomial Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_crc_polynomial  0x00000008U
#define Adr_NX51_crc_crc_polynomial  0x1018C588U
#define Adr_NX51_crc_polynomial      0x1018C588U
#define DFLT_VAL_NX51_crc_polynomial 0x04c11db7U

#define MSK_NX51_crc_polynomial_crc_polynomial         0xffffffffU
#define SRT_NX51_crc_polynomial_crc_polynomial         0
#define DFLT_VAL_NX51_crc_polynomial_crc_polynomial    0x04c11db7U
#define DFLT_BF_VAL_NX51_crc_polynomial_crc_polynomial 0x04c11db7U

/* all used bits of 'NX51_crc_polynomial': */
#define MSK_USED_BITS_NX51_crc_polynomial 0xffffffffU

enum {
	BFW_NX51_crc_polynomial_crc_polynomial = 32  /* [31:0] */
};

typedef struct NX51_CRC_POLYNOMIAL_BIT_Ttag {
	unsigned int crc_polynomial : BFW_NX51_crc_polynomial_crc_polynomial; /* crc polynomial (default:Ethenet CRC32)                               */
	                                                                      /* Most significant bit of polynome is always one, thus not considered. */
} NX51_CRC_POLYNOMIAL_BIT_T;

typedef union {
	unsigned int              val;
	NX51_CRC_POLYNOMIAL_BIT_T bf;
} NX51_CRC_POLYNOMIAL_T;

/* --------------------------------------------------------------------- */
/* Register crc_config */
/* => CRC config Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_crc_config  0x0000000CU
#define Adr_NX51_crc_crc_config  0x1018C58CU
#define Adr_NX51_crc_config      0x1018C58CU
#define DFLT_VAL_NX51_crc_config 0x00000000U

#define MSK_NX51_crc_config_crc_len                 0x0000003fU
#define SRT_NX51_crc_config_crc_len                 0
#define DFLT_VAL_NX51_crc_config_crc_len            0x00000000U
#define DFLT_BF_VAL_NX51_crc_config_crc_len         0x00000000U
#define MSK_NX51_crc_config_crc_shift_right         0x00000040U
#define SRT_NX51_crc_config_crc_shift_right         6
#define DFLT_VAL_NX51_crc_config_crc_shift_right    0x00000000U
#define DFLT_BF_VAL_NX51_crc_config_crc_shift_right 0x00000000U
#define MSK_NX51_crc_config_crc_direct_div          0x00000080U
#define SRT_NX51_crc_config_crc_direct_div          7
#define DFLT_VAL_NX51_crc_config_crc_direct_div     0x00000000U
#define DFLT_BF_VAL_NX51_crc_config_crc_direct_div  0x00000000U
#define MSK_NX51_crc_config_crc_nof_bits            0x00000300U
#define SRT_NX51_crc_config_crc_nof_bits            8
#define DFLT_VAL_NX51_crc_config_crc_nof_bits       0x00000000U
#define DFLT_BF_VAL_NX51_crc_config_crc_nof_bits    0x00000000U
#define MSK_NX51_crc_config_crc_in_msb_low          0x00000400U
#define SRT_NX51_crc_config_crc_in_msb_low          10
#define DFLT_VAL_NX51_crc_config_crc_in_msb_low     0x00000000U
#define DFLT_BF_VAL_NX51_crc_config_crc_in_msb_low  0x00000000U

/* all used bits of 'NX51_crc_config': */
#define MSK_USED_BITS_NX51_crc_config 0x000007ffU

enum {
	BFW_NX51_crc_config_crc_len         = 6,  /* [5:0] */
	BFW_NX51_crc_config_crc_shift_right = 1,  /* [6] */
	BFW_NX51_crc_config_crc_direct_div  = 1,  /* [7] */
	BFW_NX51_crc_config_crc_nof_bits    = 2,  /* [9:8] */
	BFW_NX51_crc_config_crc_in_msb_low  = 1,  /* [10] */
	BFW_NX51_crc_config_reserved1       = 21  /* [31:11] */
};

typedef struct NX51_CRC_CONFIG_BIT_Ttag {
	unsigned int crc_len         : BFW_NX51_crc_config_crc_len;         /* Length of CRC - 1                                                                                   */
	unsigned int crc_shift_right : BFW_NX51_crc_config_crc_shift_right; /* 1: shift crc right                                                                                  */
	unsigned int crc_direct_div  : BFW_NX51_crc_config_crc_direct_div;  /* 1: calculate direct polynolial division without n zeros after frame, usefull for parity calculation */
	unsigned int crc_nof_bits    : BFW_NX51_crc_config_crc_nof_bits;    /* number of bits to be calculated in parallel (00: 1, 01: 2, 10; 4, 11: 8)                            */
	unsigned int crc_in_msb_low  : BFW_NX51_crc_config_crc_in_msb_low;  /* swap crc_data_in, only usefull when calculating multiple bits in parallel (crc_nof_bits > 0):       */
	                                                                    /* 1: msb of incoming bits is data_in[0],                                                              */
	                                                                    /* 0: msb is data_in[crc_nof_bits_m1]                                                                  */
	                                                                    /* (msb=first bit in data-stream)                                                                      */
	unsigned int reserved1       : BFW_NX51_crc_config_reserved1;       /* reserved                                                                                            */
} NX51_CRC_CONFIG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_CRC_CONFIG_BIT_T bf;
} NX51_CRC_CONFIG_T;


/* ===================================================================== */

/* AREA systime */
/* Area of systime, systime_uc */

/* ===================================================================== */

#define Addr_NX51_systime       0x1018C590U
#define NX51_NETX_SYS_TIME_AREA 0x1018C590U
#define Addr_NX51_systime_uc    0x1018C5A0U

/* --------------------------------------------------------------------- */
/* Register systime_s */
/* => Upper SYSTIME register: */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    This register should be dedicated to accesses via DPM. */
/*    ARM software should access systime via arm_timer_systime_s. */
/*    xPIC software should access systime via xpic_timer_systime_s. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_systime_s        0x00000000U
#define Adr_NX51_systime_systime_s    0x1018C590U
#define Adr_NX51_systime_uc_systime_s 0x1018C5A0U
#define DFLT_VAL_NX51_systime_s       0x00000000U

#define MSK_NX51_systime_s_systime_s         0xffffffffU
#define SRT_NX51_systime_s_systime_s         0
#define DFLT_VAL_NX51_systime_s_systime_s    0x00000000U
#define DFLT_BF_VAL_NX51_systime_s_systime_s 0x00000000U

/* all used bits of 'NX51_systime_s': */
#define MSK_USED_BITS_NX51_systime_s 0xffffffffU

enum {
	BFW_NX51_systime_s_systime_s = 32  /* [31:0] */
};

typedef struct NX51_SYSTIME_S_BIT_Ttag {
	unsigned int systime_s : BFW_NX51_systime_s_systime_s; /* systime high                                               */
	                                                       /* value is incremented, if systime_ns reaches systime_border */
	                                                       /* Sample systime_ns at read access to systime_s.             */
} NX51_SYSTIME_S_BIT_T;

typedef union {
	unsigned int         val;
	NX51_SYSTIME_S_BIT_T bf;
} NX51_SYSTIME_S_T;

/* --------------------------------------------------------------------- */
/* Register systime_ns */
/* => Lower SYSTIME register: */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    If no systime_s is read before (or at 2nd read access of systime_ns), the actual value of systime_ns is read. */
/*    This register should be dedicated to accesses via DPM. */
/*    ARM software should access systime via arm_timer_systime_ns. */
/*    xPIC software should access systime via xpic_timer_systime_ns. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_systime_ns        0x00000004U
#define Adr_NX51_systime_systime_ns    0x1018C594U
#define Adr_NX51_systime_uc_systime_ns 0x1018C5A4U
#define DFLT_VAL_NX51_systime_ns       0x00000000U

#define MSK_NX51_systime_ns_systime_ns         0xffffffffU
#define SRT_NX51_systime_ns_systime_ns         0
#define DFLT_VAL_NX51_systime_ns_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_systime_ns_systime_ns 0x00000000U

/* all used bits of 'NX51_systime_ns': */
#define MSK_USED_BITS_NX51_systime_ns 0xffffffffU

enum {
	BFW_NX51_systime_ns_systime_ns = 32  /* [31:0] */
};

typedef struct NX51_SYSTIME_NS_BIT_Ttag {
	unsigned int systime_ns : BFW_NX51_systime_ns_systime_ns; /* Systime low:                                                        */
	                                                          /* Sample systime_ns at read access to systime_s.                      */
	                                                          /* Without sample read systime_s, read the actual value of systime_ns. */
} NX51_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int          val;
	NX51_SYSTIME_NS_BIT_T bf;
} NX51_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register systime_border */
/* => SYSTIME border register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_systime_border        0x00000008U
#define Adr_NX51_systime_systime_border    0x1018C598U
#define Adr_NX51_systime_uc_systime_border 0x1018C5A8U
#define DFLT_VAL_NX51_systime_border       0x3b9ac9ffU

#define MSK_NX51_systime_border_systime_border         0xffffffffU
#define SRT_NX51_systime_border_systime_border         0
#define DFLT_VAL_NX51_systime_border_systime_border    0x3b9ac9ffU
#define DFLT_BF_VAL_NX51_systime_border_systime_border 0x3b9ac9ffU

/* all used bits of 'NX51_systime_border': */
#define MSK_USED_BITS_NX51_systime_border 0xffffffffU

enum {
	BFW_NX51_systime_border_systime_border = 32  /* [31:0] */
};

typedef struct NX51_SYSTIME_BORDER_BIT_Ttag {
	unsigned int systime_border : BFW_NX51_systime_border_systime_border; /* Systime border for lower systime:                                                                    */
	                                                                      /* systime_ns counts from 0 to this value (inlcuded),                                                   */
	                                                                      /* i.e. systime_ns counts modulo (systime_border + 1)                                                   */
	                                                                      /* Attention: the border value Bit 3 to 1 must be b'1111 (hex f) for all netX systime - match functions */
} NX51_SYSTIME_BORDER_BIT_T;

typedef union {
	unsigned int              val;
	NX51_SYSTIME_BORDER_BIT_T bf;
} NX51_SYSTIME_BORDER_T;

/* --------------------------------------------------------------------- */
/* Register systime_count_value */
/* => SYSTIME count register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_systime_count_value        0x0000000CU
#define Adr_NX51_systime_systime_count_value    0x1018C59CU
#define Adr_NX51_systime_uc_systime_count_value 0x1018C5ACU
#define DFLT_VAL_NX51_systime_count_value       0xa0000000U

#define MSK_NX51_systime_count_value_systime_count_value         0xffffffffU
#define SRT_NX51_systime_count_value_systime_count_value         0
#define DFLT_VAL_NX51_systime_count_value_systime_count_value    0xa0000000U
#define DFLT_BF_VAL_NX51_systime_count_value_systime_count_value 0xa0000000U

/* all used bits of 'NX51_systime_count_value': */
#define MSK_USED_BITS_NX51_systime_count_value 0xffffffffU

enum {
	BFW_NX51_systime_count_value_systime_count_value = 32  /* [31:0] */
};

typedef struct NX51_SYSTIME_COUNT_VALUE_BIT_Ttag {
	unsigned int systime_count_value : BFW_NX51_systime_count_value_systime_count_value; /* Each clock cycle (systime_count_value >> 28)                              */
	                                                                                     /* will be added to systime (rate multiplier for IEEE1588).                  */
	                                                                                     /* Value 0x10000000 can be used for counting in 10ns (ethernet clock) steps. */
} NX51_SYSTIME_COUNT_VALUE_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_SYSTIME_COUNT_VALUE_BIT_T bf;
} NX51_SYSTIME_COUNT_VALUE_T;


/* ===================================================================== */

/* Area of watchdog */

/* ===================================================================== */

#define Addr_NX51_watchdog 0x1018C5B0U
#define NX51_NETX_WDG_AREA 0x1018C5B0U

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_ctrl */
/* => netX System Watchdog Trigger Register. */
/*    The watchdog access code is generated by a pseudo random generator. */
/*    Note: */
/*       WDGACT signal on netX IO HIF_D19 must be configured additionally inside 'hif_io_cfg' register (area HIF_IO_CTRL). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_sys_wdg_ctrl      0x00000000U
#define Adr_NX51_watchdog_netx_sys_wdg_ctrl 0x1018C5B0U
#define Adr_NX51_netx_sys_wdg_ctrl          0x1018C5B0U
#define DFLT_VAL_NX51_netx_sys_wdg_ctrl     0x00000000U

#define MSK_NX51_netx_sys_wdg_ctrl_wdg_access_code               0x000fffffU
#define SRT_NX51_netx_sys_wdg_ctrl_wdg_access_code               0
#define DFLT_VAL_NX51_netx_sys_wdg_ctrl_wdg_access_code          0x00000000U
#define DFLT_BF_VAL_NX51_netx_sys_wdg_ctrl_wdg_access_code       0x00000000U
#define MSK_NX51_netx_sys_wdg_ctrl_irq_req_watchdog              0x01000000U
#define SRT_NX51_netx_sys_wdg_ctrl_irq_req_watchdog              24
#define DFLT_VAL_NX51_netx_sys_wdg_ctrl_irq_req_watchdog         0x00000000U
#define DFLT_BF_VAL_NX51_netx_sys_wdg_ctrl_irq_req_watchdog      0x00000000U
#define MSK_NX51_netx_sys_wdg_ctrl_wdg_counter_trigger_w         0x10000000U
#define SRT_NX51_netx_sys_wdg_ctrl_wdg_counter_trigger_w         28
#define DFLT_VAL_NX51_netx_sys_wdg_ctrl_wdg_counter_trigger_w    0x00000000U
#define DFLT_BF_VAL_NX51_netx_sys_wdg_ctrl_wdg_counter_trigger_w 0x00000000U
#define MSK_NX51_netx_sys_wdg_ctrl_write_enable                  0x80000000U
#define SRT_NX51_netx_sys_wdg_ctrl_write_enable                  31
#define DFLT_VAL_NX51_netx_sys_wdg_ctrl_write_enable             0x00000000U
#define DFLT_BF_VAL_NX51_netx_sys_wdg_ctrl_write_enable          0x00000000U

/* all used bits of 'NX51_netx_sys_wdg_ctrl': */
#define MSK_USED_BITS_NX51_netx_sys_wdg_ctrl 0x910fffffU

enum {
	BFW_NX51_netx_sys_wdg_ctrl_wdg_access_code       = 20, /* [19:0] */
	BFW_NX51_netx_sys_wdg_ctrl_reserved1             = 4,  /* [23:20] */
	BFW_NX51_netx_sys_wdg_ctrl_irq_req_watchdog      = 1,  /* [24] */
	BFW_NX51_netx_sys_wdg_ctrl_reserved2             = 3,  /* [27:25] */
	BFW_NX51_netx_sys_wdg_ctrl_wdg_counter_trigger_w = 1,  /* [28] */
	BFW_NX51_netx_sys_wdg_ctrl_reserved3             = 2,  /* [30:29] */
	BFW_NX51_netx_sys_wdg_ctrl_write_enable          = 1   /* [31] */
};

typedef struct NX51_NETX_SYS_WDG_CTRL_BIT_Ttag {
	unsigned int wdg_access_code       : BFW_NX51_netx_sys_wdg_ctrl_wdg_access_code;       /* Watchdog access code for triggering. A read access gives the next 16 bit code for trigger. */
	                                                                                       /* A write access with correct access code will trigger the watchdog counter.                 */
	unsigned int reserved1             : BFW_NX51_netx_sys_wdg_ctrl_reserved1;             /* reserved                                                                                   */
	unsigned int irq_req_watchdog      : BFW_NX51_netx_sys_wdg_ctrl_irq_req_watchdog;      /* IRQ request of watchdog, writing 1 deletes IRQ                                             */
	unsigned int reserved2             : BFW_NX51_netx_sys_wdg_ctrl_reserved2;             /* reserved                                                                                   */
	unsigned int wdg_counter_trigger_w : BFW_NX51_netx_sys_wdg_ctrl_wdg_counter_trigger_w; /* Watchdog trigger bit:                                                                      */
	                                                                                       /* Bit must be set to trigger the watchdog counter.                                           */
	                                                                                       /* When read, this bit is always '0'                                                          */
	unsigned int reserved3             : BFW_NX51_netx_sys_wdg_ctrl_reserved3;             /* reserved                                                                                   */
	unsigned int write_enable          : BFW_NX51_netx_sys_wdg_ctrl_write_enable;          /* Write enable bit for timeout register:                                                     */
	                                                                                       /* As long as this bit is not set all write accesses to the timeout register are ignored.     */
} NX51_NETX_SYS_WDG_CTRL_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_NETX_SYS_WDG_CTRL_BIT_T bf;
} NX51_NETX_SYS_WDG_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg */
/* => netX System Watchdog Register */
/*    The counter value is decremented each 10000 system clock cycles. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_sys_wdg      0x00000004U
#define Adr_NX51_watchdog_netx_sys_wdg 0x1018C5B4U
#define Adr_NX51_netx_sys_wdg          0x1018C5B4U

#define MSK_NX51_netx_sys_wdg_wdg_counter 0x0001ffffU
#define SRT_NX51_netx_sys_wdg_wdg_counter 0

/* all used bits of 'NX51_netx_sys_wdg': */
#define MSK_USED_BITS_NX51_netx_sys_wdg 0x0001ffffU

enum {
	BFW_NX51_netx_sys_wdg_wdg_counter = 17, /* [16:0] */
	BFW_NX51_netx_sys_wdg_reserved1   = 15  /* [31:17] */
};

typedef struct NX51_NETX_SYS_WDG_BIT_Ttag {
	unsigned int wdg_counter : BFW_NX51_netx_sys_wdg_wdg_counter; /* Actual watchdog counter value */
	unsigned int reserved1   : BFW_NX51_netx_sys_wdg_reserved1;   /* reserved                      */
} NX51_NETX_SYS_WDG_BIT_T;

typedef union {
	unsigned int            val;
	NX51_NETX_SYS_WDG_BIT_T bf;
} NX51_NETX_SYS_WDG_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_irq_timeout */
/* => netX System Wachtdog Interrupt Timout Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_sys_wdg_irq_timeout      0x00000008U
#define Adr_NX51_watchdog_netx_sys_wdg_irq_timeout 0x1018C5B8U
#define Adr_NX51_netx_sys_wdg_irq_timeout          0x1018C5B8U
#define DFLT_VAL_NX51_netx_sys_wdg_irq_timeout     0x00000000U

#define MSK_NX51_netx_sys_wdg_irq_timeout_wdg_irq_timeout         0x0000ffffU
#define SRT_NX51_netx_sys_wdg_irq_timeout_wdg_irq_timeout         0
#define DFLT_VAL_NX51_netx_sys_wdg_irq_timeout_wdg_irq_timeout    0x00000000U
#define DFLT_BF_VAL_NX51_netx_sys_wdg_irq_timeout_wdg_irq_timeout 0x00000000U

/* all used bits of 'NX51_netx_sys_wdg_irq_timeout': */
#define MSK_USED_BITS_NX51_netx_sys_wdg_irq_timeout 0x0000ffffU

enum {
	BFW_NX51_netx_sys_wdg_irq_timeout_wdg_irq_timeout = 16, /* [15:0] */
	BFW_NX51_netx_sys_wdg_irq_timeout_reserved1       = 16  /* [31:16] */
};

typedef struct NX51_NETX_SYS_WDG_IRQ_TIMEOUT_BIT_Ttag {
	unsigned int wdg_irq_timeout : BFW_NX51_netx_sys_wdg_irq_timeout_wdg_irq_timeout; /* Watchdog interrupt timeout                                                            */
	                                                                                  /* The total netx_sys_irq timeout for a netX clock of 100MHz is: wdg_irq_timeout * 100s */
	unsigned int reserved1       : BFW_NX51_netx_sys_wdg_irq_timeout_reserved1;       /* reserved                                                                              */
} NX51_NETX_SYS_WDG_IRQ_TIMEOUT_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_NETX_SYS_WDG_IRQ_TIMEOUT_BIT_T bf;
} NX51_NETX_SYS_WDG_IRQ_TIMEOUT_T;

/* --------------------------------------------------------------------- */
/* Register netx_sys_wdg_res_timeout */
/* => netX System Watchdog Reset Timeout Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_netx_sys_wdg_res_timeout      0x0000000CU
#define Adr_NX51_watchdog_netx_sys_wdg_res_timeout 0x1018C5BCU
#define Adr_NX51_netx_sys_wdg_res_timeout          0x1018C5BCU
#define DFLT_VAL_NX51_netx_sys_wdg_res_timeout     0x00000000U

#define MSK_NX51_netx_sys_wdg_res_timeout_wdg_res_timeout         0x0000ffffU
#define SRT_NX51_netx_sys_wdg_res_timeout_wdg_res_timeout         0
#define DFLT_VAL_NX51_netx_sys_wdg_res_timeout_wdg_res_timeout    0x00000000U
#define DFLT_BF_VAL_NX51_netx_sys_wdg_res_timeout_wdg_res_timeout 0x00000000U

/* all used bits of 'NX51_netx_sys_wdg_res_timeout': */
#define MSK_USED_BITS_NX51_netx_sys_wdg_res_timeout 0x0000ffffU

enum {
	BFW_NX51_netx_sys_wdg_res_timeout_wdg_res_timeout = 16, /* [15:0] */
	BFW_NX51_netx_sys_wdg_res_timeout_reserved1       = 16  /* [31:16] */
};

typedef struct NX51_NETX_SYS_WDG_RES_TIMEOUT_BIT_Ttag {
	unsigned int wdg_res_timeout : BFW_NX51_netx_sys_wdg_res_timeout_wdg_res_timeout; /* Watchdog reset request timeout                                                                     */
	                                                                                  /* The total reset timeout for a netX clock of 100MHz is: (wdg_irq_timeout + wdg_res_timeout) * 100s */
	unsigned int reserved1       : BFW_NX51_netx_sys_wdg_res_timeout_reserved1;       /* reserved                                                                                           */
} NX51_NETX_SYS_WDG_RES_TIMEOUT_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_NETX_SYS_WDG_RES_TIMEOUT_BIT_T bf;
} NX51_NETX_SYS_WDG_RES_TIMEOUT_T;


/* ===================================================================== */

/* Area of sqi */

/* ===================================================================== */

#define Addr_NX51_sqi      0x1018C5C0U
#define NX51_NETX_SQI_AREA 0x1018C5C0U

/* --------------------------------------------------------------------- */
/* Register sqi_cr0 */
/* => SQI control register 0 */
/*    This register is compatible to netX50 and netX10 SPI module. However, there are some additional settings possible. SQI module */
/*    is provides only master functionality, hence slave settings are omitted. Compatible mode for netx100 is not supported by SQI module. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_cr0  0x00000000U
#define Adr_NX51_sqi_sqi_cr0  0x1018C5C0U
#define Adr_NX51_sqi_cr0      0x1018C5C0U
#define DFLT_VAL_NX51_sqi_cr0 0x00080007U

#define MSK_NX51_sqi_cr0_datasize           0x0000000fU
#define SRT_NX51_sqi_cr0_datasize           0
#define DFLT_VAL_NX51_sqi_cr0_datasize      0x00000007U
#define DFLT_BF_VAL_NX51_sqi_cr0_datasize   0x00000007U
#define MSK_NX51_sqi_cr0_sck_pol            0x00000040U
#define SRT_NX51_sqi_cr0_sck_pol            6
#define DFLT_VAL_NX51_sqi_cr0_sck_pol       0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr0_sck_pol    0x00000000U
#define MSK_NX51_sqi_cr0_sck_phase          0x00000080U
#define SRT_NX51_sqi_cr0_sck_phase          7
#define DFLT_VAL_NX51_sqi_cr0_sck_phase     0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr0_sck_phase  0x00000000U
#define MSK_NX51_sqi_cr0_sck_muladd         0x000fff00U
#define SRT_NX51_sqi_cr0_sck_muladd         8
#define DFLT_VAL_NX51_sqi_cr0_sck_muladd    0x00080000U
#define DFLT_BF_VAL_NX51_sqi_cr0_sck_muladd 0x00000800U
#define MSK_NX51_sqi_cr0_sio_cfg            0x00c00000U
#define SRT_NX51_sqi_cr0_sio_cfg            22
#define DFLT_VAL_NX51_sqi_cr0_sio_cfg       0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr0_sio_cfg    0x00000000U
#define MSK_NX51_sqi_cr0_filter_in          0x08000000U
#define SRT_NX51_sqi_cr0_filter_in          27
#define DFLT_VAL_NX51_sqi_cr0_filter_in     0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr0_filter_in  0x00000000U

/* all used bits of 'NX51_sqi_cr0': */
#define MSK_USED_BITS_NX51_sqi_cr0 0x08cfffcfU

enum {
	BFW_NX51_sqi_cr0_datasize   = 4,  /* [3:0] */
	BFW_NX51_sqi_cr0_reserved1  = 2,  /* [5:4] */
	BFW_NX51_sqi_cr0_sck_pol    = 1,  /* [6] */
	BFW_NX51_sqi_cr0_sck_phase  = 1,  /* [7] */
	BFW_NX51_sqi_cr0_sck_muladd = 12, /* [19:8] */
	BFW_NX51_sqi_cr0_reserved2  = 2,  /* [21:20] */
	BFW_NX51_sqi_cr0_sio_cfg    = 2,  /* [23:22] */
	BFW_NX51_sqi_cr0_reserved3  = 3,  /* [26:24] */
	BFW_NX51_sqi_cr0_filter_in  = 1,  /* [27] */
	BFW_NX51_sqi_cr0_reserved4  = 4   /* [31:28] */
};

typedef struct NX51_SQI_CR0_BIT_Ttag {
	unsigned int datasize   : BFW_NX51_sqi_cr0_datasize;   /* data size select for standard Motorola SPI mode.                                                  */
	                                                       /* This bit field is unused in 2- and 4-bit SPI modes (running always byte transfers).               */
	                                                       /* (transfer size = datasize + 1 bits)                                                               */
	                                                       /* 0000...0010: reserved                                                                             */
	                                                       /* 0011:  4 bit                                                                                      */
	                                                       /* 0100:  5 bit                                                                                      */
	                                                       /* ...                                                                                               */
	                                                       /* 0111:  8 bit                                                                                      */
	                                                       /* ...                                                                                               */
	                                                       /* 1111: 16 bit                                                                                      */
	unsigned int reserved1  : BFW_NX51_sqi_cr0_reserved1;  /* reserved                                                                                          */
	unsigned int sck_pol    : BFW_NX51_sqi_cr0_sck_pol;    /* serial clock polarity                                                                             */
	                                                       /* 0: idle: clock is low, first edge is rising                                                       */
	                                                       /* 1: idle: clock is high, first edge is falling                                                     */
	unsigned int sck_phase  : BFW_NX51_sqi_cr0_sck_phase;  /* serial clock phase                                                                                */
	                                                       /* 1: sample data at second clock edge, data is generated half a clock phase before sampling         */
	                                                       /* 0: sample data at first clock edge, data is generated half a clock phase before sampling          */
	unsigned int sck_muladd : BFW_NX51_sqi_cr0_sck_muladd; /* serial clock rate multiply add value for sck generation.                                          */
	                                                       /* sck-frequency: f_sck = (sck_muladd * 100)/4096 [MHz].                                             */
	                                                       /* Default value 0x800 equals 50MHz clock rate.                                                      */
	                                                       /* Note:                                                                                             */
	                                                       /*    If sck_muladd is set to zero, transfer will freeze.                                            */
	                                                       /* Note:                                                                                             */
	                                                       /*    SQIROM (XiP) serial clock rate ust be programmed in 'sqi_sqirom_cfg' register.                 */
	unsigned int reserved2  : BFW_NX51_sqi_cr0_reserved2;  /* reserved                                                                                          */
	unsigned int sio_cfg    : BFW_NX51_sqi_cr0_sio_cfg;    /* SQI IO configuration. Default is all IOs are in PIO input mode.                                   */
	                                                       /* Coding                                                                                            */
	                                                       /*  00: only SIO2,3 are controllable as PIOs (2-bit SPI or Standard Motorola SPI),                   */
	                                                       /*  01: all SQP IOs are used for transfers (4-bit SPI/SQI).                                          */
	                                                       /*  10: reserved                                                                                     */
	                                                       /*  11: all SQI IOs are controllable as PIOs                                                         */
	unsigned int reserved3  : BFW_NX51_sqi_cr0_reserved3;  /* reserved                                                                                          */
	unsigned int filter_in  : BFW_NX51_sqi_cr0_filter_in;  /* Receive-data is sampled every 10ns (100MHz system clock). If this bit is set, the                 */
	                                                       /* stored receive value will be the result of a majority decision of the three sampling points       */
	                                                       /* around a sck clock edge (if two or more '1s! were sampled a '1' will be stored, else a '0' will   */
	                                                       /* be stored.                                                                                        */
	                                                       /* Input filtering should be used for sck_muladd<=0x200 (i.e. below 12.5MHz). For higher frequencies */
	                                                       /* stable signal phases are too short.                                                               */
	unsigned int reserved4  : BFW_NX51_sqi_cr0_reserved4;  /* reserved                                                                                          */
} NX51_SQI_CR0_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SQI_CR0_BIT_T bf;
} NX51_SQI_CR0_T;

/* --------------------------------------------------------------------- */
/* Register sqi_cr1 */
/* => SQI control register 1 */
/*    This register is compatible to netX50 and netX10 SPI module. However, there are some additional settings possible. SQI module */
/*    is provides only master functionality, hence slave settings are omitted. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_cr1  0x00000004U
#define Adr_NX51_sqi_sqi_cr1  0x1018C5C4U
#define Adr_NX51_sqi_cr1      0x1018C5C4U
#define DFLT_VAL_NX51_sqi_cr1 0x08080000U

#define MSK_NX51_sqi_cr1_sqi_en                 0x00000002U
#define SRT_NX51_sqi_cr1_sqi_en                 1
#define DFLT_VAL_NX51_sqi_cr1_sqi_en            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr1_sqi_en         0x00000000U
#define MSK_NX51_sqi_cr1_fss                    0x00000700U
#define SRT_NX51_sqi_cr1_fss                    8
#define DFLT_VAL_NX51_sqi_cr1_fss               0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr1_fss            0x00000000U
#define MSK_NX51_sqi_cr1_fss_static             0x00000800U
#define SRT_NX51_sqi_cr1_fss_static             11
#define DFLT_VAL_NX51_sqi_cr1_fss_static        0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr1_fss_static     0x00000000U
#define MSK_NX51_sqi_cr1_spi_trans_ctrl         0x00001000U
#define SRT_NX51_sqi_cr1_spi_trans_ctrl         12
#define DFLT_VAL_NX51_sqi_cr1_spi_trans_ctrl    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr1_spi_trans_ctrl 0x00000000U
#define MSK_NX51_sqi_cr1_tx_fifo_wm             0x000f0000U
#define SRT_NX51_sqi_cr1_tx_fifo_wm             16
#define DFLT_VAL_NX51_sqi_cr1_tx_fifo_wm        0x00080000U
#define DFLT_BF_VAL_NX51_sqi_cr1_tx_fifo_wm     0x00000008U
#define MSK_NX51_sqi_cr1_tx_fifo_clr            0x00100000U
#define SRT_NX51_sqi_cr1_tx_fifo_clr            20
#define DFLT_VAL_NX51_sqi_cr1_tx_fifo_clr       0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr1_tx_fifo_clr    0x00000000U
#define MSK_NX51_sqi_cr1_rx_fifo_wm             0x0f000000U
#define SRT_NX51_sqi_cr1_rx_fifo_wm             24
#define DFLT_VAL_NX51_sqi_cr1_rx_fifo_wm        0x08000000U
#define DFLT_BF_VAL_NX51_sqi_cr1_rx_fifo_wm     0x00000008U
#define MSK_NX51_sqi_cr1_rx_fifo_clr            0x10000000U
#define SRT_NX51_sqi_cr1_rx_fifo_clr            28
#define DFLT_VAL_NX51_sqi_cr1_rx_fifo_clr       0x00000000U
#define DFLT_BF_VAL_NX51_sqi_cr1_rx_fifo_clr    0x00000000U

/* all used bits of 'NX51_sqi_cr1': */
#define MSK_USED_BITS_NX51_sqi_cr1 0x1f1f1f02U

enum {
	BFW_NX51_sqi_cr1_reserved1      = 1, /* [0] */
	BFW_NX51_sqi_cr1_sqi_en         = 1, /* [1] */
	BFW_NX51_sqi_cr1_reserved2      = 6, /* [7:2] */
	BFW_NX51_sqi_cr1_fss            = 3, /* [10:8] */
	BFW_NX51_sqi_cr1_fss_static     = 1, /* [11] */
	BFW_NX51_sqi_cr1_spi_trans_ctrl = 1, /* [12] */
	BFW_NX51_sqi_cr1_reserved3      = 3, /* [15:13] */
	BFW_NX51_sqi_cr1_tx_fifo_wm     = 4, /* [19:16] */
	BFW_NX51_sqi_cr1_tx_fifo_clr    = 1, /* [20] */
	BFW_NX51_sqi_cr1_reserved4      = 3, /* [23:21] */
	BFW_NX51_sqi_cr1_rx_fifo_wm     = 4, /* [27:24] */
	BFW_NX51_sqi_cr1_rx_fifo_clr    = 1, /* [28] */
	BFW_NX51_sqi_cr1_reserved5      = 3  /* [31:29] */
};

typedef struct NX51_SQI_CR1_BIT_Ttag {
	unsigned int reserved1      : BFW_NX51_sqi_cr1_reserved1;      /* reserved                                                                                                  */
	unsigned int sqi_en         : BFW_NX51_sqi_cr1_sqi_en;         /* SQI enable.                                                                                               */
	                                                               /* 0: interface disabled                                                                                     */
	                                                               /* 1: interface enabled                                                                                      */
	                                                               /* Note:                                                                                                     */
	                                                               /*    Standard SQI/SPI function is not available if SQIROM/XiP function is selected by                       */
	                                                               /*    'enable' bit of 'sqi_sqirom_cfg' register (see description of 'sqi_sqirom_cfg' register).              */
	unsigned int reserved2      : BFW_NX51_sqi_cr1_reserved2;      /* reserved                                                                                                  */
	unsigned int fss            : BFW_NX51_sqi_cr1_fss;            /* Frame slave select (up to 3 devices can be assigned directly,                                             */
	                                                               /* up to 8 devices can be assigned if an external demultiplexer is used).                                    */
	                                                               /* This signal is active low, so the bits will be inverted before output to the SQI pins.                    */
	unsigned int fss_static     : BFW_NX51_sqi_cr1_fss_static;     /* SQI static chipselect                                                                                     */
	                                                               /* 0: chipselect will be generated automatically at data frame begin/end according to fss and datasize       */
	                                                               /* 1: chipselect will be set statically according to fss                                                     */
	                                                               /* If fss is set to statically, fss must be toggled manually after each data frame in Motorola SPI mode when */
	                                                               /* sck_phase is 0 for spec compatibility!                                                                    */
	unsigned int spi_trans_ctrl : BFW_NX51_sqi_cr1_spi_trans_ctrl; /* Transfer Control for standard Motorola SPI (default: disabled)                                            */
	                                                               /* This bit is only used for for standard Motorola SPI (register 'sqi_tcr' 'mode'-bits)                      */
	                                                               /* in full duplex and half duplex transmit mode.                                                             */
	                                                               /* If this bit is set, SPI transfer then is controlled by 'start_transfer' and 'transfer_size'               */
	                                                               /* of register 'sqi_tcr'.                                                                                    */
	                                                               /* If this bit is not set (default), SPI transfers start immediately after transfer data was written to      */
	                                                               /* TX FIFO (this is SPI module compatible). Settings of 'start_transfer' and 'transfer_size'                 */
	                                                               /* of register 'sqi_tcr' then remain unaffected and are ignored.                                             */
	                                                               /* If this bit is set and SPI is used in receive mode (full duplex or half duplex receive                    */
	                                                               /* mode set by bit field 'duplex' in register 'sqi_tcr'), transfers will be stopped when                     */
	                                                               /* receive FIFO runs full. Transfers will be continued after receive data is read from                       */
	                                                               /* receive FIFO. This is done to avoid receive FIFO overflows.                                               */
	unsigned int reserved3      : BFW_NX51_sqi_cr1_reserved3;      /* reserved                                                                                                  */
	unsigned int tx_fifo_wm     : BFW_NX51_sqi_cr1_tx_fifo_wm;     /* transmit FIFO watermark for IRQ-generation                                                                */
	unsigned int tx_fifo_clr    : BFW_NX51_sqi_cr1_tx_fifo_clr;    /* Writing "1" to this bit will clear the transmit-FIFO.                                                     */
	                                                               /* This bit will be reset automatically by hardware. It is always '0' on read.                               */
	unsigned int reserved4      : BFW_NX51_sqi_cr1_reserved4;      /* reserved                                                                                                  */
	unsigned int rx_fifo_wm     : BFW_NX51_sqi_cr1_rx_fifo_wm;     /* receive FIFO watermark for IRQ-generation.                                                                */
	                                                               /* If receive FIFO watermark IRQ is enabled ('RXIM' bit is set in 'sqi_irq_mask' register),                  */
	                                                               /* transfers will be stopped when receive FIFO runs full. Transfers will be continued after                  */
	                                                               /* receive data is read from receive FIFO. This is done to avoid receive FIFO overflows.                     */
	                                                               /* If receive FIFO watermark IRQ is disabled ('RXIM' bit is not set in 'sqi_irq_mask' register),             */
	                                                               /* transfers will not be stopped when receive FIFO runs full. In this case receive FIFO                      */
	                                                               /* overrun could occur. This is compatible to netX50 behavior and allows writing data in                     */
	                                                               /* full duplex mode without reading receive FIFO.                                                            */
	unsigned int rx_fifo_clr    : BFW_NX51_sqi_cr1_rx_fifo_clr;    /* Writing "1" to this bit will clear the receive-FIFO.                                                      */
	                                                               /* This bit will be reset automatically by hardware. It is always '0' on read.                               */
	unsigned int reserved5      : BFW_NX51_sqi_cr1_reserved5;      /* reserved                                                                                                  */
} NX51_SQI_CR1_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SQI_CR1_BIT_T bf;
} NX51_SQI_CR1_T;

/* --------------------------------------------------------------------- */
/* Register sqi_dr */
/* => SQI data register (DR) */
/*    read access: received data byte is delivered from receive FIFO */
/*    write access: send data byte is written to send FIFO */
/*    Both, receive and transmit FIFO have a depth of 16. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_dr  0x00000008U
#define Adr_NX51_sqi_sqi_dr  0x1018C5C8U
#define Adr_NX51_sqi_dr      0x1018C5C8U
#define DFLT_VAL_NX51_sqi_dr 0x00000000U

#define MSK_NX51_sqi_dr_data         0xffffffffU
#define SRT_NX51_sqi_dr_data         0
#define DFLT_VAL_NX51_sqi_dr_data    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_dr_data 0x00000000U

/* all used bits of 'NX51_sqi_dr': */
#define MSK_USED_BITS_NX51_sqi_dr 0xffffffffU

enum {
	BFW_NX51_sqi_dr_data = 32  /* [31:0] */
};

typedef struct NX51_SQI_DR_BIT_Ttag {
	unsigned int data : BFW_NX51_sqi_dr_data; /* Transmit data, must be right aligned on writing.                                                                           */
	                                          /* In Standard SPI mode only bits according to sqi_cr0.datasize are being transferred.                                        */
	                                          /* In SQI mode data must be written in full DWords (i.e. software needs to collect four bytes prior to writing).              */
	                                          /* Unused bytes won't be transferred and may be padded at will (number of transfered bytes depends on sqi_tcr.transfer_size). */
	                                          /* Receive data will be delivered right aligned in both modes, unused bits will be "0".                                       */
} NX51_SQI_DR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SQI_DR_BIT_T bf;
} NX51_SQI_DR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_sr */
/* => Read only SQI status register */
/*    SQI master mode: MISO-input-data will be stored in the receive FIFO, transmit FIFO generates MOSI-output-data */
/*    Shows the current status of the SQI interface. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_sr 0x0000000CU
#define Adr_NX51_sqi_sqi_sr 0x1018C5CCU
#define Adr_NX51_sqi_sr     0x1018C5CCU

#define MSK_NX51_sqi_sr_tx_fifo_empty       0x00000001U
#define SRT_NX51_sqi_sr_tx_fifo_empty       0
#define MSK_NX51_sqi_sr_tx_fifo_not_full    0x00000002U
#define SRT_NX51_sqi_sr_tx_fifo_not_full    1
#define MSK_NX51_sqi_sr_rx_fifo_not_empty   0x00000004U
#define SRT_NX51_sqi_sr_rx_fifo_not_empty   2
#define MSK_NX51_sqi_sr_rx_fifo_full        0x00000008U
#define SRT_NX51_sqi_sr_rx_fifo_full        3
#define MSK_NX51_sqi_sr_busy                0x00000010U
#define SRT_NX51_sqi_sr_busy                4
#define MSK_NX51_sqi_sr_sqirom_timeout_err  0x00002000U
#define SRT_NX51_sqi_sr_sqirom_timeout_err  13
#define MSK_NX51_sqi_sr_sqirom_write_err    0x00004000U
#define SRT_NX51_sqi_sr_sqirom_write_err    14
#define MSK_NX51_sqi_sr_sqirom_disabled_err 0x00008000U
#define SRT_NX51_sqi_sr_sqirom_disabled_err 15
#define MSK_NX51_sqi_sr_tx_fifo_level       0x001f0000U
#define SRT_NX51_sqi_sr_tx_fifo_level       16
#define MSK_NX51_sqi_sr_tx_fifo_err_ovfl    0x00400000U
#define SRT_NX51_sqi_sr_tx_fifo_err_ovfl    22
#define MSK_NX51_sqi_sr_tx_fifo_err_undr    0x00800000U
#define SRT_NX51_sqi_sr_tx_fifo_err_undr    23
#define MSK_NX51_sqi_sr_rx_fifo_level       0x1f000000U
#define SRT_NX51_sqi_sr_rx_fifo_level       24
#define MSK_NX51_sqi_sr_rx_fifo_err_ovfl    0x40000000U
#define SRT_NX51_sqi_sr_rx_fifo_err_ovfl    30
#define MSK_NX51_sqi_sr_rx_fifo_err_undr    0x80000000U
#define SRT_NX51_sqi_sr_rx_fifo_err_undr    31

/* all used bits of 'NX51_sqi_sr': */
#define MSK_USED_BITS_NX51_sqi_sr 0xdfdfe01fU

enum {
	BFW_NX51_sqi_sr_tx_fifo_empty       = 1, /* [0] */
	BFW_NX51_sqi_sr_tx_fifo_not_full    = 1, /* [1] */
	BFW_NX51_sqi_sr_rx_fifo_not_empty   = 1, /* [2] */
	BFW_NX51_sqi_sr_rx_fifo_full        = 1, /* [3] */
	BFW_NX51_sqi_sr_busy                = 1, /* [4] */
	BFW_NX51_sqi_sr_reserved1           = 8, /* [12:5] */
	BFW_NX51_sqi_sr_sqirom_timeout_err  = 1, /* [13] */
	BFW_NX51_sqi_sr_sqirom_write_err    = 1, /* [14] */
	BFW_NX51_sqi_sr_sqirom_disabled_err = 1, /* [15] */
	BFW_NX51_sqi_sr_tx_fifo_level       = 5, /* [20:16] */
	BFW_NX51_sqi_sr_reserved2           = 1, /* [21] */
	BFW_NX51_sqi_sr_tx_fifo_err_ovfl    = 1, /* [22] */
	BFW_NX51_sqi_sr_tx_fifo_err_undr    = 1, /* [23] */
	BFW_NX51_sqi_sr_rx_fifo_level       = 5, /* [28:24] */
	BFW_NX51_sqi_sr_reserved3           = 1, /* [29] */
	BFW_NX51_sqi_sr_rx_fifo_err_ovfl    = 1, /* [30] */
	BFW_NX51_sqi_sr_rx_fifo_err_undr    = 1  /* [31] */
};

typedef struct NX51_SQI_SR_BIT_Ttag {
	unsigned int tx_fifo_empty       : BFW_NX51_sqi_sr_tx_fifo_empty;       /* Transmit FIFO is empty (1 if empty).                                                            */
	unsigned int tx_fifo_not_full    : BFW_NX51_sqi_sr_tx_fifo_not_full;    /* Transmit FIFO is not full (0 if full).                                                          */
	unsigned int rx_fifo_not_empty   : BFW_NX51_sqi_sr_rx_fifo_not_empty;   /* Receive FIFO is not empty (0 if empty).                                                         */
	unsigned int rx_fifo_full        : BFW_NX51_sqi_sr_rx_fifo_full;        /* Receive FIFO is full (1 if full).                                                               */
	unsigned int busy                : BFW_NX51_sqi_sr_busy;                /* Device is busy (1 if data is currently transmitted/received or the transmit FIFO is not empty). */
	unsigned int reserved1           : BFW_NX51_sqi_sr_reserved1;           /* reserved                                                                                        */
	unsigned int sqirom_timeout_err  : BFW_NX51_sqi_sr_sqirom_timeout_err;  /* Timeout during SQIROM area read detected.                                                       */
	                                                                        /* A timeout results from a fix level on netX serial clock IO. Check IO                            */
	                                                                        /* multiplexing configuration and ensure that serial clock output is not clamped.                  */
	                                                                        /* This bit can be used to determine the reason for 'sqirom_error' IRQ assertion.                  */
	                                                                        /* This status flag is only cleared by writing a '1' here.                                         */
	                                                                        /* SQIROM function must be disabled and enabled again to reset module internal state               */
	                                                                        /* machines after this bit has ben set (register 'sqirom_cfg', reset and set again 'enable' bit).  */
	unsigned int sqirom_write_err    : BFW_NX51_sqi_sr_sqirom_write_err;    /* Write access to SQIROM area detected.                                                           */
	                                                                        /* SQIROM area is read only.                                                                       */
	                                                                        /* This bit can be used to determine the reason for 'sqirom_error' IRQ assertion.                  */
	                                                                        /* This status flag is only cleared by writing a '1' here.                                         */
	unsigned int sqirom_disabled_err : BFW_NX51_sqi_sr_sqirom_disabled_err; /* Access to SQIROM area detected while SQIROM was disabled.                                       */
	                                                                        /* To enable SQIROM functionality set 'enable' bit in 'sqi_sqirom_cfg' register.                   */
	                                                                        /* This bit can be used to determine the reason for 'sqirom_error' IRQ assertion.                  */
	                                                                        /* This status flag is only cleared by writing a '1' here.                                         */
	unsigned int tx_fifo_level       : BFW_NX51_sqi_sr_tx_fifo_level;       /* Transmit FIFO level (number of words to transmit are left in FIFO).                             */
	unsigned int reserved2           : BFW_NX51_sqi_sr_reserved2;           /* reserved                                                                                        */
	unsigned int tx_fifo_err_ovfl    : BFW_NX51_sqi_sr_tx_fifo_err_ovfl;    /* Transmit FIFO overflow error occurred, data is lost.                                            */
	                                                                        /* This status flag is cleared by clearing TX FIFO ('sqi_cr1' register).                           */
	unsigned int tx_fifo_err_undr    : BFW_NX51_sqi_sr_tx_fifo_err_undr;    /* Transmit FIFO underrun error occurred, data is lost.                                            */
	                                                                        /* This status flag is cleared by clearing TX FIFO ('sqi_cr1' register).                           */
	unsigned int rx_fifo_level       : BFW_NX51_sqi_sr_rx_fifo_level;       /* Receive FIFO level (number of received words to read out are left in FIFO).                     */
	unsigned int reserved3           : BFW_NX51_sqi_sr_reserved3;           /* reserved                                                                                        */
	unsigned int rx_fifo_err_ovfl    : BFW_NX51_sqi_sr_rx_fifo_err_ovfl;    /* Receive FIFO overflow error occurred, data is lost.                                             */
	                                                                        /* This status flag is cleared by clearing RX FIFO ('sqi_cr1' register).                           */
	unsigned int rx_fifo_err_undr    : BFW_NX51_sqi_sr_rx_fifo_err_undr;    /* Receive FIFO underrun error occurred, data is lost.                                             */
	                                                                        /* This status flag is cleared by clearing RX FIFO ('sqi_cr1' register).                           */
} NX51_SQI_SR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_SQI_SR_BIT_T bf;
} NX51_SQI_SR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_tcr */
/* => SQI transfer control (Module address offset 0x10 is reserved in netX10/50 SPI module. No compatibility problems by using this address for new register). */
/*    This register must not be changed while a transfer is running ('busy' bit in register 'sqi_sr' is '1') to avoid corrupted transfers causing hardware damage. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_tcr  0x00000010U
#define Adr_NX51_sqi_sqi_tcr  0x1018C5D0U
#define Adr_NX51_sqi_tcr      0x1018C5D0U
#define DFLT_VAL_NX51_sqi_tcr 0x1c000000U

#define MSK_NX51_sqi_tcr_transfer_size          0x0007ffffU
#define SRT_NX51_sqi_tcr_transfer_size          0
#define DFLT_VAL_NX51_sqi_tcr_transfer_size     0x00000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_transfer_size  0x00000000U
#define MSK_NX51_sqi_tcr_tx_out                 0x00200000U
#define SRT_NX51_sqi_tcr_tx_out                 21
#define DFLT_VAL_NX51_sqi_tcr_tx_out            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_tx_out         0x00000000U
#define MSK_NX51_sqi_tcr_tx_oe                  0x00400000U
#define SRT_NX51_sqi_tcr_tx_oe                  22
#define DFLT_VAL_NX51_sqi_tcr_tx_oe             0x00000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_tx_oe          0x00000000U
#define MSK_NX51_sqi_tcr_start_transfer         0x00800000U
#define SRT_NX51_sqi_tcr_start_transfer         23
#define DFLT_VAL_NX51_sqi_tcr_start_transfer    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_start_transfer 0x00000000U
#define MSK_NX51_sqi_tcr_mode                   0x03000000U
#define SRT_NX51_sqi_tcr_mode                   24
#define DFLT_VAL_NX51_sqi_tcr_mode              0x00000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_mode           0x00000000U
#define MSK_NX51_sqi_tcr_duplex                 0x0c000000U
#define SRT_NX51_sqi_tcr_duplex                 26
#define DFLT_VAL_NX51_sqi_tcr_duplex            0x0c000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_duplex         0x00000003U
#define MSK_NX51_sqi_tcr_ms_bit_first           0x10000000U
#define SRT_NX51_sqi_tcr_ms_bit_first           28
#define DFLT_VAL_NX51_sqi_tcr_ms_bit_first      0x10000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_ms_bit_first   0x00000001U
#define MSK_NX51_sqi_tcr_ms_byte_first          0x20000000U
#define SRT_NX51_sqi_tcr_ms_byte_first          29
#define DFLT_VAL_NX51_sqi_tcr_ms_byte_first     0x00000000U
#define DFLT_BF_VAL_NX51_sqi_tcr_ms_byte_first  0x00000000U

/* all used bits of 'NX51_sqi_tcr': */
#define MSK_USED_BITS_NX51_sqi_tcr 0x3fe7ffffU

enum {
	BFW_NX51_sqi_tcr_transfer_size  = 19, /* [18:0] */
	BFW_NX51_sqi_tcr_reserved1      = 2,  /* [20:19] */
	BFW_NX51_sqi_tcr_tx_out         = 1,  /* [21] */
	BFW_NX51_sqi_tcr_tx_oe          = 1,  /* [22] */
	BFW_NX51_sqi_tcr_start_transfer = 1,  /* [23] */
	BFW_NX51_sqi_tcr_mode           = 2,  /* [25:24] */
	BFW_NX51_sqi_tcr_duplex         = 2,  /* [27:26] */
	BFW_NX51_sqi_tcr_ms_bit_first   = 1,  /* [28] */
	BFW_NX51_sqi_tcr_ms_byte_first  = 1,  /* [29] */
	BFW_NX51_sqi_tcr_reserved2      = 2   /* [31:30] */
};

typedef struct NX51_SQI_TCR_BIT_Ttag {
	unsigned int transfer_size  : BFW_NX51_sqi_tcr_transfer_size;  /* Number of bytes within the current SQI transaction (transfer_size+1).                                          */
	                                                               /* Program (actual number of bytes - 1) in SQI modes or (number of dummy clock cycles - 1)                        */
	                                                               /* Example:                                                                                                       */
	                                                               /*    0x00000: one byte / dummy cycle                                                                             */
	                                                               /*    ...                                                                                                         */
	                                                               /*    0x7ffff: 512k bytes / dummy cycles                                                                          */
	                                                               /* This bit field counts down during transfer with each transferred word/byte or dummy cycle. It                  */
	                                                               /* is only writable after a transfer sequence is finished  or if the transfer sequence is                         */
	                                                               /* terminated by a FIFO clear. Hence, it is writable but can also be changed by hardware.                         */
	                                                               /* A running transfer sequence can be terminated by FIFO clearing (register 'sqi_cr1').                           */
	                                                               /* This may be necessary if a read sequence has to be terminated.                                                 */
	                                                               /* Example:                                                                                                       */
	                                                               /*    A half duplex write transfer of 128k bytes was programmed but there is not enough                           */
	                                                               /*    write data. To terminate this write sequence, clear TX FIFO. If there is an external                        */
	                                                               /*    transfer running at the moment of clearing the FIFO, this transfer will not be broken                       */
	                                                               /*    and finished with the last bit to be transferred.                                                           */
	                                                               /* Note:                                                                                                          */
	                                                               /*    A transfer sequence is finished completely when 'busy' bit in 'sqi_sr' register is not set.                 */
	                                                               /* TBD Note:                                                                                                      */
	                                                               /* TBD    In 4-bit SQI mode it is only allowed to programm 1 to 4 bytes or sizes in multiples of                  */
	                                                               /* TBD    full DWords. So, valid values in 4-bit mode are: 0, 1, 2, 3, 7, 11, ..., (4n - 1)                       */
	unsigned int reserved1      : BFW_NX51_sqi_tcr_reserved1;      /* reserved                                                                                                       */
	unsigned int tx_out         : BFW_NX51_sqi_tcr_tx_out;         /* Output level in dummy or standard SPI receive-only mode.                                                       */
	                                                               /* This bit selects the output level when the output driver is enabled in dummy mode.                             */
	unsigned int tx_oe          : BFW_NX51_sqi_tcr_tx_oe;          /* Output driver enable in dummy or standard SPI receive-only mode                                                */
	                                                               /* Writing a "1" enables the output drivers of the data pins in dummy mode.                                       */
	unsigned int start_transfer : BFW_NX51_sqi_tcr_start_transfer; /* Transfer start signal                                                                                          */
	                                                               /* Writing a "1" starts the transfer of transfer_size bytes.                                                      */
	                                                               /* Also starts transfer of dummy cycles.                                                                          */
	                                                               /* This bit will be reset automatically by hardware and is always '0' on read. It                                 */
	                                                               /* is only writable after a transfer sequence is finished or if the transfer sequence is                          */
	                                                               /* terminated by a FIFO clear.                                                                                    */
	                                                               /* Note:                                                                                                          */
	                                                               /*    A transfer sequence is finished completely when 'busy' bit in 'sqi_sr' register is not set.                 */
	                                                               /* Note:                                                                                                          */
	                                                               /*    For standard Motorola SPI mode, this function can be controlled by 'spi_trans_ctrl' bit in                  */
	                                                               /*    'sqi_cr1' register (for SPI module compatibility).                                                          */
	unsigned int mode           : BFW_NX51_sqi_tcr_mode;           /* SPI/SQI Mode selection                                                                                         */
	                                                               /* 00: Standard Motorola SPI mode.                                                                                */
	                                                               /* 01: 2-bit SPI mode                                                                                             */
	                                                               /* 10: 4-bit SPI mode                                                                                             */
	                                                               /* 11: reserved                                                                                                   */
	unsigned int duplex         : BFW_NX51_sqi_tcr_duplex;         /* Transfer type selection (default is '11' for SPI compatibility).                                               */
	                                                               /* 00: dummy.                                                                                                     */
	                                                               /*     Generates 'transfer_size' + 1 serial clock periods. No change of RX and TX FIFOs.                          */
	                                                               /*     Data lines (standard Motorola SPI mode: SPI_MOSI) are controlled by 'tx_oe' and 'tx_out'.                  */
	                                                               /* 01: half duplex receive                                                                                        */
	                                                               /*     Receives 'transfer_size' + 1 words.                                                                        */
	                                                               /*     In 2-bit and 4-bit mode TX-FIFO will be cleared and are not available during reveive.                      */
	                                                               /*     In standard SPI mode SPI_MOSI is controlled by 'tx_oe' and 'tx_out'. There is no need to                   */
	                                                               /*     fill the TX-FIFO with dummy TX-data to receive RX-data. TX FIFOs are not changed and are always available. */
	                                                               /* 10: half duplex transmit                                                                                       */
	                                                               /*     Transmits 'transfer_size' + 1 words.                                                                       */
	                                                               /*     In 2-bit and 4-bit mode RX-FIFO will be cleared and are not available during receive.                      */
	                                                               /*     In standard SPI mode SPI_MISO input is ignored. RX-FIFO is available and remains unchanged.                */
	                                                               /* 11: full duplex (Standard Motorola SPI mode only, reserved in 2-bit and 4-bit modes)                           */
	                                                               /*     This is full duplex standard Motorola SPI mode always transmitting and receiving data. Transmit data       */
	                                                               /*     is taken from TX-FIFO, receive data is stored in RX-FIFO.                                                  */
	                                                               /* Note:                                                                                                          */
	                                                               /*    If '11' is set in 2-bit or 4-bit mode, this is treated as 'receive' (like '01' setting).                    */
	                                                               /* Note:                                                                                                          */
	                                                               /*    If there was a FIFO error (overrun, underrun) before changing to '01' or '10'                               */
	                                                               /*    the FIFO error status bits in register 'sqi_sr' are not cleared by half duplex modes FIFO clearing.         */
	unsigned int ms_bit_first   : BFW_NX51_sqi_tcr_ms_bit_first;   /* Most significant bit first                                                                                     */
	                                                               /* 2- and 4-bit mode: Writing "1" to this bit will transfer most significant bit first                            */
	                                                               /* In Standard Motorola SPI mode this bit is ignored.                                                             */
	unsigned int ms_byte_first  : BFW_NX51_sqi_tcr_ms_byte_first;  /* Most significant byte first                                                                                    */
	                                                               /* 2- and 4-bit mode: Writing "1" to this bit will use most significant byte first in DWords                      */
	                                                               /* In Standard Motorola SPI mode this bit is ignored.                                                             */
	                                                               /* Endianess of a transferred 32-bit word can be controlled by this bit. Default 0 is little endianess.           */
	unsigned int reserved2      : BFW_NX51_sqi_tcr_reserved2;      /* reserved                                                                                                       */
} NX51_SQI_TCR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_SQI_TCR_BIT_T bf;
} NX51_SQI_TCR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_mask */
/* => SQI interrupt mask set or clear register. */
/*    IRQ mask is an AND-mask: only IRQ with mask bit set can generate module IRQ. */
/*    For detailed IRQ behavior and function view 'sqi_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_irq_mask  0x00000014U
#define Adr_NX51_sqi_sqi_irq_mask  0x1018C5D4U
#define Adr_NX51_sqi_irq_mask      0x1018C5D4U
#define DFLT_VAL_NX51_sqi_irq_mask 0x00000000U

#define MSK_NX51_sqi_irq_mask_RORIM                0x00000001U
#define SRT_NX51_sqi_irq_mask_RORIM                0
#define DFLT_VAL_NX51_sqi_irq_mask_RORIM           0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_RORIM        0x00000000U
#define MSK_NX51_sqi_irq_mask_RTIM                 0x00000002U
#define SRT_NX51_sqi_irq_mask_RTIM                 1
#define DFLT_VAL_NX51_sqi_irq_mask_RTIM            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_RTIM         0x00000000U
#define MSK_NX51_sqi_irq_mask_RXIM                 0x00000004U
#define SRT_NX51_sqi_irq_mask_RXIM                 2
#define DFLT_VAL_NX51_sqi_irq_mask_RXIM            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_RXIM         0x00000000U
#define MSK_NX51_sqi_irq_mask_TXIM                 0x00000008U
#define SRT_NX51_sqi_irq_mask_TXIM                 3
#define DFLT_VAL_NX51_sqi_irq_mask_TXIM            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_TXIM         0x00000000U
#define MSK_NX51_sqi_irq_mask_rxneim               0x00000010U
#define SRT_NX51_sqi_irq_mask_rxneim               4
#define DFLT_VAL_NX51_sqi_irq_mask_rxneim          0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_rxneim       0x00000000U
#define MSK_NX51_sqi_irq_mask_rxfim                0x00000020U
#define SRT_NX51_sqi_irq_mask_rxfim                5
#define DFLT_VAL_NX51_sqi_irq_mask_rxfim           0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_rxfim        0x00000000U
#define MSK_NX51_sqi_irq_mask_txeim                0x00000040U
#define SRT_NX51_sqi_irq_mask_txeim                6
#define DFLT_VAL_NX51_sqi_irq_mask_txeim           0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_txeim        0x00000000U
#define MSK_NX51_sqi_irq_mask_trans_end            0x00000080U
#define SRT_NX51_sqi_irq_mask_trans_end            7
#define DFLT_VAL_NX51_sqi_irq_mask_trans_end       0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_trans_end    0x00000000U
#define MSK_NX51_sqi_irq_mask_sqirom_error         0x00000100U
#define SRT_NX51_sqi_irq_mask_sqirom_error         8
#define DFLT_VAL_NX51_sqi_irq_mask_sqirom_error    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_mask_sqirom_error 0x00000000U

/* all used bits of 'NX51_sqi_irq_mask': */
#define MSK_USED_BITS_NX51_sqi_irq_mask 0x000001ffU

enum {
	BFW_NX51_sqi_irq_mask_RORIM        = 1,  /* [0] */
	BFW_NX51_sqi_irq_mask_RTIM         = 1,  /* [1] */
	BFW_NX51_sqi_irq_mask_RXIM         = 1,  /* [2] */
	BFW_NX51_sqi_irq_mask_TXIM         = 1,  /* [3] */
	BFW_NX51_sqi_irq_mask_rxneim       = 1,  /* [4] */
	BFW_NX51_sqi_irq_mask_rxfim        = 1,  /* [5] */
	BFW_NX51_sqi_irq_mask_txeim        = 1,  /* [6] */
	BFW_NX51_sqi_irq_mask_trans_end    = 1,  /* [7] */
	BFW_NX51_sqi_irq_mask_sqirom_error = 1,  /* [8] */
	BFW_NX51_sqi_irq_mask_reserved1    = 23  /* [31:9] */
};

typedef struct NX51_SQI_IRQ_MASK_BIT_Ttag {
	unsigned int RORIM        : BFW_NX51_sqi_irq_mask_RORIM;        /* receive FIFO overrun interrupt mask                                */
	unsigned int RTIM         : BFW_NX51_sqi_irq_mask_RTIM;         /* receive timeout interrupt mask                                     */
	unsigned int RXIM         : BFW_NX51_sqi_irq_mask_RXIM;         /* receive FIFO interrupt mask                                        */
	unsigned int TXIM         : BFW_NX51_sqi_irq_mask_TXIM;         /* transmit FIFO interrupt mask                                       */
	unsigned int rxneim       : BFW_NX51_sqi_irq_mask_rxneim;       /* receive FIFO not empty interrupt mask (for netx100/500 compliance) */
	unsigned int rxfim        : BFW_NX51_sqi_irq_mask_rxfim;        /* receive FIFO full interrupt mask (for netx100/500 compliance)      */
	unsigned int txeim        : BFW_NX51_sqi_irq_mask_txeim;        /* transmit FIFO empty interrupt mask (for netx100/500 compliance)    */
	unsigned int trans_end    : BFW_NX51_sqi_irq_mask_trans_end;    /* transfer end interrupt mask                                        */
	unsigned int sqirom_error : BFW_NX51_sqi_irq_mask_sqirom_error; /* SQIROM error interrupt mask                                        */
	unsigned int reserved1    : BFW_NX51_sqi_irq_mask_reserved1;    /* reserved                                                           */
} NX51_SQI_IRQ_MASK_BIT_T;

typedef union {
	unsigned int            val;
	NX51_SQI_IRQ_MASK_BIT_T bf;
} NX51_SQI_IRQ_MASK_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_raw */
/* => SQI interrupt state before masking register (raw interrupt). */
/*    Writing a "1" to a bit clears this interrupt. */
/*    Note: */
/*        Both, receive and transmit FIFO have a depth of 16. */
/*    Note: */
/*       IRQ flags can also be cleared by using 'sqi_icr' for SPI module compatibility. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_irq_raw 0x00000018U
#define Adr_NX51_sqi_sqi_irq_raw 0x1018C5D8U
#define Adr_NX51_sqi_irq_raw     0x1018C5D8U

#define MSK_NX51_sqi_irq_raw_RORRIS       0x00000001U
#define SRT_NX51_sqi_irq_raw_RORRIS       0
#define MSK_NX51_sqi_irq_raw_RTRIS        0x00000002U
#define SRT_NX51_sqi_irq_raw_RTRIS        1
#define MSK_NX51_sqi_irq_raw_RXRIS        0x00000004U
#define SRT_NX51_sqi_irq_raw_RXRIS        2
#define MSK_NX51_sqi_irq_raw_TXRIS        0x00000008U
#define SRT_NX51_sqi_irq_raw_TXRIS        3
#define MSK_NX51_sqi_irq_raw_rxneris      0x00000010U
#define SRT_NX51_sqi_irq_raw_rxneris      4
#define MSK_NX51_sqi_irq_raw_rxfris       0x00000020U
#define SRT_NX51_sqi_irq_raw_rxfris       5
#define MSK_NX51_sqi_irq_raw_txeris       0x00000040U
#define SRT_NX51_sqi_irq_raw_txeris       6
#define MSK_NX51_sqi_irq_raw_trans_end    0x00000080U
#define SRT_NX51_sqi_irq_raw_trans_end    7
#define MSK_NX51_sqi_irq_raw_sqirom_error 0x00000100U
#define SRT_NX51_sqi_irq_raw_sqirom_error 8

/* all used bits of 'NX51_sqi_irq_raw': */
#define MSK_USED_BITS_NX51_sqi_irq_raw 0x000001ffU

enum {
	BFW_NX51_sqi_irq_raw_RORRIS       = 1,  /* [0] */
	BFW_NX51_sqi_irq_raw_RTRIS        = 1,  /* [1] */
	BFW_NX51_sqi_irq_raw_RXRIS        = 1,  /* [2] */
	BFW_NX51_sqi_irq_raw_TXRIS        = 1,  /* [3] */
	BFW_NX51_sqi_irq_raw_rxneris      = 1,  /* [4] */
	BFW_NX51_sqi_irq_raw_rxfris       = 1,  /* [5] */
	BFW_NX51_sqi_irq_raw_txeris       = 1,  /* [6] */
	BFW_NX51_sqi_irq_raw_trans_end    = 1,  /* [7] */
	BFW_NX51_sqi_irq_raw_sqirom_error = 1,  /* [8] */
	BFW_NX51_sqi_irq_raw_reserved1    = 23  /* [31:9] */
};

typedef struct NX51_SQI_IRQ_RAW_BIT_Ttag {
	unsigned int RORRIS       : BFW_NX51_sqi_irq_raw_RORRIS;       /* unmasked receive FIFO overrun interrupt state                                               */
	                                                               /* 1: receive FIFO overrun error occurred                                                      */
	                                                               /* 0: no receive FIFO overrun error occurred                                                   */
	unsigned int RTRIS        : BFW_NX51_sqi_irq_raw_RTRIS;        /* unmasked receive timeout interrupt state                                                    */
	                                                               /* timeout period are 32 SQI-clock periods depending on adr_sqi_cr0.SCR                        */
	                                                               /* 1: receive FIFO is not empty and not read out in the passed timeout period                  */
	                                                               /* 0: receive FIFO is empty or read during the last timeout period                             */
	unsigned int RXRIS        : BFW_NX51_sqi_irq_raw_RXRIS;        /* unmasked receive FIFO interrupt state                                                       */
	                                                               /* 1: receive FIFO is higher than sqi_cr1.rx_fifo_wm                                           */
	                                                               /* 0: receive FIFO is equals or is below sqi_cr1.rx_fifo_wm                                    */
	                                                               /* Note:                                                                                       */
	                                                               /*     View description of register 'sqi_cr1' for bits 'spi_trans_ctrl' and 'rx_fifo_wm'       */
	                                                               /*     for receive FIFO behavior before programming this IRQ.                                  */
	unsigned int TXRIS        : BFW_NX51_sqi_irq_raw_TXRIS;        /* unmasked transmit FIFO interrupt state                                                      */
	                                                               /* 1: transmit FIFO level is below sqi_cr1.tx_fifo_wm                                          */
	                                                               /* 0: transmit FIFO equals or is higher than sqi_cr1.tx_fifo_wm                                */
	unsigned int rxneris      : BFW_NX51_sqi_irq_raw_rxneris;      /* unmasked receive FIFO not empty interrupt state (for netx100/500 compliance)                */
	                                                               /* 1: receive FIFO is not empty                                                                */
	                                                               /* 0: receive FIFO is empty                                                                    */
	unsigned int rxfris       : BFW_NX51_sqi_irq_raw_rxfris;       /* unmasked receive FIFO full interrupt state (for netx100/500 compliance)                     */
	                                                               /* 1: receive FIFO is full                                                                     */
	                                                               /* 0: receive FIFO is not full                                                                 */
	unsigned int txeris       : BFW_NX51_sqi_irq_raw_txeris;       /* unmasked transmit FIFO empty interrupt state (for netx100/500 compliance)                   */
	                                                               /* 1: transmit FIFO is empty                                                                   */
	                                                               /* 0: transmit FIFO is not empty                                                               */
	unsigned int trans_end    : BFW_NX51_sqi_irq_raw_trans_end;    /* unmasked transfer end interrupt state (related to Bit 'busy' of 'sqi_sr' register)          */
	                                                               /* 1: transfer finished. Bit 'busy' of 'sqi_sr' register has become inactive.                  */
	                                                               /* 0: transfer finished not finished. Bit 'busy' of 'sqi_sr' register is active.               */
	unsigned int sqirom_error : BFW_NX51_sqi_irq_raw_sqirom_error; /* SQIROM error interrupt state                                                                */
	                                                               /* 1: SQIROM access error detected.                                                            */
	                                                               /*    This IRQ is asserted when an error occurs on a SQIROM access. Detailed error information */
	                                                               /*    is provided by SQIROM error bit in register 'sqi_sr'.                                    */
	                                                               /*    For error handling both, this IRQ bit and bits in register 'sqi_sr' must be cleared.     */
	                                                               /* 0: no SQIROM error detected.                                                                */
	unsigned int reserved1    : BFW_NX51_sqi_irq_raw_reserved1;    /* reserved                                                                                    */
} NX51_SQI_IRQ_RAW_BIT_T;

typedef union {
	unsigned int           val;
	NX51_SQI_IRQ_RAW_BIT_T bf;
} NX51_SQI_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_masked */
/* => SQI masked interrupt status register */
/*    For detailed IRQ behavior and function view 'sqi_irq_raw' register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_irq_masked 0x0000001CU
#define Adr_NX51_sqi_sqi_irq_masked 0x1018C5DCU
#define Adr_NX51_sqi_irq_masked     0x1018C5DCU

#define MSK_NX51_sqi_irq_masked_RORMIS       0x00000001U
#define SRT_NX51_sqi_irq_masked_RORMIS       0
#define MSK_NX51_sqi_irq_masked_RTMIS        0x00000002U
#define SRT_NX51_sqi_irq_masked_RTMIS        1
#define MSK_NX51_sqi_irq_masked_RXMIS        0x00000004U
#define SRT_NX51_sqi_irq_masked_RXMIS        2
#define MSK_NX51_sqi_irq_masked_TXMIS        0x00000008U
#define SRT_NX51_sqi_irq_masked_TXMIS        3
#define MSK_NX51_sqi_irq_masked_rxnemis      0x00000010U
#define SRT_NX51_sqi_irq_masked_rxnemis      4
#define MSK_NX51_sqi_irq_masked_rxfmis       0x00000020U
#define SRT_NX51_sqi_irq_masked_rxfmis       5
#define MSK_NX51_sqi_irq_masked_txemis       0x00000040U
#define SRT_NX51_sqi_irq_masked_txemis       6
#define MSK_NX51_sqi_irq_masked_trans_end    0x00000080U
#define SRT_NX51_sqi_irq_masked_trans_end    7
#define MSK_NX51_sqi_irq_masked_sqirom_error 0x00000100U
#define SRT_NX51_sqi_irq_masked_sqirom_error 8

/* all used bits of 'NX51_sqi_irq_masked': */
#define MSK_USED_BITS_NX51_sqi_irq_masked 0x000001ffU

enum {
	BFW_NX51_sqi_irq_masked_RORMIS       = 1,  /* [0] */
	BFW_NX51_sqi_irq_masked_RTMIS        = 1,  /* [1] */
	BFW_NX51_sqi_irq_masked_RXMIS        = 1,  /* [2] */
	BFW_NX51_sqi_irq_masked_TXMIS        = 1,  /* [3] */
	BFW_NX51_sqi_irq_masked_rxnemis      = 1,  /* [4] */
	BFW_NX51_sqi_irq_masked_rxfmis       = 1,  /* [5] */
	BFW_NX51_sqi_irq_masked_txemis       = 1,  /* [6] */
	BFW_NX51_sqi_irq_masked_trans_end    = 1,  /* [7] */
	BFW_NX51_sqi_irq_masked_sqirom_error = 1,  /* [8] */
	BFW_NX51_sqi_irq_masked_reserved1    = 23  /* [31:9] */
};

typedef struct NX51_SQI_IRQ_MASKED_BIT_Ttag {
	unsigned int RORMIS       : BFW_NX51_sqi_irq_masked_RORMIS;       /* masked receive FIFO overrun interrupt state                                */
	unsigned int RTMIS        : BFW_NX51_sqi_irq_masked_RTMIS;        /* masked receive timeout interrupt state                                     */
	unsigned int RXMIS        : BFW_NX51_sqi_irq_masked_RXMIS;        /* masked receive FIFO interrupt state                                        */
	unsigned int TXMIS        : BFW_NX51_sqi_irq_masked_TXMIS;        /* masked transmit FIFO interrupt state                                       */
	unsigned int rxnemis      : BFW_NX51_sqi_irq_masked_rxnemis;      /* masked receive FIFO not empty interrupt state (for netx100/500 compliance) */
	unsigned int rxfmis       : BFW_NX51_sqi_irq_masked_rxfmis;       /* masked receive FIFO full interrupt state (for netx100/500 compliance)      */
	unsigned int txemis       : BFW_NX51_sqi_irq_masked_txemis;       /* masked transmit FIFO empty interrupt state (for netx100/500 compliance)    */
	unsigned int trans_end    : BFW_NX51_sqi_irq_masked_trans_end;    /* masked transfer end interrupt state                                        */
	unsigned int sqirom_error : BFW_NX51_sqi_irq_masked_sqirom_error; /* masked SQIROM error interrupt state                                        */
	unsigned int reserved1    : BFW_NX51_sqi_irq_masked_reserved1;    /* reserved                                                                   */
} NX51_SQI_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int              val;
	NX51_SQI_IRQ_MASKED_BIT_T bf;
} NX51_SQI_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_clear */
/* => SQI interrupt clear register (for compatibility to netX10/50 SPI module). */
/*    This register is always '0' on read. */
/*    Note: */
/*       IRQ flags can also be cleared by writing 'sqi_irq_raw' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_irq_clear  0x00000020U
#define Adr_NX51_sqi_sqi_irq_clear  0x1018C5E0U
#define Adr_NX51_sqi_irq_clear      0x1018C5E0U
#define DFLT_VAL_NX51_sqi_irq_clear 0x00000000U

#define MSK_NX51_sqi_irq_clear_RORIC                0x00000001U
#define SRT_NX51_sqi_irq_clear_RORIC                0
#define DFLT_VAL_NX51_sqi_irq_clear_RORIC           0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_RORIC        0x00000000U
#define MSK_NX51_sqi_irq_clear_RTIC                 0x00000002U
#define SRT_NX51_sqi_irq_clear_RTIC                 1
#define DFLT_VAL_NX51_sqi_irq_clear_RTIC            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_RTIC         0x00000000U
#define MSK_NX51_sqi_irq_clear_RXIC                 0x00000004U
#define SRT_NX51_sqi_irq_clear_RXIC                 2
#define DFLT_VAL_NX51_sqi_irq_clear_RXIC            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_RXIC         0x00000000U
#define MSK_NX51_sqi_irq_clear_TXIC                 0x00000008U
#define SRT_NX51_sqi_irq_clear_TXIC                 3
#define DFLT_VAL_NX51_sqi_irq_clear_TXIC            0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_TXIC         0x00000000U
#define MSK_NX51_sqi_irq_clear_rxneic               0x00000010U
#define SRT_NX51_sqi_irq_clear_rxneic               4
#define DFLT_VAL_NX51_sqi_irq_clear_rxneic          0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_rxneic       0x00000000U
#define MSK_NX51_sqi_irq_clear_rxfic                0x00000020U
#define SRT_NX51_sqi_irq_clear_rxfic                5
#define DFLT_VAL_NX51_sqi_irq_clear_rxfic           0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_rxfic        0x00000000U
#define MSK_NX51_sqi_irq_clear_txeic                0x00000040U
#define SRT_NX51_sqi_irq_clear_txeic                6
#define DFLT_VAL_NX51_sqi_irq_clear_txeic           0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_txeic        0x00000000U
#define MSK_NX51_sqi_irq_clear_trans_end            0x00000080U
#define SRT_NX51_sqi_irq_clear_trans_end            7
#define DFLT_VAL_NX51_sqi_irq_clear_trans_end       0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_trans_end    0x00000000U
#define MSK_NX51_sqi_irq_clear_sqirom_error         0x00000100U
#define SRT_NX51_sqi_irq_clear_sqirom_error         8
#define DFLT_VAL_NX51_sqi_irq_clear_sqirom_error    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_clear_sqirom_error 0x00000000U

/* all used bits of 'NX51_sqi_irq_clear': */
#define MSK_USED_BITS_NX51_sqi_irq_clear 0x000001ffU

enum {
	BFW_NX51_sqi_irq_clear_RORIC        = 1,  /* [0] */
	BFW_NX51_sqi_irq_clear_RTIC         = 1,  /* [1] */
	BFW_NX51_sqi_irq_clear_RXIC         = 1,  /* [2] */
	BFW_NX51_sqi_irq_clear_TXIC         = 1,  /* [3] */
	BFW_NX51_sqi_irq_clear_rxneic       = 1,  /* [4] */
	BFW_NX51_sqi_irq_clear_rxfic        = 1,  /* [5] */
	BFW_NX51_sqi_irq_clear_txeic        = 1,  /* [6] */
	BFW_NX51_sqi_irq_clear_trans_end    = 1,  /* [7] */
	BFW_NX51_sqi_irq_clear_sqirom_error = 1,  /* [8] */
	BFW_NX51_sqi_irq_clear_reserved1    = 23  /* [31:9] */
};

typedef struct NX51_SQI_IRQ_CLEAR_BIT_Ttag {
	unsigned int RORIC        : BFW_NX51_sqi_irq_clear_RORIC;        /* clear receive FIFO overrun interrupt                                */
	                                                                 /* writing '1' here will clear the receive FIFO                        */
	unsigned int RTIC         : BFW_NX51_sqi_irq_clear_RTIC;         /* clear receive FIFO overrun interrupt                                */
	unsigned int RXIC         : BFW_NX51_sqi_irq_clear_RXIC;         /* PL022 extension: clear receive FIFO interrupt                       */
	unsigned int TXIC         : BFW_NX51_sqi_irq_clear_TXIC;         /* PL022 extension: clear transmit FIFO interrupt                      */
	unsigned int rxneic       : BFW_NX51_sqi_irq_clear_rxneic;       /* clear receive FIFO not empty interrupt (for netx100/500 compliance) */
	unsigned int rxfic        : BFW_NX51_sqi_irq_clear_rxfic;        /* clear receive FIFO full interrupt (for netx100/500 compliance)      */
	unsigned int txeic        : BFW_NX51_sqi_irq_clear_txeic;        /* clear transmit FIFO empty interrupt (for netx100/500 compliance)    */
	unsigned int trans_end    : BFW_NX51_sqi_irq_clear_trans_end;    /* clear transfer end interrupt                                        */
	unsigned int sqirom_error : BFW_NX51_sqi_irq_clear_sqirom_error; /* clear SQIROM error interrupt                                        */
	unsigned int reserved1    : BFW_NX51_sqi_irq_clear_reserved1;    /* reserved                                                            */
} NX51_SQI_IRQ_CLEAR_BIT_T;

typedef union {
	unsigned int             val;
	NX51_SQI_IRQ_CLEAR_BIT_T bf;
} NX51_SQI_IRQ_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_irq_cpu_sel */
/* => SQI interrupt CPU select register */
/*    Select CPU (xPIC or ARM), which gets Interrupts from this SQI instance. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_irq_cpu_sel  0x00000024U
#define Adr_NX51_sqi_sqi_irq_cpu_sel  0x1018C5E4U
#define Adr_NX51_sqi_irq_cpu_sel      0x1018C5E4U
#define DFLT_VAL_NX51_sqi_irq_cpu_sel 0x00000001U

#define MSK_NX51_sqi_irq_cpu_sel_arm          0x00000001U
#define SRT_NX51_sqi_irq_cpu_sel_arm          0
#define DFLT_VAL_NX51_sqi_irq_cpu_sel_arm     0x00000001U
#define DFLT_BF_VAL_NX51_sqi_irq_cpu_sel_arm  0x00000001U
#define MSK_NX51_sqi_irq_cpu_sel_xpic         0x00000002U
#define SRT_NX51_sqi_irq_cpu_sel_xpic         1
#define DFLT_VAL_NX51_sqi_irq_cpu_sel_xpic    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_irq_cpu_sel_xpic 0x00000000U

/* all used bits of 'NX51_sqi_irq_cpu_sel': */
#define MSK_USED_BITS_NX51_sqi_irq_cpu_sel 0x00000003U

enum {
	BFW_NX51_sqi_irq_cpu_sel_arm       = 1,  /* [0] */
	BFW_NX51_sqi_irq_cpu_sel_xpic      = 1,  /* [1] */
	BFW_NX51_sqi_irq_cpu_sel_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_SQI_IRQ_CPU_SEL_BIT_Ttag {
	unsigned int arm       : BFW_NX51_sqi_irq_cpu_sel_arm;       /* Enable for IRQ signal to ARM  */
	unsigned int xpic      : BFW_NX51_sqi_irq_cpu_sel_xpic;      /* Enable for IRQ signal to xPIC */
	unsigned int reserved1 : BFW_NX51_sqi_irq_cpu_sel_reserved1; /* reserved                      */
} NX51_SQI_IRQ_CPU_SEL_BIT_T;

typedef union {
	unsigned int               val;
	NX51_SQI_IRQ_CPU_SEL_BIT_T bf;
} NX51_SQI_IRQ_CPU_SEL_T;

/* --------------------------------------------------------------------- */
/* Register sqi_dmacr */
/* => SQI DMA control register */
/*    Only single transfer requests will be generated by this module. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_dmacr  0x00000028U
#define Adr_NX51_sqi_sqi_dmacr  0x1018C5E8U
#define Adr_NX51_sqi_dmacr      0x1018C5E8U
#define DFLT_VAL_NX51_sqi_dmacr 0x00000000U

#define MSK_NX51_sqi_dmacr_rx_dma_en         0x00000001U
#define SRT_NX51_sqi_dmacr_rx_dma_en         0
#define DFLT_VAL_NX51_sqi_dmacr_rx_dma_en    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_dmacr_rx_dma_en 0x00000000U
#define MSK_NX51_sqi_dmacr_tx_dma_en         0x00000002U
#define SRT_NX51_sqi_dmacr_tx_dma_en         1
#define DFLT_VAL_NX51_sqi_dmacr_tx_dma_en    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_dmacr_tx_dma_en 0x00000000U

/* all used bits of 'NX51_sqi_dmacr': */
#define MSK_USED_BITS_NX51_sqi_dmacr 0x00000003U

enum {
	BFW_NX51_sqi_dmacr_rx_dma_en = 1,  /* [0] */
	BFW_NX51_sqi_dmacr_tx_dma_en = 1,  /* [1] */
	BFW_NX51_sqi_dmacr_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_SQI_DMACR_BIT_Ttag {
	unsigned int rx_dma_en : BFW_NX51_sqi_dmacr_rx_dma_en; /* Enable DMA for SQI-receive data                                                                                  */
	                                                       /* A request will be generated if RX-FIFO is not empty and sqi_cr1.SSE (module enable) is set.                      */
	                                                       /* Burst request to DMA-Ctrl will be done if the RX-FIFO contains at least 4 words (set DMA-burst-size to 4)        */
	                                                       /* If this bit is reset or the module is disabled, DMA-request will also be reset.                                  */
	                                                       /* note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module                                      */
	unsigned int tx_dma_en : BFW_NX51_sqi_dmacr_tx_dma_en; /* enable DMA for SQI-transmit data                                                                                 */
	                                                       /* A request will be generated if TX-FIFO is not full and sqi_cr1.SSE (module enable) is set.                       */
	                                                       /* Burst request to DMA-Ctrl will be done if at least 4 words are writable to the TX-FIFO (set DMA-burst-size to 4) */
	                                                       /* If this bit is reset or the module is disabled, DMA-request will also be reset.                                  */
	                                                       /* note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module                                      */
	unsigned int reserved1 : BFW_NX51_sqi_dmacr_reserved1; /* reserved                                                                                                         */
} NX51_SQI_DMACR_BIT_T;

typedef union {
	unsigned int         val;
	NX51_SQI_DMACR_BIT_T bf;
} NX51_SQI_DMACR_T;

/* --------------------------------------------------------------------- */
/* Register sqi_pio_out */
/* => SQI PIO output level control register */
/*    IO PIO mode is controlable by 'sqi_cr0' register bits 'sio_cfg'. */
/*    PIO input signal states are never filtered ('sqi_cr0' bit 'filter_in') */
/*    Note: */
/*       SQI module must be enabled by register 'sqi_cr0' bit 'sqi_en' for SQI IOs driving in PIO mode. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_pio_out  0x00000030U
#define Adr_NX51_sqi_sqi_pio_out  0x1018C5F0U
#define Adr_NX51_sqi_pio_out      0x1018C5F0U
#define DFLT_VAL_NX51_sqi_pio_out 0x0000000eU

#define MSK_NX51_sqi_pio_out_sclk         0x00000001U
#define SRT_NX51_sqi_pio_out_sclk         0
#define DFLT_VAL_NX51_sqi_pio_out_sclk    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_out_sclk 0x00000000U
#define MSK_NX51_sqi_pio_out_csn          0x0000000eU
#define SRT_NX51_sqi_pio_out_csn          1
#define DFLT_VAL_NX51_sqi_pio_out_csn     0x0000000eU
#define DFLT_BF_VAL_NX51_sqi_pio_out_csn  0x00000007U
#define MSK_NX51_sqi_pio_out_mosi         0x00000010U
#define SRT_NX51_sqi_pio_out_mosi         4
#define DFLT_VAL_NX51_sqi_pio_out_mosi    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_out_mosi 0x00000000U
#define MSK_NX51_sqi_pio_out_miso         0x00000020U
#define SRT_NX51_sqi_pio_out_miso         5
#define DFLT_VAL_NX51_sqi_pio_out_miso    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_out_miso 0x00000000U
#define MSK_NX51_sqi_pio_out_sio2         0x00000040U
#define SRT_NX51_sqi_pio_out_sio2         6
#define DFLT_VAL_NX51_sqi_pio_out_sio2    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_out_sio2 0x00000000U
#define MSK_NX51_sqi_pio_out_sio3         0x00000080U
#define SRT_NX51_sqi_pio_out_sio3         7
#define DFLT_VAL_NX51_sqi_pio_out_sio3    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_out_sio3 0x00000000U

/* all used bits of 'NX51_sqi_pio_out': */
#define MSK_USED_BITS_NX51_sqi_pio_out 0x000000ffU

enum {
	BFW_NX51_sqi_pio_out_sclk      = 1,  /* [0] */
	BFW_NX51_sqi_pio_out_csn       = 3,  /* [3:1] */
	BFW_NX51_sqi_pio_out_mosi      = 1,  /* [4] */
	BFW_NX51_sqi_pio_out_miso      = 1,  /* [5] */
	BFW_NX51_sqi_pio_out_sio2      = 1,  /* [6] */
	BFW_NX51_sqi_pio_out_sio3      = 1,  /* [7] */
	BFW_NX51_sqi_pio_out_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_SQI_PIO_OUT_BIT_Ttag {
	unsigned int sclk      : BFW_NX51_sqi_pio_out_sclk;      /* Serial SPI Clock output state.               */
	unsigned int csn       : BFW_NX51_sqi_pio_out_csn;       /* Chip-select/FSS output state {CS2, CS1, CS0} */
	unsigned int mosi      : BFW_NX51_sqi_pio_out_mosi;      /* MOSI/SIO0 output state                       */
	unsigned int miso      : BFW_NX51_sqi_pio_out_miso;      /* MISO/SIO1 output state                       */
	unsigned int sio2      : BFW_NX51_sqi_pio_out_sio2;      /* SIO2 output state                            */
	unsigned int sio3      : BFW_NX51_sqi_pio_out_sio3;      /* SIO3 output state                            */
	unsigned int reserved1 : BFW_NX51_sqi_pio_out_reserved1; /* reserved                                     */
} NX51_SQI_PIO_OUT_BIT_T;

typedef union {
	unsigned int           val;
	NX51_SQI_PIO_OUT_BIT_T bf;
} NX51_SQI_PIO_OUT_T;

/* --------------------------------------------------------------------- */
/* Register sqi_pio_oe */
/* => SQI PIO output enable control register */
/*    IO PIO mode is controlable by 'sqi_cr0' register bits 'sio_cfg'. */
/*    Note: */
/*       SQI module must be enabled by register 'sqi_cr0' bit 'sqi_en' for SQI IOs driving in PIO mode. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_pio_oe  0x00000034U
#define Adr_NX51_sqi_sqi_pio_oe  0x1018C5F4U
#define Adr_NX51_sqi_pio_oe      0x1018C5F4U
#define DFLT_VAL_NX51_sqi_pio_oe 0x00000000U

#define MSK_NX51_sqi_pio_oe_sclk         0x00000001U
#define SRT_NX51_sqi_pio_oe_sclk         0
#define DFLT_VAL_NX51_sqi_pio_oe_sclk    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_oe_sclk 0x00000000U
#define MSK_NX51_sqi_pio_oe_csn          0x0000000eU
#define SRT_NX51_sqi_pio_oe_csn          1
#define DFLT_VAL_NX51_sqi_pio_oe_csn     0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_oe_csn  0x00000000U
#define MSK_NX51_sqi_pio_oe_mosi         0x00000010U
#define SRT_NX51_sqi_pio_oe_mosi         4
#define DFLT_VAL_NX51_sqi_pio_oe_mosi    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_oe_mosi 0x00000000U
#define MSK_NX51_sqi_pio_oe_miso         0x00000020U
#define SRT_NX51_sqi_pio_oe_miso         5
#define DFLT_VAL_NX51_sqi_pio_oe_miso    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_oe_miso 0x00000000U
#define MSK_NX51_sqi_pio_oe_sio2         0x00000040U
#define SRT_NX51_sqi_pio_oe_sio2         6
#define DFLT_VAL_NX51_sqi_pio_oe_sio2    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_oe_sio2 0x00000000U
#define MSK_NX51_sqi_pio_oe_sio3         0x00000080U
#define SRT_NX51_sqi_pio_oe_sio3         7
#define DFLT_VAL_NX51_sqi_pio_oe_sio3    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_pio_oe_sio3 0x00000000U

/* all used bits of 'NX51_sqi_pio_oe': */
#define MSK_USED_BITS_NX51_sqi_pio_oe 0x000000ffU

enum {
	BFW_NX51_sqi_pio_oe_sclk      = 1,  /* [0] */
	BFW_NX51_sqi_pio_oe_csn       = 3,  /* [3:1] */
	BFW_NX51_sqi_pio_oe_mosi      = 1,  /* [4] */
	BFW_NX51_sqi_pio_oe_miso      = 1,  /* [5] */
	BFW_NX51_sqi_pio_oe_sio2      = 1,  /* [6] */
	BFW_NX51_sqi_pio_oe_sio3      = 1,  /* [7] */
	BFW_NX51_sqi_pio_oe_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_SQI_PIO_OE_BIT_Ttag {
	unsigned int sclk      : BFW_NX51_sqi_pio_oe_sclk;      /* Serial SPI Clock output enable                */
	unsigned int csn       : BFW_NX51_sqi_pio_oe_csn;       /* Chip-select/FSS output enable {CS2, CS1, CS0} */
	unsigned int mosi      : BFW_NX51_sqi_pio_oe_mosi;      /* MOSI/SIO0 output enable                       */
	unsigned int miso      : BFW_NX51_sqi_pio_oe_miso;      /* MISO/SIO1 output enable                       */
	unsigned int sio2      : BFW_NX51_sqi_pio_oe_sio2;      /* SIO2 output enable                            */
	unsigned int sio3      : BFW_NX51_sqi_pio_oe_sio3;      /* SIO3 output enable                            */
	unsigned int reserved1 : BFW_NX51_sqi_pio_oe_reserved1; /* reserved                                      */
} NX51_SQI_PIO_OE_BIT_T;

typedef union {
	unsigned int          val;
	NX51_SQI_PIO_OE_BIT_T bf;
} NX51_SQI_PIO_OE_T;

/* --------------------------------------------------------------------- */
/* Register sqi_pio_in */
/* => SQI PIO input status register */
/*    IO PIO mode is controllable by 'sqi_cr0' register bits 'sio_cfg'. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_pio_in 0x00000038U
#define Adr_NX51_sqi_sqi_pio_in 0x1018C5F8U
#define Adr_NX51_sqi_pio_in     0x1018C5F8U

#define MSK_NX51_sqi_pio_in_sclk 0x00000001U
#define SRT_NX51_sqi_pio_in_sclk 0
#define MSK_NX51_sqi_pio_in_csn  0x0000000eU
#define SRT_NX51_sqi_pio_in_csn  1
#define MSK_NX51_sqi_pio_in_mosi 0x00000010U
#define SRT_NX51_sqi_pio_in_mosi 4
#define MSK_NX51_sqi_pio_in_miso 0x00000020U
#define SRT_NX51_sqi_pio_in_miso 5
#define MSK_NX51_sqi_pio_in_sio2 0x00000040U
#define SRT_NX51_sqi_pio_in_sio2 6
#define MSK_NX51_sqi_pio_in_sio3 0x00000080U
#define SRT_NX51_sqi_pio_in_sio3 7

/* all used bits of 'NX51_sqi_pio_in': */
#define MSK_USED_BITS_NX51_sqi_pio_in 0x000000ffU

enum {
	BFW_NX51_sqi_pio_in_sclk      = 1,  /* [0] */
	BFW_NX51_sqi_pio_in_csn       = 3,  /* [3:1] */
	BFW_NX51_sqi_pio_in_mosi      = 1,  /* [4] */
	BFW_NX51_sqi_pio_in_miso      = 1,  /* [5] */
	BFW_NX51_sqi_pio_in_sio2      = 1,  /* [6] */
	BFW_NX51_sqi_pio_in_sio3      = 1,  /* [7] */
	BFW_NX51_sqi_pio_in_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_SQI_PIO_IN_BIT_Ttag {
	unsigned int sclk      : BFW_NX51_sqi_pio_in_sclk;      /* Serial SPI Clock input state                 */
	unsigned int csn       : BFW_NX51_sqi_pio_in_csn;       /* Chip-select/FSS  input state {CS2, CS1, CS0} */
	unsigned int mosi      : BFW_NX51_sqi_pio_in_mosi;      /* MOSI/SIO0 input state                        */
	unsigned int miso      : BFW_NX51_sqi_pio_in_miso;      /* MISO/SIO1 input state                        */
	unsigned int sio2      : BFW_NX51_sqi_pio_in_sio2;      /* SIO2 input state                             */
	unsigned int sio3      : BFW_NX51_sqi_pio_in_sio3;      /* SIO3 input state                             */
	unsigned int reserved1 : BFW_NX51_sqi_pio_in_reserved1; /* reserved                                     */
} NX51_SQI_PIO_IN_BIT_T;

typedef union {
	unsigned int          val;
	NX51_SQI_PIO_IN_BIT_T bf;
} NX51_SQI_PIO_IN_T;

/* --------------------------------------------------------------------- */
/* Register sqi_sqirom_cfg */
/* => SQIROM mode configuration */
/*    Configuration register for the SQIROM mode. */
/*    This mode supports the 'eXecute in Place' (XiP) feature of SQI flash chips. The position of the command byte and the address nibbles as well as */
/*    the the number of address nibbles and dummy cycles can be configured with this register. It is also possible to change the clock divider */
/*    to support a wide range of frequencies for the serial clock output. */
/*    Note: Before enabling this mode, the SQI flash chip needs to be in 4 bit command mode, otherwise the module is not able to fetch data */
/*          from the flash. */
/*    Note: When enabled, the SQI module is completely blocked, e.g. other SQI or SPI transactions are not possible. */
/*    Note: The chip select signal of the flash must be connected to sqi_cs0. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sqi_sqirom_cfg  0x0000003CU
#define Adr_NX51_sqi_sqi_sqirom_cfg  0x1018C5FCU
#define Adr_NX51_sqi_sqirom_cfg      0x1018C5FCU
#define DFLT_VAL_NX51_sqi_sqirom_cfg 0x02020004U

#define MSK_NX51_sqi_sqirom_cfg_enable                  0x00000001U
#define SRT_NX51_sqi_sqirom_cfg_enable                  0
#define DFLT_VAL_NX51_sqi_sqirom_cfg_enable             0x00000000U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_enable          0x00000000U
#define MSK_NX51_sqi_sqirom_cfg_addr_before_cmd         0x00000002U
#define SRT_NX51_sqi_sqirom_cfg_addr_before_cmd         1
#define DFLT_VAL_NX51_sqi_sqirom_cfg_addr_before_cmd    0x00000000U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_addr_before_cmd 0x00000000U
#define MSK_NX51_sqi_sqirom_cfg_addr_nibbles            0x0000000cU
#define SRT_NX51_sqi_sqirom_cfg_addr_nibbles            2
#define DFLT_VAL_NX51_sqi_sqirom_cfg_addr_nibbles       0x00000004U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_addr_nibbles    0x00000001U
#define MSK_NX51_sqi_sqirom_cfg_addr_bits               0x00000070U
#define SRT_NX51_sqi_sqirom_cfg_addr_bits               4
#define DFLT_VAL_NX51_sqi_sqirom_cfg_addr_bits          0x00000000U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_addr_bits       0x00000000U
#define MSK_NX51_sqi_sqirom_cfg_cmd_byte                0x0000ff00U
#define SRT_NX51_sqi_sqirom_cfg_cmd_byte                8
#define DFLT_VAL_NX51_sqi_sqirom_cfg_cmd_byte           0x00000000U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_cmd_byte        0x00000000U
#define MSK_NX51_sqi_sqirom_cfg_dummy_cycles            0x00070000U
#define SRT_NX51_sqi_sqirom_cfg_dummy_cycles            16
#define DFLT_VAL_NX51_sqi_sqirom_cfg_dummy_cycles       0x00020000U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_dummy_cycles    0x00000002U
#define MSK_NX51_sqi_sqirom_cfg_t_csh                   0x00300000U
#define SRT_NX51_sqi_sqirom_cfg_t_csh                   20
#define DFLT_VAL_NX51_sqi_sqirom_cfg_t_csh              0x00000000U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_t_csh           0x00000000U
#define MSK_NX51_sqi_sqirom_cfg_clk_div_val             0xff000000U
#define SRT_NX51_sqi_sqirom_cfg_clk_div_val             24
#define DFLT_VAL_NX51_sqi_sqirom_cfg_clk_div_val        0x02000000U
#define DFLT_BF_VAL_NX51_sqi_sqirom_cfg_clk_div_val     0x00000002U

/* all used bits of 'NX51_sqi_sqirom_cfg': */
#define MSK_USED_BITS_NX51_sqi_sqirom_cfg 0xff37ff7fU

enum {
	BFW_NX51_sqi_sqirom_cfg_enable          = 1, /* [0] */
	BFW_NX51_sqi_sqirom_cfg_addr_before_cmd = 1, /* [1] */
	BFW_NX51_sqi_sqirom_cfg_addr_nibbles    = 2, /* [3:2] */
	BFW_NX51_sqi_sqirom_cfg_addr_bits       = 3, /* [6:4] */
	BFW_NX51_sqi_sqirom_cfg_reserved1       = 1, /* [7] */
	BFW_NX51_sqi_sqirom_cfg_cmd_byte        = 8, /* [15:8] */
	BFW_NX51_sqi_sqirom_cfg_dummy_cycles    = 3, /* [18:16] */
	BFW_NX51_sqi_sqirom_cfg_reserved2       = 1, /* [19] */
	BFW_NX51_sqi_sqirom_cfg_t_csh           = 2, /* [21:20] */
	BFW_NX51_sqi_sqirom_cfg_reserved3       = 2, /* [23:22] */
	BFW_NX51_sqi_sqirom_cfg_clk_div_val     = 8  /* [31:24] */
};

typedef struct NX51_SQI_SQIROM_CFG_BIT_Ttag {
	unsigned int enable          : BFW_NX51_sqi_sqirom_cfg_enable;          /* Enables the SQIROM mode of the SQI module. The SQI chip needs to be initialized to                                 */
	                                                                        /* accept 4 bit read-command before activating the SQIROM mode.                                                       */
	                                                                        /* Note:                                                                                                              */
	                                                                        /*    This bit is also used to switch between SQIROM/XiP and standard SQI/SPI function.                               */
	                                                                        /*    If this bit is set, standard SQI/SPI function is not available. SQIROM/XiP function                             */
	                                                                        /*    does not depend on programmed value of 'sqi_en' bit in 'sqi_cr1' register.                                      */
	                                                                        /*    If Multiplexmatrix provides SQI functionality, this is only available in                                        */
	                                                                        /*    standard SQI/SPI but not for SQIROM/XiP usage. SQIROM/XiP function is only                                      */
	                                                                        /*    provided on dedicated non-Multiplexmatrix SQI IOs but not as Multiplexmatrix function                           */
	                                                                        /*    even if standard SQI is provided there.                                                                         */
	unsigned int addr_before_cmd : BFW_NX51_sqi_sqirom_cfg_addr_before_cmd; /* When set to '1' the address nibbles will be transferred before the command byte.                                   */
	                                                                        /* Otherwise the address is transferred first.                                                                        */
	unsigned int addr_nibbles    : BFW_NX51_sqi_sqirom_cfg_addr_nibbles;    /* Number of nibbles to transfer as the address to the SQI chip.                                                      */
	                                                                        /* This depends on the command format of the SQI chip.                                                                */
	                                                                        /* The address-command order can be controlled by the 'addr_before_cmd' bit.                                          */
	                                                                        /* Most significant address bits will be transmitted in the first address nibble.                                     */
	                                                                        /* Least significant address bits will be transmitted in the last address nibble.                                     */
	                                                                        /* 00 : 5 nibbles                                                                                                     */
	                                                                        /* 01 : 6 nibbles (default)                                                                                           */
	                                                                        /* 10 : 7 nibbles                                                                                                     */
	                                                                        /* 11 : 8 nibbles                                                                                                     */
	unsigned int addr_bits       : BFW_NX51_sqi_sqirom_cfg_addr_bits;       /* Number of address bits used to generate the address for the SQI chip. This depends                                 */
	                                                                        /* on the size of the SQI chip.                                                                                       */
	                                                                        /* 000 : 20 bits (1MByte/8MBit device) (default)                                                                      */
	                                                                        /* 001 : 21 bits (2MByte/16MBit device)                                                                               */
	                                                                        /* 010 : 22 bits (4MByte/32MBit device)                                                                               */
	                                                                        /* 011 : 23 bits (8MByte/64MBit device)                                                                               */
	                                                                        /* 100 : 24 bits (16MByte/128MBit device)                                                                             */
	                                                                        /* 101 - 111 : reserved                                                                                               */
	unsigned int reserved1       : BFW_NX51_sqi_sqirom_cfg_reserved1;       /* reserved                                                                                                           */
	unsigned int cmd_byte        : BFW_NX51_sqi_sqirom_cfg_cmd_byte;        /* This byte is transferred to the SQI chip as the command sequence.                                                  */
	                                                                        /* The address-command order can be controlled by the 'addr_before_cmd' bit.                                          */
	unsigned int dummy_cycles    : BFW_NX51_sqi_sqirom_cfg_dummy_cycles;    /* Selects the number of dummy cycles before data will be sampled from the SQI chip.                                  */
	                                                                        /* 000 : 0 cycles                                                                                                     */
	                                                                        /* 001 : 1 cycle                                                                                                      */
	                                                                        /* 010 : 2 cycles (default)                                                                                           */
	                                                                        /* ...                                                                                                                */
	                                                                        /* 111 : 7 cycles                                                                                                     */
	unsigned int reserved2       : BFW_NX51_sqi_sqirom_cfg_reserved2;       /* reserved                                                                                                           */
	unsigned int t_csh           : BFW_NX51_sqi_sqirom_cfg_t_csh;           /* Minimum SQI Chips-select-high (idle) time: (t_csh+1) * t_sck (according to clk_div_val).                           */
	                                                                        /* Programmable values are 0 to 3.                                                                                    */
	                                                                        /* Change this parameter if used SQI device requires minimum Chips-select-high times                                  */
	                                                                        /* exceeding 1 serial clock period. Required timing must be taken from used SQI device datasheet.                     */
	                                                                        /* Note:                                                                                                              */
	                                                                        /*    Serial clock will not toggle when device is not selected. Hence only Chip-select-active                         */
	                                                                        /*    timing has to be considered.                                                                                    */
	unsigned int reserved3       : BFW_NX51_sqi_sqirom_cfg_reserved3;       /* reserved                                                                                                           */
	unsigned int clk_div_val     : BFW_NX51_sqi_sqirom_cfg_clk_div_val;     /* clk400 will be divided by (clk_div_val+3) for sqirom_clk generation                                                */
	                                                                        /* Default setting '2' is 80MHz. Maximum serial clock rate (programming '0') is 133MHz.                               */
	                                                                        /* Serial clock period (t_sck) will be (clk_div_val+3)*2.5ns. Clock high and low Phase will be generated symmetrical. */
} NX51_SQI_SQIROM_CFG_BIT_T;

typedef union {
	unsigned int              val;
	NX51_SQI_SQIROM_CFG_BIT_T bf;
} NX51_SQI_SQIROM_CFG_T;


/* ===================================================================== */

/* AREA uart */
/* Area of uart0, uart1, uart2 */

/* ===================================================================== */

#define Addr_NX51_uart0      0x1018C600U
#define NX51_NETX_UART0_AREA 0x1018C600U
#define Addr_NX51_uart1      0x1018C640U
#define NX51_NETX_UART1_AREA 0x1018C640U
#define Addr_NX51_uart2      0x1018C680U
#define NX51_NETX_UART2_AREA 0x1018C680U

/* --------------------------------------------------------------------- */
/* Register uartdr */
/* => data read or written from the interface */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartdr   0x00000000U
#define Adr_NX51_uart0_uartdr 0x1018C600U
#define Adr_NX51_uart1_uartdr 0x1018C640U
#define Adr_NX51_uart2_uartdr 0x1018C680U
#define DFLT_VAL_NX51_uartdr  0x00000000U

#define MSK_NX51_uartdr_DATA         0x000000ffU
#define SRT_NX51_uartdr_DATA         0
#define DFLT_VAL_NX51_uartdr_DATA    0x00000000U
#define DFLT_BF_VAL_NX51_uartdr_DATA 0x00000000U
#define MSK_NX51_uartdr_FE           0x00000100U
#define SRT_NX51_uartdr_FE           8
#define DFLT_VAL_NX51_uartdr_FE      0x00000000U
#define DFLT_BF_VAL_NX51_uartdr_FE   0x00000000U
#define MSK_NX51_uartdr_PE           0x00000200U
#define SRT_NX51_uartdr_PE           9
#define DFLT_VAL_NX51_uartdr_PE      0x00000000U
#define DFLT_BF_VAL_NX51_uartdr_PE   0x00000000U
#define MSK_NX51_uartdr_BE           0x00000400U
#define SRT_NX51_uartdr_BE           10
#define DFLT_VAL_NX51_uartdr_BE      0x00000000U
#define DFLT_BF_VAL_NX51_uartdr_BE   0x00000000U

/* all used bits of 'NX51_uartdr': */
#define MSK_USED_BITS_NX51_uartdr 0x000007ffU

enum {
	BFW_NX51_uartdr_DATA      = 8,  /* [7:0] */
	BFW_NX51_uartdr_FE        = 1,  /* [8] */
	BFW_NX51_uartdr_PE        = 1,  /* [9] */
	BFW_NX51_uartdr_BE        = 1,  /* [10] */
	BFW_NX51_uartdr_reserved1 = 21  /* [31:11] */
};

typedef struct NX51_UARTDR_BIT_Ttag {
	unsigned int DATA      : BFW_NX51_uartdr_DATA;      /* data read or written from the interface                                         */
	unsigned int FE        : BFW_NX51_uartdr_FE;        /* Framing Error, read only, mirrored from uartrsr, to handle in DMA-read-out data */
	unsigned int PE        : BFW_NX51_uartdr_PE;        /* Parity Error, read only, mirrored from uartrsr, to handle in DMA-read-out data  */
	unsigned int BE        : BFW_NX51_uartdr_BE;        /* Break Error, read only, mirrored from uartrsr, to handle in DMA-read-out data   */
	unsigned int reserved1 : BFW_NX51_uartdr_reserved1; /* reserved                                                                        */
} NX51_UARTDR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_UARTDR_BIT_T bf;
} NX51_UARTDR_T;

/* --------------------------------------------------------------------- */
/* Register uartrsr */
/* => receive status register (read) / Error Clear Register (write) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartrsr   0x00000004U
#define Adr_NX51_uart0_uartrsr 0x1018C604U
#define Adr_NX51_uart1_uartrsr 0x1018C644U
#define Adr_NX51_uart2_uartrsr 0x1018C684U
#define DFLT_VAL_NX51_uartrsr  0x00000000U

#define MSK_NX51_uartrsr_FE         0x00000001U
#define SRT_NX51_uartrsr_FE         0
#define DFLT_VAL_NX51_uartrsr_FE    0x00000000U
#define DFLT_BF_VAL_NX51_uartrsr_FE 0x00000000U
#define MSK_NX51_uartrsr_PE         0x00000002U
#define SRT_NX51_uartrsr_PE         1
#define DFLT_VAL_NX51_uartrsr_PE    0x00000000U
#define DFLT_BF_VAL_NX51_uartrsr_PE 0x00000000U
#define MSK_NX51_uartrsr_BE         0x00000004U
#define SRT_NX51_uartrsr_BE         2
#define DFLT_VAL_NX51_uartrsr_BE    0x00000000U
#define DFLT_BF_VAL_NX51_uartrsr_BE 0x00000000U
#define MSK_NX51_uartrsr_OE         0x00000008U
#define SRT_NX51_uartrsr_OE         3
#define DFLT_VAL_NX51_uartrsr_OE    0x00000000U
#define DFLT_BF_VAL_NX51_uartrsr_OE 0x00000000U

/* all used bits of 'NX51_uartrsr': */
#define MSK_USED_BITS_NX51_uartrsr 0x0000000fU

enum {
	BFW_NX51_uartrsr_FE        = 1,  /* [0] */
	BFW_NX51_uartrsr_PE        = 1,  /* [1] */
	BFW_NX51_uartrsr_BE        = 1,  /* [2] */
	BFW_NX51_uartrsr_OE        = 1,  /* [3] */
	BFW_NX51_uartrsr_reserved1 = 28  /* [31:4] */
};

typedef struct NX51_UARTRSR_BIT_Ttag {
	unsigned int FE        : BFW_NX51_uartrsr_FE;        /* Framing Error */
	unsigned int PE        : BFW_NX51_uartrsr_PE;        /* Parity Error  */
	unsigned int BE        : BFW_NX51_uartrsr_BE;        /* Break Error   */
	unsigned int OE        : BFW_NX51_uartrsr_OE;        /* Overrun Error */
	unsigned int reserved1 : BFW_NX51_uartrsr_reserved1; /* reserved      */
} NX51_UARTRSR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_UARTRSR_BIT_T bf;
} NX51_UARTRSR_T;

/* --------------------------------------------------------------------- */
/* Register uartlcr_h */
/* => Line control Register, high byte */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartlcr_h   0x00000008U
#define Adr_NX51_uart0_uartlcr_h 0x1018C608U
#define Adr_NX51_uart1_uartlcr_h 0x1018C648U
#define Adr_NX51_uart2_uartlcr_h 0x1018C688U
#define DFLT_VAL_NX51_uartlcr_h  0x00000000U

#define MSK_NX51_uartlcr_h_BRK          0x00000001U
#define SRT_NX51_uartlcr_h_BRK          0
#define DFLT_VAL_NX51_uartlcr_h_BRK     0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_h_BRK  0x00000000U
#define MSK_NX51_uartlcr_h_PEN          0x00000002U
#define SRT_NX51_uartlcr_h_PEN          1
#define DFLT_VAL_NX51_uartlcr_h_PEN     0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_h_PEN  0x00000000U
#define MSK_NX51_uartlcr_h_EPS          0x00000004U
#define SRT_NX51_uartlcr_h_EPS          2
#define DFLT_VAL_NX51_uartlcr_h_EPS     0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_h_EPS  0x00000000U
#define MSK_NX51_uartlcr_h_STP2         0x00000008U
#define SRT_NX51_uartlcr_h_STP2         3
#define DFLT_VAL_NX51_uartlcr_h_STP2    0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_h_STP2 0x00000000U
#define MSK_NX51_uartlcr_h_FEN          0x00000010U
#define SRT_NX51_uartlcr_h_FEN          4
#define DFLT_VAL_NX51_uartlcr_h_FEN     0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_h_FEN  0x00000000U
#define MSK_NX51_uartlcr_h_WLEN         0x00000060U
#define SRT_NX51_uartlcr_h_WLEN         5
#define DFLT_VAL_NX51_uartlcr_h_WLEN    0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_h_WLEN 0x00000000U

/* all used bits of 'NX51_uartlcr_h': */
#define MSK_USED_BITS_NX51_uartlcr_h 0x0000007fU

enum {
	BFW_NX51_uartlcr_h_BRK       = 1,  /* [0] */
	BFW_NX51_uartlcr_h_PEN       = 1,  /* [1] */
	BFW_NX51_uartlcr_h_EPS       = 1,  /* [2] */
	BFW_NX51_uartlcr_h_STP2      = 1,  /* [3] */
	BFW_NX51_uartlcr_h_FEN       = 1,  /* [4] */
	BFW_NX51_uartlcr_h_WLEN      = 2,  /* [6:5] */
	BFW_NX51_uartlcr_h_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_UARTLCR_H_BIT_Ttag {
	unsigned int BRK       : BFW_NX51_uartlcr_h_BRK;       /* Send Break         */
	unsigned int PEN       : BFW_NX51_uartlcr_h_PEN;       /* Parity Enalble     */
	unsigned int EPS       : BFW_NX51_uartlcr_h_EPS;       /* Even Parity Select */
	unsigned int STP2      : BFW_NX51_uartlcr_h_STP2;      /* 2 Stop Bits Select */
	unsigned int FEN       : BFW_NX51_uartlcr_h_FEN;       /* FIFO Enable        */
	unsigned int WLEN      : BFW_NX51_uartlcr_h_WLEN;      /*  Word Length       */
	                                                       /* "00" 5 bits        */
	                                                       /* "01" 6 bits        */
	                                                       /* "10" 7 bits        */
	                                                       /* "11" 8 bits        */
	unsigned int reserved1 : BFW_NX51_uartlcr_h_reserved1; /* reserved           */
} NX51_UARTLCR_H_BIT_T;

typedef union {
	unsigned int         val;
	NX51_UARTLCR_H_BIT_T bf;
} NX51_UARTLCR_H_T;

/* --------------------------------------------------------------------- */
/* Register uartlcr_m */
/* => Line control Register, middle byte */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartlcr_m   0x0000000CU
#define Adr_NX51_uart0_uartlcr_m 0x1018C60CU
#define Adr_NX51_uart1_uartlcr_m 0x1018C64CU
#define Adr_NX51_uart2_uartlcr_m 0x1018C68CU
#define DFLT_VAL_NX51_uartlcr_m  0x00000000U

#define MSK_NX51_uartlcr_m_BAUDDIVMS         0x000000ffU
#define SRT_NX51_uartlcr_m_BAUDDIVMS         0
#define DFLT_VAL_NX51_uartlcr_m_BAUDDIVMS    0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_m_BAUDDIVMS 0x00000000U

/* all used bits of 'NX51_uartlcr_m': */
#define MSK_USED_BITS_NX51_uartlcr_m 0x000000ffU

enum {
	BFW_NX51_uartlcr_m_BAUDDIVMS = 8,  /* [7:0] */
	BFW_NX51_uartlcr_m_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_UARTLCR_M_BIT_Ttag {
	unsigned int BAUDDIVMS : BFW_NX51_uartlcr_m_BAUDDIVMS; /* bauddiv : Baud Divisor Most Significant Byte                     */
	                                                       /* use higher byte of bauddiv = (system clk / (16 * baud rate)) - 1 */
	                                                       /* if not alternative settings by register uartcr_2 are done        */
	unsigned int reserved1 : BFW_NX51_uartlcr_m_reserved1; /* reserved                                                         */
} NX51_UARTLCR_M_BIT_T;

typedef union {
	unsigned int         val;
	NX51_UARTLCR_M_BIT_T bf;
} NX51_UARTLCR_M_T;

/* --------------------------------------------------------------------- */
/* Register uartlcr_l */
/* => Line control Register, low byte */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartlcr_l   0x00000010U
#define Adr_NX51_uart0_uartlcr_l 0x1018C610U
#define Adr_NX51_uart1_uartlcr_l 0x1018C650U
#define Adr_NX51_uart2_uartlcr_l 0x1018C690U
#define DFLT_VAL_NX51_uartlcr_l  0x00000000U

#define MSK_NX51_uartlcr_l_BAUDDIVLS         0x000000ffU
#define SRT_NX51_uartlcr_l_BAUDDIVLS         0
#define DFLT_VAL_NX51_uartlcr_l_BAUDDIVLS    0x00000000U
#define DFLT_BF_VAL_NX51_uartlcr_l_BAUDDIVLS 0x00000000U

/* all used bits of 'NX51_uartlcr_l': */
#define MSK_USED_BITS_NX51_uartlcr_l 0x000000ffU

enum {
	BFW_NX51_uartlcr_l_BAUDDIVLS = 8,  /* [7:0] */
	BFW_NX51_uartlcr_l_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_UARTLCR_L_BIT_Ttag {
	unsigned int BAUDDIVLS : BFW_NX51_uartlcr_l_BAUDDIVLS; /* Baud Divisor Least Significant Byte                             */
	                                                       /* use lower byte of bauddiv = (system clk / (16 * baud rate)) - 1 */
	                                                       /* if not alternative settings by register uartcr_2 are done       */
	unsigned int reserved1 : BFW_NX51_uartlcr_l_reserved1; /* reserved                                                        */
} NX51_UARTLCR_L_BIT_T;

typedef union {
	unsigned int         val;
	NX51_UARTLCR_L_BIT_T bf;
} NX51_UARTLCR_L_T;

/* --------------------------------------------------------------------- */
/* Register uartcr */
/* => uart control Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartcr   0x00000014U
#define Adr_NX51_uart0_uartcr 0x1018C614U
#define Adr_NX51_uart1_uartcr 0x1018C654U
#define Adr_NX51_uart2_uartcr 0x1018C694U
#define DFLT_VAL_NX51_uartcr  0x00000000U

#define MSK_NX51_uartcr_uartEN             0x00000001U
#define SRT_NX51_uartcr_uartEN             0
#define DFLT_VAL_NX51_uartcr_uartEN        0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_uartEN     0x00000000U
#define MSK_NX51_uartcr_SIREN              0x00000002U
#define SRT_NX51_uartcr_SIREN              1
#define DFLT_VAL_NX51_uartcr_SIREN         0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_SIREN      0x00000000U
#define MSK_NX51_uartcr_SIRLP              0x00000004U
#define SRT_NX51_uartcr_SIRLP              2
#define DFLT_VAL_NX51_uartcr_SIRLP         0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_SIRLP      0x00000000U
#define MSK_NX51_uartcr_MSIE               0x00000008U
#define SRT_NX51_uartcr_MSIE               3
#define DFLT_VAL_NX51_uartcr_MSIE          0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_MSIE       0x00000000U
#define MSK_NX51_uartcr_RIE                0x00000010U
#define SRT_NX51_uartcr_RIE                4
#define DFLT_VAL_NX51_uartcr_RIE           0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_RIE        0x00000000U
#define MSK_NX51_uartcr_TIE                0x00000020U
#define SRT_NX51_uartcr_TIE                5
#define DFLT_VAL_NX51_uartcr_TIE           0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_TIE        0x00000000U
#define MSK_NX51_uartcr_RTIE               0x00000040U
#define SRT_NX51_uartcr_RTIE               6
#define DFLT_VAL_NX51_uartcr_RTIE          0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_RTIE       0x00000000U
#define MSK_NX51_uartcr_LBE                0x00000080U
#define SRT_NX51_uartcr_LBE                7
#define DFLT_VAL_NX51_uartcr_LBE           0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_LBE        0x00000000U
#define MSK_NX51_uartcr_TX_RX_LOOP         0x00000100U
#define SRT_NX51_uartcr_TX_RX_LOOP         8
#define DFLT_VAL_NX51_uartcr_TX_RX_LOOP    0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_TX_RX_LOOP 0x00000000U

/* all used bits of 'NX51_uartcr': */
#define MSK_USED_BITS_NX51_uartcr 0x000001ffU

enum {
	BFW_NX51_uartcr_uartEN     = 1,  /* [0] */
	BFW_NX51_uartcr_SIREN      = 1,  /* [1] */
	BFW_NX51_uartcr_SIRLP      = 1,  /* [2] */
	BFW_NX51_uartcr_MSIE       = 1,  /* [3] */
	BFW_NX51_uartcr_RIE        = 1,  /* [4] */
	BFW_NX51_uartcr_TIE        = 1,  /* [5] */
	BFW_NX51_uartcr_RTIE       = 1,  /* [6] */
	BFW_NX51_uartcr_LBE        = 1,  /* [7] */
	BFW_NX51_uartcr_TX_RX_LOOP = 1,  /* [8] */
	BFW_NX51_uartcr_reserved1  = 23  /* [31:9] */
};

typedef struct NX51_UARTCR_BIT_Ttag {
	unsigned int uartEN     : BFW_NX51_uartcr_uartEN;     /* uart Enable                                  */
	unsigned int SIREN      : BFW_NX51_uartcr_SIREN;      /* SIR Enable                                   */
	unsigned int SIRLP      : BFW_NX51_uartcr_SIRLP;      /* IrDA SIR Low Power Mode                      */
	unsigned int MSIE       : BFW_NX51_uartcr_MSIE;       /* Modem Status Interrupt Enable                */
	unsigned int RIE        : BFW_NX51_uartcr_RIE;        /* Receive Interrupt Enable                     */
	unsigned int TIE        : BFW_NX51_uartcr_TIE;        /* Transmit Interrupt Enable                    */
	unsigned int RTIE       : BFW_NX51_uartcr_RTIE;       /* Receive Timeout Interrupt Enable             */
	unsigned int LBE        : BFW_NX51_uartcr_LBE;        /* Loop Back Enable for IrDA mode               */
	unsigned int TX_RX_LOOP : BFW_NX51_uartcr_TX_RX_LOOP; /* internal loop (TX -> RX) (test purpose only) */
	unsigned int reserved1  : BFW_NX51_uartcr_reserved1;  /* reserved                                     */
} NX51_UARTCR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_UARTCR_BIT_T bf;
} NX51_UARTCR_T;

/* --------------------------------------------------------------------- */
/* Register uartfr */
/* => uart Flag Register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartfr   0x00000018U
#define Adr_NX51_uart0_uartfr 0x1018C618U
#define Adr_NX51_uart1_uartfr 0x1018C658U
#define Adr_NX51_uart2_uartfr 0x1018C698U

#define MSK_NX51_uartfr_CTS  0x00000001U
#define SRT_NX51_uartfr_CTS  0
#define MSK_NX51_uartfr_DSR  0x00000002U
#define SRT_NX51_uartfr_DSR  1
#define MSK_NX51_uartfr_DCD  0x00000004U
#define SRT_NX51_uartfr_DCD  2
#define MSK_NX51_uartfr_BUSY 0x00000008U
#define SRT_NX51_uartfr_BUSY 3
#define MSK_NX51_uartfr_RXFE 0x00000010U
#define SRT_NX51_uartfr_RXFE 4
#define MSK_NX51_uartfr_TXFF 0x00000020U
#define SRT_NX51_uartfr_TXFF 5
#define MSK_NX51_uartfr_RXFF 0x00000040U
#define SRT_NX51_uartfr_RXFF 6
#define MSK_NX51_uartfr_TXFE 0x00000080U
#define SRT_NX51_uartfr_TXFE 7

/* all used bits of 'NX51_uartfr': */
#define MSK_USED_BITS_NX51_uartfr 0x000000ffU

enum {
	BFW_NX51_uartfr_CTS       = 1,  /* [0] */
	BFW_NX51_uartfr_DSR       = 1,  /* [1] */
	BFW_NX51_uartfr_DCD       = 1,  /* [2] */
	BFW_NX51_uartfr_BUSY      = 1,  /* [3] */
	BFW_NX51_uartfr_RXFE      = 1,  /* [4] */
	BFW_NX51_uartfr_TXFF      = 1,  /* [5] */
	BFW_NX51_uartfr_RXFF      = 1,  /* [6] */
	BFW_NX51_uartfr_TXFE      = 1,  /* [7] */
	BFW_NX51_uartfr_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_UARTFR_BIT_Ttag {
	unsigned int CTS       : BFW_NX51_uartfr_CTS;       /* Clear To Send       */
	unsigned int DSR       : BFW_NX51_uartfr_DSR;       /* Data Set Ready      */
	unsigned int DCD       : BFW_NX51_uartfr_DCD;       /* Data Carrier Detect */
	unsigned int BUSY      : BFW_NX51_uartfr_BUSY;      /* uart BUSY           */
	unsigned int RXFE      : BFW_NX51_uartfr_RXFE;      /* Receive FIFO Empty  */
	unsigned int TXFF      : BFW_NX51_uartfr_TXFF;      /* Transmit FIFO Full  */
	unsigned int RXFF      : BFW_NX51_uartfr_RXFF;      /* Receive FIFO Full   */
	unsigned int TXFE      : BFW_NX51_uartfr_TXFE;      /* Transmit FIFO Empty */
	unsigned int reserved1 : BFW_NX51_uartfr_reserved1; /* reserved            */
} NX51_UARTFR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_UARTFR_BIT_T bf;
} NX51_UARTFR_T;

/* --------------------------------------------------------------------- */
/* Register uartiir */
/* => Interrupt Identification (read) / interrupt clear (write) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartiir   0x0000001CU
#define Adr_NX51_uart0_uartiir 0x1018C61CU
#define Adr_NX51_uart1_uartiir 0x1018C65CU
#define Adr_NX51_uart2_uartiir 0x1018C69CU
#define DFLT_VAL_NX51_uartiir  0x00000000U

#define MSK_NX51_uartiir_MIS          0x00000001U
#define SRT_NX51_uartiir_MIS          0
#define DFLT_VAL_NX51_uartiir_MIS     0x00000000U
#define DFLT_BF_VAL_NX51_uartiir_MIS  0x00000000U
#define MSK_NX51_uartiir_RIS          0x00000002U
#define SRT_NX51_uartiir_RIS          1
#define DFLT_VAL_NX51_uartiir_RIS     0x00000000U
#define DFLT_BF_VAL_NX51_uartiir_RIS  0x00000000U
#define MSK_NX51_uartiir_TIS          0x00000004U
#define SRT_NX51_uartiir_TIS          2
#define DFLT_VAL_NX51_uartiir_TIS     0x00000000U
#define DFLT_BF_VAL_NX51_uartiir_TIS  0x00000000U
#define MSK_NX51_uartiir_RTIS         0x00000008U
#define SRT_NX51_uartiir_RTIS         3
#define DFLT_VAL_NX51_uartiir_RTIS    0x00000000U
#define DFLT_BF_VAL_NX51_uartiir_RTIS 0x00000000U

/* all used bits of 'NX51_uartiir': */
#define MSK_USED_BITS_NX51_uartiir 0x0000000fU

enum {
	BFW_NX51_uartiir_MIS       = 1,  /* [0] */
	BFW_NX51_uartiir_RIS       = 1,  /* [1] */
	BFW_NX51_uartiir_TIS       = 1,  /* [2] */
	BFW_NX51_uartiir_RTIS      = 1,  /* [3] */
	BFW_NX51_uartiir_reserved1 = 28  /* [31:4] */
};

typedef struct NX51_UARTIIR_BIT_Ttag {
	unsigned int MIS       : BFW_NX51_uartiir_MIS;       /* Modem Interrupt Status           */
	unsigned int RIS       : BFW_NX51_uartiir_RIS;       /* Receive Interrupt Status         */
	unsigned int TIS       : BFW_NX51_uartiir_TIS;       /* Transmit Interrupt Status        */
	unsigned int RTIS      : BFW_NX51_uartiir_RTIS;      /* Receive Timeout Interrupt Status */
	unsigned int reserved1 : BFW_NX51_uartiir_reserved1; /* reserved                         */
} NX51_UARTIIR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_UARTIIR_BIT_T bf;
} NX51_UARTIIR_T;

/* --------------------------------------------------------------------- */
/* Register uartilpr */
/* => IrDA Low Power Counter Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartilpr   0x00000020U
#define Adr_NX51_uart0_uartilpr 0x1018C620U
#define Adr_NX51_uart1_uartilpr 0x1018C660U
#define Adr_NX51_uart2_uartilpr 0x1018C6A0U
#define DFLT_VAL_NX51_uartilpr  0x00000000U

#define MSK_NX51_uartilpr_ILPDVSR         0x000000ffU
#define SRT_NX51_uartilpr_ILPDVSR         0
#define DFLT_VAL_NX51_uartilpr_ILPDVSR    0x00000000U
#define DFLT_BF_VAL_NX51_uartilpr_ILPDVSR 0x00000000U

/* all used bits of 'NX51_uartilpr': */
#define MSK_USED_BITS_NX51_uartilpr 0x000000ffU

enum {
	BFW_NX51_uartilpr_ILPDVSR   = 8,  /* [7:0] */
	BFW_NX51_uartilpr_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_UARTILPR_BIT_Ttag {
	unsigned int ILPDVSR   : BFW_NX51_uartilpr_ILPDVSR;   /* IrDA Low Power Divisor */
	unsigned int reserved1 : BFW_NX51_uartilpr_reserved1; /* reserved               */
} NX51_UARTILPR_BIT_T;

typedef union {
	unsigned int        val;
	NX51_UARTILPR_BIT_T bf;
} NX51_UARTILPR_T;

/* --------------------------------------------------------------------- */
/* Register uartrts */
/* => RTS Control Register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartrts   0x00000024U
#define Adr_NX51_uart0_uartrts 0x1018C624U
#define Adr_NX51_uart1_uartrts 0x1018C664U
#define Adr_NX51_uart2_uartrts 0x1018C6A4U
#define DFLT_VAL_NX51_uartrts  0x00000000U

#define MSK_NX51_uartrts_AUTO            0x00000001U
#define SRT_NX51_uartrts_AUTO            0
#define DFLT_VAL_NX51_uartrts_AUTO       0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_AUTO    0x00000000U
#define MSK_NX51_uartrts_RTS             0x00000002U
#define SRT_NX51_uartrts_RTS             1
#define DFLT_VAL_NX51_uartrts_RTS        0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_RTS     0x00000000U
#define MSK_NX51_uartrts_COUNT           0x00000004U
#define SRT_NX51_uartrts_COUNT           2
#define DFLT_VAL_NX51_uartrts_COUNT      0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_COUNT   0x00000000U
#define MSK_NX51_uartrts_MOD2            0x00000008U
#define SRT_NX51_uartrts_MOD2            3
#define DFLT_VAL_NX51_uartrts_MOD2       0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_MOD2    0x00000000U
#define MSK_NX51_uartrts_RTS_pol         0x00000010U
#define SRT_NX51_uartrts_RTS_pol         4
#define DFLT_VAL_NX51_uartrts_RTS_pol    0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_RTS_pol 0x00000000U
#define MSK_NX51_uartrts_CTS_ctr         0x00000020U
#define SRT_NX51_uartrts_CTS_ctr         5
#define DFLT_VAL_NX51_uartrts_CTS_ctr    0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_CTS_ctr 0x00000000U
#define MSK_NX51_uartrts_CTS_pol         0x00000040U
#define SRT_NX51_uartrts_CTS_pol         6
#define DFLT_VAL_NX51_uartrts_CTS_pol    0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_CTS_pol 0x00000000U
#define MSK_NX51_uartrts_STICK           0x00000080U
#define SRT_NX51_uartrts_STICK           7
#define DFLT_VAL_NX51_uartrts_STICK      0x00000000U
#define DFLT_BF_VAL_NX51_uartrts_STICK   0x00000000U

/* all used bits of 'NX51_uartrts': */
#define MSK_USED_BITS_NX51_uartrts 0x000000ffU

enum {
	BFW_NX51_uartrts_AUTO      = 1,  /* [0] */
	BFW_NX51_uartrts_RTS       = 1,  /* [1] */
	BFW_NX51_uartrts_COUNT     = 1,  /* [2] */
	BFW_NX51_uartrts_MOD2      = 1,  /* [3] */
	BFW_NX51_uartrts_RTS_pol   = 1,  /* [4] */
	BFW_NX51_uartrts_CTS_ctr   = 1,  /* [5] */
	BFW_NX51_uartrts_CTS_pol   = 1,  /* [6] */
	BFW_NX51_uartrts_STICK     = 1,  /* [7] */
	BFW_NX51_uartrts_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_UARTRTS_BIT_Ttag {
	unsigned int AUTO      : BFW_NX51_uartrts_AUTO;      /* automatic or controlled by the next bit (RTS) */
	unsigned int RTS       : BFW_NX51_uartrts_RTS;       /* if AUTO=0: controlled by this bit             */
	unsigned int COUNT     : BFW_NX51_uartrts_COUNT;     /* count base: 1=system clocks, 0=time in bauds  */
	unsigned int MOD2      : BFW_NX51_uartrts_MOD2;      /* mode1/mode2                                   */
	unsigned int RTS_pol   : BFW_NX51_uartrts_RTS_pol;   /* RTS polarity: 1=active high                   */
	unsigned int CTS_ctr   : BFW_NX51_uartrts_CTS_ctr;   /* nUARTCTS control                              */
	unsigned int CTS_pol   : BFW_NX51_uartrts_CTS_pol;   /* nUARTCTS polarity: 1=active high              */
	unsigned int STICK     : BFW_NX51_uartrts_STICK;     /* stick parity                                  */
	unsigned int reserved1 : BFW_NX51_uartrts_reserved1; /* reserved                                      */
} NX51_UARTRTS_BIT_T;

typedef union {
	unsigned int       val;
	NX51_UARTRTS_BIT_T bf;
} NX51_UARTRTS_T;

/* --------------------------------------------------------------------- */
/* Register uartforerun */
/* => RTS forerun cycles */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartforerun   0x00000028U
#define Adr_NX51_uart0_uartforerun 0x1018C628U
#define Adr_NX51_uart1_uartforerun 0x1018C668U
#define Adr_NX51_uart2_uartforerun 0x1018C6A8U
#define DFLT_VAL_NX51_uartforerun  0x00000000U

#define MSK_NX51_uartforerun_FORERUN         0x000000ffU
#define SRT_NX51_uartforerun_FORERUN         0
#define DFLT_VAL_NX51_uartforerun_FORERUN    0x00000000U
#define DFLT_BF_VAL_NX51_uartforerun_FORERUN 0x00000000U

/* all used bits of 'NX51_uartforerun': */
#define MSK_USED_BITS_NX51_uartforerun 0x000000ffU

enum {
	BFW_NX51_uartforerun_FORERUN   = 8,  /* [7:0] */
	BFW_NX51_uartforerun_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_UARTFORERUN_BIT_Ttag {
	unsigned int FORERUN   : BFW_NX51_uartforerun_FORERUN;   /* number of forerun cycles in system clocks or bauds */
	unsigned int reserved1 : BFW_NX51_uartforerun_reserved1; /* reserved                                           */
} NX51_UARTFORERUN_BIT_T;

typedef union {
	unsigned int           val;
	NX51_UARTFORERUN_BIT_T bf;
} NX51_UARTFORERUN_T;

/* --------------------------------------------------------------------- */
/* Register uarttrail */
/* => RTS trail cycles */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uarttrail   0x0000002CU
#define Adr_NX51_uart0_uarttrail 0x1018C62CU
#define Adr_NX51_uart1_uarttrail 0x1018C66CU
#define Adr_NX51_uart2_uarttrail 0x1018C6ACU
#define DFLT_VAL_NX51_uarttrail  0x00000000U

#define MSK_NX51_uarttrail_TRAIL         0x000000ffU
#define SRT_NX51_uarttrail_TRAIL         0
#define DFLT_VAL_NX51_uarttrail_TRAIL    0x00000000U
#define DFLT_BF_VAL_NX51_uarttrail_TRAIL 0x00000000U

/* all used bits of 'NX51_uarttrail': */
#define MSK_USED_BITS_NX51_uarttrail 0x000000ffU

enum {
	BFW_NX51_uarttrail_TRAIL     = 8,  /* [7:0] */
	BFW_NX51_uarttrail_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_UARTTRAIL_BIT_Ttag {
	unsigned int TRAIL     : BFW_NX51_uarttrail_TRAIL;     /* number of trail cycles in system clocks or bauds */
	unsigned int reserved1 : BFW_NX51_uarttrail_reserved1; /* reserved                                         */
} NX51_UARTTRAIL_BIT_T;

typedef union {
	unsigned int         val;
	NX51_UARTTRAIL_BIT_T bf;
} NX51_UARTTRAIL_T;

/* --------------------------------------------------------------------- */
/* Register uartdrvout */
/* => Drive Output */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartdrvout   0x00000030U
#define Adr_NX51_uart0_uartdrvout 0x1018C630U
#define Adr_NX51_uart1_uartdrvout 0x1018C670U
#define Adr_NX51_uart2_uartdrvout 0x1018C6B0U
#define DFLT_VAL_NX51_uartdrvout  0x00000000U

#define MSK_NX51_uartdrvout_DRVTX          0x00000001U
#define SRT_NX51_uartdrvout_DRVTX          0
#define DFLT_VAL_NX51_uartdrvout_DRVTX     0x00000000U
#define DFLT_BF_VAL_NX51_uartdrvout_DRVTX  0x00000000U
#define MSK_NX51_uartdrvout_DRVRTS         0x00000002U
#define SRT_NX51_uartdrvout_DRVRTS         1
#define DFLT_VAL_NX51_uartdrvout_DRVRTS    0x00000000U
#define DFLT_BF_VAL_NX51_uartdrvout_DRVRTS 0x00000000U

/* all used bits of 'NX51_uartdrvout': */
#define MSK_USED_BITS_NX51_uartdrvout 0x00000003U

enum {
	BFW_NX51_uartdrvout_DRVTX     = 1,  /* [0] */
	BFW_NX51_uartdrvout_DRVRTS    = 1,  /* [1] */
	BFW_NX51_uartdrvout_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_UARTDRVOUT_BIT_Ttag {
	unsigned int DRVTX     : BFW_NX51_uartdrvout_DRVTX;     /* enable driver for TX  */
	unsigned int DRVRTS    : BFW_NX51_uartdrvout_DRVRTS;    /* enable driver for RTS */
	unsigned int reserved1 : BFW_NX51_uartdrvout_reserved1; /* reserved              */
} NX51_UARTDRVOUT_BIT_T;

typedef union {
	unsigned int          val;
	NX51_UARTDRVOUT_BIT_T bf;
} NX51_UARTDRVOUT_T;

/* --------------------------------------------------------------------- */
/* Register uartcr_2 */
/* => Control Register 2 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartcr_2   0x00000034U
#define Adr_NX51_uart0_uartcr_2 0x1018C634U
#define Adr_NX51_uart1_uartcr_2 0x1018C674U
#define Adr_NX51_uart2_uartcr_2 0x1018C6B4U
#define DFLT_VAL_NX51_uartcr_2  0x00000000U

#define MSK_NX51_uartcr_2_Baud_Rate_Mode         0x00000001U
#define SRT_NX51_uartcr_2_Baud_Rate_Mode         0
#define DFLT_VAL_NX51_uartcr_2_Baud_Rate_Mode    0x00000000U
#define DFLT_BF_VAL_NX51_uartcr_2_Baud_Rate_Mode 0x00000000U

/* all used bits of 'NX51_uartcr_2': */
#define MSK_USED_BITS_NX51_uartcr_2 0x00000001U

enum {
	BFW_NX51_uartcr_2_Baud_Rate_Mode = 1,  /* [0] */
	BFW_NX51_uartcr_2_reserved1      = 31  /* [31:1] */
};

typedef struct NX51_UARTCR_2_BIT_Ttag {
	unsigned int Baud_Rate_Mode : BFW_NX51_uartcr_2_Baud_Rate_Mode; /* If this bit is set the baud rate is generated more exactly by the following formula: */
	                                                                /* value = ( (Baud Rate * 16) / System Frequency ) * 2^16  .                            */
	                                                                /* You have to write this 16-bit value in register uartlcr_l and uartlcr_m.             */
	unsigned int reserved1      : BFW_NX51_uartcr_2_reserved1;      /* reserved                                                                             */
} NX51_UARTCR_2_BIT_T;

typedef union {
	unsigned int        val;
	NX51_UARTCR_2_BIT_T bf;
} NX51_UARTCR_2_T;

/* --------------------------------------------------------------------- */
/* Register uartrxiflsel */
/* => RX FIFO trigger level and RX-DMA enable */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uartrxiflsel   0x00000038U
#define Adr_NX51_uart0_uartrxiflsel 0x1018C638U
#define Adr_NX51_uart1_uartrxiflsel 0x1018C678U
#define Adr_NX51_uart2_uartrxiflsel 0x1018C6B8U
#define DFLT_VAL_NX51_uartrxiflsel  0x00000008U

#define MSK_NX51_uartrxiflsel_RXIFLSEL         0x0000001fU
#define SRT_NX51_uartrxiflsel_RXIFLSEL         0
#define DFLT_VAL_NX51_uartrxiflsel_RXIFLSEL    0x00000008U
#define DFLT_BF_VAL_NX51_uartrxiflsel_RXIFLSEL 0x00000008U
#define MSK_NX51_uartrxiflsel_RXDMA            0x00000020U
#define SRT_NX51_uartrxiflsel_RXDMA            5
#define DFLT_VAL_NX51_uartrxiflsel_RXDMA       0x00000000U
#define DFLT_BF_VAL_NX51_uartrxiflsel_RXDMA    0x00000000U

/* all used bits of 'NX51_uartrxiflsel': */
#define MSK_USED_BITS_NX51_uartrxiflsel 0x0000003fU

enum {
	BFW_NX51_uartrxiflsel_RXIFLSEL  = 5,  /* [4:0] */
	BFW_NX51_uartrxiflsel_RXDMA     = 1,  /* [5] */
	BFW_NX51_uartrxiflsel_reserved1 = 26  /* [31:6] */
};

typedef struct NX51_UARTRXIFLSEL_BIT_Ttag {
	unsigned int RXIFLSEL  : BFW_NX51_uartrxiflsel_RXIFLSEL;  /*   Choose a number between 1 and 16. It defines the IRQ trigger level of the receive fifo.                                  */
	                                                          /*   The IRQ (UARTRXINTR) will be set if the number of received bytes in the receive fifo are greater than or equal RXIFLSEL. */
	unsigned int RXDMA     : BFW_NX51_uartrxiflsel_RXDMA;     /*   Enable DMA-requests for RX-fifo-data.                                                                                    */
	                                                          /*   A request will be generated if RX-FIFO is not empty and uartcr.uartEN (module enable) is set.                            */
	                                                          /*   Burst request to DMA-Ctrl will be done if the RX-FIFO contains at least 4 words (set DMA-burst-size to 4)                */
	                                                          /*   If this bit is reset or the module is disabled, DMA-request will also be reset.                                          */
	                                                          /*   single transfer request: RX-FIFO contains 1 byte or more, burst request: 4 bytes or more                                 */
	                                                          /*   note: set adr_dmac_chctrl.SBSize = 1 (i.e. burst size: 4) in the DMA module                                              */
	unsigned int reserved1 : BFW_NX51_uartrxiflsel_reserved1; /* reserved                                                                                                                   */
} NX51_UARTRXIFLSEL_BIT_T;

typedef union {
	unsigned int            val;
	NX51_UARTRXIFLSEL_BIT_T bf;
} NX51_UARTRXIFLSEL_T;

/* --------------------------------------------------------------------- */
/* Register uarttxiflsel */
/* => TX FIFO trigger level and TX-DMA enable */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_uarttxiflsel   0x0000003CU
#define Adr_NX51_uart0_uarttxiflsel 0x1018C63CU
#define Adr_NX51_uart1_uarttxiflsel 0x1018C67CU
#define Adr_NX51_uart2_uarttxiflsel 0x1018C6BCU
#define DFLT_VAL_NX51_uarttxiflsel  0x00000008U

#define MSK_NX51_uarttxiflsel_TXIFLSEL         0x0000001fU
#define SRT_NX51_uarttxiflsel_TXIFLSEL         0
#define DFLT_VAL_NX51_uarttxiflsel_TXIFLSEL    0x00000008U
#define DFLT_BF_VAL_NX51_uarttxiflsel_TXIFLSEL 0x00000008U
#define MSK_NX51_uarttxiflsel_TXDMA            0x00000020U
#define SRT_NX51_uarttxiflsel_TXDMA            5
#define DFLT_VAL_NX51_uarttxiflsel_TXDMA       0x00000000U
#define DFLT_BF_VAL_NX51_uarttxiflsel_TXDMA    0x00000000U

/* all used bits of 'NX51_uarttxiflsel': */
#define MSK_USED_BITS_NX51_uarttxiflsel 0x0000003fU

enum {
	BFW_NX51_uarttxiflsel_TXIFLSEL  = 5,  /* [4:0] */
	BFW_NX51_uarttxiflsel_TXDMA     = 1,  /* [5] */
	BFW_NX51_uarttxiflsel_reserved1 = 26  /* [31:6] */
};

typedef struct NX51_UARTTXIFLSEL_BIT_Ttag {
	unsigned int TXIFLSEL  : BFW_NX51_uarttxiflsel_TXIFLSEL;  /*   Choose a number between 1 and 16. It defines the IRQ trigger level of the transmit fifo.                         */
	                                                          /*   The IRQ (UARTTXINTR) will be set if the number of transmitted bytes in the transmit fifo are less than TXIFLSEL. */
	unsigned int TXDMA     : BFW_NX51_uarttxiflsel_TXDMA;     /*   Enable DMA-requests for TX-fifo-data.                                                                            */
	                                                          /*   A request will be generated if TX-FIFO is not full and uartcr.uartEN (module enable) is set.                     */
	                                                          /*   Burst request to DMA-Ctrl will be done if at least 4 words are writable to the TX-FIFO (set DMA-burst-size to 4) */
	                                                          /*   If this bit is reset or the module is disabled, DMA-request will also be reset.                                  */
	                                                          /*   note: set adr_dmac_chctrl.DBSize = 1 (i.e. burst size: 4) in the DMA module                                      */
	unsigned int reserved1 : BFW_NX51_uarttxiflsel_reserved1; /* reserved                                                                                                           */
} NX51_UARTTXIFLSEL_BIT_T;

typedef union {
	unsigned int            val;
	NX51_UARTTXIFLSEL_BIT_T bf;
} NX51_UARTTXIFLSEL_T;


/* ===================================================================== */

/* AREA i2c */
/* Area of i2c0, i2c1 */

/* ===================================================================== */

#define Addr_NX51_i2c0      0x1018C6C0U
#define NX51_NETX_I2C0_AREA 0x1018C6C0U
#define Addr_NX51_i2c1      0x1018C700U
#define NX51_NETX_I2C1_AREA 0x1018C700U

/* --------------------------------------------------------------------- */
/* Register i2c_mcr */
/* => I2C master control register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_mcr  0x00000000U
#define Adr_NX51_i2c0_i2c_mcr 0x1018C6C0U
#define Adr_NX51_i2c1_i2c_mcr 0x1018C700U
#define DFLT_VAL_NX51_i2c_mcr 0x00000000U

#define MSK_NX51_i2c_mcr_en_i2c           0x00000001U
#define SRT_NX51_i2c_mcr_en_i2c           0
#define DFLT_VAL_NX51_i2c_mcr_en_i2c      0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mcr_en_i2c   0x00000000U
#define MSK_NX51_i2c_mcr_mode             0x0000000eU
#define SRT_NX51_i2c_mcr_mode             1
#define DFLT_VAL_NX51_i2c_mcr_mode        0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mcr_mode     0x00000000U
#define MSK_NX51_i2c_mcr_sadr             0x000007f0U
#define SRT_NX51_i2c_mcr_sadr             4
#define DFLT_VAL_NX51_i2c_mcr_sadr        0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mcr_sadr     0x00000000U
#define MSK_NX51_i2c_mcr_pio_mode         0x00010000U
#define SRT_NX51_i2c_mcr_pio_mode         16
#define DFLT_VAL_NX51_i2c_mcr_pio_mode    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mcr_pio_mode 0x00000000U
#define MSK_NX51_i2c_mcr_rst_i2c          0x00020000U
#define SRT_NX51_i2c_mcr_rst_i2c          17
#define DFLT_VAL_NX51_i2c_mcr_rst_i2c     0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mcr_rst_i2c  0x00000000U

/* all used bits of 'NX51_i2c_mcr': */
#define MSK_USED_BITS_NX51_i2c_mcr 0x000307ffU

enum {
	BFW_NX51_i2c_mcr_en_i2c    = 1,  /* [0] */
	BFW_NX51_i2c_mcr_mode      = 3,  /* [3:1] */
	BFW_NX51_i2c_mcr_sadr      = 7,  /* [10:4] */
	BFW_NX51_i2c_mcr_reserved1 = 5,  /* [15:11] */
	BFW_NX51_i2c_mcr_pio_mode  = 1,  /* [16] */
	BFW_NX51_i2c_mcr_rst_i2c   = 1,  /* [17] */
	BFW_NX51_i2c_mcr_reserved2 = 14  /* [31:18] */
};

typedef struct NX51_I2C_MCR_BIT_Ttag {
	unsigned int en_i2c    : BFW_NX51_i2c_mcr_en_i2c;    /* Global I2C controller enable                                                                                                                              */
	                                                     /*  1: Enable I2C-controller                                                                                                                                 */
	                                                     /*  0: Disable I2C-controller                                                                                                                                */
	                                                     /* Note:                                                                                                                                                     */
	                                                     /*    I2C bus state detections 'bus_master' and 'started'  are even done when module is disabled.                                                            */
	                                                     /*    View 'i2c_sr' register for details.                                                                                                                    */
	                                                     /* Note:                                                                                                                                                     */
	                                                     /*    Disabling the I2C module while a transfer is running will take back this I2C module                                                                    */
	                                                     /*    form the bus immediately and not generate a STOP. Internal I2C state machine will be                                                                   */
	                                                     /*    set back to initial/idle state.                                                                                                                        */
	unsigned int mode      : BFW_NX51_i2c_mcr_mode;      /* I2C-speed-mode:                                                                                                                                           */
	                                                     /* If this device is used only as slave, mode should be set to the maximum data rate generated by the fastest master on the I2C-bus                          */
	                                                     /* for appropriate input filtering and spike suppression                                                                                                     */
	                                                     /*  000: Fast/Standard-mode, 50kbit/s                                                                                                                        */
	                                                     /*  001: Fast/Standard-mode, 100kbit/s                                                                                                                       */
	                                                     /*  010: Fast/Standard-mode, 200kbit/s                                                                                                                       */
	                                                     /*  011: Fast/Standard-mode, 400kbit/s                                                                                                                       */
	                                                     /*  100: Fast/Standard-mode, 800kbit/s                                                                                                                       */
	                                                     /*  101: Fast/Standard-mode, 1.2Mbit/s                                                                                                                       */
	                                                     /*  110: High-speed-mode, 1.7Mbit/s                                                                                                                          */
	                                                     /*  111: High-speed-mode, 3.4Mbit/s)                                                                                                                         */
	unsigned int sadr      : BFW_NX51_i2c_mcr_sadr;      /* 7-bit Slave address send after (r)START:                                                                                                                  */
	                                                     /* For 10-bit addressing, the first byte (10bit-start "11110", MSB[9:8] must be programmed here, second start                                                */
	                                                     /* byte (slave address LSBs) must be top of the master FIFO (i2c_mdr).                                                                                       */
	                                                     /* This register must be rewritten (even if value does not change) if another 10-bit addressed slave shall be addressed (run 2-byte start sequence). It must */
	                                                     /* not be rewritten before repeated START on the same 10-bit addressed slave (run 1-byte start sequence e.g. write to read change).                          */
	unsigned int reserved1 : BFW_NX51_i2c_mcr_reserved1; /* reserved                                                                                                                                                  */
	unsigned int pio_mode  : BFW_NX51_i2c_mcr_pio_mode;  /* If this bit is set, SCL and SDA will be directly controllable by i2c_pio-register to access non I2C compatible devices.                                   */
	                                                     /* In pio-mode the I2C-controller statemachine is disabled, so no FIFO-action is done no IRQs occur and no DMA-controlling is possible.                      */
	unsigned int rst_i2c   : BFW_NX51_i2c_mcr_rst_i2c;   /* Reset detected I2C bus states.                                                                                                                            */
	                                                     /* Current state of I2C bus (e.g. master arbitration) is provided by 'i2c_sr' register.                                                                      */
	                                                     /* Some bus states like bus-master-arbitration-detection is always performed, even when I2C module is disable.                                               */
	                                                     /* This is done to avoid conflicts with other masters. E.g.: Another I2C master is running                                                                   */
	                                                     /* while netX I2C is changed from disabled to enabled: In this case netX I2C module will wait                                                                */
	                                                     /* for other masters STOP before it tries to access bus. However it could be possible that netX                                                              */
	                                                     /* I2C master detected START which never generates a STOP (e.g. as generating master is crashed                                                              */
	                                                     /* or non-standard I2C sequences were performed in PIO mode).                                                                                                */
	                                                     /* This bit can be used to set netX I2C module back to I2C bus master and also clear other bus states manually.                                              */
	                                                     /* However be carefull doing this. All running I2C sequences of other devices will fail when a transfer is                                                   */
	                                                     /* started to a non-idle I2C bus.                                                                                                                            */
	                                                     /* Note:                                                                                                                                                     */
	                                                     /*    View 'i2c_sr' register description for effected status bits.                                                                                           */
	                                                     /* Note:                                                                                                                                                     */
	                                                     /*    This bit is always 0 when read.                                                                                                                        */
	                                                     /* Note:                                                                                                                                                     */
	                                                     /*    This is a new netX51 feature.                                                                                                                          */
	unsigned int reserved2 : BFW_NX51_i2c_mcr_reserved2; /* reserved                                                                                                                                                  */
} NX51_I2C_MCR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_I2C_MCR_BIT_T bf;
} NX51_I2C_MCR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_scr */
/* => I2C slave control register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_scr  0x00000004U
#define Adr_NX51_i2c0_i2c_scr 0x1018C6C4U
#define Adr_NX51_i2c1_i2c_scr 0x1018C704U
#define DFLT_VAL_NX51_i2c_scr 0x00000000U

#define MSK_NX51_i2c_scr_sid                        0x000003ffU
#define SRT_NX51_i2c_scr_sid                        0
#define DFLT_VAL_NX51_i2c_scr_sid                   0x00000000U
#define DFLT_BF_VAL_NX51_i2c_scr_sid                0x00000000U
#define MSK_NX51_i2c_scr_sid10                      0x00000400U
#define SRT_NX51_i2c_scr_sid10                      10
#define DFLT_VAL_NX51_i2c_scr_sid10                 0x00000000U
#define DFLT_BF_VAL_NX51_i2c_scr_sid10              0x00000000U
#define MSK_NX51_i2c_scr_ac_srx                     0x00010000U
#define SRT_NX51_i2c_scr_ac_srx                     16
#define DFLT_VAL_NX51_i2c_scr_ac_srx                0x00000000U
#define DFLT_BF_VAL_NX51_i2c_scr_ac_srx             0x00000000U
#define MSK_NX51_i2c_scr_ac_start                   0x00020000U
#define SRT_NX51_i2c_scr_ac_start                   17
#define DFLT_VAL_NX51_i2c_scr_ac_start              0x00000000U
#define DFLT_BF_VAL_NX51_i2c_scr_ac_start           0x00000000U
#define MSK_NX51_i2c_scr_ac_gcall                   0x00040000U
#define SRT_NX51_i2c_scr_ac_gcall                   18
#define DFLT_VAL_NX51_i2c_scr_ac_gcall              0x00000000U
#define DFLT_BF_VAL_NX51_i2c_scr_ac_gcall           0x00000000U
#define MSK_NX51_i2c_scr_autoreset_ac_start         0x00100000U
#define SRT_NX51_i2c_scr_autoreset_ac_start         20
#define DFLT_VAL_NX51_i2c_scr_autoreset_ac_start    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_scr_autoreset_ac_start 0x00000000U

/* all used bits of 'NX51_i2c_scr': */
#define MSK_USED_BITS_NX51_i2c_scr 0x001707ffU

enum {
	BFW_NX51_i2c_scr_sid                = 10, /* [9:0] */
	BFW_NX51_i2c_scr_sid10              = 1,  /* [10] */
	BFW_NX51_i2c_scr_reserved1          = 5,  /* [15:11] */
	BFW_NX51_i2c_scr_ac_srx             = 1,  /* [16] */
	BFW_NX51_i2c_scr_ac_start           = 1,  /* [17] */
	BFW_NX51_i2c_scr_ac_gcall           = 1,  /* [18] */
	BFW_NX51_i2c_scr_reserved2          = 1,  /* [19] */
	BFW_NX51_i2c_scr_autoreset_ac_start = 1,  /* [20] */
	BFW_NX51_i2c_scr_reserved3          = 11  /* [31:21] */
};

typedef struct NX51_I2C_SCR_BIT_Ttag {
	unsigned int sid                : BFW_NX51_i2c_scr_sid;                /* Slave device ID:                                                                                             */
	                                                                       /* External masters can address this device by this address.                                                    */
	unsigned int sid10              : BFW_NX51_i2c_scr_sid10;              /* 10-bit Slave device ID:                                                                                      */
	                                                                       /*  0: listen for 7bit slave address after (r)START                                                             */
	                                                                       /*  1: listen for 10bit slave address after (r)START                                                            */
	unsigned int reserved1          : BFW_NX51_i2c_scr_reserved1;          /* reserved                                                                                                     */
	unsigned int ac_srx             : BFW_NX51_i2c_scr_ac_srx;             /* Enable slave-receive-data acknowledge:                                                                       */
	                                                                       /*  0: do not generate acknowledge on receive bytes.                                                            */
	                                                                       /*  1: generate acknowledge on receive bytes.                                                                   */
	                                                                       /* No acknowledge will be generated on receive data if the slave FIFO is full.                                  */
	unsigned int ac_start           : BFW_NX51_i2c_scr_ac_start;           /* Enable start sequence acknowledge:                                                                           */
	                                                                       /* The start byte (2 bytes if sid10 is set) will be acknowledged if the received address matches the sid-bits.  */
	                                                                       /* If master requests a read transfer, slave FIFO read access is done immediately after acknowledge, so         */
	                                                                       /* valid data must be present in the slave FIFO before acknowledge is enabled.                                  */
	                                                                       /* If autoreset_ac_start is enabled, this bit will reset automatically by the controller. If autoreset_ac_start */
	                                                                       /* is not enabled, this bit should be reset by software after the start sequence was                            */
	                                                                       /* acknowledged to avoid acknowledge and FIFO errors after next (r)START.                                       */
	                                                                       /*  0: do not generate acknowledge after start sequence.                                                        */
	                                                                       /*  1: generate acknowledge after start sequence.                                                               */
	                                                                       /* Note: This bit is writable but can also be changed by hardware.                                              */
	unsigned int ac_gcall           : BFW_NX51_i2c_scr_ac_gcall;           /* General Call acknowledge:                                                                                    */
	                                                                       /*  0: do not generate acknowledge after General Call                                                           */
	                                                                       /*  1: generate acknowledge after General Call                                                                  */
	unsigned int reserved2          : BFW_NX51_i2c_scr_reserved2;          /* reserved                                                                                                     */
	unsigned int autoreset_ac_start : BFW_NX51_i2c_scr_autoreset_ac_start; /* auto reset ac_start (ac_start must be set again after any (r)START)                                          */
	                                                                       /*  0: ac_start will not be automatically reset (netx50 compatible)                                             */
	                                                                       /*  1: reset ac_start after this slave acknowledged a starts sequence                                           */
	unsigned int reserved3          : BFW_NX51_i2c_scr_reserved3;          /* reserved                                                                                                     */
} NX51_I2C_SCR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_I2C_SCR_BIT_T bf;
} NX51_I2C_SCR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_cmd */
/* => I2C master command register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_cmd  0x00000008U
#define Adr_NX51_i2c0_i2c_cmd 0x1018C6C8U
#define Adr_NX51_i2c1_i2c_cmd 0x1018C708U
#define DFLT_VAL_NX51_i2c_cmd 0x0000000eU

#define MSK_NX51_i2c_cmd_nwr               0x00000001U
#define SRT_NX51_i2c_cmd_nwr               0
#define DFLT_VAL_NX51_i2c_cmd_nwr          0x00000000U
#define DFLT_BF_VAL_NX51_i2c_cmd_nwr       0x00000000U
#define MSK_NX51_i2c_cmd_cmd               0x0000000eU
#define SRT_NX51_i2c_cmd_cmd               1
#define DFLT_VAL_NX51_i2c_cmd_cmd          0x0000000eU
#define DFLT_BF_VAL_NX51_i2c_cmd_cmd       0x00000007U
#define MSK_NX51_i2c_cmd_tsize             0x0003ff00U
#define SRT_NX51_i2c_cmd_tsize             8
#define DFLT_VAL_NX51_i2c_cmd_tsize        0x00000000U
#define DFLT_BF_VAL_NX51_i2c_cmd_tsize     0x00000000U
#define MSK_NX51_i2c_cmd_acpollmax         0x0ff00000U
#define SRT_NX51_i2c_cmd_acpollmax         20
#define DFLT_VAL_NX51_i2c_cmd_acpollmax    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_cmd_acpollmax 0x00000000U

/* all used bits of 'NX51_i2c_cmd': */
#define MSK_USED_BITS_NX51_i2c_cmd 0x0ff3ff0fU

enum {
	BFW_NX51_i2c_cmd_nwr       = 1,  /* [0] */
	BFW_NX51_i2c_cmd_cmd       = 3,  /* [3:1] */
	BFW_NX51_i2c_cmd_reserved1 = 4,  /* [7:4] */
	BFW_NX51_i2c_cmd_tsize     = 10, /* [17:8] */
	BFW_NX51_i2c_cmd_reserved2 = 2,  /* [19:18] */
	BFW_NX51_i2c_cmd_acpollmax = 8,  /* [27:20] */
	BFW_NX51_i2c_cmd_reserved3 = 4   /* [31:28] */
};

typedef struct NX51_I2C_CMD_BIT_Ttag {
	unsigned int nwr       : BFW_NX51_i2c_cmd_nwr;       /* Transfer direction:                                                                                                                                            */
	                                                     /*  0: cmd will be done as write.                                                                                                                                 */
	                                                     /*  1: cmd will be done as read.                                                                                                                                  */
	                                                     /* Master FIFO-requests (IRQ and DMA) are generated depending this direction flag.                                                                                */
	unsigned int cmd       : BFW_NX51_i2c_cmd_cmd;       /* I2C sequence command:                                                                                                                                          */
	                                                     /* All commands will either generate the cmd_ok IRQ or the cmd_err IRQ. Successful command termination will always generate                                       */
	                                                     /* cmd_ok IRQ. If a command could not be finished successfully, cmd_err IRQ will be set.                                                                          */
	                                                     /* For 10-bit-addressed slaves, the second start-byte (LSBs) must be top of the master FIFO.                                                                      */
	                                                     /* 000: START:    generate (r)START-condition.                                                                                                                    */
	                                                     /* 001: S_AC:     acknowledge-polling: generate up to acpollmax+1 START-sequences (until acknowledged by slave).                                                  */
	                                                     /* 010: S_AC_T:   run S_AC, then transfer tsize+1 bytes from/to master FIFO. Not to be continued.                                                                 */
	                                                     /* 011: S_AC_TC:  run S_AC, then transfer tsize+1 bytes from/to master FIFO. To be continued.                                                                     */
	                                                     /* 100: CT:       Continued transfer not to be continued.                                                                                                         */
	                                                     /* 101: CTC:      Continued transfer to be continued.                                                                                                             */
	                                                     /* 110: STOP      generate STOP-condition.                                                                                                                        */
	                                                     /* 111: IDLE      nothing to do, last command finished, break current command.                                                                                    */
	                                                     /* Sequences including not to be continued transfers (S_AC_T, CT) will generate no acknowledge (if read) after last the received byte (read transfer ends). To be */
	                                                     /* continued transfers (S_AC_TC, CTC) will generate acknowledge after the last received byte and must be followed by CT or CTC.                                   */
	                                                     /* Before continued transfers (CT, CTC) a command including START (START, S_AC, S_AC_T, S_AC_TC) must be done to generate a valid I2C sequence..                  */
	                                                     /* View i2c_mdr description for FIFO error handling.                                                                                                              */
	                                                     /* STOP must always be done by software to free the bus after transfer end. STOP is not included in any command sequence and never done                           */
	                                                     /* automatically by this device.                                                                                                                                  */
	                                                     /* Some commands are handled as sequences (i.e after setting S_AC_T, first S_AC, later CT will be seen when read out).                                            */
	                                                     /* Note:                                                                                                                                                          */
	                                                     /*    It is not necessary to poll for IDLE here before setting up a new command. However it is                                                                    */
	                                                     /*    necessary to wait for assertion of cmd_ok or cmd_err status flags of i2c_irqsr register.                                                                    */
	                                                     /* Note: This bit is writable but can also be changed by hardware.                                                                                                */
	unsigned int reserved1 : BFW_NX51_i2c_cmd_reserved1; /* reserved                                                                                                                                                       */
	unsigned int tsize     : BFW_NX51_i2c_cmd_tsize;     /* Transfer tsize+1 bytes (1...1024):                                                                                                                             */
	                                                     /* If no acknowledge was generated by slave (receiver), write transfers will be terminated and the cmd_err IRQ will be generated.                                 */
	                                                     /* For 10-bit-addressed slaves, the second start-byte (LSBs) must be top of the master FIFO. This byte must not be regarded by the                                */
	                                                     /* value programmed here  for subsequent transfers.                                                                                                               */
	                                                     /* This value will count down during transfers after each byte.                                                                                                   */
	                                                     /* Note: This bit is writable but can also be changed by hardware.                                                                                                */
	unsigned int reserved2 : BFW_NX51_i2c_cmd_reserved2; /* reserved                                                                                                                                                       */
	unsigned int acpollmax : BFW_NX51_i2c_cmd_acpollmax; /* acpollmax+1 (1...256) tries for start sequence acknowledge polling:                                                                                            */
	                                                     /* For 7-bit addressed acknowledge polling START and the first byte containing the slave address (i2c_mcr.sadr) will be repeated up                               */
	                                                     /* to acpollmax+1 times until a slave generates acknowledge. If no acknowledge is received within acpollmax+1 tries, the cmd_err IRQ will be generated.           */
	                                                     /* For 10-bit-addressed slaves, the 2-byte start sequence is done. The second address-byte (LSBs) must be top of the                                              */
	                                                     /* master FIFO (i2c_mdr). This byte must not be regarded by the value programmed in tsize for subsequent transfers.                                               */
	                                                     /* This value will count down during acknowledge polling after each start sequence.                                                                               */
	                                                     /* Note: This bit is writable but can also be changed by hardware.                                                                                                */
	unsigned int reserved3 : BFW_NX51_i2c_cmd_reserved3; /* reserved                                                                                                                                                       */
} NX51_I2C_CMD_BIT_T;

typedef union {
	unsigned int       val;
	NX51_I2C_CMD_BIT_T bf;
} NX51_I2C_CMD_T;

/* --------------------------------------------------------------------- */
/* Register i2c_mdr */
/* => I2C master data register (master FIFO) */
/*    There is only one FIFO for both, receive and transmit master data with a depth of 16 bytes. For master write access, data send by the master */
/*    is delivered from the FIFO, for master read access data received by the master is stored in the FIFO. */
/*    In case of imminent data transfer failure (read transfer and FIFO is full or write transfer and FIFO is empty), the cmd_err IRQ will be set after the last */
/*    byte that could be transmitted. No FIFO-underrun or overflow will occur. i2c_cmd.tsize+1 will show amount of not transmitted data. */
/*    In case of master write transfer direction, either the FIFO can be filled and the transfer may be completed (CTC, CT) or the transfer can be broken (rSTART, STOP). */
/*    In case of master read transfer direction, the command will terminate when the FIFO is full. The last read byte will be acknowledged and */
/*    stored in the FIFO. After reading out data from the FIFO the transfer must be completed (CTC, CT) to flag read data end (no acknowledge at last byte). STOP or rSTART */
/*    will fail if next read data MSB is 0 (as the next bit already driven by the slave is 0). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_mdr  0x0000000CU
#define Adr_NX51_i2c0_i2c_mdr 0x1018C6CCU
#define Adr_NX51_i2c1_i2c_mdr 0x1018C70CU
#define DFLT_VAL_NX51_i2c_mdr 0x00000000U

#define MSK_NX51_i2c_mdr_mdata         0x000000ffU
#define SRT_NX51_i2c_mdr_mdata         0
#define DFLT_VAL_NX51_i2c_mdr_mdata    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mdr_mdata 0x00000000U

/* all used bits of 'NX51_i2c_mdr': */
#define MSK_USED_BITS_NX51_i2c_mdr 0x000000ffU

enum {
	BFW_NX51_i2c_mdr_mdata     = 8,  /* [7:0] */
	BFW_NX51_i2c_mdr_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_I2C_MDR_BIT_Ttag {
	unsigned int mdata     : BFW_NX51_i2c_mdr_mdata;     /* I2C master transmit or receive data:                                                                                     */
	                                                     /* Write data will be removed from the FIFO after receiving slave has generated the according acknowledge. Not acknowledged */
	                                                     /* write data will not be removed from the FIFO.                                                                            */
	unsigned int reserved1 : BFW_NX51_i2c_mdr_reserved1; /* reserved                                                                                                                 */
} NX51_I2C_MDR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_I2C_MDR_BIT_T bf;
} NX51_I2C_MDR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_sdr */
/* => I2C slave data register (slave FIFO) */
/*    There is only one FIFO for both, receive and transmit slave data with a depth of 16 bytes. For master read access, data send by the slave */
/*    is delivered from the FIFO, for master write access data received by the slave is stored in the FIFO. */
/*    A transfer is initiated after detection of I2C-start-sequence to the device address (i2c_scr.sid, sreq IRQ) which is acknowledged by this device (i2c_scr.ac_start). For read */
/*    transfers send data is read from the FIFO immediately after acknowledge was detected on the I2C-bus. SDA will be driven with next data MSB immediately after acknowledge SCL high phase. */
/*    In case of master read transfer and slave FIFO underrun, corrupted data will be send to the master and the fifo_err IRQ will be set. */
/*    In case of master write transfer and slave FIFO is full, no acknowledge will be generated for the last received byte. No FIFO overflow will occur but */
/*    the last transferred byte (not acknowledged) will be lost and has to be send again by the master. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_sdr  0x00000010U
#define Adr_NX51_i2c0_i2c_sdr 0x1018C6D0U
#define Adr_NX51_i2c1_i2c_sdr 0x1018C710U
#define DFLT_VAL_NX51_i2c_sdr 0x00000000U

#define MSK_NX51_i2c_sdr_sdata         0x000000ffU
#define SRT_NX51_i2c_sdr_sdata         0
#define DFLT_VAL_NX51_i2c_sdr_sdata    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_sdr_sdata 0x00000000U

/* all used bits of 'NX51_i2c_sdr': */
#define MSK_USED_BITS_NX51_i2c_sdr 0x000000ffU

enum {
	BFW_NX51_i2c_sdr_sdata     = 8,  /* [7:0] */
	BFW_NX51_i2c_sdr_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_I2C_SDR_BIT_Ttag {
	unsigned int sdata     : BFW_NX51_i2c_sdr_sdata;     /* I2C slave transmit or receive data:                                                         */
	                                                     /* i2c_scr.ac_start must be handled correctly by software to avoid FIFO errors after (r)START. */
	unsigned int reserved1 : BFW_NX51_i2c_sdr_reserved1; /* reserved                                                                                    */
} NX51_I2C_SDR_BIT_T;

typedef union {
	unsigned int       val;
	NX51_I2C_SDR_BIT_T bf;
} NX51_I2C_SDR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_mfifo_cr */
/* => I2C master FIFO control register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_mfifo_cr  0x00000014U
#define Adr_NX51_i2c0_i2c_mfifo_cr 0x1018C6D4U
#define Adr_NX51_i2c1_i2c_mfifo_cr 0x1018C714U
#define DFLT_VAL_NX51_i2c_mfifo_cr 0x00000000U

#define MSK_NX51_i2c_mfifo_cr_mfifo_wm          0x0000000fU
#define SRT_NX51_i2c_mfifo_cr_mfifo_wm          0
#define DFLT_VAL_NX51_i2c_mfifo_cr_mfifo_wm     0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mfifo_cr_mfifo_wm  0x00000000U
#define MSK_NX51_i2c_mfifo_cr_mfifo_clr         0x00000100U
#define SRT_NX51_i2c_mfifo_cr_mfifo_clr         8
#define DFLT_VAL_NX51_i2c_mfifo_cr_mfifo_clr    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_mfifo_cr_mfifo_clr 0x00000000U

/* all used bits of 'NX51_i2c_mfifo_cr': */
#define MSK_USED_BITS_NX51_i2c_mfifo_cr 0x0000010fU

enum {
	BFW_NX51_i2c_mfifo_cr_mfifo_wm  = 4,  /* [3:0] */
	BFW_NX51_i2c_mfifo_cr_reserved1 = 4,  /* [7:4] */
	BFW_NX51_i2c_mfifo_cr_mfifo_clr = 1,  /* [8] */
	BFW_NX51_i2c_mfifo_cr_reserved2 = 23  /* [31:9] */
};

typedef struct NX51_I2C_MFIFO_CR_BIT_Ttag {
	unsigned int mfifo_wm  : BFW_NX51_i2c_mfifo_cr_mfifo_wm;  /* Master FIFO watermark for mfifo_req IRQ generation:                                                        */
	                                                          /* If master is transmitter (enabled and nwr==0-command), mfifo_req IRQ is generated if mfifo_level<mfifo_wm. */
	                                                          /* If master is receiver (enabled and nwr==1-command), mfifo_req IRQ is generated if mfifo_level>mfifo_wm.    */
	                                                          /* Setting the watermark to 0 at transfer end avoids further IRQ generation.                                  */
	unsigned int reserved1 : BFW_NX51_i2c_mfifo_cr_reserved1; /* reserved                                                                                                   */
	unsigned int mfifo_clr : BFW_NX51_i2c_mfifo_cr_mfifo_clr; /* Clear master data FIFO, write only bit.                                                                    */
	                                                          /* Note: This bit is writable but can also be changed by hardware.                                            */
	unsigned int reserved2 : BFW_NX51_i2c_mfifo_cr_reserved2; /* reserved                                                                                                   */
} NX51_I2C_MFIFO_CR_BIT_T;

typedef union {
	unsigned int            val;
	NX51_I2C_MFIFO_CR_BIT_T bf;
} NX51_I2C_MFIFO_CR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_sfifo_cr */
/* => I2C slave FIFO control register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_sfifo_cr  0x00000018U
#define Adr_NX51_i2c0_i2c_sfifo_cr 0x1018C6D8U
#define Adr_NX51_i2c1_i2c_sfifo_cr 0x1018C718U
#define DFLT_VAL_NX51_i2c_sfifo_cr 0x00000000U

#define MSK_NX51_i2c_sfifo_cr_sfifo_wm          0x0000000fU
#define SRT_NX51_i2c_sfifo_cr_sfifo_wm          0
#define DFLT_VAL_NX51_i2c_sfifo_cr_sfifo_wm     0x00000000U
#define DFLT_BF_VAL_NX51_i2c_sfifo_cr_sfifo_wm  0x00000000U
#define MSK_NX51_i2c_sfifo_cr_sfifo_clr         0x00000100U
#define SRT_NX51_i2c_sfifo_cr_sfifo_clr         8
#define DFLT_VAL_NX51_i2c_sfifo_cr_sfifo_clr    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_sfifo_cr_sfifo_clr 0x00000000U

/* all used bits of 'NX51_i2c_sfifo_cr': */
#define MSK_USED_BITS_NX51_i2c_sfifo_cr 0x0000010fU

enum {
	BFW_NX51_i2c_sfifo_cr_sfifo_wm  = 4,  /* [3:0] */
	BFW_NX51_i2c_sfifo_cr_reserved1 = 4,  /* [7:4] */
	BFW_NX51_i2c_sfifo_cr_sfifo_clr = 1,  /* [8] */
	BFW_NX51_i2c_sfifo_cr_reserved2 = 23  /* [31:9] */
};

typedef struct NX51_I2C_SFIFO_CR_BIT_Ttag {
	unsigned int sfifo_wm  : BFW_NX51_i2c_sfifo_cr_sfifo_wm;  /* Slave FIFO Watermark for sfifo_req IRQ generation:                                                                                             */
	                                                          /* If slave is transmitter (start sequence with set read bit was acknowledged by this slave), sfifo_req IRQ is generated if sfifo_level<sfifo_wm. */
	                                                          /* If slave is not transmitter (is receiver or not selected), sfifo_req IRQ is generated if sfifo_level>sfifo_wm                                  */
	unsigned int reserved1 : BFW_NX51_i2c_sfifo_cr_reserved1; /* reserved                                                                                                                                       */
	unsigned int sfifo_clr : BFW_NX51_i2c_sfifo_cr_sfifo_clr; /* Clear slave data FIFO, write only bit.                                                                                                         */
	                                                          /* Note: This bit is writable but can also be changed by hardware.                                                                                */
	unsigned int reserved2 : BFW_NX51_i2c_sfifo_cr_reserved2; /* reserved                                                                                                                                       */
} NX51_I2C_SFIFO_CR_BIT_T;

typedef union {
	unsigned int            val;
	NX51_I2C_SFIFO_CR_BIT_T bf;
} NX51_I2C_SFIFO_CR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_sr */
/* => read only I2C status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_sr  0x0000001CU
#define Adr_NX51_i2c0_i2c_sr 0x1018C6DCU
#define Adr_NX51_i2c1_i2c_sr 0x1018C71CU

#define MSK_NX51_i2c_sr_mfifo_level    0x0000001fU
#define SRT_NX51_i2c_sr_mfifo_level    0
#define MSK_NX51_i2c_sr_mfifo_empty    0x00000040U
#define SRT_NX51_i2c_sr_mfifo_empty    6
#define MSK_NX51_i2c_sr_mfifo_full     0x00000080U
#define SRT_NX51_i2c_sr_mfifo_full     7
#define MSK_NX51_i2c_sr_mfifo_err_ovfl 0x00000100U
#define SRT_NX51_i2c_sr_mfifo_err_ovfl 8
#define MSK_NX51_i2c_sr_mfifo_err_undr 0x00000200U
#define SRT_NX51_i2c_sr_mfifo_err_undr 9
#define MSK_NX51_i2c_sr_sfifo_level    0x00007c00U
#define SRT_NX51_i2c_sr_sfifo_level    10
#define MSK_NX51_i2c_sr_sfifo_empty    0x00010000U
#define SRT_NX51_i2c_sr_sfifo_empty    16
#define MSK_NX51_i2c_sr_sfifo_full     0x00020000U
#define SRT_NX51_i2c_sr_sfifo_full     17
#define MSK_NX51_i2c_sr_sfifo_err_ovfl 0x00040000U
#define SRT_NX51_i2c_sr_sfifo_err_ovfl 18
#define MSK_NX51_i2c_sr_sfifo_err_undr 0x00080000U
#define SRT_NX51_i2c_sr_sfifo_err_undr 19
#define MSK_NX51_i2c_sr_bus_master     0x00100000U
#define SRT_NX51_i2c_sr_bus_master     20
#define MSK_NX51_i2c_sr_nwr            0x00200000U
#define SRT_NX51_i2c_sr_nwr            21
#define MSK_NX51_i2c_sr_started        0x00400000U
#define SRT_NX51_i2c_sr_started        22
#define MSK_NX51_i2c_sr_slave_access   0x00800000U
#define SRT_NX51_i2c_sr_slave_access   23
#define MSK_NX51_i2c_sr_last_ac        0x01000000U
#define SRT_NX51_i2c_sr_last_ac        24
#define MSK_NX51_i2c_sr_nwr_aced       0x02000000U
#define SRT_NX51_i2c_sr_nwr_aced       25
#define MSK_NX51_i2c_sr_gcall_aced     0x04000000U
#define SRT_NX51_i2c_sr_gcall_aced     26
#define MSK_NX51_i2c_sr_sid10_aced     0x08000000U
#define SRT_NX51_i2c_sr_sid10_aced     27
#define MSK_NX51_i2c_sr_scl_state      0x40000000U
#define SRT_NX51_i2c_sr_scl_state      30
#define MSK_NX51_i2c_sr_sda_state      0x80000000U
#define SRT_NX51_i2c_sr_sda_state      31

/* all used bits of 'NX51_i2c_sr': */
#define MSK_USED_BITS_NX51_i2c_sr 0xcfff7fdfU

enum {
	BFW_NX51_i2c_sr_mfifo_level    = 5, /* [4:0] */
	BFW_NX51_i2c_sr_reserved1      = 1, /* [5] */
	BFW_NX51_i2c_sr_mfifo_empty    = 1, /* [6] */
	BFW_NX51_i2c_sr_mfifo_full     = 1, /* [7] */
	BFW_NX51_i2c_sr_mfifo_err_ovfl = 1, /* [8] */
	BFW_NX51_i2c_sr_mfifo_err_undr = 1, /* [9] */
	BFW_NX51_i2c_sr_sfifo_level    = 5, /* [14:10] */
	BFW_NX51_i2c_sr_reserved2      = 1, /* [15] */
	BFW_NX51_i2c_sr_sfifo_empty    = 1, /* [16] */
	BFW_NX51_i2c_sr_sfifo_full     = 1, /* [17] */
	BFW_NX51_i2c_sr_sfifo_err_ovfl = 1, /* [18] */
	BFW_NX51_i2c_sr_sfifo_err_undr = 1, /* [19] */
	BFW_NX51_i2c_sr_bus_master     = 1, /* [20] */
	BFW_NX51_i2c_sr_nwr            = 1, /* [21] */
	BFW_NX51_i2c_sr_started        = 1, /* [22] */
	BFW_NX51_i2c_sr_slave_access   = 1, /* [23] */
	BFW_NX51_i2c_sr_last_ac        = 1, /* [24] */
	BFW_NX51_i2c_sr_nwr_aced       = 1, /* [25] */
	BFW_NX51_i2c_sr_gcall_aced     = 1, /* [26] */
	BFW_NX51_i2c_sr_sid10_aced     = 1, /* [27] */
	BFW_NX51_i2c_sr_reserved3      = 2, /* [29:28] */
	BFW_NX51_i2c_sr_scl_state      = 1, /* [30] */
	BFW_NX51_i2c_sr_sda_state      = 1  /* [31] */
};

typedef struct NX51_I2C_SR_BIT_Ttag {
	unsigned int mfifo_level    : BFW_NX51_i2c_sr_mfifo_level;    /* master FIFO level  (0..16)                                                                                                 */
	unsigned int reserved1      : BFW_NX51_i2c_sr_reserved1;      /* reserved                                                                                                                   */
	unsigned int mfifo_empty    : BFW_NX51_i2c_sr_mfifo_empty;    /* master FIFO is empty (1 if empty)                                                                                          */
	unsigned int mfifo_full     : BFW_NX51_i2c_sr_mfifo_full;     /* master FIFO is full (1 if full)                                                                                            */
	unsigned int mfifo_err_ovfl : BFW_NX51_i2c_sr_mfifo_err_ovfl; /* master FIFO overflow error occurred, data is lost                                                                          */
	unsigned int mfifo_err_undr : BFW_NX51_i2c_sr_mfifo_err_undr; /* master FIFO underrun error occurred, data is lost                                                                          */
	unsigned int sfifo_level    : BFW_NX51_i2c_sr_sfifo_level;    /* slave FIFO level (0..16)                                                                                                   */
	unsigned int reserved2      : BFW_NX51_i2c_sr_reserved2;      /* reserved                                                                                                                   */
	unsigned int sfifo_empty    : BFW_NX51_i2c_sr_sfifo_empty;    /* slave FIFO is empty (1 if empty)                                                                                           */
	unsigned int sfifo_full     : BFW_NX51_i2c_sr_sfifo_full;     /* slave FIFO is full (1 if full)                                                                                             */
	unsigned int sfifo_err_ovfl : BFW_NX51_i2c_sr_sfifo_err_ovfl; /* slave FIFO overflow error occurred, data is lost                                                                           */
	unsigned int sfifo_err_undr : BFW_NX51_i2c_sr_sfifo_err_undr; /* slave FIFO underrun error occurred, data is lost                                                                           */
	unsigned int bus_master     : BFW_NX51_i2c_sr_bus_master;     /* Status: Master side of this module is master of I2C bus.                                                                   */
	                                                              /* 0: Master lost bus arbitration, bus is busy by another master.                                                             */
	                                                              /* 1: Master gains bus arbitration or bus is idle.                                                                            */
	                                                              /* For multi-master purpose this detection is also done, if this device is not enabled to get current bus state after enable. */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int nwr            : BFW_NX51_i2c_sr_nwr;            /* Transfer direction detected after last (s)START.                                                                           */
	                                                              /* 0: write                                                                                                                   */
	                                                              /* 1: read.                                                                                                                   */
	                                                              /* This bit is reset to 0 during START and does not care for slave acknowledge.                                               */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int started        : BFW_NX51_i2c_sr_started;        /* START condition detection:                                                                                                 */
	                                                              /* 0: bus is idle (Stop was detected, not started).                                                                           */
	                                                              /* 1: (r)START was detected on bus.                                                                                           */
	                                                              /* For multi-master purpose this detection is also done, if this device is not enabled to get current bus state after enable. */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int slave_access   : BFW_NX51_i2c_sr_slave_access;   /* 0: No slave access on this device (reset at START or STOP).                                                                */
	                                                              /* 1: A master addressed this slave device (set if start-byte with address matching this slave).                              */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int last_ac        : BFW_NX51_i2c_sr_last_ac;        /* Last acknowledge detected on bus:                                                                                          */
	                                                              /* 0: SDA was high i.e no acknowledge.                                                                                        */
	                                                              /* 1: SDA was low i.e acknowledge).                                                                                           */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int nwr_aced       : BFW_NX51_i2c_sr_nwr_aced;       /* Last transfer direction (nwr-bit during start-byte with address matching this slave) acknowledged by this slave to handle  */
	                                                              /* slave FIFO (0: write; 1: read). Slave FIFO-requests (IRQ and DMA) are generated depending this direction flag              */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int gcall_aced     : BFW_NX51_i2c_sr_gcall_aced;     /* Received General Call was acknowledged (General Call was done and i2c_scr.ac_gcall is set).                                */
	                                                              /* 0: SDA was high i.e no acknowledge.                                                                                        */
	                                                              /* 1: SDA was low i.e acknowledge).                                                                                           */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int sid10_aced     : BFW_NX51_i2c_sr_sid10_aced;     /* Master detected that a 10-bit addressed slave acknowledge the 2-byte start sequence. Master will generate                  */
	                                                              /* only first START-byte during rSTART.                                                                                       */
	                                                              /* 0: SDA was high i.e no acknowledge.                                                                                        */
	                                                              /* 1: SDA was low i.e acknowledge).                                                                                           */
	                                                              /* This status bit will be cleared when an module reset by 'i2c_mcr.rst_i2c' bit is performed.                                */
	unsigned int reserved3      : BFW_NX51_i2c_sr_reserved3;      /* reserved                                                                                                                   */
	unsigned int scl_state      : BFW_NX51_i2c_sr_scl_state;      /* SCL signal state sampled and filtered from bus (e.g. to detect bus blockings)                                              */
	unsigned int sda_state      : BFW_NX51_i2c_sr_sda_state;      /* SDA signal state sampled and filtered from bus (e.g. to detect bus blockings)                                              */
} NX51_I2C_SR_BIT_T;

typedef union {
	unsigned int      val;
	NX51_I2C_SR_BIT_T bf;
} NX51_I2C_SR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_irqmsk */
/* => I2C interrupt mask set or clear register */
/*    These bits have AND-mask character (only if mask bit is set, the appropriate IRQ generates the module IRQ). Enabling (writing '1' and */
/*    prior mask was "0") will clear according raw IRQ-state if it was set before. */
/*    For detailed IRQ-description view i2c_irqraw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_irqmsk  0x00000020U
#define Adr_NX51_i2c0_i2c_irqmsk 0x1018C6E0U
#define Adr_NX51_i2c1_i2c_irqmsk 0x1018C720U
#define DFLT_VAL_NX51_i2c_irqmsk 0x00000000U

#define MSK_NX51_i2c_irqmsk_cmd_ok            0x00000001U
#define SRT_NX51_i2c_irqmsk_cmd_ok            0
#define DFLT_VAL_NX51_i2c_irqmsk_cmd_ok       0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqmsk_cmd_ok    0x00000000U
#define MSK_NX51_i2c_irqmsk_cmd_err           0x00000002U
#define SRT_NX51_i2c_irqmsk_cmd_err           1
#define DFLT_VAL_NX51_i2c_irqmsk_cmd_err      0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqmsk_cmd_err   0x00000000U
#define MSK_NX51_i2c_irqmsk_fifo_err          0x00000004U
#define SRT_NX51_i2c_irqmsk_fifo_err          2
#define DFLT_VAL_NX51_i2c_irqmsk_fifo_err     0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqmsk_fifo_err  0x00000000U
#define MSK_NX51_i2c_irqmsk_bus_busy          0x00000008U
#define SRT_NX51_i2c_irqmsk_bus_busy          3
#define DFLT_VAL_NX51_i2c_irqmsk_bus_busy     0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqmsk_bus_busy  0x00000000U
#define MSK_NX51_i2c_irqmsk_mfifo_req         0x00000010U
#define SRT_NX51_i2c_irqmsk_mfifo_req         4
#define DFLT_VAL_NX51_i2c_irqmsk_mfifo_req    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqmsk_mfifo_req 0x00000000U
#define MSK_NX51_i2c_irqmsk_sfifo_req         0x00000020U
#define SRT_NX51_i2c_irqmsk_sfifo_req         5
#define DFLT_VAL_NX51_i2c_irqmsk_sfifo_req    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqmsk_sfifo_req 0x00000000U
#define MSK_NX51_i2c_irqmsk_sreq              0x00000040U
#define SRT_NX51_i2c_irqmsk_sreq              6
#define DFLT_VAL_NX51_i2c_irqmsk_sreq         0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqmsk_sreq      0x00000000U

/* all used bits of 'NX51_i2c_irqmsk': */
#define MSK_USED_BITS_NX51_i2c_irqmsk 0x0000007fU

enum {
	BFW_NX51_i2c_irqmsk_cmd_ok    = 1,  /* [0] */
	BFW_NX51_i2c_irqmsk_cmd_err   = 1,  /* [1] */
	BFW_NX51_i2c_irqmsk_fifo_err  = 1,  /* [2] */
	BFW_NX51_i2c_irqmsk_bus_busy  = 1,  /* [3] */
	BFW_NX51_i2c_irqmsk_mfifo_req = 1,  /* [4] */
	BFW_NX51_i2c_irqmsk_sfifo_req = 1,  /* [5] */
	BFW_NX51_i2c_irqmsk_sreq      = 1,  /* [6] */
	BFW_NX51_i2c_irqmsk_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_I2C_IRQMSK_BIT_Ttag {
	unsigned int cmd_ok    : BFW_NX51_i2c_irqmsk_cmd_ok;    /* Command OK interrupt mask.                 */
	unsigned int cmd_err   : BFW_NX51_i2c_irqmsk_cmd_err;   /* Command error interrupt mask.              */
	unsigned int fifo_err  : BFW_NX51_i2c_irqmsk_fifo_err;  /* FIFO error interrupt mask.                 */
	unsigned int bus_busy  : BFW_NX51_i2c_irqmsk_bus_busy;  /* External I2C-bus is busy interrupt mask.   */
	unsigned int mfifo_req : BFW_NX51_i2c_irqmsk_mfifo_req; /* Master FIFO action request interrupt mask. */
	unsigned int sfifo_req : BFW_NX51_i2c_irqmsk_sfifo_req; /* Slave FIFO action request interrupt mask.  */
	unsigned int sreq      : BFW_NX51_i2c_irqmsk_sreq;      /* Slave request interrupt mask.              */
	unsigned int reserved1 : BFW_NX51_i2c_irqmsk_reserved1; /* reserved                                   */
} NX51_I2C_IRQMSK_BIT_T;

typedef union {
	unsigned int          val;
	NX51_I2C_IRQMSK_BIT_T bf;
} NX51_I2C_IRQMSK_T;

/* --------------------------------------------------------------------- */
/* Register i2c_irqsr */
/* => I2C interrupt state register (raw interrupt before masking) */
/*    Writing '1' will clear according IRQ. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_irqsr  0x00000024U
#define Adr_NX51_i2c0_i2c_irqsr 0x1018C6E4U
#define Adr_NX51_i2c1_i2c_irqsr 0x1018C724U
#define DFLT_VAL_NX51_i2c_irqsr 0x00000000U

#define MSK_NX51_i2c_irqsr_cmd_ok            0x00000001U
#define SRT_NX51_i2c_irqsr_cmd_ok            0
#define DFLT_VAL_NX51_i2c_irqsr_cmd_ok       0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqsr_cmd_ok    0x00000000U
#define MSK_NX51_i2c_irqsr_cmd_err           0x00000002U
#define SRT_NX51_i2c_irqsr_cmd_err           1
#define DFLT_VAL_NX51_i2c_irqsr_cmd_err      0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqsr_cmd_err   0x00000000U
#define MSK_NX51_i2c_irqsr_fifo_err          0x00000004U
#define SRT_NX51_i2c_irqsr_fifo_err          2
#define DFLT_VAL_NX51_i2c_irqsr_fifo_err     0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqsr_fifo_err  0x00000000U
#define MSK_NX51_i2c_irqsr_bus_busy          0x00000008U
#define SRT_NX51_i2c_irqsr_bus_busy          3
#define DFLT_VAL_NX51_i2c_irqsr_bus_busy     0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqsr_bus_busy  0x00000000U
#define MSK_NX51_i2c_irqsr_mfifo_req         0x00000010U
#define SRT_NX51_i2c_irqsr_mfifo_req         4
#define DFLT_VAL_NX51_i2c_irqsr_mfifo_req    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqsr_mfifo_req 0x00000000U
#define MSK_NX51_i2c_irqsr_sfifo_req         0x00000020U
#define SRT_NX51_i2c_irqsr_sfifo_req         5
#define DFLT_VAL_NX51_i2c_irqsr_sfifo_req    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqsr_sfifo_req 0x00000000U
#define MSK_NX51_i2c_irqsr_sreq              0x00000040U
#define SRT_NX51_i2c_irqsr_sreq              6
#define DFLT_VAL_NX51_i2c_irqsr_sreq         0x00000000U
#define DFLT_BF_VAL_NX51_i2c_irqsr_sreq      0x00000000U

/* all used bits of 'NX51_i2c_irqsr': */
#define MSK_USED_BITS_NX51_i2c_irqsr 0x0000007fU

enum {
	BFW_NX51_i2c_irqsr_cmd_ok    = 1,  /* [0] */
	BFW_NX51_i2c_irqsr_cmd_err   = 1,  /* [1] */
	BFW_NX51_i2c_irqsr_fifo_err  = 1,  /* [2] */
	BFW_NX51_i2c_irqsr_bus_busy  = 1,  /* [3] */
	BFW_NX51_i2c_irqsr_mfifo_req = 1,  /* [4] */
	BFW_NX51_i2c_irqsr_sfifo_req = 1,  /* [5] */
	BFW_NX51_i2c_irqsr_sreq      = 1,  /* [6] */
	BFW_NX51_i2c_irqsr_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_I2C_IRQSR_BIT_Ttag {
	unsigned int cmd_ok    : BFW_NX51_i2c_irqsr_cmd_ok;    /* Unmasked command OK interrupt state:                                                                                */
	                                                       /* Purpose: check last command termination.                                                                            */
	                                                       /* 1: last command finished successfully.                                                                              */
	                                                       /* 0: command not finished, no command or command finished erroneous.                                                  */
	unsigned int cmd_err   : BFW_NX51_i2c_irqsr_cmd_err;   /* Unmasked command error interrupt state:                                                                             */
	                                                       /* Purpose: check last command termination.                                                                            */
	                                                       /* 1: last command finished erroneous.                                                                                 */
	                                                       /* 0: command not finished, no command or command finished successfully.                                               */
	unsigned int fifo_err  : BFW_NX51_i2c_irqsr_fifo_err;  /* Unmasked FIFO error interrupt state:                                                                                */
	                                                       /* Purpose: detect FIFO errors/transfer failures.                                                                      */
	                                                       /* 1: FIFO error occurred, check i2c_sr for details.                                                                   */
	                                                       /* 0: FIFOs ok.                                                                                                        */
	unsigned int bus_busy  : BFW_NX51_i2c_irqsr_bus_busy;  /* Unmasked external I2C-bus is busy interrupt state:                                                                  */
	                                                       /* Purpose: detect I2C-bus arbitration loss.                                                                           */
	                                                       /* 1: master did not gain requested bus access due to another master accessing the bus.                                */
	                                                       /* 0: bus is idle or no transfer is requested by this master.                                                          */
	unsigned int mfifo_req : BFW_NX51_i2c_irqsr_mfifo_req; /* Unmasked master FIFO action request interrupt state:                                                                */
	                                                       /* Purpose: master FIFO should be updated.                                                                             */
	                                                       /* 1: master FIFO request: i2c_sr.mfifo_level is above or below i2c_mfifo_cr.mfifo_wm (view description i2c_mfifo_cr). */
	                                                       /* 0: master FIFO state not critical                                                                                   */
	unsigned int sfifo_req : BFW_NX51_i2c_irqsr_sfifo_req; /* Unmasked slave FIFO action request interrupt state:                                                                 */
	                                                       /* Purpose: slave FIFO should be updated.                                                                              */
	                                                       /* 1: slave FIFO request: i2c_sr.sfifo_level is above or below i2c_sfifo_cr.sfifo_wm (view description i2c_sfifo_cr).  */
	                                                       /* 0: slave FIFO state not critical                                                                                    */
	unsigned int sreq      : BFW_NX51_i2c_irqsr_sreq;      /* Unmasked slave request interrupt state:                                                                             */
	                                                       /* Purpose: set up slave FIFO.                                                                                         */
	                                                       /* 1: external master was running START-sequence and requested this slave.                                             */
	                                                       /* 0: slave is not requested.                                                                                          */
	unsigned int reserved1 : BFW_NX51_i2c_irqsr_reserved1; /* reserved                                                                                                            */
} NX51_I2C_IRQSR_BIT_T;

typedef union {
	unsigned int         val;
	NX51_I2C_IRQSR_BIT_T bf;
} NX51_I2C_IRQSR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_irqmsked */
/* => read only I2C masked interrupt state register */
/*    If one of these bits is set, the I2C IRQ will be asserted to the Interrupt-Controller. */
/*    For detailed IRQ-description view i2c_irqraw. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_irqmsked  0x00000028U
#define Adr_NX51_i2c0_i2c_irqmsked 0x1018C6E8U
#define Adr_NX51_i2c1_i2c_irqmsked 0x1018C728U

#define MSK_NX51_i2c_irqmsked_cmd_ok    0x00000001U
#define SRT_NX51_i2c_irqmsked_cmd_ok    0
#define MSK_NX51_i2c_irqmsked_cmd_err   0x00000002U
#define SRT_NX51_i2c_irqmsked_cmd_err   1
#define MSK_NX51_i2c_irqmsked_fifo_err  0x00000004U
#define SRT_NX51_i2c_irqmsked_fifo_err  2
#define MSK_NX51_i2c_irqmsked_bus_busy  0x00000008U
#define SRT_NX51_i2c_irqmsked_bus_busy  3
#define MSK_NX51_i2c_irqmsked_mfifo_req 0x00000010U
#define SRT_NX51_i2c_irqmsked_mfifo_req 4
#define MSK_NX51_i2c_irqmsked_sfifo_req 0x00000020U
#define SRT_NX51_i2c_irqmsked_sfifo_req 5
#define MSK_NX51_i2c_irqmsked_sreq      0x00000040U
#define SRT_NX51_i2c_irqmsked_sreq      6

/* all used bits of 'NX51_i2c_irqmsked': */
#define MSK_USED_BITS_NX51_i2c_irqmsked 0x0000007fU

enum {
	BFW_NX51_i2c_irqmsked_cmd_ok    = 1,  /* [0] */
	BFW_NX51_i2c_irqmsked_cmd_err   = 1,  /* [1] */
	BFW_NX51_i2c_irqmsked_fifo_err  = 1,  /* [2] */
	BFW_NX51_i2c_irqmsked_bus_busy  = 1,  /* [3] */
	BFW_NX51_i2c_irqmsked_mfifo_req = 1,  /* [4] */
	BFW_NX51_i2c_irqmsked_sfifo_req = 1,  /* [5] */
	BFW_NX51_i2c_irqmsked_sreq      = 1,  /* [6] */
	BFW_NX51_i2c_irqmsked_reserved1 = 25  /* [31:7] */
};

typedef struct NX51_I2C_IRQMSKED_BIT_Ttag {
	unsigned int cmd_ok    : BFW_NX51_i2c_irqmsked_cmd_ok;    /* Masked command OK interrupt state.                 */
	unsigned int cmd_err   : BFW_NX51_i2c_irqmsked_cmd_err;   /* Masked command error interrupt state.              */
	unsigned int fifo_err  : BFW_NX51_i2c_irqmsked_fifo_err;  /* Masked FIFO error interrupt state.                 */
	unsigned int bus_busy  : BFW_NX51_i2c_irqmsked_bus_busy;  /* Masked external I2C-bus is busy interrupt state.   */
	unsigned int mfifo_req : BFW_NX51_i2c_irqmsked_mfifo_req; /* Masked master FIFO action request interrupt state. */
	unsigned int sfifo_req : BFW_NX51_i2c_irqmsked_sfifo_req; /* Masked slave FIFO action request interrupt state.  */
	unsigned int sreq      : BFW_NX51_i2c_irqmsked_sreq;      /* Masked slave request interrupt state.              */
	unsigned int reserved1 : BFW_NX51_i2c_irqmsked_reserved1; /* reserved                                           */
} NX51_I2C_IRQMSKED_BIT_T;

typedef union {
	unsigned int            val;
	NX51_I2C_IRQMSKED_BIT_T bf;
} NX51_I2C_IRQMSKED_T;

/* --------------------------------------------------------------------- */
/* Register i2c_dmacr */
/* => I2C DMA control register */
/*    DMA transfer size to/from I2C-module: byte. */
/*    DMA burst length to/from I2C-module: 4. */
/*    DMA burst requests are generated if the according FIFO contains more than 4 bytes (receive case), or if */
/*    there are more than 4 bytes writable to the according FIFO (transmit case). */
/*    DMA single transfer requests are generated if the according FIFO contains more than 1 byte (receive case), or if */
/*    there is more than 1 byte writable to the according FIFO (transmit case). */
/*    No further DMA requests will be generated if all transmit data was written to the master FIFO and flowcontrolling */
/*    is done by this module (for master data only). Once all data is written */
/*    to the master FIFO last burst/single request is generated for the DMA controller. */
/*    If the DMA-Controller flags transfer end by setting DMACTC (terminal count) the appropriate bit will be cleared. */
/*    If one of the bits of this register is set to 0 by software and a dma-transfer was requested before, one last */
/*    transfer will be done by the DMA-Controller to reset DMA-request signals. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_dmacr  0x0000002CU
#define Adr_NX51_i2c0_i2c_dmacr 0x1018C6ECU
#define Adr_NX51_i2c1_i2c_dmacr 0x1018C72CU
#define DFLT_VAL_NX51_i2c_dmacr 0x00000000U

#define MSK_NX51_i2c_dmacr_mdmas_en         0x00000001U
#define SRT_NX51_i2c_dmacr_mdmas_en         0
#define DFLT_VAL_NX51_i2c_dmacr_mdmas_en    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_dmacr_mdmas_en 0x00000000U
#define MSK_NX51_i2c_dmacr_mdmab_en         0x00000002U
#define SRT_NX51_i2c_dmacr_mdmab_en         1
#define DFLT_VAL_NX51_i2c_dmacr_mdmab_en    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_dmacr_mdmab_en 0x00000000U
#define MSK_NX51_i2c_dmacr_sdmas_en         0x00000004U
#define SRT_NX51_i2c_dmacr_sdmas_en         2
#define DFLT_VAL_NX51_i2c_dmacr_sdmas_en    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_dmacr_sdmas_en 0x00000000U
#define MSK_NX51_i2c_dmacr_sdmab_en         0x00000008U
#define SRT_NX51_i2c_dmacr_sdmab_en         3
#define DFLT_VAL_NX51_i2c_dmacr_sdmab_en    0x00000000U
#define DFLT_BF_VAL_NX51_i2c_dmacr_sdmab_en 0x00000000U

/* all used bits of 'NX51_i2c_dmacr': */
#define MSK_USED_BITS_NX51_i2c_dmacr 0x0000000fU

enum {
	BFW_NX51_i2c_dmacr_mdmas_en  = 1,  /* [0] */
	BFW_NX51_i2c_dmacr_mdmab_en  = 1,  /* [1] */
	BFW_NX51_i2c_dmacr_sdmas_en  = 1,  /* [2] */
	BFW_NX51_i2c_dmacr_sdmab_en  = 1,  /* [3] */
	BFW_NX51_i2c_dmacr_reserved1 = 28  /* [31:4] */
};

typedef struct NX51_I2C_DMACR_BIT_Ttag {
	unsigned int mdmas_en  : BFW_NX51_i2c_dmacr_mdmas_en;  /* Enable DMA single requests for I2C master data.                                                              */
	                                                       /* Flowcontrolling may be done my DMA-Controller or by I2C-controller controlled by decrementing i2c_cmd.tsize  */
	                                                       /* Note: This bit is writable but can also be changed by hardware.                                              */
	unsigned int mdmab_en  : BFW_NX51_i2c_dmacr_mdmab_en;  /* Enable DMA burst requests for I2C master data.                                                               */
	                                                       /* Note: This bit is writable but can also be changed by hardware.                                              */
	                                                       /* Flowcontrolling may be done my DMA-Controller or by I2C-controller controlled by decrementing i2c_cmd.tsize. */
	unsigned int sdmas_en  : BFW_NX51_i2c_dmacr_sdmas_en;  /* Enable DMA single requests for I2C slave data.                                                               */
	                                                       /* Flowcontrolling must be done my DMA-Controller.                                                              */
	                                                       /* Note: This bit is writable but can also be changed by hardware.                                              */
	unsigned int sdmab_en  : BFW_NX51_i2c_dmacr_sdmab_en;  /* Enable DMA burst requests for I2C slave data.                                                                */
	                                                       /* Flowcontrolling must be done my DMA-Controller.                                                              */
	                                                       /* Note: This bit is writable but can also be changed by hardware.                                              */
	unsigned int reserved1 : BFW_NX51_i2c_dmacr_reserved1; /* reserved                                                                                                     */
} NX51_I2C_DMACR_BIT_T;

typedef union {
	unsigned int         val;
	NX51_I2C_DMACR_BIT_T bf;
} NX51_I2C_DMACR_T;

/* --------------------------------------------------------------------- */
/* Register i2c_pio */
/* => direct i2c IO access controlling. */
/*    The i2c signals SCL and SDA can be directly controlled by this register if in i2c_mcr-register pio_mode is enabled. */
/*    In pio-mode the I2C-controller statemachine is disabled, so no FIFO-action is done no IRQs occure and no DMA-controlling is possible. */
/*    Warning: i2c-signals SCL and SDA are never driven active high by i2c specification. High-level should be done by pad pullup and setting */
/*    the appropriate output enable to 0 (scl_oe, sda_oe) instead of active high level driving to avoid external driving conflicts. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_i2c_pio  0x00000030U
#define Adr_NX51_i2c0_i2c_pio 0x1018C6F0U
#define Adr_NX51_i2c1_i2c_pio 0x1018C730U
#define DFLT_VAL_NX51_i2c_pio 0x00000044U

#define MSK_NX51_i2c_pio_scl_out           0x00000001U
#define SRT_NX51_i2c_pio_scl_out           0
#define DFLT_VAL_NX51_i2c_pio_scl_out      0x00000000U
#define DFLT_BF_VAL_NX51_i2c_pio_scl_out   0x00000000U
#define MSK_NX51_i2c_pio_scl_oe            0x00000002U
#define SRT_NX51_i2c_pio_scl_oe            1
#define DFLT_VAL_NX51_i2c_pio_scl_oe       0x00000000U
#define DFLT_BF_VAL_NX51_i2c_pio_scl_oe    0x00000000U
#define MSK_NX51_i2c_pio_scl_in_ro         0x00000004U
#define SRT_NX51_i2c_pio_scl_in_ro         2
#define DFLT_VAL_NX51_i2c_pio_scl_in_ro    0x00000004U
#define DFLT_BF_VAL_NX51_i2c_pio_scl_in_ro 0x00000001U
#define MSK_NX51_i2c_pio_sda_out           0x00000010U
#define SRT_NX51_i2c_pio_sda_out           4
#define DFLT_VAL_NX51_i2c_pio_sda_out      0x00000000U
#define DFLT_BF_VAL_NX51_i2c_pio_sda_out   0x00000000U
#define MSK_NX51_i2c_pio_sda_oe            0x00000020U
#define SRT_NX51_i2c_pio_sda_oe            5
#define DFLT_VAL_NX51_i2c_pio_sda_oe       0x00000000U
#define DFLT_BF_VAL_NX51_i2c_pio_sda_oe    0x00000000U
#define MSK_NX51_i2c_pio_sda_in_ro         0x00000040U
#define SRT_NX51_i2c_pio_sda_in_ro         6
#define DFLT_VAL_NX51_i2c_pio_sda_in_ro    0x00000040U
#define DFLT_BF_VAL_NX51_i2c_pio_sda_in_ro 0x00000001U

/* all used bits of 'NX51_i2c_pio': */
#define MSK_USED_BITS_NX51_i2c_pio 0x00000077U

enum {
	BFW_NX51_i2c_pio_scl_out   = 1,  /* [0] */
	BFW_NX51_i2c_pio_scl_oe    = 1,  /* [1] */
	BFW_NX51_i2c_pio_scl_in_ro = 1,  /* [2] */
	BFW_NX51_i2c_pio_reserved1 = 1,  /* [3] */
	BFW_NX51_i2c_pio_sda_out   = 1,  /* [4] */
	BFW_NX51_i2c_pio_sda_oe    = 1,  /* [5] */
	BFW_NX51_i2c_pio_sda_in_ro = 1,  /* [6] */
	BFW_NX51_i2c_pio_reserved2 = 25  /* [31:7] */
};

typedef struct NX51_I2C_PIO_BIT_Ttag {
	unsigned int scl_out   : BFW_NX51_i2c_pio_scl_out;   /* driving level (1: high, 0: low) of SCL if output is enabled (scl_oe is set) */
	unsigned int scl_oe    : BFW_NX51_i2c_pio_scl_oe;    /* SCL output enable                                                           */
	                                                     /*  0: dont drive SCL, switch pad to highZ.                                    */
	                                                     /*  1: drive SCL, switch pad to programmed scl_out-state                       */
	unsigned int scl_in_ro : BFW_NX51_i2c_pio_scl_in_ro; /* SCL input state (read only)                                                 */
	unsigned int reserved1 : BFW_NX51_i2c_pio_reserved1; /* reserved                                                                    */
	unsigned int sda_out   : BFW_NX51_i2c_pio_sda_out;   /* driving level (1: high, 0: low) of SDA if output is enabled (sda_oe is set) */
	unsigned int sda_oe    : BFW_NX51_i2c_pio_sda_oe;    /* SDA output enable                                                           */
	                                                     /*  0: don't drive SDA, switch pad to highZ.                                   */
	                                                     /*  1: drive SDA, switch pad to programmed sda_out-state                       */
	unsigned int sda_in_ro : BFW_NX51_i2c_pio_sda_in_ro; /* SDA input state (read only)                                                 */
	unsigned int reserved2 : BFW_NX51_i2c_pio_reserved2; /* reserved                                                                    */
} NX51_I2C_PIO_BIT_T;

typedef union {
	unsigned int       val;
	NX51_I2C_PIO_BIT_T bf;
} NX51_I2C_PIO_T;


/* ===================================================================== */

/* Area of parity */

/* ===================================================================== */

#define Addr_NX51_parity 0x1018C740U

/* --------------------------------------------------------------------- */
/* Register parity_enable */
/* => Enable Bits for different Intram areas */
/*    When bit is set the parity error detection is enabled. I.e. in case of parity failure the parity-interrupt */
/*    will be asserted to ARM and the access address and master will be logged inside the 'parity_error_access' register. */
/*    The IRQ generation does not depend on accessing (parity error generating) master. E.g. ARM will */
/*    receive IRQ when parity failure is result of an xPIC access. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_enable    0x00000000U
#define Adr_NX51_parity_parity_enable 0x1018C740U
#define Adr_NX51_parity_enable        0x1018C740U
#define DFLT_VAL_NX51_parity_enable   0x00000000U

#define MSK_NX51_parity_enable_intram0         0x00000001U
#define SRT_NX51_parity_enable_intram0         0
#define DFLT_VAL_NX51_parity_enable_intram0    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram0 0x00000000U
#define MSK_NX51_parity_enable_intram1         0x00000002U
#define SRT_NX51_parity_enable_intram1         1
#define DFLT_VAL_NX51_parity_enable_intram1    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram1 0x00000000U
#define MSK_NX51_parity_enable_intram2         0x00000004U
#define SRT_NX51_parity_enable_intram2         2
#define DFLT_VAL_NX51_parity_enable_intram2    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram2 0x00000000U
#define MSK_NX51_parity_enable_intram3         0x00000008U
#define SRT_NX51_parity_enable_intram3         3
#define DFLT_VAL_NX51_parity_enable_intram3    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram3 0x00000000U
#define MSK_NX51_parity_enable_intram4         0x00000010U
#define SRT_NX51_parity_enable_intram4         4
#define DFLT_VAL_NX51_parity_enable_intram4    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram4 0x00000000U
#define MSK_NX51_parity_enable_intram5         0x00000020U
#define SRT_NX51_parity_enable_intram5         5
#define DFLT_VAL_NX51_parity_enable_intram5    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram5 0x00000000U
#define MSK_NX51_parity_enable_intram6         0x00000040U
#define SRT_NX51_parity_enable_intram6         6
#define DFLT_VAL_NX51_parity_enable_intram6    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram6 0x00000000U
#define MSK_NX51_parity_enable_intram7         0x00000080U
#define SRT_NX51_parity_enable_intram7         7
#define DFLT_VAL_NX51_parity_enable_intram7    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram7 0x00000000U
#define MSK_NX51_parity_enable_intram8         0x00000100U
#define SRT_NX51_parity_enable_intram8         8
#define DFLT_VAL_NX51_parity_enable_intram8    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram8 0x00000000U
#define MSK_NX51_parity_enable_intram9         0x00000200U
#define SRT_NX51_parity_enable_intram9         9
#define DFLT_VAL_NX51_parity_enable_intram9    0x00000000U
#define DFLT_BF_VAL_NX51_parity_enable_intram9 0x00000000U

/* all used bits of 'NX51_parity_enable': */
#define MSK_USED_BITS_NX51_parity_enable 0x000003ffU

enum {
	BFW_NX51_parity_enable_intram0   = 1,  /* [0] */
	BFW_NX51_parity_enable_intram1   = 1,  /* [1] */
	BFW_NX51_parity_enable_intram2   = 1,  /* [2] */
	BFW_NX51_parity_enable_intram3   = 1,  /* [3] */
	BFW_NX51_parity_enable_intram4   = 1,  /* [4] */
	BFW_NX51_parity_enable_intram5   = 1,  /* [5] */
	BFW_NX51_parity_enable_intram6   = 1,  /* [6] */
	BFW_NX51_parity_enable_intram7   = 1,  /* [7] */
	BFW_NX51_parity_enable_intram8   = 1,  /* [8] */
	BFW_NX51_parity_enable_intram9   = 1,  /* [9] */
	BFW_NX51_parity_enable_reserved1 = 22  /* [31:10] */
};

typedef struct NX51_PARITY_ENABLE_BIT_Ttag {
	unsigned int intram0   : BFW_NX51_parity_enable_intram0;   /* enable parity check for intram0          */
	unsigned int intram1   : BFW_NX51_parity_enable_intram1;   /* enable parity check for intram1          */
	unsigned int intram2   : BFW_NX51_parity_enable_intram2;   /* enable parity check for intram2          */
	unsigned int intram3   : BFW_NX51_parity_enable_intram3;   /* enable parity check for intram3          */
	unsigned int intram4   : BFW_NX51_parity_enable_intram4;   /* enable parity check for intram4          */
	unsigned int intram5   : BFW_NX51_parity_enable_intram5;   /* enable parity check for intram5          */
	unsigned int intram6   : BFW_NX51_parity_enable_intram6;   /* enable parity check for intram6          */
	unsigned int intram7   : BFW_NX51_parity_enable_intram7;   /* enable parity check for intram7          */
	unsigned int intram8   : BFW_NX51_parity_enable_intram8;   /* enable parity check for intram8          */
	unsigned int intram9   : BFW_NX51_parity_enable_intram9;   /* enable parity check for intram9/intramhs */
	unsigned int reserved1 : BFW_NX51_parity_enable_reserved1; /* reserved                                 */
} NX51_PARITY_ENABLE_BIT_T;

typedef union {
	unsigned int             val;
	NX51_PARITY_ENABLE_BIT_T bf;
} NX51_PARITY_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register parity_abort_enable */
/* => Enable Bits for different INTRAM areas. */
/*    When bit is set, HRESP/Abort will be asserted for accessing master. Related parity_enable-bit must */
/*    be also active for this (abort will be generated when bit is set here AND inside 'parity_enable' register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_abort_enable    0x00000004U
#define Adr_NX51_parity_parity_abort_enable 0x1018C744U
#define Adr_NX51_parity_abort_enable        0x1018C744U
#define DFLT_VAL_NX51_parity_abort_enable   0x00000000U

#define MSK_NX51_parity_abort_enable_intram0         0x00000001U
#define SRT_NX51_parity_abort_enable_intram0         0
#define DFLT_VAL_NX51_parity_abort_enable_intram0    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram0 0x00000000U
#define MSK_NX51_parity_abort_enable_intram1         0x00000002U
#define SRT_NX51_parity_abort_enable_intram1         1
#define DFLT_VAL_NX51_parity_abort_enable_intram1    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram1 0x00000000U
#define MSK_NX51_parity_abort_enable_intram2         0x00000004U
#define SRT_NX51_parity_abort_enable_intram2         2
#define DFLT_VAL_NX51_parity_abort_enable_intram2    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram2 0x00000000U
#define MSK_NX51_parity_abort_enable_intram3         0x00000008U
#define SRT_NX51_parity_abort_enable_intram3         3
#define DFLT_VAL_NX51_parity_abort_enable_intram3    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram3 0x00000000U
#define MSK_NX51_parity_abort_enable_intram4         0x00000010U
#define SRT_NX51_parity_abort_enable_intram4         4
#define DFLT_VAL_NX51_parity_abort_enable_intram4    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram4 0x00000000U
#define MSK_NX51_parity_abort_enable_intram5         0x00000020U
#define SRT_NX51_parity_abort_enable_intram5         5
#define DFLT_VAL_NX51_parity_abort_enable_intram5    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram5 0x00000000U
#define MSK_NX51_parity_abort_enable_intram6         0x00000040U
#define SRT_NX51_parity_abort_enable_intram6         6
#define DFLT_VAL_NX51_parity_abort_enable_intram6    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram6 0x00000000U
#define MSK_NX51_parity_abort_enable_intram7         0x00000080U
#define SRT_NX51_parity_abort_enable_intram7         7
#define DFLT_VAL_NX51_parity_abort_enable_intram7    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram7 0x00000000U
#define MSK_NX51_parity_abort_enable_intram8         0x00000100U
#define SRT_NX51_parity_abort_enable_intram8         8
#define DFLT_VAL_NX51_parity_abort_enable_intram8    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram8 0x00000000U
#define MSK_NX51_parity_abort_enable_intram9         0x00000200U
#define SRT_NX51_parity_abort_enable_intram9         9
#define DFLT_VAL_NX51_parity_abort_enable_intram9    0x00000000U
#define DFLT_BF_VAL_NX51_parity_abort_enable_intram9 0x00000000U

/* all used bits of 'NX51_parity_abort_enable': */
#define MSK_USED_BITS_NX51_parity_abort_enable 0x000003ffU

enum {
	BFW_NX51_parity_abort_enable_intram0   = 1,  /* [0] */
	BFW_NX51_parity_abort_enable_intram1   = 1,  /* [1] */
	BFW_NX51_parity_abort_enable_intram2   = 1,  /* [2] */
	BFW_NX51_parity_abort_enable_intram3   = 1,  /* [3] */
	BFW_NX51_parity_abort_enable_intram4   = 1,  /* [4] */
	BFW_NX51_parity_abort_enable_intram5   = 1,  /* [5] */
	BFW_NX51_parity_abort_enable_intram6   = 1,  /* [6] */
	BFW_NX51_parity_abort_enable_intram7   = 1,  /* [7] */
	BFW_NX51_parity_abort_enable_intram8   = 1,  /* [8] */
	BFW_NX51_parity_abort_enable_intram9   = 1,  /* [9] */
	BFW_NX51_parity_abort_enable_reserved1 = 22  /* [31:10] */
};

typedef struct NX51_PARITY_ABORT_ENABLE_BIT_Ttag {
	unsigned int intram0   : BFW_NX51_parity_abort_enable_intram0;   /* enable parity abort for intram0          */
	unsigned int intram1   : BFW_NX51_parity_abort_enable_intram1;   /* enable parity abort for intram1          */
	unsigned int intram2   : BFW_NX51_parity_abort_enable_intram2;   /* enable parity abort for intram2          */
	unsigned int intram3   : BFW_NX51_parity_abort_enable_intram3;   /* enable parity abort for intram3          */
	unsigned int intram4   : BFW_NX51_parity_abort_enable_intram4;   /* enable parity abort for intram4          */
	unsigned int intram5   : BFW_NX51_parity_abort_enable_intram5;   /* enable parity abort for intram5          */
	unsigned int intram6   : BFW_NX51_parity_abort_enable_intram6;   /* enable parity abort for intram6          */
	unsigned int intram7   : BFW_NX51_parity_abort_enable_intram7;   /* enable parity abort for intram7          */
	unsigned int intram8   : BFW_NX51_parity_abort_enable_intram8;   /* enable parity abort for intram8          */
	unsigned int intram9   : BFW_NX51_parity_abort_enable_intram9;   /* enable parity abort for intram9/intramhs */
	unsigned int reserved1 : BFW_NX51_parity_abort_enable_reserved1; /* reserved                                 */
} NX51_PARITY_ABORT_ENABLE_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_PARITY_ABORT_ENABLE_BIT_T bf;
} NX51_PARITY_ABORT_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register parity_error_mem_status */
/* => Parity status register: */
/*    Parity error status for each INTRAM is logged inside this register. Logging is always done, */
/*    even when related bit is not set inside 'parity_enable' register. */
/*    Status can be cleared by writing '1s'. */
/*    Note: */
/*      Reading uninitialized data from INTRAM will produce parity errors as parity matches data only */
/*      when the related data was written before (there is no automatic RAM initialisazion after */
/*      netX reset) */
/*     */
/*    Note: */
/*      Parity of netX INTRAM covers 32bit data only. Writing 8 or 16bit words will result a parity */
/*      update over the whole 32bit (4 byte address boundary) word, this data was written to */
/*      considering the resulting data. */
/*      Example: Address 0x100 contains 0xabe01234, i.e. current parity is '1' (13 bits are set) */
/*               Byte-write access to 0x101, write data is 0x57 */
/*               Resulting 32bit word at 0x100 is 0xabe05734 (16 bits are set) */
/*               i.e. parity bit will be updated to '0'. */
/*      Bit errors outside the new written data will not be covered by parity check then. However */
/*      they will be very rare. To avoid them completely write only 32bit words. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_error_mem_status    0x00000008U
#define Adr_NX51_parity_parity_error_mem_status 0x1018C748U
#define Adr_NX51_parity_error_mem_status        0x1018C748U
#define DFLT_VAL_NX51_parity_error_mem_status   0x00000000U

#define MSK_NX51_parity_error_mem_status_intram0         0x00000001U
#define SRT_NX51_parity_error_mem_status_intram0         0
#define DFLT_VAL_NX51_parity_error_mem_status_intram0    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram0 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram1         0x00000002U
#define SRT_NX51_parity_error_mem_status_intram1         1
#define DFLT_VAL_NX51_parity_error_mem_status_intram1    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram1 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram2         0x00000004U
#define SRT_NX51_parity_error_mem_status_intram2         2
#define DFLT_VAL_NX51_parity_error_mem_status_intram2    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram2 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram3         0x00000008U
#define SRT_NX51_parity_error_mem_status_intram3         3
#define DFLT_VAL_NX51_parity_error_mem_status_intram3    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram3 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram4         0x00000010U
#define SRT_NX51_parity_error_mem_status_intram4         4
#define DFLT_VAL_NX51_parity_error_mem_status_intram4    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram4 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram5         0x00000020U
#define SRT_NX51_parity_error_mem_status_intram5         5
#define DFLT_VAL_NX51_parity_error_mem_status_intram5    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram5 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram6         0x00000040U
#define SRT_NX51_parity_error_mem_status_intram6         6
#define DFLT_VAL_NX51_parity_error_mem_status_intram6    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram6 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram7         0x00000080U
#define SRT_NX51_parity_error_mem_status_intram7         7
#define DFLT_VAL_NX51_parity_error_mem_status_intram7    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram7 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram8         0x00000100U
#define SRT_NX51_parity_error_mem_status_intram8         8
#define DFLT_VAL_NX51_parity_error_mem_status_intram8    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram8 0x00000000U
#define MSK_NX51_parity_error_mem_status_intram9         0x00000200U
#define SRT_NX51_parity_error_mem_status_intram9         9
#define DFLT_VAL_NX51_parity_error_mem_status_intram9    0x00000000U
#define DFLT_BF_VAL_NX51_parity_error_mem_status_intram9 0x00000000U

/* all used bits of 'NX51_parity_error_mem_status': */
#define MSK_USED_BITS_NX51_parity_error_mem_status 0x000003ffU

enum {
	BFW_NX51_parity_error_mem_status_intram0   = 1,  /* [0] */
	BFW_NX51_parity_error_mem_status_intram1   = 1,  /* [1] */
	BFW_NX51_parity_error_mem_status_intram2   = 1,  /* [2] */
	BFW_NX51_parity_error_mem_status_intram3   = 1,  /* [3] */
	BFW_NX51_parity_error_mem_status_intram4   = 1,  /* [4] */
	BFW_NX51_parity_error_mem_status_intram5   = 1,  /* [5] */
	BFW_NX51_parity_error_mem_status_intram6   = 1,  /* [6] */
	BFW_NX51_parity_error_mem_status_intram7   = 1,  /* [7] */
	BFW_NX51_parity_error_mem_status_intram8   = 1,  /* [8] */
	BFW_NX51_parity_error_mem_status_intram9   = 1,  /* [9] */
	BFW_NX51_parity_error_mem_status_reserved1 = 22  /* [31:10] */
};

typedef struct NX51_PARITY_ERROR_MEM_STATUS_BIT_Ttag {
	unsigned int intram0   : BFW_NX51_parity_error_mem_status_intram0;   /* parity status for intram0          */
	unsigned int intram1   : BFW_NX51_parity_error_mem_status_intram1;   /* parity status for intram1          */
	unsigned int intram2   : BFW_NX51_parity_error_mem_status_intram2;   /* parity status for intram2          */
	unsigned int intram3   : BFW_NX51_parity_error_mem_status_intram3;   /* parity status for intram3          */
	unsigned int intram4   : BFW_NX51_parity_error_mem_status_intram4;   /* parity status for intram4          */
	unsigned int intram5   : BFW_NX51_parity_error_mem_status_intram5;   /* parity status for intram5          */
	unsigned int intram6   : BFW_NX51_parity_error_mem_status_intram6;   /* parity status for intram6          */
	unsigned int intram7   : BFW_NX51_parity_error_mem_status_intram7;   /* parity status for intram7          */
	unsigned int intram8   : BFW_NX51_parity_error_mem_status_intram8;   /* parity status for intram8          */
	unsigned int intram9   : BFW_NX51_parity_error_mem_status_intram9;   /* parity status for intram9/intramhs */
	unsigned int reserved1 : BFW_NX51_parity_error_mem_status_reserved1; /* reserved                           */
} NX51_PARITY_ERROR_MEM_STATUS_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_PARITY_ERROR_MEM_STATUS_BIT_T bf;
} NX51_PARITY_ERROR_MEM_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register parity_error_acc_status */
/* => Parity error address register: */
/*    If a parity error occured, this register shows the address inside the ram, where the error occured. */
/*    This register is only updated when current parity error status is clear, i.e. when */
/*    'parity.parity_irq_raw' bit is not active. Only access to INTRAMs where parity-check is */
/*    enabled ('parity_enable' register) will effect this register. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_error_acc_status    0x0000000CU
#define Adr_NX51_parity_parity_error_acc_status 0x1018C74CU
#define Adr_NX51_parity_error_acc_status        0x1018C74CU

#define MSK_NX51_parity_error_acc_status_addr   0x00ffffffU
#define SRT_NX51_parity_error_acc_status_addr   0
#define MSK_NX51_parity_error_acc_status_master 0xf0000000U
#define SRT_NX51_parity_error_acc_status_master 28

/* all used bits of 'NX51_parity_error_acc_status': */
#define MSK_USED_BITS_NX51_parity_error_acc_status 0xf0ffffffU

enum {
	BFW_NX51_parity_error_acc_status_addr      = 24, /* [23:0] */
	BFW_NX51_parity_error_acc_status_reserved1 = 4,  /* [27:24] */
	BFW_NX51_parity_error_acc_status_master    = 4   /* [31:28] */
};

typedef struct NX51_PARITY_ERROR_ACC_STATUS_BIT_Ttag {
	unsigned int addr      : BFW_NX51_parity_error_acc_status_addr;      /* Address offset of errorneous access inside related INTRAM. */
	unsigned int reserved1 : BFW_NX51_parity_error_acc_status_reserved1; /* reserved                                                   */
	unsigned int master    : BFW_NX51_parity_error_acc_status_master;    /* netX master which initiated the parity error access.       */
	                                                                     /*  0: DPM                                                    */
	                                                                     /*  1: xC data                                                */
	                                                                     /*  2: xC system                                              */
	                                                                     /*  3: OSAC (NFIFO)                                           */
	                                                                     /*  4: xPIC data                                              */
	                                                                     /*  5: xPIC inst                                              */
	                                                                     /*  6: ARM TCM inst                                           */
	                                                                     /*  7: ARM TCM data                                           */
	                                                                     /*  8: ARM AHB                                                */
	                                                                     /*  9: SYSDEBUG                                               */
	                                                                     /* 10: DMAC                                                   */
} NX51_PARITY_ERROR_ACC_STATUS_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_PARITY_ERROR_ACC_STATUS_BIT_T bf;
} NX51_PARITY_ERROR_ACC_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register parity_irq_raw */
/* => Raw IRQ: */
/*    Read access shows status of unmasked IRQs. */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_irq_raw    0x00000010U
#define Adr_NX51_parity_parity_irq_raw 0x1018C750U
#define Adr_NX51_parity_irq_raw        0x1018C750U
#define DFLT_VAL_NX51_parity_irq_raw   0x00000000U

#define MSK_NX51_parity_irq_raw_parity         0x00000001U
#define SRT_NX51_parity_irq_raw_parity         0
#define DFLT_VAL_NX51_parity_irq_raw_parity    0x00000000U
#define DFLT_BF_VAL_NX51_parity_irq_raw_parity 0x00000000U

/* all used bits of 'NX51_parity_irq_raw': */
#define MSK_USED_BITS_NX51_parity_irq_raw 0x00000001U

enum {
	BFW_NX51_parity_irq_raw_parity    = 1,  /* [0] */
	BFW_NX51_parity_irq_raw_reserved1 = 31  /* [31:1] */
};

typedef struct NX51_PARITY_IRQ_RAW_BIT_Ttag {
	unsigned int parity    : BFW_NX51_parity_irq_raw_parity;    /* any parity error occured */
	unsigned int reserved1 : BFW_NX51_parity_irq_raw_reserved1; /* reserved                 */
} NX51_PARITY_IRQ_RAW_BIT_T;

typedef union {
	unsigned int              val;
	NX51_PARITY_IRQ_RAW_BIT_T bf;
} NX51_PARITY_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register parity_irq_masked */
/* => Masked IRQ: */
/*    Shows status of masked IRQs (as connected to ARM/xPIC). */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_irq_masked    0x00000014U
#define Adr_NX51_parity_parity_irq_masked 0x1018C754U
#define Adr_NX51_parity_irq_masked        0x1018C754U

#define MSK_NX51_parity_irq_masked_parity 0x00000001U
#define SRT_NX51_parity_irq_masked_parity 0

/* all used bits of 'NX51_parity_irq_masked': */
#define MSK_USED_BITS_NX51_parity_irq_masked 0x00000001U

enum {
	BFW_NX51_parity_irq_masked_parity    = 1,  /* [0] */
	BFW_NX51_parity_irq_masked_reserved1 = 31  /* [31:1] */
};

typedef struct NX51_PARITY_IRQ_MASKED_BIT_Ttag {
	unsigned int parity    : BFW_NX51_parity_irq_masked_parity;    /* any parity error occured */
	unsigned int reserved1 : BFW_NX51_parity_irq_masked_reserved1; /* reserved                 */
} NX51_PARITY_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_PARITY_IRQ_MASKED_BIT_T bf;
} NX51_PARITY_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register parity_irq_msk_set */
/* => IRQ enable mask: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. */
/*    As its bits might be changed by different software tasks, */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_parity_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_irq_msk_set    0x00000018U
#define Adr_NX51_parity_parity_irq_msk_set 0x1018C758U
#define Adr_NX51_parity_irq_msk_set        0x1018C758U
#define DFLT_VAL_NX51_parity_irq_msk_set   0x00000000U

#define MSK_NX51_parity_irq_msk_set_parity         0x00000001U
#define SRT_NX51_parity_irq_msk_set_parity         0
#define DFLT_VAL_NX51_parity_irq_msk_set_parity    0x00000000U
#define DFLT_BF_VAL_NX51_parity_irq_msk_set_parity 0x00000000U

/* all used bits of 'NX51_parity_irq_msk_set': */
#define MSK_USED_BITS_NX51_parity_irq_msk_set 0x00000001U

enum {
	BFW_NX51_parity_irq_msk_set_parity    = 1,  /* [0] */
	BFW_NX51_parity_irq_msk_set_reserved1 = 31  /* [31:1] */
};

typedef struct NX51_PARITY_IRQ_MSK_SET_BIT_Ttag {
	unsigned int parity    : BFW_NX51_parity_irq_msk_set_parity;    /* any parity error occured */
	unsigned int reserved1 : BFW_NX51_parity_irq_msk_set_reserved1; /* reserved                 */
} NX51_PARITY_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_PARITY_IRQ_MSK_SET_BIT_T bf;
} NX51_PARITY_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register parity_irq_msk_reset */
/* => IRQ disable mask: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_parity_irq_msk_reset    0x0000001CU
#define Adr_NX51_parity_parity_irq_msk_reset 0x1018C75CU
#define Adr_NX51_parity_irq_msk_reset        0x1018C75CU
#define DFLT_VAL_NX51_parity_irq_msk_reset   0x00000000U

#define MSK_NX51_parity_irq_msk_reset_parity         0x00000001U
#define SRT_NX51_parity_irq_msk_reset_parity         0
#define DFLT_VAL_NX51_parity_irq_msk_reset_parity    0x00000000U
#define DFLT_BF_VAL_NX51_parity_irq_msk_reset_parity 0x00000000U

/* all used bits of 'NX51_parity_irq_msk_reset': */
#define MSK_USED_BITS_NX51_parity_irq_msk_reset 0x00000001U

enum {
	BFW_NX51_parity_irq_msk_reset_parity    = 1,  /* [0] */
	BFW_NX51_parity_irq_msk_reset_reserved1 = 31  /* [31:1] */
};

typedef struct NX51_PARITY_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int parity    : BFW_NX51_parity_irq_msk_reset_parity;    /* any parity error occured */
	unsigned int reserved1 : BFW_NX51_parity_irq_msk_reset_reserved1; /* reserved                 */
} NX51_PARITY_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_PARITY_IRQ_MSK_RESET_BIT_T bf;
} NX51_PARITY_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* Area of usb_dev */

/* ===================================================================== */

#define Addr_NX51_usb_dev 0x1018C800U

/* ===================================================================== */

/* Area of usb_dev_ctrl */

/* ===================================================================== */

#define Addr_NX51_usb_dev_ctrl 0x1018C800U

/* --------------------------------------------------------------------- */
/* Register usb_dev_cfg */
/* => USB device configuration register. */
/*    This register configures the USB device functions. It allows to entirely disable the USB core and the USB to JTAG bridge. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_cfg          0x00000000U
#define Adr_NX51_usb_dev_ctrl_usb_dev_cfg 0x1018C800U
#define Adr_NX51_usb_dev_cfg              0x1018C800U
#define DFLT_VAL_NX51_usb_dev_cfg         0x00000032U

#define MSK_NX51_usb_dev_cfg_usb_core_enable            0x00000001U
#define SRT_NX51_usb_dev_cfg_usb_core_enable            0
#define DFLT_VAL_NX51_usb_dev_cfg_usb_core_enable       0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_cfg_usb_core_enable    0x00000000U
#define MSK_NX51_usb_dev_cfg_usb_to_jtag_enable         0x00000002U
#define SRT_NX51_usb_dev_cfg_usb_to_jtag_enable         1
#define DFLT_VAL_NX51_usb_dev_cfg_usb_to_jtag_enable    0x00000002U
#define DFLT_BF_VAL_NX51_usb_dev_cfg_usb_to_jtag_enable 0x00000001U
#define MSK_NX51_usb_dev_cfg_usb_dev_reset              0x00000004U
#define SRT_NX51_usb_dev_cfg_usb_dev_reset              2
#define DFLT_VAL_NX51_usb_dev_cfg_usb_dev_reset         0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_cfg_usb_dev_reset      0x00000000U
#define MSK_NX51_usb_dev_cfg_disconn_timeout            0x00000030U
#define SRT_NX51_usb_dev_cfg_disconn_timeout            4
#define DFLT_VAL_NX51_usb_dev_cfg_disconn_timeout       0x00000030U
#define DFLT_BF_VAL_NX51_usb_dev_cfg_disconn_timeout    0x00000003U

/* all used bits of 'NX51_usb_dev_cfg': */
#define MSK_USED_BITS_NX51_usb_dev_cfg 0x00000037U

enum {
	BFW_NX51_usb_dev_cfg_usb_core_enable    = 1,  /* [0] */
	BFW_NX51_usb_dev_cfg_usb_to_jtag_enable = 1,  /* [1] */
	BFW_NX51_usb_dev_cfg_usb_dev_reset      = 1,  /* [2] */
	BFW_NX51_usb_dev_cfg_reserved1          = 1,  /* [3] */
	BFW_NX51_usb_dev_cfg_disconn_timeout    = 2,  /* [5:4] */
	BFW_NX51_usb_dev_cfg_reserved2          = 26  /* [31:6] */
};

typedef struct NX51_USB_DEV_CFG_BIT_Ttag {
	unsigned int usb_core_enable    : BFW_NX51_usb_dev_cfg_usb_core_enable;    /* Writing a '1' to this bit will enable the USB core.                                         */
	unsigned int usb_to_jtag_enable : BFW_NX51_usb_dev_cfg_usb_to_jtag_enable; /* When set, the USB to JTAG module is active. This bit in combination with usb2jtag_en in     */
	                                                                           /* the 'io_config' register controls whether or not to use the JTAG features of the USB core.  */
	                                                                           /* To have control over the JTAG pins of the internal system through USB the following         */
	                                                                           /* conditions must be met:                                                                     */
	                                                                           /* The 'usb2jtag_en' bit in 'io_config' must be set, the USB core must be enabled, this bit    */
	                                                                           /* must be set, the USB host must have done a full enumeration (i.e. the USB core is in state  */
	                                                                           /* configured) and a valid JTAG mode, speed and enable must have been set through the vendor   */
	                                                                           /* feature mechanism by the USB host. If and only if all these conditions are met,             */
	                                                                           /* the external JTAG pins are being disabled and the pins of the JTAG TAP controller           */
	                                                                           /* are routed to the USB core.                                                                 */
	unsigned int usb_dev_reset      : BFW_NX51_usb_dev_cfg_usb_dev_reset;      /* Writing a '1' to this bit will reset the USB core and JTAG module.                          */
	                                                                           /* The user must deassert the bit manually.                                                    */
	unsigned int reserved1          : BFW_NX51_usb_dev_cfg_reserved1;          /* reserved                                                                                    */
	unsigned int disconn_timeout    : BFW_NX51_usb_dev_cfg_disconn_timeout;    /* These bits define the timeout used to detect a disconnection from the USB host.             */
	                                                                           /* This is done monitoring the Start-of-Frames. The user may choose between the                */
	                                                                           /* following timeouts:                                                                         */
	                                                                           /*  00 : 4 ms (for testing purposes)                                                           */
	                                                                           /*  01 : 131 ms                                                                                */
	                                                                           /*  10 : 262 ms                                                                                */
	                                                                           /*  11 : 524 ms (default)                                                                      */
	                                                                           /* Note: Changing the timeout to a lower value while a timeout is in progress may              */
	                                                                           /* result in the desired timeout + 1048 ms. So, be sure to set the timeout while the           */
	                                                                           /* core is disabled.                                                                           */
	unsigned int reserved2          : BFW_NX51_usb_dev_cfg_reserved2;          /* reserved                                                                                    */
} NX51_USB_DEV_CFG_BIT_T;

typedef union {
	unsigned int           val;
	NX51_USB_DEV_CFG_BIT_T bf;
} NX51_USB_DEV_CFG_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_status */
/* => USB device status register. */
/*    This register represents various status information of the USB core and its FIFOs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_status          0x00000004U
#define Adr_NX51_usb_dev_ctrl_usb_dev_status 0x1018C804U
#define Adr_NX51_usb_dev_status              0x1018C804U

#define MSK_NX51_usb_dev_status_usb_busy         0x00000001U
#define SRT_NX51_usb_dev_status_usb_busy         0
#define MSK_NX51_usb_dev_status_usb_addressed    0x00000002U
#define SRT_NX51_usb_dev_status_usb_addressed    1
#define MSK_NX51_usb_dev_status_usb_configured   0x00000004U
#define SRT_NX51_usb_dev_status_usb_configured   2
#define MSK_NX51_usb_dev_status_usb_bus_reset    0x00000008U
#define SRT_NX51_usb_dev_status_usb_bus_reset    3
#define MSK_NX51_usb_dev_status_usb_connected    0x00000010U
#define SRT_NX51_usb_dev_status_usb_connected    4
#define MSK_NX51_usb_dev_status_usb_disconnected 0x00000020U
#define SRT_NX51_usb_dev_status_usb_disconnected 5

/* all used bits of 'NX51_usb_dev_status': */
#define MSK_USED_BITS_NX51_usb_dev_status 0x0000003fU

enum {
	BFW_NX51_usb_dev_status_usb_busy         = 1,  /* [0] */
	BFW_NX51_usb_dev_status_usb_addressed    = 1,  /* [1] */
	BFW_NX51_usb_dev_status_usb_configured   = 1,  /* [2] */
	BFW_NX51_usb_dev_status_usb_bus_reset    = 1,  /* [3] */
	BFW_NX51_usb_dev_status_usb_connected    = 1,  /* [4] */
	BFW_NX51_usb_dev_status_usb_disconnected = 1,  /* [5] */
	BFW_NX51_usb_dev_status_reserved1        = 26  /* [31:6] */
};

typedef struct NX51_USB_DEV_STATUS_BIT_Ttag {
	unsigned int usb_busy         : BFW_NX51_usb_dev_status_usb_busy;         /* This bit is set while an USB transfer is active.                                        */
	unsigned int usb_addressed    : BFW_NX51_usb_dev_status_usb_addressed;    /* This bit is set as soon as the USB host set a valid address.                            */
	unsigned int usb_configured   : BFW_NX51_usb_dev_status_usb_configured;   /* This bit is set as soon as the USB host has configured the core.                        */
	unsigned int usb_bus_reset    : BFW_NX51_usb_dev_status_usb_bus_reset;    /* This bit is set when the bus is held in reset state (i.e. the FIFOs are held in reset). */
	unsigned int usb_connected    : BFW_NX51_usb_dev_status_usb_connected;    /* This bit is set when the device has successfully been configured.                       */
	unsigned int usb_disconnected : BFW_NX51_usb_dev_status_usb_disconnected; /* This bit is set when the device is currently disconnected.                              */
	unsigned int reserved1        : BFW_NX51_usb_dev_status_reserved1;        /* reserved                                                                                */
} NX51_USB_DEV_STATUS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_USB_DEV_STATUS_BIT_T bf;
} NX51_USB_DEV_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_vendor_features */
/* => USB vendor feature status register. */
/*    This register represents the last valid vendor features that the USB Host has set. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_vendor_features          0x00000008U
#define Adr_NX51_usb_dev_ctrl_usb_dev_vendor_features 0x1018C808U
#define Adr_NX51_usb_dev_vendor_features              0x1018C808U

#define MSK_NX51_usb_dev_vendor_features_vendor_features 0x0000ffffU
#define SRT_NX51_usb_dev_vendor_features_vendor_features 0

/* all used bits of 'NX51_usb_dev_vendor_features': */
#define MSK_USED_BITS_NX51_usb_dev_vendor_features 0x0000ffffU

enum {
	BFW_NX51_usb_dev_vendor_features_vendor_features = 16, /* [15:0] */
	BFW_NX51_usb_dev_vendor_features_reserved1       = 16  /* [31:16] */
};

typedef struct NX51_USB_DEV_VENDOR_FEATURES_BIT_Ttag {
	unsigned int vendor_features : BFW_NX51_usb_dev_vendor_features_vendor_features; /* The last valid vendor features set by the host. */
	unsigned int reserved1       : BFW_NX51_usb_dev_vendor_features_reserved1;       /* reserved                                        */
} NX51_USB_DEV_VENDOR_FEATURES_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_USB_DEV_VENDOR_FEATURES_BIT_T bf;
} NX51_USB_DEV_VENDOR_FEATURES_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_irq_mask */
/* => USB device interrupt mask register. */
/*    The value of this register is used for AND-masking the raw interrupt register. When a bit is set, \ */
/*    the corresponding interrupt is routed to the interrupt controller. \ */
/*    For a detailed IRQ description see usb_dev_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_irq_mask          0x0000000CU
#define Adr_NX51_usb_dev_ctrl_usb_dev_irq_mask 0x1018C80CU
#define Adr_NX51_usb_dev_irq_mask              0x1018C80CU
#define DFLT_VAL_NX51_usb_dev_irq_mask         0x00000000U

#define MSK_NX51_usb_dev_irq_mask_uart_rx_fifo_full                    0x00000001U
#define SRT_NX51_usb_dev_irq_mask_uart_rx_fifo_full                    0
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_rx_fifo_full               0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_rx_fifo_full            0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_rx_fifo_empty                   0x00000002U
#define SRT_NX51_usb_dev_irq_mask_uart_rx_fifo_empty                   1
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_rx_fifo_empty              0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_rx_fifo_empty           0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_tx_fifo_full                    0x00000004U
#define SRT_NX51_usb_dev_irq_mask_uart_tx_fifo_full                    2
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_tx_fifo_full               0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_tx_fifo_full            0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_tx_fifo_empty                   0x00000008U
#define SRT_NX51_usb_dev_irq_mask_uart_tx_fifo_empty                   3
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_tx_fifo_empty              0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_tx_fifo_empty           0x00000000U
#define MSK_NX51_usb_dev_irq_mask_fifo_overflow_underrun_err           0x00000010U
#define SRT_NX51_usb_dev_irq_mask_fifo_overflow_underrun_err           4
#define DFLT_VAL_NX51_usb_dev_irq_mask_fifo_overflow_underrun_err      0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_fifo_overflow_underrun_err   0x00000000U
#define MSK_NX51_usb_dev_irq_mask_crc16_error                          0x00000020U
#define SRT_NX51_usb_dev_irq_mask_crc16_error                          5
#define DFLT_VAL_NX51_usb_dev_irq_mask_crc16_error                     0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_crc16_error                  0x00000000U
#define MSK_NX51_usb_dev_irq_mask_dropped_frame                        0x00000040U
#define SRT_NX51_usb_dev_irq_mask_dropped_frame                        6
#define DFLT_VAL_NX51_usb_dev_irq_mask_dropped_frame                   0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_dropped_frame                0x00000000U
#define MSK_NX51_usb_dev_irq_mask_reset_detected                       0x00000100U
#define SRT_NX51_usb_dev_irq_mask_reset_detected                       8
#define DFLT_VAL_NX51_usb_dev_irq_mask_reset_detected                  0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_reset_detected               0x00000000U
#define MSK_NX51_usb_dev_irq_mask_jtag_srst_requested                  0x00000200U
#define SRT_NX51_usb_dev_irq_mask_jtag_srst_requested                  9
#define DFLT_VAL_NX51_usb_dev_irq_mask_jtag_srst_requested             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_jtag_srst_requested          0x00000000U
#define MSK_NX51_usb_dev_irq_mask_jtag_tx_packet_sent                  0x00000400U
#define SRT_NX51_usb_dev_irq_mask_jtag_tx_packet_sent                  10
#define DFLT_VAL_NX51_usb_dev_irq_mask_jtag_tx_packet_sent             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_jtag_tx_packet_sent          0x00000000U
#define MSK_NX51_usb_dev_irq_mask_jtag_rx_packet_received              0x00000800U
#define SRT_NX51_usb_dev_irq_mask_jtag_rx_packet_received              11
#define DFLT_VAL_NX51_usb_dev_irq_mask_jtag_rx_packet_received         0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_jtag_rx_packet_received      0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_tx_packet_sent                  0x00001000U
#define SRT_NX51_usb_dev_irq_mask_uart_tx_packet_sent                  12
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_tx_packet_sent             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_tx_packet_sent          0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_rx_packet_received              0x00002000U
#define SRT_NX51_usb_dev_irq_mask_uart_rx_packet_received              13
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_rx_packet_received         0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_rx_packet_received      0x00000000U
#define MSK_NX51_usb_dev_irq_mask_jtag_tx_transaction_sent             0x00010000U
#define SRT_NX51_usb_dev_irq_mask_jtag_tx_transaction_sent             16
#define DFLT_VAL_NX51_usb_dev_irq_mask_jtag_tx_transaction_sent        0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_jtag_tx_transaction_sent     0x00000000U
#define MSK_NX51_usb_dev_irq_mask_jtag_rx_transaction_received         0x00020000U
#define SRT_NX51_usb_dev_irq_mask_jtag_rx_transaction_received         17
#define DFLT_VAL_NX51_usb_dev_irq_mask_jtag_rx_transaction_received    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_jtag_rx_transaction_received 0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_tx_transaction_sent             0x00040000U
#define SRT_NX51_usb_dev_irq_mask_uart_tx_transaction_sent             18
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_tx_transaction_sent        0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_tx_transaction_sent     0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_rx_transaction_received         0x00080000U
#define SRT_NX51_usb_dev_irq_mask_uart_rx_transaction_received         19
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_rx_transaction_received    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_rx_transaction_received 0x00000000U
#define MSK_NX51_usb_dev_irq_mask_uart_rx_zlp_received                 0x00400000U
#define SRT_NX51_usb_dev_irq_mask_uart_rx_zlp_received                 22
#define DFLT_VAL_NX51_usb_dev_irq_mask_uart_rx_zlp_received            0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_uart_rx_zlp_received         0x00000000U
#define MSK_NX51_usb_dev_irq_mask_device_connected                     0x00800000U
#define SRT_NX51_usb_dev_irq_mask_device_connected                     23
#define DFLT_VAL_NX51_usb_dev_irq_mask_device_connected                0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_device_connected             0x00000000U
#define MSK_NX51_usb_dev_irq_mask_device_disconnected                  0x01000000U
#define SRT_NX51_usb_dev_irq_mask_device_disconnected                  24
#define DFLT_VAL_NX51_usb_dev_irq_mask_device_disconnected             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_mask_device_disconnected          0x00000000U

/* all used bits of 'NX51_usb_dev_irq_mask': */
#define MSK_USED_BITS_NX51_usb_dev_irq_mask 0x01cf3f7fU

enum {
	BFW_NX51_usb_dev_irq_mask_uart_rx_fifo_full            = 1, /* [0] */
	BFW_NX51_usb_dev_irq_mask_uart_rx_fifo_empty           = 1, /* [1] */
	BFW_NX51_usb_dev_irq_mask_uart_tx_fifo_full            = 1, /* [2] */
	BFW_NX51_usb_dev_irq_mask_uart_tx_fifo_empty           = 1, /* [3] */
	BFW_NX51_usb_dev_irq_mask_fifo_overflow_underrun_err   = 1, /* [4] */
	BFW_NX51_usb_dev_irq_mask_crc16_error                  = 1, /* [5] */
	BFW_NX51_usb_dev_irq_mask_dropped_frame                = 1, /* [6] */
	BFW_NX51_usb_dev_irq_mask_reserved1                    = 1, /* [7] */
	BFW_NX51_usb_dev_irq_mask_reset_detected               = 1, /* [8] */
	BFW_NX51_usb_dev_irq_mask_jtag_srst_requested          = 1, /* [9] */
	BFW_NX51_usb_dev_irq_mask_jtag_tx_packet_sent          = 1, /* [10] */
	BFW_NX51_usb_dev_irq_mask_jtag_rx_packet_received      = 1, /* [11] */
	BFW_NX51_usb_dev_irq_mask_uart_tx_packet_sent          = 1, /* [12] */
	BFW_NX51_usb_dev_irq_mask_uart_rx_packet_received      = 1, /* [13] */
	BFW_NX51_usb_dev_irq_mask_reserved2                    = 2, /* [15:14] */
	BFW_NX51_usb_dev_irq_mask_jtag_tx_transaction_sent     = 1, /* [16] */
	BFW_NX51_usb_dev_irq_mask_jtag_rx_transaction_received = 1, /* [17] */
	BFW_NX51_usb_dev_irq_mask_uart_tx_transaction_sent     = 1, /* [18] */
	BFW_NX51_usb_dev_irq_mask_uart_rx_transaction_received = 1, /* [19] */
	BFW_NX51_usb_dev_irq_mask_reserved3                    = 2, /* [21:20] */
	BFW_NX51_usb_dev_irq_mask_uart_rx_zlp_received         = 1, /* [22] */
	BFW_NX51_usb_dev_irq_mask_device_connected             = 1, /* [23] */
	BFW_NX51_usb_dev_irq_mask_device_disconnected          = 1, /* [24] */
	BFW_NX51_usb_dev_irq_mask_reserved4                    = 7  /* [31:25] */
};

typedef struct NX51_USB_DEV_IRQ_MASK_BIT_Ttag {
	unsigned int uart_rx_fifo_full            : BFW_NX51_usb_dev_irq_mask_uart_rx_fifo_full;            /* UART rx FIFO full interrupt mask.                   */
	unsigned int uart_rx_fifo_empty           : BFW_NX51_usb_dev_irq_mask_uart_rx_fifo_empty;           /* UART rx FIFO empty interrupt mask.                  */
	unsigned int uart_tx_fifo_full            : BFW_NX51_usb_dev_irq_mask_uart_tx_fifo_full;            /* UART tx FIFO full interrupt mask.                   */
	unsigned int uart_tx_fifo_empty           : BFW_NX51_usb_dev_irq_mask_uart_tx_fifo_empty;           /* UART tx FIFO empty interrupt mask.                  */
	unsigned int fifo_overflow_underrun_err   : BFW_NX51_usb_dev_irq_mask_fifo_overflow_underrun_err;   /* FIFO overflow or underrun error interrupt mask.     */
	unsigned int crc16_error                  : BFW_NX51_usb_dev_irq_mask_crc16_error;                  /* CRC16 error in USB packet occurred interrupt mask.  */
	unsigned int dropped_frame                : BFW_NX51_usb_dev_irq_mask_dropped_frame;                /* Dropped frame occurred interrupt mask.              */
	unsigned int reserved1                    : BFW_NX51_usb_dev_irq_mask_reserved1;                    /* reserved                                            */
	unsigned int reset_detected               : BFW_NX51_usb_dev_irq_mask_reset_detected;               /* Reset detected interrupt mask.                      */
	unsigned int jtag_srst_requested          : BFW_NX51_usb_dev_irq_mask_jtag_srst_requested;          /* JTAG system reset request detected interrupt mask   */
	unsigned int jtag_tx_packet_sent          : BFW_NX51_usb_dev_irq_mask_jtag_tx_packet_sent;          /* JTAG tx packet sent interrupt mask.                 */
	unsigned int jtag_rx_packet_received      : BFW_NX51_usb_dev_irq_mask_jtag_rx_packet_received;      /* JTAG rx packet received interrupt mask.             */
	unsigned int uart_tx_packet_sent          : BFW_NX51_usb_dev_irq_mask_uart_tx_packet_sent;          /* UART tx packet sent interrupt mask.                 */
	unsigned int uart_rx_packet_received      : BFW_NX51_usb_dev_irq_mask_uart_rx_packet_received;      /* UART rx packet received interrupt mask.             */
	unsigned int reserved2                    : BFW_NX51_usb_dev_irq_mask_reserved2;                    /* reserved                                            */
	unsigned int jtag_tx_transaction_sent     : BFW_NX51_usb_dev_irq_mask_jtag_tx_transaction_sent;     /* JTAG tx transaction sent interrupt mask.            */
	unsigned int jtag_rx_transaction_received : BFW_NX51_usb_dev_irq_mask_jtag_rx_transaction_received; /* JTAG rx transaction received interrupt mask.        */
	unsigned int uart_tx_transaction_sent     : BFW_NX51_usb_dev_irq_mask_uart_tx_transaction_sent;     /* UART tx transaction sent interrupt mask.            */
	unsigned int uart_rx_transaction_received : BFW_NX51_usb_dev_irq_mask_uart_rx_transaction_received; /* UART rx transaction received interrupt mask.        */
	unsigned int reserved3                    : BFW_NX51_usb_dev_irq_mask_reserved3;                    /* reserved                                            */
	unsigned int uart_rx_zlp_received         : BFW_NX51_usb_dev_irq_mask_uart_rx_zlp_received;         /* UART rx zero length packet received interrupt mask. */
	unsigned int device_connected             : BFW_NX51_usb_dev_irq_mask_device_connected;             /* Device connected interrupt mask.                    */
	unsigned int device_disconnected          : BFW_NX51_usb_dev_irq_mask_device_disconnected;          /* Device disconnected interrupt mask.                 */
	unsigned int reserved4                    : BFW_NX51_usb_dev_irq_mask_reserved4;                    /* reserved                                            */
} NX51_USB_DEV_IRQ_MASK_BIT_T;

typedef union {
	unsigned int                val;
	NX51_USB_DEV_IRQ_MASK_BIT_T bf;
} NX51_USB_DEV_IRQ_MASK_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_irq_raw */
/* => USB device raw interrupt status register */
/*    This register holds the raw interrupt status before masking has been applied. \ */
/*    Writing '1' will clear the corresponding interrupt. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_irq_raw          0x00000010U
#define Adr_NX51_usb_dev_ctrl_usb_dev_irq_raw 0x1018C810U
#define Adr_NX51_usb_dev_irq_raw              0x1018C810U
#define DFLT_VAL_NX51_usb_dev_irq_raw         0x00000000U

#define MSK_NX51_usb_dev_irq_raw_uart_rx_fifo_full                    0x00000001U
#define SRT_NX51_usb_dev_irq_raw_uart_rx_fifo_full                    0
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_rx_fifo_full               0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_rx_fifo_full            0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_rx_fifo_empty                   0x00000002U
#define SRT_NX51_usb_dev_irq_raw_uart_rx_fifo_empty                   1
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_rx_fifo_empty              0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_rx_fifo_empty           0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_tx_fifo_full                    0x00000004U
#define SRT_NX51_usb_dev_irq_raw_uart_tx_fifo_full                    2
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_tx_fifo_full               0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_tx_fifo_full            0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_tx_fifo_empty                   0x00000008U
#define SRT_NX51_usb_dev_irq_raw_uart_tx_fifo_empty                   3
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_tx_fifo_empty              0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_tx_fifo_empty           0x00000000U
#define MSK_NX51_usb_dev_irq_raw_fifo_overflow_underrun_err           0x00000010U
#define SRT_NX51_usb_dev_irq_raw_fifo_overflow_underrun_err           4
#define DFLT_VAL_NX51_usb_dev_irq_raw_fifo_overflow_underrun_err      0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_fifo_overflow_underrun_err   0x00000000U
#define MSK_NX51_usb_dev_irq_raw_crc16_error                          0x00000020U
#define SRT_NX51_usb_dev_irq_raw_crc16_error                          5
#define DFLT_VAL_NX51_usb_dev_irq_raw_crc16_error                     0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_crc16_error                  0x00000000U
#define MSK_NX51_usb_dev_irq_raw_dropped_frame                        0x00000040U
#define SRT_NX51_usb_dev_irq_raw_dropped_frame                        6
#define DFLT_VAL_NX51_usb_dev_irq_raw_dropped_frame                   0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_dropped_frame                0x00000000U
#define MSK_NX51_usb_dev_irq_raw_reset_detected                       0x00000100U
#define SRT_NX51_usb_dev_irq_raw_reset_detected                       8
#define DFLT_VAL_NX51_usb_dev_irq_raw_reset_detected                  0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_reset_detected               0x00000000U
#define MSK_NX51_usb_dev_irq_raw_jtag_srst_requested                  0x00000200U
#define SRT_NX51_usb_dev_irq_raw_jtag_srst_requested                  9
#define DFLT_VAL_NX51_usb_dev_irq_raw_jtag_srst_requested             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_jtag_srst_requested          0x00000000U
#define MSK_NX51_usb_dev_irq_raw_jtag_tx_packet_sent                  0x00000400U
#define SRT_NX51_usb_dev_irq_raw_jtag_tx_packet_sent                  10
#define DFLT_VAL_NX51_usb_dev_irq_raw_jtag_tx_packet_sent             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_jtag_tx_packet_sent          0x00000000U
#define MSK_NX51_usb_dev_irq_raw_jtag_rx_packet_received              0x00000800U
#define SRT_NX51_usb_dev_irq_raw_jtag_rx_packet_received              11
#define DFLT_VAL_NX51_usb_dev_irq_raw_jtag_rx_packet_received         0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_jtag_rx_packet_received      0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_tx_packet_sent                  0x00001000U
#define SRT_NX51_usb_dev_irq_raw_uart_tx_packet_sent                  12
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_tx_packet_sent             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_tx_packet_sent          0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_rx_packet_received              0x00002000U
#define SRT_NX51_usb_dev_irq_raw_uart_rx_packet_received              13
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_rx_packet_received         0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_rx_packet_received      0x00000000U
#define MSK_NX51_usb_dev_irq_raw_jtag_tx_transaction_sent             0x00010000U
#define SRT_NX51_usb_dev_irq_raw_jtag_tx_transaction_sent             16
#define DFLT_VAL_NX51_usb_dev_irq_raw_jtag_tx_transaction_sent        0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_jtag_tx_transaction_sent     0x00000000U
#define MSK_NX51_usb_dev_irq_raw_jtag_rx_transaction_received         0x00020000U
#define SRT_NX51_usb_dev_irq_raw_jtag_rx_transaction_received         17
#define DFLT_VAL_NX51_usb_dev_irq_raw_jtag_rx_transaction_received    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_jtag_rx_transaction_received 0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_tx_transaction_sent             0x00040000U
#define SRT_NX51_usb_dev_irq_raw_uart_tx_transaction_sent             18
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_tx_transaction_sent        0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_tx_transaction_sent     0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_rx_transaction_received         0x00080000U
#define SRT_NX51_usb_dev_irq_raw_uart_rx_transaction_received         19
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_rx_transaction_received    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_rx_transaction_received 0x00000000U
#define MSK_NX51_usb_dev_irq_raw_uart_rx_zlp_received                 0x00400000U
#define SRT_NX51_usb_dev_irq_raw_uart_rx_zlp_received                 22
#define DFLT_VAL_NX51_usb_dev_irq_raw_uart_rx_zlp_received            0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_uart_rx_zlp_received         0x00000000U
#define MSK_NX51_usb_dev_irq_raw_device_connected                     0x00800000U
#define SRT_NX51_usb_dev_irq_raw_device_connected                     23
#define DFLT_VAL_NX51_usb_dev_irq_raw_device_connected                0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_device_connected             0x00000000U
#define MSK_NX51_usb_dev_irq_raw_device_disconnected                  0x01000000U
#define SRT_NX51_usb_dev_irq_raw_device_disconnected                  24
#define DFLT_VAL_NX51_usb_dev_irq_raw_device_disconnected             0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_irq_raw_device_disconnected          0x00000000U

/* all used bits of 'NX51_usb_dev_irq_raw': */
#define MSK_USED_BITS_NX51_usb_dev_irq_raw 0x01cf3f7fU

enum {
	BFW_NX51_usb_dev_irq_raw_uart_rx_fifo_full            = 1, /* [0] */
	BFW_NX51_usb_dev_irq_raw_uart_rx_fifo_empty           = 1, /* [1] */
	BFW_NX51_usb_dev_irq_raw_uart_tx_fifo_full            = 1, /* [2] */
	BFW_NX51_usb_dev_irq_raw_uart_tx_fifo_empty           = 1, /* [3] */
	BFW_NX51_usb_dev_irq_raw_fifo_overflow_underrun_err   = 1, /* [4] */
	BFW_NX51_usb_dev_irq_raw_crc16_error                  = 1, /* [5] */
	BFW_NX51_usb_dev_irq_raw_dropped_frame                = 1, /* [6] */
	BFW_NX51_usb_dev_irq_raw_reserved1                    = 1, /* [7] */
	BFW_NX51_usb_dev_irq_raw_reset_detected               = 1, /* [8] */
	BFW_NX51_usb_dev_irq_raw_jtag_srst_requested          = 1, /* [9] */
	BFW_NX51_usb_dev_irq_raw_jtag_tx_packet_sent          = 1, /* [10] */
	BFW_NX51_usb_dev_irq_raw_jtag_rx_packet_received      = 1, /* [11] */
	BFW_NX51_usb_dev_irq_raw_uart_tx_packet_sent          = 1, /* [12] */
	BFW_NX51_usb_dev_irq_raw_uart_rx_packet_received      = 1, /* [13] */
	BFW_NX51_usb_dev_irq_raw_reserved2                    = 2, /* [15:14] */
	BFW_NX51_usb_dev_irq_raw_jtag_tx_transaction_sent     = 1, /* [16] */
	BFW_NX51_usb_dev_irq_raw_jtag_rx_transaction_received = 1, /* [17] */
	BFW_NX51_usb_dev_irq_raw_uart_tx_transaction_sent     = 1, /* [18] */
	BFW_NX51_usb_dev_irq_raw_uart_rx_transaction_received = 1, /* [19] */
	BFW_NX51_usb_dev_irq_raw_reserved3                    = 2, /* [21:20] */
	BFW_NX51_usb_dev_irq_raw_uart_rx_zlp_received         = 1, /* [22] */
	BFW_NX51_usb_dev_irq_raw_device_connected             = 1, /* [23] */
	BFW_NX51_usb_dev_irq_raw_device_disconnected          = 1, /* [24] */
	BFW_NX51_usb_dev_irq_raw_reserved4                    = 7  /* [31:25] */
};

typedef struct NX51_USB_DEV_IRQ_RAW_BIT_Ttag {
	unsigned int uart_rx_fifo_full            : BFW_NX51_usb_dev_irq_raw_uart_rx_fifo_full;            /* Unmasked UART receive FIFO full interrupt state:                                      */
	                                                                                                   /* When set the receive FIFO of the UART channel is full.                                */
	unsigned int uart_rx_fifo_empty           : BFW_NX51_usb_dev_irq_raw_uart_rx_fifo_empty;           /* Unmasked UART receive FIFO empty interrupt state:                                     */
	                                                                                                   /* When set the receive FIFO of the UART channel is empty.                               */
	unsigned int uart_tx_fifo_full            : BFW_NX51_usb_dev_irq_raw_uart_tx_fifo_full;            /* Unmasked UART transmit FIFO full interrupt state:                                     */
	                                                                                                   /* When set the transmit FIFO of the UART channel is full.                               */
	unsigned int uart_tx_fifo_empty           : BFW_NX51_usb_dev_irq_raw_uart_tx_fifo_empty;           /* Unmasked UART transmit FIFO empty interrupt state:                                    */
	                                                                                                   /* When set the transmit FIFO of the UART channel is empty.                              */
	unsigned int fifo_overflow_underrun_err   : BFW_NX51_usb_dev_irq_raw_fifo_overflow_underrun_err;   /* Unmasked FIFO overflow or underrun error interrupt state:                             */
	                                                                                                   /* An overflow or underrun of one of the endpoint FIFOs has occurred. The user           */
	                                                                                                   /* needs to check the usb_dev_fifo_ctrl_error register for details.                      */
	unsigned int crc16_error                  : BFW_NX51_usb_dev_irq_raw_crc16_error;                  /* Unmasked CRC16 error in USB packet interrupt state:                                   */
	                                                                                                   /* A CRC16 mismatch in a USB packet has been detected. The corresponding packet          */
	                                                                                                   /* has been dropped.                                                                     */
	unsigned int dropped_frame                : BFW_NX51_usb_dev_irq_raw_dropped_frame;                /* Unmasked dropped frame interrupt state:                                               */
	                                                                                                   /* A dropped frame has been detected, i.e. an endpoint buffer was not free when          */
	                                                                                                   /* the host started to transfer a new packet. Operation continues normally, because the  */
	                                                                                                   /* host will resend the packet later. This interrupt is meant as an information to the   */
	                                                                                                   /* user's software.                                                                      */
	unsigned int reserved1                    : BFW_NX51_usb_dev_irq_raw_reserved1;                    /* reserved                                                                              */
	unsigned int reset_detected               : BFW_NX51_usb_dev_irq_raw_reset_detected;               /* Unmasked reset detected interrupt state:                                              */
	                                                                                                   /* This bit is set, when the USB core detected a reset condition on the bus.             */
	                                                                                                   /* This means that all FIFOs have been reset and the user should check                   */
	                                                                                                   /* FIFO states before reading again.                                                     */
	                                                                                                   /* This bit is set, when the USB core detected a halted condition. This may happen       */
	                                                                                                   /* on bus errors or when the host explicitly requests it.                                */
	unsigned int jtag_srst_requested          : BFW_NX51_usb_dev_irq_raw_jtag_srst_requested;          /* Unmakesd JTAG system reset request detected interrupt state:                          */
	                                                                                                   /* This IRQ is generated, when the USB Host software requested a system reset. \         */
	unsigned int jtag_tx_packet_sent          : BFW_NX51_usb_dev_irq_raw_jtag_tx_packet_sent;          /* Unmasked JTAG tx packet sent interrupt state:                                         */
	                                                                                                   /* A packet in the JTAG transmit FIFO has been sent to the USB host. The FIFO is         */
	                                                                                                   /* normally not under user control.                                                      */
	                                                                                                   /* This IRQ is useful, when the FIFO is in packet control mode.                          */
	unsigned int jtag_rx_packet_received      : BFW_NX51_usb_dev_irq_raw_jtag_rx_packet_received;      /* Unmasked JTAG rx packet received interrupt state:                                     */
	                                                                                                   /* A packet in the JTAG receive FIFO has arrived.                                        */
	                                                                                                   /* This IRQ is useful, when the FIFO is in packet or transaction mode. The FIFO is       */
	                                                                                                   /* normally not under user control.                                                      */
	unsigned int uart_tx_packet_sent          : BFW_NX51_usb_dev_irq_raw_uart_tx_packet_sent;          /* Unmasked UART tx packet sent interrupt state:                                         */
	                                                                                                   /* A packet in the UART transmit FIFO has been sent to the USB host.                     */
	                                                                                                   /* This IRQ is useful, when the FIFO is in packet or transaction mode.                   */
	unsigned int uart_rx_packet_received      : BFW_NX51_usb_dev_irq_raw_uart_rx_packet_received;      /* Unmasked UART rx packet received interrupt state:                                     */
	                                                                                                   /* A packet in the UART receive FIFO has arrived.                                        */
	                                                                                                   /* This IRQ is useful, when the FIFO is in packet or transaction mode.                   */
	unsigned int reserved2                    : BFW_NX51_usb_dev_irq_raw_reserved2;                    /* reserved                                                                              */
	unsigned int jtag_tx_transaction_sent     : BFW_NX51_usb_dev_irq_raw_jtag_tx_transaction_sent;     /* Unmaksed JTAG tx transaction sent interrupt state:                                    */
	                                                                                                   /* A transaction on the JTAG transmit FIFO has been sent to the USB host. The FIFO is    */
	                                                                                                   /* normally not under user control.                                                      */
	                                                                                                   /* This IRQ is useful, when the FIFO is in packet control mode.                          */
	unsigned int jtag_rx_transaction_received : BFW_NX51_usb_dev_irq_raw_jtag_rx_transaction_received; /* Unmasked JTAG rx transaction received interrupt state:                                */
	                                                                                                   /* A transaction on the JTAG receive FIFO has completed.                                 */
	                                                                                                   /* This IRQ is useful, when the FIFO is in transaction mode. The FIFO is                 */
	                                                                                                   /* normally not under user control.                                                      */
	unsigned int uart_tx_transaction_sent     : BFW_NX51_usb_dev_irq_raw_uart_tx_transaction_sent;     /* Unmaksed UART tx transaction sent interrupt state:                                    */
	                                                                                                   /* A transaction on the UART transmit FIFO has been sent to the USB host.                */
	                                                                                                   /* This IRQ is useful, when the FIFO is in transaction mode.                             */
	unsigned int uart_rx_transaction_received : BFW_NX51_usb_dev_irq_raw_uart_rx_transaction_received; /* Unmaksed UART rx transaction received interrupt state:                                */
	                                                                                                   /* A transaction on the UART receive FIFO has completed.                                 */
	                                                                                                   /* This IRQ is useful, when the FIFO is in transaction mode.                             */
	unsigned int reserved3                    : BFW_NX51_usb_dev_irq_raw_reserved3;                    /* reserved                                                                              */
	unsigned int uart_rx_zlp_received         : BFW_NX51_usb_dev_irq_raw_uart_rx_zlp_received;         /* Unmaksed UART rx zero length packet received interrupt mask:                          */
	                                                                                                   /* This IRQ is generated whenever a zero length packet has been received on              */
	                                                                                                   /* the UART rx channel. This is useful to determine if the USB host supports             */
	                                                                                                   /* sending of ZLPs.                                                                      */
	unsigned int device_connected             : BFW_NX51_usb_dev_irq_raw_device_connected;             /* Unmaksed device connected interrupt state:                                            */
	                                                                                                   /* The device has been connected and has been successfully                               */
	                                                                                                   /* addressed and configured by the host.                                                 */
	unsigned int device_disconnected          : BFW_NX51_usb_dev_irq_raw_device_disconnected;          /* Unmasked device disconnected interrupt state:                                         */
	                                                                                                   /* The device has been disconnected from the host, i.e.                                  */
	                                                                                                   /* receiving periodic SOFs timed out.                                                    */
	unsigned int reserved4                    : BFW_NX51_usb_dev_irq_raw_reserved4;                    /* reserved                                                                              */
} NX51_USB_DEV_IRQ_RAW_BIT_T;

typedef union {
	unsigned int               val;
	NX51_USB_DEV_IRQ_RAW_BIT_T bf;
} NX51_USB_DEV_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_irq_masked */
/* => USB device masked interrupt status register. */
/*    If one of these bits is set, the USB device interrupt will be asserted to the interrupt controller. \ */
/*    For a detailed IRQ description view usb_dev_irq_raw. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_irq_masked          0x00000014U
#define Adr_NX51_usb_dev_ctrl_usb_dev_irq_masked 0x1018C814U
#define Adr_NX51_usb_dev_irq_masked              0x1018C814U

#define MSK_NX51_usb_dev_irq_masked_uart_rx_fifo_full            0x00000001U
#define SRT_NX51_usb_dev_irq_masked_uart_rx_fifo_full            0
#define MSK_NX51_usb_dev_irq_masked_uart_rx_fifo_empty           0x00000002U
#define SRT_NX51_usb_dev_irq_masked_uart_rx_fifo_empty           1
#define MSK_NX51_usb_dev_irq_masked_uart_tx_fifo_full            0x00000004U
#define SRT_NX51_usb_dev_irq_masked_uart_tx_fifo_full            2
#define MSK_NX51_usb_dev_irq_masked_uart_tx_fifo_empty           0x00000008U
#define SRT_NX51_usb_dev_irq_masked_uart_tx_fifo_empty           3
#define MSK_NX51_usb_dev_irq_masked_fifo_overflow_underrun_err   0x00000010U
#define SRT_NX51_usb_dev_irq_masked_fifo_overflow_underrun_err   4
#define MSK_NX51_usb_dev_irq_masked_crc16_error                  0x00000020U
#define SRT_NX51_usb_dev_irq_masked_crc16_error                  5
#define MSK_NX51_usb_dev_irq_masked_dropped_frame                0x00000040U
#define SRT_NX51_usb_dev_irq_masked_dropped_frame                6
#define MSK_NX51_usb_dev_irq_masked_reset_detected               0x00000100U
#define SRT_NX51_usb_dev_irq_masked_reset_detected               8
#define MSK_NX51_usb_dev_irq_masked_jtag_srst_requested          0x00000200U
#define SRT_NX51_usb_dev_irq_masked_jtag_srst_requested          9
#define MSK_NX51_usb_dev_irq_masked_jtag_tx_packet_sent          0x00000400U
#define SRT_NX51_usb_dev_irq_masked_jtag_tx_packet_sent          10
#define MSK_NX51_usb_dev_irq_masked_jtag_rx_packet_received      0x00000800U
#define SRT_NX51_usb_dev_irq_masked_jtag_rx_packet_received      11
#define MSK_NX51_usb_dev_irq_masked_uart_tx_packet_sent          0x00001000U
#define SRT_NX51_usb_dev_irq_masked_uart_tx_packet_sent          12
#define MSK_NX51_usb_dev_irq_masked_uart_rx_packet_received      0x00002000U
#define SRT_NX51_usb_dev_irq_masked_uart_rx_packet_received      13
#define MSK_NX51_usb_dev_irq_masked_jtag_tx_transaction_sent     0x00010000U
#define SRT_NX51_usb_dev_irq_masked_jtag_tx_transaction_sent     16
#define MSK_NX51_usb_dev_irq_masked_jtag_rx_transaction_received 0x00020000U
#define SRT_NX51_usb_dev_irq_masked_jtag_rx_transaction_received 17
#define MSK_NX51_usb_dev_irq_masked_uart_tx_transaction_sent     0x00040000U
#define SRT_NX51_usb_dev_irq_masked_uart_tx_transaction_sent     18
#define MSK_NX51_usb_dev_irq_masked_uart_rx_transaction_received 0x00080000U
#define SRT_NX51_usb_dev_irq_masked_uart_rx_transaction_received 19
#define MSK_NX51_usb_dev_irq_masked_uart_rx_zlp_received         0x00400000U
#define SRT_NX51_usb_dev_irq_masked_uart_rx_zlp_received         22
#define MSK_NX51_usb_dev_irq_masked_device_connected             0x00800000U
#define SRT_NX51_usb_dev_irq_masked_device_connected             23
#define MSK_NX51_usb_dev_irq_masked_device_disconnected          0x01000000U
#define SRT_NX51_usb_dev_irq_masked_device_disconnected          24

/* all used bits of 'NX51_usb_dev_irq_masked': */
#define MSK_USED_BITS_NX51_usb_dev_irq_masked 0x01cf3f7fU

enum {
	BFW_NX51_usb_dev_irq_masked_uart_rx_fifo_full            = 1, /* [0] */
	BFW_NX51_usb_dev_irq_masked_uart_rx_fifo_empty           = 1, /* [1] */
	BFW_NX51_usb_dev_irq_masked_uart_tx_fifo_full            = 1, /* [2] */
	BFW_NX51_usb_dev_irq_masked_uart_tx_fifo_empty           = 1, /* [3] */
	BFW_NX51_usb_dev_irq_masked_fifo_overflow_underrun_err   = 1, /* [4] */
	BFW_NX51_usb_dev_irq_masked_crc16_error                  = 1, /* [5] */
	BFW_NX51_usb_dev_irq_masked_dropped_frame                = 1, /* [6] */
	BFW_NX51_usb_dev_irq_masked_reserved1                    = 1, /* [7] */
	BFW_NX51_usb_dev_irq_masked_reset_detected               = 1, /* [8] */
	BFW_NX51_usb_dev_irq_masked_jtag_srst_requested          = 1, /* [9] */
	BFW_NX51_usb_dev_irq_masked_jtag_tx_packet_sent          = 1, /* [10] */
	BFW_NX51_usb_dev_irq_masked_jtag_rx_packet_received      = 1, /* [11] */
	BFW_NX51_usb_dev_irq_masked_uart_tx_packet_sent          = 1, /* [12] */
	BFW_NX51_usb_dev_irq_masked_uart_rx_packet_received      = 1, /* [13] */
	BFW_NX51_usb_dev_irq_masked_reserved2                    = 2, /* [15:14] */
	BFW_NX51_usb_dev_irq_masked_jtag_tx_transaction_sent     = 1, /* [16] */
	BFW_NX51_usb_dev_irq_masked_jtag_rx_transaction_received = 1, /* [17] */
	BFW_NX51_usb_dev_irq_masked_uart_tx_transaction_sent     = 1, /* [18] */
	BFW_NX51_usb_dev_irq_masked_uart_rx_transaction_received = 1, /* [19] */
	BFW_NX51_usb_dev_irq_masked_reserved3                    = 2, /* [21:20] */
	BFW_NX51_usb_dev_irq_masked_uart_rx_zlp_received         = 1, /* [22] */
	BFW_NX51_usb_dev_irq_masked_device_connected             = 1, /* [23] */
	BFW_NX51_usb_dev_irq_masked_device_disconnected          = 1, /* [24] */
	BFW_NX51_usb_dev_irq_masked_reserved4                    = 7  /* [31:25] */
};

typedef struct NX51_USB_DEV_IRQ_MASKED_BIT_Ttag {
	unsigned int uart_rx_fifo_full            : BFW_NX51_usb_dev_irq_masked_uart_rx_fifo_full;            /* Masked UART receive FIFO full interrupt state.              */
	unsigned int uart_rx_fifo_empty           : BFW_NX51_usb_dev_irq_masked_uart_rx_fifo_empty;           /* Masked UART receive FIFO empty interrupt state.             */
	unsigned int uart_tx_fifo_full            : BFW_NX51_usb_dev_irq_masked_uart_tx_fifo_full;            /* Masked UART transmit FIFO full interrupt state.             */
	unsigned int uart_tx_fifo_empty           : BFW_NX51_usb_dev_irq_masked_uart_tx_fifo_empty;           /* Masked UART transmit FIFO empty interrupt state.            */
	unsigned int fifo_overflow_underrun_err   : BFW_NX51_usb_dev_irq_masked_fifo_overflow_underrun_err;   /* Masked FIFO overflow or underrun error interrupt state.     */
	unsigned int crc16_error                  : BFW_NX51_usb_dev_irq_masked_crc16_error;                  /* Masked CRC16 error in USB packet interrupt state.           */
	unsigned int dropped_frame                : BFW_NX51_usb_dev_irq_masked_dropped_frame;                /* Masked dropped frame interrupt state                        */
	unsigned int reserved1                    : BFW_NX51_usb_dev_irq_masked_reserved1;                    /* reserved                                                    */
	unsigned int reset_detected               : BFW_NX51_usb_dev_irq_masked_reset_detected;               /* Masked reset detected interrupt state.                      */
	unsigned int jtag_srst_requested          : BFW_NX51_usb_dev_irq_masked_jtag_srst_requested;          /* Makesd JTAG system reset request detected interrupt state.  */
	unsigned int jtag_tx_packet_sent          : BFW_NX51_usb_dev_irq_masked_jtag_tx_packet_sent;          /* Masked JTAG tx packet sent interrupt state.                 */
	unsigned int jtag_rx_packet_received      : BFW_NX51_usb_dev_irq_masked_jtag_rx_packet_received;      /* Masked JTAG rx packet received interrupt state.             */
	unsigned int uart_tx_packet_sent          : BFW_NX51_usb_dev_irq_masked_uart_tx_packet_sent;          /* Masked UART tx packet sent interrupt state.                 */
	unsigned int uart_rx_packet_received      : BFW_NX51_usb_dev_irq_masked_uart_rx_packet_received;      /* Masked UART rx packet received interrupt state.             */
	unsigned int reserved2                    : BFW_NX51_usb_dev_irq_masked_reserved2;                    /* reserved                                                    */
	unsigned int jtag_tx_transaction_sent     : BFW_NX51_usb_dev_irq_masked_jtag_tx_transaction_sent;     /* Masked JTAG tx transaction sent interrupt mask.             */
	unsigned int jtag_rx_transaction_received : BFW_NX51_usb_dev_irq_masked_jtag_rx_transaction_received; /* Masked JTAG rx transaction received interrupt mask.         */
	unsigned int uart_tx_transaction_sent     : BFW_NX51_usb_dev_irq_masked_uart_tx_transaction_sent;     /* Masked UART tx transaction sent interrupt state.            */
	unsigned int uart_rx_transaction_received : BFW_NX51_usb_dev_irq_masked_uart_rx_transaction_received; /* Masked UART rx transaction received interrupt state.        */
	unsigned int reserved3                    : BFW_NX51_usb_dev_irq_masked_reserved3;                    /* reserved                                                    */
	unsigned int uart_rx_zlp_received         : BFW_NX51_usb_dev_irq_masked_uart_rx_zlp_received;         /* Maksed UART rx zero length packet received interrupt state. */
	unsigned int device_connected             : BFW_NX51_usb_dev_irq_masked_device_connected;             /* Masked device connected interrupt state.                    */
	unsigned int device_disconnected          : BFW_NX51_usb_dev_irq_masked_device_disconnected;          /* Masked device disconnected interrupt state.                 */
	unsigned int reserved4                    : BFW_NX51_usb_dev_irq_masked_reserved4;                    /* reserved                                                    */
} NX51_USB_DEV_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_USB_DEV_IRQ_MASKED_BIT_T bf;
} NX51_USB_DEV_IRQ_MASKED_T;


/* ===================================================================== */

/* Area of usb_dev_enum_ram */

/* ===================================================================== */

#define Addr_NX51_usb_dev_enum_ram 0x1018C840U

/* --------------------------------------------------------------------- */
/* Register usb_dev_enum_ram_descriptors_base */
/* => USB device descriptor start */
/*    Device descriptor configuration start address in the enumeration RAM. */
/*    The layout of the RAM area is as following: */
/*    {         | */
/*    Byte(s)    Function */
/*    ============================================= */
/*               Device descriptor */
/*     0, 1      Vendor ID (low, high) */
/*     2, 3      Product ID (low, high) */
/*     4, 5      Device release number (low, high) */
/*               Configuration descriptor */
/*     6         Configuration characteristics */
/*     7         Maximum power consumption          } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_enum_ram_descriptors_base              0x00000000U
#define Adr_NX51_usb_dev_enum_ram_usb_dev_enum_ram_descriptors_base 0x1018C840U
#define Adr_NX51_usb_dev_enum_ram_descriptors_base                  0x1018C840U

/* --------------------------------------------------------------------- */
/* Register usb_dev_enum_ram_descriptors_end */
/* => USB device descriptor end */
/*    Device descriptor configuration end address */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_enum_ram_descriptors_end              0x00000004U
#define Adr_NX51_usb_dev_enum_ram_usb_dev_enum_ram_descriptors_end 0x1018C844U
#define Adr_NX51_usb_dev_enum_ram_descriptors_end                  0x1018C844U

/* --------------------------------------------------------------------- */
/* Register usb_dev_enum_ram_string_descriptors_base */
/* => USB string descriptor start */
/*    String descriptor start address in the enumeration RAM. */
/*    The layout of the RAM area is as following: */
/*    {         | */
/*    Byte(s)    Function */
/*    ============================================ */
/*    0          Vendor string descriptor length */
/*    1          Vendor string descriptor type */
/*    2 - 17     Vendor string */
/*    18         Product string descriptor length */
/*    19         Product string descriptor type */
/*    20 - 35    Product string */
/*    36         S/N string descriptor length */
/*    37         S/N string descriptor type */
/*    38 - 53    S/N string                          } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_enum_ram_string_descriptors_base              0x00000008U
#define Adr_NX51_usb_dev_enum_ram_usb_dev_enum_ram_string_descriptors_base 0x1018C848U
#define Adr_NX51_usb_dev_enum_ram_string_descriptors_base                  0x1018C848U

/* --------------------------------------------------------------------- */
/* Register usb_dev_enum_ram_string_descriptors_end */
/* => USB string descriptor end */
/*    String descriptor end address */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_enum_ram_string_descriptors_end              0x0000003CU
#define Adr_NX51_usb_dev_enum_ram_usb_dev_enum_ram_string_descriptors_end 0x1018C87CU
#define Adr_NX51_usb_dev_enum_ram_string_descriptors_end                  0x1018C87CU


/* ===================================================================== */

/* Area of usb_dev_fifo_ctrl */

/* ===================================================================== */

#define Addr_NX51_usb_dev_fifo_ctrl 0x1018C880U

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_conf */
/* => USB device FIFO configuration register. */
/*    This register configures the FIFOs of the USB core. The user can select one of three modes for each FIFO. It is also possible to enable \ */
/*    the DMA control signals for the UART RX and TX FIFOs. */
/*    Receive direction (USB naming: OUT transfer) is meant from USB host TO netX. Transmit direction (USB naming: IN transfer) is meant \ */
/*    FROM netX to USB host. */
/*    In stream mode, receive direction all successfully received data from the USB host is directly stored in the FIFO and can be read out \ */
/*    by the system CPU. Packets from the USB host are accepted as long as there is space left in the FIFO. Received Zero-Length-Packtes \ */
/*    will be ignored and not signalized. In addition to FIFO stati IRQs a packet received IRQ will also be generated on newly received packets. */
/*    In stream mode, transmit direction all data put into the FIFO by the system CPU will be transferred at will. This means, there is no \ */
/*    way to control packet borders. Data is being transferred on request by the USB host. Zero-Length-Packets will never be sent to the USB \ */
/*    host. When no data to be sent is available, the core will send a NAK handshake to the USB host. When configured to stream mode with ZLPs, \ */
/*    a ZLP packet will be sent when the last transferred packet has been 64 bytes long and the FIFO has no data to be transferred when the Host */
/*    requests an IN transaction. In addition to FIFO stati IRQs a packet sent IRQ will also be generated on sent packets. */
/*    In packet mode, receive direction a new packet sent by the USB host is only accepted when the rx_len register has been read after the \ */
/*    packet reception. Received Zero-Length-Packtes will be ignored and not signalized. In addition to FIFO stati IRQs a packet received IRQ \ */
/*    will also be generated on newly received packets. */
/*    In transaction mode, receive direction the FIFO operates on transactions. A transaction is finished whenever the first packet with a size \ */
/*    less than 64 bytes or a Zero-Length-Packet arrives. Packet received IRQs will be generated on all packet receptions. The transaction \ */
/*    received IRQ will be generated when the transaction is finished. To accept the next transaction, the rx_len register must be read. */
/*    Packet and transaction modes in transmit direction are identical. To achieve single packet transmissions a transaction size of 64 bytes \ */
/*    must be programmed. The behaviour when the programmed transaction is finished and the USB host request an IN transfer depends on the \ */
/*    configuration of the 'transaction_no_zlp' bit. When set, no Zero-Length-Packets will be generated, otherwise a ZLP will be sent if \ */
/*    needed (i.e. the last transferred packet had a packet size of 64 bytes). After sending the ZLP, NAKs will be generated for IN requests. \ */
/*    Should the FIFO get empty during a programmed transaction or not a full 64 byte packet is available in the FIFO, a NAK handshake will be \ */
/*    generated for IN requests. This ensures that a transaction will not be considered finished by the USB host before the programmed size \ */
/*    has been transferred. In addition to FIFO stati IRQs a packet sent and transaction sent IRQ will also be generated on sent packets / \ */
/*    completed transactions. */
/*     */
/*    The default configuration of the UART channel is stream mode with ZLPs in both directions. */
/*    The JTAG channel may only be reconfigured when not used for JTAG communication (i.e. USB host configured JTAG bypass mode). For \ */
/*    normal system operation they need to be configured in stream mode. */
/*     */
/*    Note: To use the DMA controller, the dma_en bits must be enabled here. Otherwise no DMAC handshake signals will be generated. */
/*    For correct operation with the DMAC the following sequence must be maintained: */
/*    Stream mode: just read or write the data to the FIFO. Flow controller must be the DMAC. */
/*    Packet mode, receive: Program read of data, afterwards the rx_len register must be read by the DMAC (will also be signalized to \ */
/*    the DMAC by the FIFO). Flow controller is the USB core (peripheral controlled). */
/*    Packet mode, transmit: The tx_len register with the control information must be programmed by the DMAC first (will also be signalized to \ */
/*    the DMAC). After that feed the data. Flow controller is the USB core (peripheral controlled). */
/*    Transaction mode, receive: same as packet mode, receive. */
/*    Transaction mode, transmit: same as packet mode, transmit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_conf               0x00000000U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_conf 0x1018C880U
#define Adr_NX51_usb_dev_fifo_ctrl_conf                   0x1018C880U
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf              0x00001017U

#define MSK_NX51_usb_dev_fifo_ctrl_conf_mode_interrupt                        0x00000003U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_mode_interrupt                        0
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_interrupt                   0x00000003U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_interrupt                0x00000003U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_mode_uart_rx                          0x0000000cU
#define SRT_NX51_usb_dev_fifo_ctrl_conf_mode_uart_rx                          2
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_uart_rx                     0x00000004U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_uart_rx                  0x00000001U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_mode_uart_tx                          0x00000030U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_mode_uart_tx                          4
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_uart_tx                     0x00000010U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_uart_tx                  0x00000001U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_rx                          0x000000c0U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_rx                          6
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_rx                     0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_rx                  0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_tx                          0x00000300U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_tx                          8
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_tx                     0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_tx                  0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_rx                        0x00000400U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_rx                        10
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_rx                   0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_rx                0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_tx                        0x00000800U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_tx                        11
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_tx                   0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_tx                0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_dma_uart_tx_stream_burst_only         0x00001000U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_dma_uart_tx_stream_burst_only         12
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_dma_uart_tx_stream_burst_only    0x00001000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_dma_uart_tx_stream_burst_only 0x00000001U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_reset                                 0x000fe000U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_reset                                 13
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_reset                            0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_reset                         0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_max_transaction_len                   0x07f00000U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_max_transaction_len                   20
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_max_transaction_len              0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_max_transaction_len           0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_uart_rx_nak_all                       0x08000000U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_uart_rx_nak_all                       27
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_uart_rx_nak_all                  0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_uart_rx_nak_all               0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_conf_jtag_rx_nak_all                       0x10000000U
#define SRT_NX51_usb_dev_fifo_ctrl_conf_jtag_rx_nak_all                       28
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_conf_jtag_rx_nak_all                  0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_conf_jtag_rx_nak_all               0x00000000U

/* all used bits of 'NX51_usb_dev_fifo_ctrl_conf': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_conf 0x1fffffffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_conf_mode_interrupt                = 2, /* [1:0] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_mode_uart_rx                  = 2, /* [3:2] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_mode_uart_tx                  = 2, /* [5:4] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_rx                  = 2, /* [7:6] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_tx                  = 2, /* [9:8] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_rx                = 1, /* [10] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_tx                = 1, /* [11] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_dma_uart_tx_stream_burst_only = 1, /* [12] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_reset                         = 7, /* [19:13] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_max_transaction_len           = 7, /* [26:20] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_uart_rx_nak_all               = 1, /* [27] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_jtag_rx_nak_all               = 1, /* [28] */
	BFW_NX51_usb_dev_fifo_ctrl_conf_reserved1                     = 3  /* [31:29] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_CONF_BIT_Ttag {
	unsigned int mode_interrupt                : BFW_NX51_usb_dev_fifo_ctrl_conf_mode_interrupt;                /* Selects the mode of Endpoint 1 - Interrupt IN, FIFO 2.                                                          */
	                                                                                                            /* Each FIFO is configured by two bits to select between the following modes:                                      */
	                                                                                                            /* {       |                                                                                                       */
	                                                                                                            /*  binary   mode                                                                                                  */
	                                                                                                            /*  2'b00    stream-mode (i.e. all valid data will be directly transferred.)                                       */
	                                                                                                            /*  2'b01    stream-mode with zero-length-packets                                                                  */
	                                                                                                            /*  2'b10    packet-mode (packet-based transfers)                                                                  */
	                                                                                                            /*  2'b11    transaction-mode (transaction-based with preprogrammed transfer size)                                 */
	                                                                                                            /*           }                                                                                                     */
	                                                                                                            /* Note: When a FIFO is used in TX direction, packet-mode and transction-mode is identical.                        */
	                                                                                                            /* The behaviour is configured when programming the corresponding FIFO tx_len register.                            */
	                                                                                                            /* UART RX and TX are fully user definable (see text above), but should operate in a mode with ZLP generation      */
	                                                                                                            /* for CDC drivers to work properly (i.e. stream mode with ZLP, packet or transaction mode with no_zlp unset).     */
	                                                                                                            /* JTAG RX and TX may be switched, when the USB host has switched to JTAG bypass mode (see text above), otherwise  */
	                                                                                                            /* they must be kept in stream mode.                                                                               */
	unsigned int mode_uart_rx                  : BFW_NX51_usb_dev_fifo_ctrl_conf_mode_uart_rx;                  /* Selects the mode of Endpoint 2 - UART RX (OUT), FIFO 3. For details see 'mode_interrupt'.                       */
	unsigned int mode_uart_tx                  : BFW_NX51_usb_dev_fifo_ctrl_conf_mode_uart_tx;                  /* Selects the mode of Endpoint 3 - UART TX (IN), FIFO 4. For details see 'mode_interrupt'.                        */
	unsigned int mode_jtag_rx                  : BFW_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_rx;                  /* Selects the mode of Endpoint 4 - JTAG RX (OUT), FIFO 5. For details see 'mode_interrupt'.                       */
	unsigned int mode_jtag_tx                  : BFW_NX51_usb_dev_fifo_ctrl_conf_mode_jtag_tx;                  /* Selects the mode of Endpoint 5 - JTAG TX (IN), FIFO 6. For details see 'mode_interrupt'.                        */
	unsigned int dma_en_uart_rx                : BFW_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_rx;                /* Enables DMA control on UART RX channel.                                                                         */
	                                                                                                            /* Note: The maximum transaction length may be configured with the max_transaction_len bits.                       */
	                                                                                                            /* The total buffer size of the DMAC request must also satisfy this limit.                                         */
	unsigned int dma_en_uart_tx                : BFW_NX51_usb_dev_fifo_ctrl_conf_dma_en_uart_tx;                /* Enables DMA control on UART TX channel.                                                                         */
	unsigned int dma_uart_tx_stream_burst_only : BFW_NX51_usb_dev_fifo_ctrl_conf_dma_uart_tx_stream_burst_only; /* Configures usage of DMAC single requests of the UART TX FIFO:                                                   */
	                                                                                                            /* When set to '1' the DMAC logic of the UART TX FIFO will only generate burst                                     */
	                                                                                                            /* requests to the DMAC when the FIFO is configured to stream mode. This is to                                     */
	                                                                                                            /* overcome limitations of the current DMA controller implementation that only                                     */
	                                                                                                            /* accepts burst requests for DMAC controlled memory to peripheral transfers.                                      */
	                                                                                                            /* Note: If active, the FIFO may not be filled completely by the DMAC in some                                      */
	                                                                                                            /* situations due to the lack of working single requests.                                                          */
	unsigned int reset                         : BFW_NX51_usb_dev_fifo_ctrl_conf_reset;                         /* Endpoint reset:                                                                                                 */
	                                                                                                            /* Writing a '1' to a bit resets the corresponding endpoint FIFO.                                                  */
	                                                                                                            /* Resets must be manually cleared by the user.                                                                    */
	                                                                                                            /* Bit to FIFO mapping:                                                                                            */
	                                                                                                            /* {       |                                                                                                       */
	                                                                                                            /*  Bit      FIFO                                                                                                  */
	                                                                                                            /*  0        Endpoint 0 Control OUT (FIFO 0)                                                                       */
	                                                                                                            /*  1        Endpoint 0 Control IN (FIFO 1)                                                                        */
	                                                                                                            /*  2        Endpoint 1 Interrupt IN (FIFO 2)                                                                      */
	                                                                                                            /*  3        Endpoint 2 UART Rx (FIFO 3)                                                                           */
	                                                                                                            /*  4        Endpoint 3 UART Tx (FIFO 4)                                                                           */
	                                                                                                            /*  5        Endpoint 4 JTAG Rx (FIFO 5)                                                                           */
	                                                                                                            /*  6        Endpoint 5 JTAG Tx (FIFO 6)                                                                           */
	                                                                                                            /*           }                                                                                                     */
	unsigned int max_transaction_len           : BFW_NX51_usb_dev_fifo_ctrl_conf_max_transaction_len;           /* Maximum transaction length in 64 byte quantums:                                                                 */
	                                                                                                            /* Only used for the Rx-FIFOs in transaction mode.                                                                 */
	                                                                                                            /* If an incoming transaction reaches (max_transaction_len * 64) bytes, the                                        */
	                                                                                                            /* transaction will be split on this boundary, i.e. it will be handled as if the                                   */
	                                                                                                            /* host sent a transaction of this size followed by another transaction with the rest.                             */
	                                                                                                            /* This condition will be signaled by the 'transaction_max_reached' bit in the                                     */
	                                                                                                            /* corresponding 'rx_len' register for the first transaction. Additionally, the                                    */
	                                                                                                            /* 'transaction_continued' bit will be set in the following transaction. For a                                     */
	                                                                                                            /* transaction lengt of exactly the configured size the 'transaction_continued'                                    */
	                                                                                                            /* bit in the following transaction will not be set.                                                               */
	                                                                                                            /* Configuring '0' will not limit the transaction length.                                                          */
	unsigned int uart_rx_nak_all               : BFW_NX51_usb_dev_fifo_ctrl_conf_uart_rx_nak_all;               /* NAK all received packets on the UART channel.                                                                   */
	                                                                                                            /* When set, all further received packets on the UART channel will be NAKed. This is useful                        */
	                                                                                                            /* when changing the FIFO mode on the fly is needed.                                                               */
	unsigned int jtag_rx_nak_all               : BFW_NX51_usb_dev_fifo_ctrl_conf_jtag_rx_nak_all;               /* NAK all received packets on the JTAG channel.                                                                   */
	                                                                                                            /* When set, all further received packets on the JTAG channel will be NAKed. This is useful                        */
	                                                                                                            /* when changing the FIFO mode on the fly is needed.                                                               */
	unsigned int reserved1                     : BFW_NX51_usb_dev_fifo_ctrl_conf_reserved1;                     /* reserved                                                                                                        */
} NX51_USB_DEV_FIFO_CTRL_CONF_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_USB_DEV_FIFO_CTRL_CONF_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_CONF_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_error */
/* => USB device FIFOs error status register. */
/*    This register holds the overflow and underrun flags of all FIFOs. To reset a flag the corresponding FIFO must be reset. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_error               0x00000004U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_error 0x1018C884U
#define Adr_NX51_usb_dev_fifo_ctrl_error                   0x1018C884U

#define MSK_NX51_usb_dev_fifo_ctrl_error_overflow 0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_error_overflow 0
#define MSK_NX51_usb_dev_fifo_ctrl_error_underrun 0x007f0000U
#define SRT_NX51_usb_dev_fifo_ctrl_error_underrun 16

/* all used bits of 'NX51_usb_dev_fifo_ctrl_error': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_error 0x007f007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_error_overflow  = 7, /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_error_reserved1 = 9, /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_error_underrun  = 7, /* [22:16] */
	BFW_NX51_usb_dev_fifo_ctrl_error_reserved2 = 9  /* [31:23] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_ERROR_BIT_Ttag {
	unsigned int overflow  : BFW_NX51_usb_dev_fifo_ctrl_error_overflow;  /* Combined overflow flags for FIFOs 6-0. */
	unsigned int reserved1 : BFW_NX51_usb_dev_fifo_ctrl_error_reserved1; /* reserved                               */
	unsigned int underrun  : BFW_NX51_usb_dev_fifo_ctrl_error_underrun;  /* Combined underrun flags for FIFOs 6-0. */
	unsigned int reserved2 : BFW_NX51_usb_dev_fifo_ctrl_error_reserved2; /* reserved                               */
} NX51_USB_DEV_FIFO_CTRL_ERROR_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_USB_DEV_FIFO_CTRL_ERROR_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_ERROR_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_control_ep_rx_len */
/* => USB device Endpoint 0 - Control OUT, FIFO 0 length register. */
/*    This register holds the fill levels and other status information of FIFO 0. */
/*    Use this register for debug purposes only. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_control_ep_rx_len               0x00000008U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_control_ep_rx_len 0x1018C888U
#define Adr_NX51_usb_dev_fifo_ctrl_control_ep_rx_len                   0x1018C888U

#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_packet_len      0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_packet_len      0
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_transaction_len 0x1fff0000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_transaction_len 16

/* all used bits of 'NX51_usb_dev_fifo_ctrl_control_ep_rx_len': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_control_ep_rx_len 0x1fff007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_packet_len      = 7,  /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_reserved1       = 9,  /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_transaction_len = 13, /* [28:16] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_reserved2       = 3   /* [31:29] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_LEN_BIT_Ttag {
	unsigned int packet_len      : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_packet_len;      /* Size of the last received packet. This is a read only status bit field.                 */
	unsigned int reserved1       : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_reserved1;       /* reserved                                                                                */
	unsigned int transaction_len : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_transaction_len; /* Read only: When a transaction has finished, this is the actual size, otherwise 0.       */
	                                                                                             /* Note: In case the USB host sends a transaction bigger than 8128 bytes (8k - 64), the    */
	                                                                                             /* transaction will be split on this boundary (i.e. it will be handled as if the           */
	                                                                                             /* host sent a transaction with size 8128, followed by another transaction with the rest). */
	unsigned int reserved2       : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_len_reserved2;       /* reserved                                                                                */
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_LEN_BIT_T;

typedef union {
	unsigned int                                   val;
	NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_LEN_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_control_ep_rx_stat */
/* => USB device Endpoint 0 - Control OUT, FIFO 0 status register. */
/*    This register holds the fill levels and other status information of FIFO 0. */
/*    Use this register for debug purposes only. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat               0x0000000CU
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_control_ep_rx_stat 0x1018C88CU
#define Adr_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat                   0x1018C88CU

#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_fill_level             0x000001ffU
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_fill_level             0
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_packet_transfer_active 0x10000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_packet_transfer_active 28
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_transaction_active     0x20000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_transaction_active     29
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_empty                  0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_empty                  30
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_full                   0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_full                   31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_control_ep_rx_stat': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat 0xf00001ffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_fill_level             = 9,  /* [8:0] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_reserved1              = 19, /* [27:9] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_packet_transfer_active = 1,  /* [28] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_transaction_active     = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_empty                  = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_full                   = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_STAT_BIT_Ttag {
	unsigned int fill_level             : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_fill_level;             /* Fill level of the FIFO (excluding non-acked data).         */
	unsigned int reserved1              : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_reserved1;              /* reserved                                                   */
	unsigned int packet_transfer_active : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_packet_transfer_active; /* A packet transfer is currently active.                     */
	                                                                                                            /* This bit is active when the host currently sends a packet  */
	                                                                                                            /* that isn't valid yet.                                      */
	unsigned int transaction_active     : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_transaction_active;     /* A transaction is currently active.                         */
	unsigned int empty                  : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_empty;                  /* FIFO is empty (excluding data not yet acked by USB core).  */
	unsigned int full                   : BFW_NX51_usb_dev_fifo_ctrl_control_ep_rx_stat_full;                   /* FIFO is full (including data not yet acked by USB core).   */
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_STAT_BIT_T;

typedef union {
	unsigned int                                    val;
	NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_STAT_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_RX_STAT_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_control_ep_tx_len */
/* => USB device Endpoint 0 - Control IN, FIFO 1 length register. */
/*    This register holds the fill levels and other status information of FIFO 1. */
/*    Use this register for debug purposes only. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_control_ep_tx_len               0x00000010U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_control_ep_tx_len 0x1018C890U
#define Adr_NX51_usb_dev_fifo_ctrl_control_ep_tx_len                   0x1018C890U
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_control_ep_tx_len              0x00000000U

#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_packet_len                 0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_packet_len                 0
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_packet_len            0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_packet_len         0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_len            0x1fff0000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_len            16
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_len       0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_len    0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_no_zlp         0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_no_zlp         31
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_no_zlp    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_no_zlp 0x00000000U

/* all used bits of 'NX51_usb_dev_fifo_ctrl_control_ep_tx_len': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_control_ep_tx_len 0x9fff007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_packet_len         = 7,  /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_reserved1          = 9,  /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_len    = 13, /* [28:16] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_reserved2          = 2,  /* [30:29] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_no_zlp = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_LEN_BIT_Ttag {
	unsigned int packet_len         : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_packet_len;         /* Size of the last sent packet. This is a read only status bit field.                 */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_reserved1;          /* reserved                                                                            */
	unsigned int transaction_len    : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_len;    /* Read: Number of bytes left in the programmed transfer.                              */
	                                                                                                   /* Write: The actual size of the transaction. Set to 0 to abort a running transcation. */
	                                                                                                   /* Note: This bit field is writable but can also be changed by hardware.               */
	unsigned int reserved2          : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_reserved2;          /* reserved                                                                            */
	unsigned int transaction_no_zlp : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_len_transaction_no_zlp; /* When set to '1' no ZLP will be sent, when a transaction is finished.                */
	                                                                                                   /* This bit will be reset automatically by hardware and is always '0' on read.         */
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_LEN_BIT_T;

typedef union {
	unsigned int                                   val;
	NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_LEN_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_control_ep_tx_stat */
/* => USB device Endpoint 0 - Control IN, FIFO 1 status register. */
/*    This register holds the fill levels and other status information of FIFO 1. */
/*    Use this register for debug purposes only. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat               0x00000014U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_control_ep_tx_stat 0x1018C894U
#define Adr_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat                   0x1018C894U

#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_fill_level         0x000001ffU
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_fill_level         0
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_transaction_active 0x20000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_transaction_active 29
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_empty              0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_empty              30
#define MSK_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_full               0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_full               31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_control_ep_tx_stat': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat 0xe00001ffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_fill_level         = 9,  /* [8:0] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_reserved1          = 20, /* [28:9] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_transaction_active = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_empty              = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_full               = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_STAT_BIT_Ttag {
	unsigned int fill_level         : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_fill_level;         /* Fill level of the FIFO (including data currently in transit).                */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_reserved1;          /* reserved                                                                     */
	unsigned int transaction_active : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_transaction_active; /* A transaction is currently active. No further transaction may be programmed. */
	unsigned int empty              : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_empty;              /* FIFO is empty (including data still needed by USB core).                     */
	unsigned int full               : BFW_NX51_usb_dev_fifo_ctrl_control_ep_tx_stat_full;               /* FIFO is full (including data still needed by USB core).                      */
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_STAT_BIT_T;

typedef union {
	unsigned int                                    val;
	NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_STAT_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_CONTROL_EP_TX_STAT_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_interrupt_ep_tx_len */
/* => USB device Endpoint 1 - Interrupt IN, FIFO 2 length register. */
/*    This register is used to program or abort a transaction. */
/*    Note: It is not allowed to re-program a transaction while it is active. Only an abort is allowed. */
/*    Note: A new transaction may only programmed when the last transaction is finished (i.e. check 'transaction_active' \ */
/*    flag in the tx_stat register). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len               0x00000018U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_interrupt_ep_tx_len 0x1018C898U
#define Adr_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len                   0x1018C898U
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len              0x00000000U

#define MSK_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_packet_len                 0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_packet_len                 0
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_packet_len            0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_packet_len         0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_len            0x1fff0000U
#define SRT_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_len            16
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_len       0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_len    0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_no_zlp         0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_no_zlp         31
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_no_zlp    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_no_zlp 0x00000000U

/* all used bits of 'NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len 0x9fff007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_packet_len         = 7,  /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_reserved1          = 9,  /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_len    = 13, /* [28:16] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_reserved2          = 2,  /* [30:29] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_no_zlp = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_LEN_BIT_Ttag {
	unsigned int packet_len         : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_packet_len;         /* Size of the last sent packet. This is a read only status bit field.                 */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_reserved1;          /* reserved                                                                            */
	unsigned int transaction_len    : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_len;    /* Read: Number of bytes left in the programmed transfer.                              */
	                                                                                                     /* Write: The actual size of the transaction. Set to 0 to abort a running transcation. */
	                                                                                                     /* Note: This bit field is writable but can also be changed by hardware.               */
	unsigned int reserved2          : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_reserved2;          /* reserved                                                                            */
	unsigned int transaction_no_zlp : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_len_transaction_no_zlp; /* When set to '1' no ZLP will be sent, when a transaction is finished.                */
	                                                                                                     /* This bit will be reset automatically by hardware and is always '0' on read.         */
} NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_LEN_BIT_T;

typedef union {
	unsigned int                                     val;
	NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_LEN_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_interrupt_ep_tx_stat */
/* => USB device Endpoint 1 - Control IN, FIFO 2 status register. */
/*    This register holds the fill levels and other status information of FIFO 2. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat               0x0000001CU
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_interrupt_ep_tx_stat 0x1018C89CU
#define Adr_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat                   0x1018C89CU

#define MSK_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_fill_level         0x000001ffU
#define SRT_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_fill_level         0
#define MSK_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_transaction_active 0x20000000U
#define SRT_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_transaction_active 29
#define MSK_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_empty              0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_empty              30
#define MSK_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_full               0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_full               31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat 0xe00001ffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_fill_level         = 9,  /* [8:0] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_reserved1          = 20, /* [28:9] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_transaction_active = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_empty              = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_full               = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_STAT_BIT_Ttag {
	unsigned int fill_level         : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_fill_level;         /* Fill level of the FIFO (including data currently in transit).                */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_reserved1;          /* reserved                                                                     */
	unsigned int transaction_active : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_transaction_active; /* A transaction is currently active. No further transaction may be programmed. */
	unsigned int empty              : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_empty;              /* FIFO is empty (including data still needed by USB core).                     */
	unsigned int full               : BFW_NX51_usb_dev_fifo_ctrl_interrupt_ep_tx_stat_full;               /* FIFO is full (including data still needed by USB core).                      */
} NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_STAT_BIT_T;

typedef union {
	unsigned int                                      val;
	NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_STAT_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_INTERRUPT_EP_TX_STAT_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_uart_ep_rx_len */
/* => USB device Endpoint 2 - UART RX (OUT), FIFO 3 length register. */
/*    This register holds the status information of FIFO 3. It is also used to acknowledge a transaction or packet reception. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len               0x00000020U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_uart_ep_rx_len 0x1018C8A0U
#define Adr_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len                   0x1018C8A0U

#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_packet_len              0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_packet_len              0
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_len         0x1fff0000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_len         16
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_max_reached 0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_max_reached 30
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_continued   0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_continued   31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_uart_ep_rx_len': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len 0xdfff007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_packet_len              = 7,  /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_reserved1               = 9,  /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_len         = 13, /* [28:16] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_reserved2               = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_max_reached = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_continued   = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_LEN_BIT_Ttag {
	unsigned int packet_len              : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_packet_len;              /* Size of the last received packet.                                                       */
	unsigned int reserved1               : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_reserved1;               /* reserved                                                                                */
	unsigned int transaction_len         : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_len;         /* When a transaction has finished, this is the actual size, otherwise 0.                  */
	                                                                                                          /* Note: In case the USB host sends a transaction bigger than 8128 bytes (8k - 64), the    */
	                                                                                                          /* transaction will be split on this boundary (i.e. it will be handled as if the           */
	                                                                                                          /* host sent a transaction with size 8128, followed by another transaction with the rest). */
	unsigned int reserved2               : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_reserved2;               /* reserved                                                                                */
	unsigned int transaction_max_reached : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_max_reached; /* This transaction reached the configured maximum transaction length.                     */
	                                                                                                          /* Following data will be put into the next transaction.                                   */
	unsigned int transaction_continued   : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_len_transaction_continued;   /* This transaction is a continuation of the last transaction.                             */
} NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_LEN_BIT_T;

typedef union {
	unsigned int                                val;
	NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_LEN_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_uart_ep_rx_stat */
/* => USB device Endpoint 2 - UART RX (OUT), FIFO 3 status register. */
/*    This register holds the fill levels and other status information of FIFO 3. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat               0x00000024U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_uart_ep_rx_stat 0x1018C8A4U
#define Adr_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat                   0x1018C8A4U

#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_fill_level             0x000001ffU
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_fill_level             0
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_packet_transfer_active 0x10000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_packet_transfer_active 28
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_transaction_active     0x20000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_transaction_active     29
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_empty                  0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_empty                  30
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_full                   0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_full                   31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat 0xf00001ffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_fill_level             = 9,  /* [8:0] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_reserved1              = 19, /* [27:9] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_packet_transfer_active = 1,  /* [28] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_transaction_active     = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_empty                  = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_full                   = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_STAT_BIT_Ttag {
	unsigned int fill_level             : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_fill_level;             /* Fill level of the FIFO (excluding non-acked data).                           */
	unsigned int reserved1              : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_reserved1;              /* reserved                                                                     */
	unsigned int packet_transfer_active : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_packet_transfer_active; /* A packet transfer is currently active.                                       */
	                                                                                                         /* This bit is active when the host currently sends a packet                    */
	                                                                                                         /* that isn't valid yet.                                                        */
	unsigned int transaction_active     : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_transaction_active;     /* A transaction is currently active. No further transaction may be programmed. */
	unsigned int empty                  : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_empty;                  /* FIFO is empty (excluding data not yet acked by USB core).                    */
	unsigned int full                   : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_rx_stat_full;                   /* FIFO is full (including data not yet acked by USB core).                     */
} NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_STAT_BIT_T;

typedef union {
	unsigned int                                 val;
	NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_STAT_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_UART_EP_RX_STAT_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_uart_ep_tx_len */
/* => USB device Endpoint 3 - UART TX (IN), FIFO 4 length register. */
/*    This register is used to program or abort a transaction. */
/*    Note: It is not allowed to re-program a transaction while it is active. Only an abort is allowed. */
/*    Note: A new transaction may only programmed when the last transaction is finished (i.e. check 'transaction_active' \ */
/*    flag in the tx_stat register). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len               0x00000028U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_uart_ep_tx_len 0x1018C8A8U
#define Adr_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len                   0x1018C8A8U
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len              0x00000000U

#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_packet_len                 0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_packet_len                 0
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_packet_len            0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_packet_len         0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_len            0x1fff0000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_len            16
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_len       0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_len    0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_no_zlp         0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_no_zlp         31
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_no_zlp    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_no_zlp 0x00000000U

/* all used bits of 'NX51_usb_dev_fifo_ctrl_uart_ep_tx_len': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len 0x9fff007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_packet_len         = 7,  /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_reserved1          = 9,  /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_len    = 13, /* [28:16] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_reserved2          = 2,  /* [30:29] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_no_zlp = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_LEN_BIT_Ttag {
	unsigned int packet_len         : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_packet_len;         /* Size of the last sent packet. This is a read only status bit field.                 */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_reserved1;          /* reserved                                                                            */
	unsigned int transaction_len    : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_len;    /* Read: Number of bytes left in the programmed transfer.                              */
	                                                                                                /* Write: The actual size of the transaction. Set to 0 to abort a running transcation. */
	                                                                                                /* Note: This bit field is writable but can also be changed by hardware.               */
	unsigned int reserved2          : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_reserved2;          /* reserved                                                                            */
	unsigned int transaction_no_zlp : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_len_transaction_no_zlp; /* When set to '1' no ZLP will be sent, when a transaction is finished.                */
	                                                                                                /* This bit will be reset automatically by hardware and is always '0' on read.         */
} NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_LEN_BIT_T;

typedef union {
	unsigned int                                val;
	NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_LEN_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_uart_ep_tx_stat */
/* => USB device Endpoint 3 - UART TX (IN), FIFO 4 status register. */
/*    This register holds the fill levels and other status information of FIFO 4. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat               0x0000002CU
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_uart_ep_tx_stat 0x1018C8ACU
#define Adr_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat                   0x1018C8ACU

#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_fill_level         0x000001ffU
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_fill_level         0
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_transaction_active 0x20000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_transaction_active 29
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_empty              0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_empty              30
#define MSK_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_full               0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_full               31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat 0xe00001ffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_fill_level         = 9,  /* [8:0] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_reserved1          = 20, /* [28:9] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_transaction_active = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_empty              = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_full               = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_STAT_BIT_Ttag {
	unsigned int fill_level         : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_fill_level;         /* Fill level of the FIFO (including data currently in transit).                */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_reserved1;          /* reserved                                                                     */
	unsigned int transaction_active : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_transaction_active; /* A transaction is currently active. No further transaction may be programmed. */
	unsigned int empty              : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_empty;              /* FIFO is empty (including data still needed by USB core).                     */
	unsigned int full               : BFW_NX51_usb_dev_fifo_ctrl_uart_ep_tx_stat_full;               /* FIFO is full (including data still needed by USB core).                      */
} NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_STAT_BIT_T;

typedef union {
	unsigned int                                 val;
	NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_STAT_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_UART_EP_TX_STAT_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_jtag_ep_rx_len */
/* => USB device Endpoint 4 - JTAG RX (OUT), FIFO 5 length register. */
/*    This register holds the status information of FIFO 5. It is also used to acknowledge a transaction or packet reception. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len               0x00000030U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_jtag_ep_rx_len 0x1018C8B0U
#define Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len                   0x1018C8B0U

#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_packet_len              0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_packet_len              0
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_len         0x1fff0000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_len         16
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_max_reached 0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_max_reached 30
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_continued   0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_continued   31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len 0xdfff007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_packet_len              = 7,  /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_reserved1               = 9,  /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_len         = 13, /* [28:16] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_reserved2               = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_max_reached = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_continued   = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_LEN_BIT_Ttag {
	unsigned int packet_len              : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_packet_len;              /* Size of the last received packet.                                                       */
	unsigned int reserved1               : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_reserved1;               /* reserved                                                                                */
	unsigned int transaction_len         : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_len;         /* When a transaction has finished, this is the actual size, otherwise 0.                  */
	                                                                                                          /* Note: In case the USB host sends a transaction bigger than 8128 bytes (8k - 64), the    */
	                                                                                                          /* transaction will be split on this boundary (i.e. it will be handled as if the           */
	                                                                                                          /* host sent a transaction with size 8128, followed by another transaction with the rest). */
	unsigned int reserved2               : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_reserved2;               /* reserved                                                                                */
	unsigned int transaction_max_reached : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_max_reached; /* This transaction reached the configured maximum transaction length.                     */
	                                                                                                          /* Following data will be put into the next transaction.                                   */
	unsigned int transaction_continued   : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_len_transaction_continued;   /* This transaction is a continuation of the last transaction.                             */
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_LEN_BIT_T;

typedef union {
	unsigned int                                val;
	NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_LEN_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_jtag_ep_rx_stat */
/* => USB device Endpoint 4 - JTAG RX (OUT), FIFO 5 status register. */
/*    This register holds the fill levels and other status information of FIFO 5. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat               0x00000034U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_jtag_ep_rx_stat 0x1018C8B4U
#define Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat                   0x1018C8B4U

#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_fill_level             0x000001ffU
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_fill_level             0
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_packet_transfer_active 0x10000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_packet_transfer_active 28
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_transaction_active     0x20000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_transaction_active     29
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_empty                  0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_empty                  30
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_full                   0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_full                   31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat 0xf00001ffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_fill_level             = 9,  /* [8:0] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_reserved1              = 19, /* [27:9] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_packet_transfer_active = 1,  /* [28] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_transaction_active     = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_empty                  = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_full                   = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_STAT_BIT_Ttag {
	unsigned int fill_level             : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_fill_level;             /* Fill level of the FIFO (excluding non-acked data).                           */
	unsigned int reserved1              : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_reserved1;              /* reserved                                                                     */
	unsigned int packet_transfer_active : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_packet_transfer_active; /* A packet transfer is currently active.                                       */
	                                                                                                         /* This bit is active when the host currently sends a packet                    */
	                                                                                                         /* that isn't valid yet.                                                        */
	unsigned int transaction_active     : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_transaction_active;     /* A transaction is currently active. No further transaction may be programmed. */
	unsigned int empty                  : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_empty;                  /* FIFO is empty (excluding data not yet acked by USB core).                    */
	unsigned int full                   : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_rx_stat_full;                   /* FIFO is full (including data not yet acked by USB core).                     */
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_STAT_BIT_T;

typedef union {
	unsigned int                                 val;
	NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_STAT_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_RX_STAT_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_jtag_ep_tx_len */
/* => USB device Endpoint 5 - JTAG TX (IN), FIFO 6 length register. */
/*    This register is used to program or abort a transaction. */
/*    Note: It is not allowed to re-program a transaction while it is active. Only an abort is allowed. */
/*    Note: A new transaction may only programmed when the last transaction is finished (i.e. check 'transaction_active' \ */
/*    flag in the tx_stat register). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len               0x00000038U
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_jtag_ep_tx_len 0x1018C8B8U
#define Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len                   0x1018C8B8U
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len              0x00000000U

#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_packet_len                 0x0000007fU
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_packet_len                 0
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_packet_len            0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_packet_len         0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_len            0x1fff0000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_len            16
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_len       0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_len    0x00000000U
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_no_zlp         0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_no_zlp         31
#define DFLT_VAL_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_no_zlp    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_no_zlp 0x00000000U

/* all used bits of 'NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len 0x9fff007fU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_packet_len         = 7,  /* [6:0] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_reserved1          = 9,  /* [15:7] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_len    = 13, /* [28:16] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_reserved2          = 2,  /* [30:29] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_no_zlp = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_LEN_BIT_Ttag {
	unsigned int packet_len         : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_packet_len;         /* Size of the last sent packet. This is a read only status bit field.                 */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_reserved1;          /* reserved                                                                            */
	unsigned int transaction_len    : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_len;    /* Read: Number of bytes left in the programmed transfer.                              */
	                                                                                                /* Write: The actual size of the transaction. Set to 0 to abort a running transcation. */
	                                                                                                /* Note: This bit field is writable but can also be changed by hardware.               */
	unsigned int reserved2          : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_reserved2;          /* reserved                                                                            */
	unsigned int transaction_no_zlp : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_len_transaction_no_zlp; /* When set to '1' no ZLP will be sent, when a transaction is finished.                */
	                                                                                                /* This bit will be reset automatically by hardware and is always '0' on read.         */
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_LEN_BIT_T;

typedef union {
	unsigned int                                val;
	NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_LEN_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_fifo_ctrl_jtag_ep_tx_stat */
/* => USB device Endpoint 5 - JTAG TX (IN), FIFO 6 status register. */
/*    This register holds the fill levels and other status information of FIFO 6. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat               0x0000003CU
#define Adr_NX51_usb_dev_fifo_ctrl_usb_dev_fifo_ctrl_jtag_ep_tx_stat 0x1018C8BCU
#define Adr_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat                   0x1018C8BCU

#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_fill_level         0x000001ffU
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_fill_level         0
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_transaction_active 0x20000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_transaction_active 29
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_empty              0x40000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_empty              30
#define MSK_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_full               0x80000000U
#define SRT_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_full               31

/* all used bits of 'NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat': */
#define MSK_USED_BITS_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat 0xe00001ffU

enum {
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_fill_level         = 9,  /* [8:0] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_reserved1          = 20, /* [28:9] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_transaction_active = 1,  /* [29] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_empty              = 1,  /* [30] */
	BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_full               = 1   /* [31] */
};

typedef struct NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_STAT_BIT_Ttag {
	unsigned int fill_level         : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_fill_level;         /* Fill level of the FIFO (including data currently in transit).                */
	unsigned int reserved1          : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_reserved1;          /* reserved                                                                     */
	unsigned int transaction_active : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_transaction_active; /* A transaction is currently active. No further transaction may be programmed. */
	unsigned int empty              : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_empty;              /* FIFO is empty (including data still needed by USB core).                     */
	unsigned int full               : BFW_NX51_usb_dev_fifo_ctrl_jtag_ep_tx_stat_full;               /* FIFO is full (including data still needed by USB core).                      */
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_STAT_BIT_T;

typedef union {
	unsigned int                                 val;
	NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_STAT_BIT_T bf;
} NX51_USB_DEV_FIFO_CTRL_JTAG_EP_TX_STAT_T;


/* ===================================================================== */

/* Area of usb_dev_fifo */

/* ===================================================================== */

#define Addr_NX51_usb_dev_fifo 0x1018C8C0U

/* --------------------------------------------------------------------- */
/* Register usb_dev_control_out_data */
/* => USB device FIFO: Control endpoint OUT. */
/*    This FIFO holds the data of the control endpoint. Direction is OUT, meaning data sent from USB host to device arrives here. \ */
/*    The FIFO is handled by the USB core itself and should not be read or written from the ARM. */
/*    Note: Reading and writing to this register while the USB module sees an reset condition on the bus results in \ */
/*    unexpected data, because the FIFOs are held in reset state. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_control_out_data          0x00000000U
#define Adr_NX51_usb_dev_fifo_usb_dev_control_out_data 0x1018C8C0U
#define Adr_NX51_usb_dev_control_out_data              0x1018C8C0U
#define DFLT_VAL_NX51_usb_dev_control_out_data         0x00000000U

#define MSK_NX51_usb_dev_control_out_data_fifo_data         0x000000ffU
#define SRT_NX51_usb_dev_control_out_data_fifo_data         0
#define DFLT_VAL_NX51_usb_dev_control_out_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_control_out_data_fifo_data 0x00000000U

/* all used bits of 'NX51_usb_dev_control_out_data': */
#define MSK_USED_BITS_NX51_usb_dev_control_out_data 0x000000ffU

enum {
	BFW_NX51_usb_dev_control_out_data_fifo_data = 8,  /* [7:0] */
	BFW_NX51_usb_dev_control_out_data_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_USB_DEV_CONTROL_OUT_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_usb_dev_control_out_data_fifo_data; /*          */
	unsigned int reserved1 : BFW_NX51_usb_dev_control_out_data_reserved1; /* reserved */
} NX51_USB_DEV_CONTROL_OUT_DATA_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_USB_DEV_CONTROL_OUT_DATA_BIT_T bf;
} NX51_USB_DEV_CONTROL_OUT_DATA_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_control_in_data */
/* => USB device FIFO: Control endpoint IN. */
/*    This FIFO holds the data of the control endpoint. Direction is IN, meaning data that should be sent from USB device to host \ */
/*    must be placed here. The FIFO is handled by the USB core itself and should not be read or written from the ARM. */
/*    Note: Reading and writing to this register while the USB module sees an reset condition on the bus results in \ */
/*    unexpected data, because the FIFOs are held in reset state. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_control_in_data          0x00000004U
#define Adr_NX51_usb_dev_fifo_usb_dev_control_in_data 0x1018C8C4U
#define Adr_NX51_usb_dev_control_in_data              0x1018C8C4U
#define DFLT_VAL_NX51_usb_dev_control_in_data         0x00000000U

#define MSK_NX51_usb_dev_control_in_data_fifo_data         0x000000ffU
#define SRT_NX51_usb_dev_control_in_data_fifo_data         0
#define DFLT_VAL_NX51_usb_dev_control_in_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_control_in_data_fifo_data 0x00000000U

/* all used bits of 'NX51_usb_dev_control_in_data': */
#define MSK_USED_BITS_NX51_usb_dev_control_in_data 0x000000ffU

enum {
	BFW_NX51_usb_dev_control_in_data_fifo_data = 8,  /* [7:0] */
	BFW_NX51_usb_dev_control_in_data_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_USB_DEV_CONTROL_IN_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_usb_dev_control_in_data_fifo_data; /*          */
	unsigned int reserved1 : BFW_NX51_usb_dev_control_in_data_reserved1; /* reserved */
} NX51_USB_DEV_CONTROL_IN_DATA_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_USB_DEV_CONTROL_IN_DATA_BIT_T bf;
} NX51_USB_DEV_CONTROL_IN_DATA_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_interrupt_data */
/* => USB device FIFO: Endpoint 1 - Interrupt IN */
/*    This FIFO holds the data of the interrupt endpoint. Direction is IN, meaning data placed here is sent \ */
/*    to the USB host. */
/*    Note: Reading and writing to this register while the USB module sees an reset condition on the bus results in \ */
/*    unexpected data, because the FIFOs are held in reset state. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_interrupt_data          0x00000008U
#define Adr_NX51_usb_dev_fifo_usb_dev_interrupt_data 0x1018C8C8U
#define Adr_NX51_usb_dev_interrupt_data              0x1018C8C8U
#define DFLT_VAL_NX51_usb_dev_interrupt_data         0x00000000U

#define MSK_NX51_usb_dev_interrupt_data_fifo_data         0x000000ffU
#define SRT_NX51_usb_dev_interrupt_data_fifo_data         0
#define DFLT_VAL_NX51_usb_dev_interrupt_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_interrupt_data_fifo_data 0x00000000U

/* all used bits of 'NX51_usb_dev_interrupt_data': */
#define MSK_USED_BITS_NX51_usb_dev_interrupt_data 0x000000ffU

enum {
	BFW_NX51_usb_dev_interrupt_data_fifo_data = 8,  /* [7:0] */
	BFW_NX51_usb_dev_interrupt_data_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_USB_DEV_INTERRUPT_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_usb_dev_interrupt_data_fifo_data; /*          */
	unsigned int reserved1 : BFW_NX51_usb_dev_interrupt_data_reserved1; /* reserved */
} NX51_USB_DEV_INTERRUPT_DATA_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_USB_DEV_INTERRUPT_DATA_BIT_T bf;
} NX51_USB_DEV_INTERRUPT_DATA_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_uart_rx_data */
/* => USB device FIFO: Endpoint 2 - UART RX */
/*    This FIFO holds the data of the bulk endpoint used for UART communication. Direction is OUT, meaning data from the USB host \ */
/*    arrives here. This FIFO may be used by the user application. */
/*    Note: Reading and writing to this register while the USB module sees an reset condition on the bus results in \ */
/*    unexpected data, because the FIFOs are held in reset state. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_uart_rx_data          0x0000000CU
#define Adr_NX51_usb_dev_fifo_usb_dev_uart_rx_data 0x1018C8CCU
#define Adr_NX51_usb_dev_uart_rx_data              0x1018C8CCU
#define DFLT_VAL_NX51_usb_dev_uart_rx_data         0x00000000U

#define MSK_NX51_usb_dev_uart_rx_data_fifo_data         0x000000ffU
#define SRT_NX51_usb_dev_uart_rx_data_fifo_data         0
#define DFLT_VAL_NX51_usb_dev_uart_rx_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_uart_rx_data_fifo_data 0x00000000U

/* all used bits of 'NX51_usb_dev_uart_rx_data': */
#define MSK_USED_BITS_NX51_usb_dev_uart_rx_data 0x000000ffU

enum {
	BFW_NX51_usb_dev_uart_rx_data_fifo_data = 8,  /* [7:0] */
	BFW_NX51_usb_dev_uart_rx_data_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_USB_DEV_UART_RX_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_usb_dev_uart_rx_data_fifo_data; /*          */
	unsigned int reserved1 : BFW_NX51_usb_dev_uart_rx_data_reserved1; /* reserved */
} NX51_USB_DEV_UART_RX_DATA_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_USB_DEV_UART_RX_DATA_BIT_T bf;
} NX51_USB_DEV_UART_RX_DATA_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_uart_tx_data */
/* => USB device FIFO: Endpoint 3 - UART TX */
/*    This FIFO holds the data of the bulk endpoint used for UART communication. Direction is IN, meaning data placed here is sent \ */
/*    to the USB host. This FIFO may be used by the user application. */
/*    Note: Reading and writing to this register while the USB module sees an reset condition on the bus results in \ */
/*    unexpected data, because the FIFOs are held in reset state. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_uart_tx_data          0x00000010U
#define Adr_NX51_usb_dev_fifo_usb_dev_uart_tx_data 0x1018C8D0U
#define Adr_NX51_usb_dev_uart_tx_data              0x1018C8D0U
#define DFLT_VAL_NX51_usb_dev_uart_tx_data         0x00000000U

#define MSK_NX51_usb_dev_uart_tx_data_fifo_data         0x000000ffU
#define SRT_NX51_usb_dev_uart_tx_data_fifo_data         0
#define DFLT_VAL_NX51_usb_dev_uart_tx_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_uart_tx_data_fifo_data 0x00000000U

/* all used bits of 'NX51_usb_dev_uart_tx_data': */
#define MSK_USED_BITS_NX51_usb_dev_uart_tx_data 0x000000ffU

enum {
	BFW_NX51_usb_dev_uart_tx_data_fifo_data = 8,  /* [7:0] */
	BFW_NX51_usb_dev_uart_tx_data_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_USB_DEV_UART_TX_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_usb_dev_uart_tx_data_fifo_data; /*          */
	unsigned int reserved1 : BFW_NX51_usb_dev_uart_tx_data_reserved1; /* reserved */
} NX51_USB_DEV_UART_TX_DATA_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_USB_DEV_UART_TX_DATA_BIT_T bf;
} NX51_USB_DEV_UART_TX_DATA_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_jtag_rx_data */
/* => USB device FIFO: Endpoint 4 - JTAG RX */
/*    This FIFO holds the data of the bulk endpoint used for JTAG communication. Direction is OUT, meaning data from the USB host \ */
/*    arrives here. The FIFO is handled by the USB JTAG core itself and should not be read or written from the ARM. */
/*    Note: Reading and writing to this register while the USB module sees an reset condition on the bus results in \ */
/*    unexpected data, because the FIFOs are held in reset state. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_jtag_rx_data          0x00000014U
#define Adr_NX51_usb_dev_fifo_usb_dev_jtag_rx_data 0x1018C8D4U
#define Adr_NX51_usb_dev_jtag_rx_data              0x1018C8D4U
#define DFLT_VAL_NX51_usb_dev_jtag_rx_data         0x00000000U

#define MSK_NX51_usb_dev_jtag_rx_data_fifo_data         0x000000ffU
#define SRT_NX51_usb_dev_jtag_rx_data_fifo_data         0
#define DFLT_VAL_NX51_usb_dev_jtag_rx_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_jtag_rx_data_fifo_data 0x00000000U

/* all used bits of 'NX51_usb_dev_jtag_rx_data': */
#define MSK_USED_BITS_NX51_usb_dev_jtag_rx_data 0x000000ffU

enum {
	BFW_NX51_usb_dev_jtag_rx_data_fifo_data = 8,  /* [7:0] */
	BFW_NX51_usb_dev_jtag_rx_data_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_USB_DEV_JTAG_RX_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_usb_dev_jtag_rx_data_fifo_data; /*          */
	unsigned int reserved1 : BFW_NX51_usb_dev_jtag_rx_data_reserved1; /* reserved */
} NX51_USB_DEV_JTAG_RX_DATA_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_USB_DEV_JTAG_RX_DATA_BIT_T bf;
} NX51_USB_DEV_JTAG_RX_DATA_T;

/* --------------------------------------------------------------------- */
/* Register usb_dev_jtag_tx_data */
/* => USB device FIFO: Endpoint 5 - JTAG TX */
/*    This FIFO holds the data of the bulk endpoint used for JTAG communication. Direction is IN, meaning data placed here is sent \ */
/*    to the USB host. The FIFO is handled by the USB JTAG core itself and should not be read or written from the ARM. */
/*    Note: Reading and writing to this register while the USB module sees an reset condition on the bus results in \ */
/*    unexpected data, because the FIFOs are held in reset state. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_usb_dev_jtag_tx_data          0x00000018U
#define Adr_NX51_usb_dev_fifo_usb_dev_jtag_tx_data 0x1018C8D8U
#define Adr_NX51_usb_dev_jtag_tx_data              0x1018C8D8U
#define DFLT_VAL_NX51_usb_dev_jtag_tx_data         0x00000000U

#define MSK_NX51_usb_dev_jtag_tx_data_fifo_data         0x000000ffU
#define SRT_NX51_usb_dev_jtag_tx_data_fifo_data         0
#define DFLT_VAL_NX51_usb_dev_jtag_tx_data_fifo_data    0x00000000U
#define DFLT_BF_VAL_NX51_usb_dev_jtag_tx_data_fifo_data 0x00000000U

/* all used bits of 'NX51_usb_dev_jtag_tx_data': */
#define MSK_USED_BITS_NX51_usb_dev_jtag_tx_data 0x000000ffU

enum {
	BFW_NX51_usb_dev_jtag_tx_data_fifo_data = 8,  /* [7:0] */
	BFW_NX51_usb_dev_jtag_tx_data_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_USB_DEV_JTAG_TX_DATA_BIT_Ttag {
	unsigned int fifo_data : BFW_NX51_usb_dev_jtag_tx_data_fifo_data; /*          */
	unsigned int reserved1 : BFW_NX51_usb_dev_jtag_tx_data_reserved1; /* reserved */
} NX51_USB_DEV_JTAG_TX_DATA_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_USB_DEV_JTAG_TX_DATA_BIT_T bf;
} NX51_USB_DEV_JTAG_TX_DATA_T;


/* ===================================================================== */

/* Area of canctrl */

/* ===================================================================== */

#define Addr_NX51_canctrl 0x1018C900U

/* --------------------------------------------------------------------- */
/* Register canctrl_mode */
/* => CAN mode register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_mode     0x00000000U
#define Adr_NX51_canctrl_canctrl_mode 0x1018C900U
#define Adr_NX51_canctrl_mode         0x1018C900U
#define DFLT_VAL_NX51_canctrl_mode    0x00000001U

#define MSK_NX51_canctrl_mode_reset_mode              0x00000001U
#define SRT_NX51_canctrl_mode_reset_mode              0
#define DFLT_VAL_NX51_canctrl_mode_reset_mode         0x00000001U
#define DFLT_BF_VAL_NX51_canctrl_mode_reset_mode      0x00000001U
#define MSK_NX51_canctrl_mode_listen_mode             0x00000002U
#define SRT_NX51_canctrl_mode_listen_mode             1
#define DFLT_VAL_NX51_canctrl_mode_listen_mode        0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_mode_listen_mode     0x00000000U
#define MSK_NX51_canctrl_mode_selftest                0x00000004U
#define SRT_NX51_canctrl_mode_selftest                2
#define DFLT_VAL_NX51_canctrl_mode_selftest           0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_mode_selftest        0x00000000U
#define MSK_NX51_canctrl_mode_acceptance_mode         0x00000008U
#define SRT_NX51_canctrl_mode_acceptance_mode         3
#define DFLT_VAL_NX51_canctrl_mode_acceptance_mode    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_mode_acceptance_mode 0x00000000U

/* all used bits of 'NX51_canctrl_mode': */
#define MSK_USED_BITS_NX51_canctrl_mode 0x0000000fU

enum {
	BFW_NX51_canctrl_mode_reset_mode      = 1,  /* [0] */
	BFW_NX51_canctrl_mode_listen_mode     = 1,  /* [1] */
	BFW_NX51_canctrl_mode_selftest        = 1,  /* [2] */
	BFW_NX51_canctrl_mode_acceptance_mode = 1,  /* [3] */
	BFW_NX51_canctrl_mode_reserved1       = 28  /* [31:4] */
};

typedef struct NX51_CANCTRL_MODE_BIT_Ttag {
	unsigned int reset_mode      : BFW_NX51_canctrl_mode_reset_mode;      /* Reset Mode                                             */
	                                                                      /* 1 reset; detection of a set reset mode bit results in  */
	                                                                      /* aborting the current transmission/reception of a       */
	                                                                      /* message and entering the reset mode                    */
	                                                                      /* 0 normal; on the `1-to-0' transition of the reset mode */
	                                                                      /* bit, the CAN controller returns to the operating       */
	                                                                      /* mode                                                   */
	unsigned int listen_mode     : BFW_NX51_canctrl_mode_listen_mode;     /* Listen Only Mode                                       */
	                                                                      /* 1 listen only; in this mode the CAN controller would   */
	                                                                      /*   give no acknowledge to the CAN-bus, even if a        */
	                                                                      /*   message is received successfully; the error          */
	                                                                      /*   counters are stopped at the current value            */
	                                                                      /* 0 normal                                               */
	unsigned int selftest        : BFW_NX51_canctrl_mode_selftest;        /* Self Test Mode                                         */
	                                                                      /* 1 self test; in this mode a full node test is possible */
	                                                                      /*   without any other active node on the bus using the   */
	                                                                      /*   self reception request command; the                  */
	                                                                      /*   CAN controller will perform a successful             */
	                                                                      /*   transmission, even if there is no acknowledge        */
	                                                                      /*   received                                             */
	                                                                      /* 0 normal; an acknowledge is required for successful    */
	                                                                      /*   transmission                                         */
	unsigned int acceptance_mode : BFW_NX51_canctrl_mode_acceptance_mode; /* Acceptance Filter Mode                                 */
	                                                                      /* 1 single; the single acceptance filter option is       */
	                                                                      /*   enabled (one filter with the length of 32 bit is     */
	                                                                      /*   active)                                              */
	                                                                      /* 0 dual; the dual acceptance filter option is enabled   */
	                                                                      /*   (two filters, each with the length of 16 bit are     */
	                                                                      /*   active)                                              */
	unsigned int reserved1       : BFW_NX51_canctrl_mode_reserved1;       /* reserved                                               */
} NX51_CANCTRL_MODE_BIT_T;

typedef union {
	unsigned int            val;
	NX51_CANCTRL_MODE_BIT_T bf;
} NX51_CANCTRL_MODE_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_command */
/* => CAN command register */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_command     0x00000004U
#define Adr_NX51_canctrl_canctrl_command 0x1018C904U
#define Adr_NX51_canctrl_command         0x1018C904U
#define DFLT_VAL_NX51_canctrl_command    0x00000000U

#define MSK_NX51_canctrl_command_tx_request              0x00000001U
#define SRT_NX51_canctrl_command_tx_request              0
#define DFLT_VAL_NX51_canctrl_command_tx_request         0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_command_tx_request      0x00000000U
#define MSK_NX51_canctrl_command_abort_tx                0x00000002U
#define SRT_NX51_canctrl_command_abort_tx                1
#define DFLT_VAL_NX51_canctrl_command_abort_tx           0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_command_abort_tx        0x00000000U
#define MSK_NX51_canctrl_command_release_rx_buf          0x00000004U
#define SRT_NX51_canctrl_command_release_rx_buf          2
#define DFLT_VAL_NX51_canctrl_command_release_rx_buf     0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_command_release_rx_buf  0x00000000U
#define MSK_NX51_canctrl_command_clr_overrun             0x00000008U
#define SRT_NX51_canctrl_command_clr_overrun             3
#define DFLT_VAL_NX51_canctrl_command_clr_overrun        0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_command_clr_overrun     0x00000000U
#define MSK_NX51_canctrl_command_self_rx_request         0x00000010U
#define SRT_NX51_canctrl_command_self_rx_request         4
#define DFLT_VAL_NX51_canctrl_command_self_rx_request    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_command_self_rx_request 0x00000000U

/* all used bits of 'NX51_canctrl_command': */
#define MSK_USED_BITS_NX51_canctrl_command 0x0000001fU

enum {
	BFW_NX51_canctrl_command_tx_request      = 1,  /* [0] */
	BFW_NX51_canctrl_command_abort_tx        = 1,  /* [1] */
	BFW_NX51_canctrl_command_release_rx_buf  = 1,  /* [2] */
	BFW_NX51_canctrl_command_clr_overrun     = 1,  /* [3] */
	BFW_NX51_canctrl_command_self_rx_request = 1,  /* [4] */
	BFW_NX51_canctrl_command_reserved1       = 27  /* [31:5] */
};

typedef struct NX51_CANCTRL_COMMAND_BIT_Ttag {
	unsigned int tx_request      : BFW_NX51_canctrl_command_tx_request;      /* Transmission Request, self-clearing                                  */
	                                                                         /* 1 present; a message shall be transmitted                            */
	unsigned int abort_tx        : BFW_NX51_canctrl_command_abort_tx;        /* Abort Transmission, self-clearing                                    */
	                                                                         /* 1 present; if not already in progress, a pending                     */
	                                                                         /*   transmission request is cancelled                                  */
	                                                                         /* Setting the command bits tx_request and abort_tx simultaneously      */
	                                                                         /* results in sending the transmit message once.                        */
	                                                                         /* No re-transmission will be performed in the event                    */
	                                                                         /* of an error or arbitration lost (single-shot transmission).          */
	unsigned int release_rx_buf  : BFW_NX51_canctrl_command_release_rx_buf;  /* Release Receive Buffer, self-clearing                                */
	                                                                         /* 1 released; the receive buffer, representing the                     */
	                                                                         /*   message memory space in the RXFIFO is                              */
	                                                                         /*   released                                                           */
	unsigned int clr_overrun     : BFW_NX51_canctrl_command_clr_overrun;     /* Clear Data Overrun, self-clearing                                    */
	                                                                         /* 1 clear; the data overrun status bit is cleared,                     */
	                                                                         /* shall be used together with release_rx_buf to release invalid buffer */
	unsigned int self_rx_request : BFW_NX51_canctrl_command_self_rx_request; /* Self Reception Request, self-clearing                                */
	                                                                         /* 1 present; a message shall be transmitted and                        */
	                                                                         /*   received simultaneously                                            */
	                                                                         /* Setting tx_request and self_rx_request simultaneously                */
	                                                                         /* will ignore the set self_rx_request bit.                             */
	unsigned int reserved1       : BFW_NX51_canctrl_command_reserved1;       /* reserved                                                             */
} NX51_CANCTRL_COMMAND_BIT_T;

typedef union {
	unsigned int               val;
	NX51_CANCTRL_COMMAND_BIT_T bf;
} NX51_CANCTRL_COMMAND_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_status */
/* => CAN status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_status     0x00000008U
#define Adr_NX51_canctrl_canctrl_status 0x1018C908U
#define Adr_NX51_canctrl_status         0x1018C908U

#define MSK_NX51_canctrl_status_rx_buf_status 0x00000001U
#define SRT_NX51_canctrl_status_rx_buf_status 0
#define MSK_NX51_canctrl_status_overrun       0x00000002U
#define SRT_NX51_canctrl_status_overrun       1
#define MSK_NX51_canctrl_status_tx_buf_status 0x00000004U
#define SRT_NX51_canctrl_status_tx_buf_status 2
#define MSK_NX51_canctrl_status_tx_complete   0x00000008U
#define SRT_NX51_canctrl_status_tx_complete   3
#define MSK_NX51_canctrl_status_rx_status     0x00000010U
#define SRT_NX51_canctrl_status_rx_status     4
#define MSK_NX51_canctrl_status_tx_status     0x00000020U
#define SRT_NX51_canctrl_status_tx_status     5
#define MSK_NX51_canctrl_status_error_status  0x00000040U
#define SRT_NX51_canctrl_status_error_status  6
#define MSK_NX51_canctrl_status_bus_status    0x00000080U
#define SRT_NX51_canctrl_status_bus_status    7

/* all used bits of 'NX51_canctrl_status': */
#define MSK_USED_BITS_NX51_canctrl_status 0x000000ffU

enum {
	BFW_NX51_canctrl_status_rx_buf_status = 1,  /* [0] */
	BFW_NX51_canctrl_status_overrun       = 1,  /* [1] */
	BFW_NX51_canctrl_status_tx_buf_status = 1,  /* [2] */
	BFW_NX51_canctrl_status_tx_complete   = 1,  /* [3] */
	BFW_NX51_canctrl_status_rx_status     = 1,  /* [4] */
	BFW_NX51_canctrl_status_tx_status     = 1,  /* [5] */
	BFW_NX51_canctrl_status_error_status  = 1,  /* [6] */
	BFW_NX51_canctrl_status_bus_status    = 1,  /* [7] */
	BFW_NX51_canctrl_status_reserved1     = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_STATUS_BIT_Ttag {
	unsigned int rx_buf_status : BFW_NX51_canctrl_status_rx_buf_status; /* Receive Buffer Status                                 */
	                                                                    /* 1 full; one or more complete messages are available   */
	                                                                    /*   in the RXFIFO                                       */
	                                                                    /* 0 empty; no message is available                      */
	unsigned int overrun       : BFW_NX51_canctrl_status_overrun;       /* Data Overrun Status                                   */
	                                                                    /* 1 overrun; a message was lost because there was       */
	                                                                    /*   not enough space for that message in the RXFIFO     */
	                                                                    /* 0 absent; no data overrun has occurred since the      */
	                                                                    /*   last clear data overrun command was given           */
	unsigned int tx_buf_status : BFW_NX51_canctrl_status_tx_buf_status; /* Transmit Buffer Status                                */
	                                                                    /* 1 released; the CPU may write a message into the      */
	                                                                    /*   transmit buffer                                     */
	                                                                    /* 0 locked; the CPU cannot access the transmit          */
	                                                                    /*   buffer ; a message is either waiting for            */
	                                                                    /*   transmission or is in the process of being          */
	                                                                    /*   transmitted                                         */
	unsigned int tx_complete   : BFW_NX51_canctrl_status_tx_complete;   /* Transmission Complete                                 */
	                                                                    /* 1 complete; last requested transmission has been      */
	                                                                    /*   successfully completed                              */
	                                                                    /* 0 incomplete; previously requested transmission is    */
	                                                                    /*   not yet completed                                   */
	unsigned int rx_status     : BFW_NX51_canctrl_status_rx_status;     /* Receive Status                                        */
	                                                                    /* 1 receive; the CAN controller is receiving a          */
	                                                                    /*   message                                             */
	                                                                    /* 0 idle                                                */
	unsigned int tx_status     : BFW_NX51_canctrl_status_tx_status;     /* Transmit Status                                       */
	                                                                    /* 1 transmit; the CAN controller is transmitting a      */
	                                                                    /*   message                                             */
	                                                                    /* 0 idle                                                */
	unsigned int error_status  : BFW_NX51_canctrl_status_error_status;  /* Error Status                                          */
	                                                                    /* 1 error; at least one of the error counters has       */
	                                                                    /*   reached or exceeded the CPU warning limit           */
	                                                                    /*   defined by the Error Warning Limit Register         */
	                                                                    /*   (EWLR)                                              */
	                                                                    /* 0 ok; both error counters are below the warning limit */
	unsigned int bus_status    : BFW_NX51_canctrl_status_bus_status;    /* Bus Status                                            */
	                                                                    /* 1 bus-off; the CAN controller is not involved in bus  */
	                                                                    /*   activities                                          */
	                                                                    /* 0 bus-on; the CAN controller is involved in bus       */
	                                                                    /*   activities                                          */
	unsigned int reserved1     : BFW_NX51_canctrl_status_reserved1;     /* reserved                                              */
} NX51_CANCTRL_STATUS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_CANCTRL_STATUS_BIT_T bf;
} NX51_CANCTRL_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_irq */
/* => CAN interrupt register */
/*    reading the register will clear all bits except rx_irq */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_irq     0x0000000CU
#define Adr_NX51_canctrl_canctrl_irq 0x1018C90CU
#define Adr_NX51_canctrl_irq         0x1018C90CU

#define MSK_NX51_canctrl_irq_rx_irq          0x00000001U
#define SRT_NX51_canctrl_irq_rx_irq          0
#define MSK_NX51_canctrl_irq_tx_irq          0x00000002U
#define SRT_NX51_canctrl_irq_tx_irq          1
#define MSK_NX51_canctrl_irq_warning_irq     0x00000004U
#define SRT_NX51_canctrl_irq_warning_irq     2
#define MSK_NX51_canctrl_irq_overrun_irq     0x00000008U
#define SRT_NX51_canctrl_irq_overrun_irq     3
#define MSK_NX51_canctrl_irq_err_passive_irq 0x00000020U
#define SRT_NX51_canctrl_irq_err_passive_irq 5
#define MSK_NX51_canctrl_irq_arb_lost_irq    0x00000040U
#define SRT_NX51_canctrl_irq_arb_lost_irq    6
#define MSK_NX51_canctrl_irq_bus_error_irq   0x00000080U
#define SRT_NX51_canctrl_irq_bus_error_irq   7

/* all used bits of 'NX51_canctrl_irq': */
#define MSK_USED_BITS_NX51_canctrl_irq 0x000000efU

enum {
	BFW_NX51_canctrl_irq_rx_irq          = 1,  /* [0] */
	BFW_NX51_canctrl_irq_tx_irq          = 1,  /* [1] */
	BFW_NX51_canctrl_irq_warning_irq     = 1,  /* [2] */
	BFW_NX51_canctrl_irq_overrun_irq     = 1,  /* [3] */
	BFW_NX51_canctrl_irq_reserved1       = 1,  /* [4] */
	BFW_NX51_canctrl_irq_err_passive_irq = 1,  /* [5] */
	BFW_NX51_canctrl_irq_arb_lost_irq    = 1,  /* [6] */
	BFW_NX51_canctrl_irq_bus_error_irq   = 1,  /* [7] */
	BFW_NX51_canctrl_irq_reserved2       = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_IRQ_BIT_Ttag {
	unsigned int rx_irq          : BFW_NX51_canctrl_irq_rx_irq;          /* Receive Interrupt                                                */
	                                                                     /* 1 set; this bit is set while the receive FIFO is not             */
	                                                                     /*   empty and the rx_irq_en bit is set within the interrupt        */
	                                                                     /*   enable register                                                */
	                                                                     /* 0 reset; no more message is available within the                 */
	                                                                     /*   RXFIFO                                                         */
	unsigned int tx_irq          : BFW_NX51_canctrl_irq_tx_irq;          /* Transmit Interrupt                                               */
	                                                                     /* 1 set; this bit is set whenever the transmit buffer              */
	                                                                     /*   status changes from `0-to-1' (released) and the                */
	                                                                     /*   tx_irq_en bit is set within the interrupt enable register      */
	                                                                     /* 0 reset                                                          */
	unsigned int warning_irq     : BFW_NX51_canctrl_irq_warning_irq;     /* Error Warning Interrupt                                          */
	                                                                     /* 1 set; this bit is set on every change (set and clear)           */
	                                                                     /*   of either the error status or bus status bits and the          */
	                                                                     /*   warning_irq_en bit is set within the interrupt enable register */
	                                                                     /* 0 reset                                                          */
	unsigned int overrun_irq     : BFW_NX51_canctrl_irq_overrun_irq;     /* Data Overrun Interrup                                            */
	                                                                     /* 1 set; this bit is set on a `0-to-1' transition of the data      */
	                                                                     /*   overrun status bit and the overrun_irq_en bit is set within    */
	                                                                     /*   the interrupt enable register                                  */
	                                                                     /* 0 reset                                                          */
	unsigned int reserved1       : BFW_NX51_canctrl_irq_reserved1;       /* reserved                                                         */
	unsigned int err_passive_irq : BFW_NX51_canctrl_irq_err_passive_irq; /* Error Passive Interrupt                                          */
	                                                                     /* 1 set; this bit is set whenever the CAN controller has           */
	                                                                     /*   reached the error passive status (at least one                 */
	                                                                     /*   error counter exceeds the protocol-defined level of            */
	                                                                     /*   127) or if the CAN controller is in the error passive          */
	                                                                     /*   status and enters the error active status again and            */
	                                                                     /*   the err_passive_irq_en bit is set within the interrupt enable  */
	                                                                     /*   register                                                       */
	                                                                     /* 0 reset                                                          */
	unsigned int arb_lost_irq    : BFW_NX51_canctrl_irq_arb_lost_irq;    /* Arbitration Lost Interrupt                                       */
	                                                                     /* 1 set; this bit is set when the CAN controller lost the          */
	                                                                     /*   arbitration and becomes a receiver and the arb_lost_irq_en     */
	                                                                     /*   bit is set within the interrupt enable register, will only     */
	                                                                     /*   get active again if canctrl_arb_lost_capture register is read  */
	                                                                     /* 0 reset                                                          */
	unsigned int bus_error_irq   : BFW_NX51_canctrl_irq_bus_error_irq;   /* Bus Error Interrupt                                              */
	                                                                     /* 1 set; this bit is set when the CAN controller detects           */
	                                                                     /*   an error on the CAN-bus and the bus_error_irq_en bit is set    */
	                                                                     /*   within the interrupt enable register, will only                */
	                                                                     /*   get active again if canctrl_err_code_capture register is read  */
	                                                                     /* 0 reset                                                          */
	unsigned int reserved2       : BFW_NX51_canctrl_irq_reserved2;       /* reserved                                                         */
} NX51_CANCTRL_IRQ_BIT_T;

typedef union {
	unsigned int           val;
	NX51_CANCTRL_IRQ_BIT_T bf;
} NX51_CANCTRL_IRQ_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_irq_en */
/* => CAN interrupt enable register */
/*    in not extended mode: acceptance_code_0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_irq_en     0x00000010U
#define Adr_NX51_canctrl_canctrl_irq_en 0x1018C910U
#define Adr_NX51_canctrl_irq_en         0x1018C910U
#define DFLT_VAL_NX51_canctrl_irq_en    0x00000000U

#define MSK_NX51_canctrl_irq_en_rx_irq_en                  0x00000001U
#define SRT_NX51_canctrl_irq_en_rx_irq_en                  0
#define DFLT_VAL_NX51_canctrl_irq_en_rx_irq_en             0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_irq_en_rx_irq_en          0x00000000U
#define MSK_NX51_canctrl_irq_en_tx_irq_en                  0x00000002U
#define SRT_NX51_canctrl_irq_en_tx_irq_en                  1
#define DFLT_VAL_NX51_canctrl_irq_en_tx_irq_en             0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_irq_en_tx_irq_en          0x00000000U
#define MSK_NX51_canctrl_irq_en_warning_irq_en             0x00000004U
#define SRT_NX51_canctrl_irq_en_warning_irq_en             2
#define DFLT_VAL_NX51_canctrl_irq_en_warning_irq_en        0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_irq_en_warning_irq_en     0x00000000U
#define MSK_NX51_canctrl_irq_en_overrun_irq_en             0x00000008U
#define SRT_NX51_canctrl_irq_en_overrun_irq_en             3
#define DFLT_VAL_NX51_canctrl_irq_en_overrun_irq_en        0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_irq_en_overrun_irq_en     0x00000000U
#define MSK_NX51_canctrl_irq_en_err_passive_irq_en         0x00000020U
#define SRT_NX51_canctrl_irq_en_err_passive_irq_en         5
#define DFLT_VAL_NX51_canctrl_irq_en_err_passive_irq_en    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_irq_en_err_passive_irq_en 0x00000000U
#define MSK_NX51_canctrl_irq_en_arb_lost_irq_en            0x00000040U
#define SRT_NX51_canctrl_irq_en_arb_lost_irq_en            6
#define DFLT_VAL_NX51_canctrl_irq_en_arb_lost_irq_en       0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_irq_en_arb_lost_irq_en    0x00000000U
#define MSK_NX51_canctrl_irq_en_bus_error_irq_en           0x00000080U
#define SRT_NX51_canctrl_irq_en_bus_error_irq_en           7
#define DFLT_VAL_NX51_canctrl_irq_en_bus_error_irq_en      0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_irq_en_bus_error_irq_en   0x00000000U

/* all used bits of 'NX51_canctrl_irq_en': */
#define MSK_USED_BITS_NX51_canctrl_irq_en 0x000000efU

enum {
	BFW_NX51_canctrl_irq_en_rx_irq_en          = 1,  /* [0] */
	BFW_NX51_canctrl_irq_en_tx_irq_en          = 1,  /* [1] */
	BFW_NX51_canctrl_irq_en_warning_irq_en     = 1,  /* [2] */
	BFW_NX51_canctrl_irq_en_overrun_irq_en     = 1,  /* [3] */
	BFW_NX51_canctrl_irq_en_reserved1          = 1,  /* [4] */
	BFW_NX51_canctrl_irq_en_err_passive_irq_en = 1,  /* [5] */
	BFW_NX51_canctrl_irq_en_arb_lost_irq_en    = 1,  /* [6] */
	BFW_NX51_canctrl_irq_en_bus_error_irq_en   = 1,  /* [7] */
	BFW_NX51_canctrl_irq_en_reserved2          = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_IRQ_EN_BIT_Ttag {
	unsigned int rx_irq_en          : BFW_NX51_canctrl_irq_en_rx_irq_en;          /* Receive Interrupt Enable                                */
	                                                                              /* 1 enabled; when the receive buffer status is `full' the */
	                                                                              /*   CAN controller requests the respective interrupt      */
	                                                                              /* 0 disabled                                              */
	unsigned int tx_irq_en          : BFW_NX51_canctrl_irq_en_tx_irq_en;          /* Transmit Interrupt Enable                               */
	                                                                              /* 1 enabled; when a message has been successfully         */
	                                                                              /*   transmitted or the transmit buffer is accessible      */
	                                                                              /*   again (e.g. after an abort transmission command),     */
	                                                                              /*   the CAN controller requests the respective            */
	                                                                              /*   interrupt                                             */
	                                                                              /* 0 disabled                                              */
	unsigned int warning_irq_en     : BFW_NX51_canctrl_irq_en_warning_irq_en;     /* Error Warning Interrupt Enable                          */
	                                                                              /* 1 enabled; if the error or bus status change (see       */
	                                                                              /*   status register), the CAN controller                  */
	                                                                              /*   requests the respective interrupt                     */
	                                                                              /* 0 disabled                                              */
	unsigned int overrun_irq_en     : BFW_NX51_canctrl_irq_en_overrun_irq_en;     /* Data Overrun Interrupt Enable                           */
	                                                                              /* 1 enabled; if the data overrun status bit is set (see   */
	                                                                              /*   status register; Table 14), the CAN controller        */
	                                                                              /*   requests the respective interrupt                     */
	                                                                              /* 0 disabled                                              */
	unsigned int reserved1          : BFW_NX51_canctrl_irq_en_reserved1;          /* reserved                                                */
	unsigned int err_passive_irq_en : BFW_NX51_canctrl_irq_en_err_passive_irq_en; /* Error Passive Interrupt Enable                          */
	                                                                              /* 1 enabled; if the error status of the CAN controller    */
	                                                                              /*   changes from error active to error passive or vice    */
	                                                                              /*   versa, the respective interrupt is requested          */
	                                                                              /* 0 disabled                                              */
	unsigned int arb_lost_irq_en    : BFW_NX51_canctrl_irq_en_arb_lost_irq_en;    /* Arbitration Lost Interrupt Enable                       */
	                                                                              /* 1 enabled; if the CAN controller has lost arbitration,  */
	                                                                              /*   the respective interrupt is requested                 */
	                                                                              /* 0 disabled                                              */
	unsigned int bus_error_irq_en   : BFW_NX51_canctrl_irq_en_bus_error_irq_en;   /* Bus Error Interrupt Enable                              */
	                                                                              /* 1 enabled; if an bus error has been detected, the       */
	                                                                              /*   CAN controller requests the respective interrupt      */
	                                                                              /* 0 disabled                                              */
	unsigned int reserved2          : BFW_NX51_canctrl_irq_en_reserved2;          /* reserved                                                */
} NX51_CANCTRL_IRQ_EN_BIT_T;

typedef union {
	unsigned int              val;
	NX51_CANCTRL_IRQ_EN_BIT_T bf;
} NX51_CANCTRL_IRQ_EN_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_not_extended_acceptance_mask0 */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_not_extended_acceptance_mask0     0x00000014U
#define Adr_NX51_canctrl_canctrl_not_extended_acceptance_mask0 0x1018C914U
#define Adr_NX51_canctrl_not_extended_acceptance_mask0         0x1018C914U

/* --------------------------------------------------------------------- */
/* Register canctrl_bus_timing0 */
/* => CAN bus timing register 0, only writeable in reset mode */
/*    in not extended mode: acceptance_mask_0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_bus_timing0     0x00000018U
#define Adr_NX51_canctrl_canctrl_bus_timing0 0x1018C918U
#define Adr_NX51_canctrl_bus_timing0         0x1018C918U
#define DFLT_VAL_NX51_canctrl_bus_timing0    0x00000000U

#define MSK_NX51_canctrl_bus_timing0_prescaler               0x000001ffU
#define SRT_NX51_canctrl_bus_timing0_prescaler               0
#define DFLT_VAL_NX51_canctrl_bus_timing0_prescaler          0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_bus_timing0_prescaler       0x00000000U
#define MSK_NX51_canctrl_bus_timing0_sync_jump_width         0x00000600U
#define SRT_NX51_canctrl_bus_timing0_sync_jump_width         9
#define DFLT_VAL_NX51_canctrl_bus_timing0_sync_jump_width    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_bus_timing0_sync_jump_width 0x00000000U

/* all used bits of 'NX51_canctrl_bus_timing0': */
#define MSK_USED_BITS_NX51_canctrl_bus_timing0 0x000007ffU

enum {
	BFW_NX51_canctrl_bus_timing0_prescaler       = 9,  /* [8:0] */
	BFW_NX51_canctrl_bus_timing0_sync_jump_width = 2,  /* [10:9] */
	BFW_NX51_canctrl_bus_timing0_reserved1       = 21  /* [31:11] */
};

typedef struct NX51_CANCTRL_BUS_TIMING0_BIT_Ttag {
	unsigned int prescaler       : BFW_NX51_canctrl_bus_timing0_prescaler;       /* Baud Rate Prescaler                                            */
	                                                                             /* The period of the CAN system clock tscl is programmable        */
	                                                                             /* and determines the individual bit timing. The CAN system clock */
	                                                                             /* is calculated using the following equation:                    */
	                                                                             /* tscl = tCLK * prescaler                                        */
	                                                                             /* with tCLK = 10 ns                                              */
	unsigned int sync_jump_width : BFW_NX51_canctrl_bus_timing0_sync_jump_width; /* Synchronization Jump Width                                     */
	                                                                             /* To compensate for phase shifts between clock oscillators       */
	                                                                             /* of different bus controllers, any bus controller must          */
	                                                                             /* re-synchronize on any relevant signal edge of the current      */
	                                                                             /* transmission. The synchronization jump width defines the       */
	                                                                             /* maximum number of clock cycles a bit period may be shortened   */
	                                                                             /* or lengthened by one re-synchronization:                       */
	                                                                             /* tSJW = tscl * (sync_jump_width + 1)                            */
	unsigned int reserved1       : BFW_NX51_canctrl_bus_timing0_reserved1;       /* reserved                                                       */
} NX51_CANCTRL_BUS_TIMING0_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_CANCTRL_BUS_TIMING0_BIT_T bf;
} NX51_CANCTRL_BUS_TIMING0_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_bus_timing1 */
/* => CAN bus timing register 1, only writeable in reset mode */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_bus_timing1     0x0000001CU
#define Adr_NX51_canctrl_canctrl_bus_timing1 0x1018C91CU
#define Adr_NX51_canctrl_bus_timing1         0x1018C91CU
#define DFLT_VAL_NX51_canctrl_bus_timing1    0x00000000U

#define MSK_NX51_canctrl_bus_timing1_tseg1                0x0000003fU
#define SRT_NX51_canctrl_bus_timing1_tseg1                0
#define DFLT_VAL_NX51_canctrl_bus_timing1_tseg1           0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_bus_timing1_tseg1        0x00000000U
#define MSK_NX51_canctrl_bus_timing1_oversampling         0x00000080U
#define SRT_NX51_canctrl_bus_timing1_oversampling         7
#define DFLT_VAL_NX51_canctrl_bus_timing1_oversampling    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_bus_timing1_oversampling 0x00000000U
#define MSK_NX51_canctrl_bus_timing1_tseg2                0x00001f00U
#define SRT_NX51_canctrl_bus_timing1_tseg2                8
#define DFLT_VAL_NX51_canctrl_bus_timing1_tseg2           0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_bus_timing1_tseg2        0x00000000U

/* all used bits of 'NX51_canctrl_bus_timing1': */
#define MSK_USED_BITS_NX51_canctrl_bus_timing1 0x00001fbfU

enum {
	BFW_NX51_canctrl_bus_timing1_tseg1        = 6,  /* [5:0] */
	BFW_NX51_canctrl_bus_timing1_reserved1    = 1,  /* [6] */
	BFW_NX51_canctrl_bus_timing1_oversampling = 1,  /* [7] */
	BFW_NX51_canctrl_bus_timing1_tseg2        = 5,  /* [12:8] */
	BFW_NX51_canctrl_bus_timing1_reserved2    = 19  /* [31:13] */
};

typedef struct NX51_CANCTRL_BUS_TIMING1_BIT_Ttag {
	unsigned int tseg1        : BFW_NX51_canctrl_bus_timing1_tseg1;        /* Time Segment 1 (TSEG1)                                                            */
	                                                                       /* TSEG1 determine the number of clock cycles per bit                                */
	                                                                       /* period and the location of the sample point, where:                               */
	                                                                       /* tSYNCSEG = 1 * tscl                                                               */
	                                                                       /* tTSEG1 = tscl * (tseg1 + 1)                                                       */
	unsigned int reserved1    : BFW_NX51_canctrl_bus_timing1_reserved1;    /* reserved                                                                          */
	unsigned int oversampling : BFW_NX51_canctrl_bus_timing1_oversampling; /* Sampling                                                                          */
	                                                                       /* 1 triple; the bus is sampled three times; recommended for low/medium speed buses  */
	                                                                       /*   (class A and B) where filtering spikes on the bus line is beneficial            */
	                                                                       /* 0 single; the bus is sampled once; recommended for high speed buses (SAE class C) */
	unsigned int tseg2        : BFW_NX51_canctrl_bus_timing1_tseg2;        /* Time Segment 2 (TSEG2)                                                            */
	                                                                       /* TSEG2 determine the number of clock cycles per bit                                */
	                                                                       /* period and the location of the sample point, where:                               */
	                                                                       /* tTSEG2 = tscl * (tseg2 + 1)                                                       */
	unsigned int reserved2    : BFW_NX51_canctrl_bus_timing1_reserved2;    /* reserved                                                                          */
} NX51_CANCTRL_BUS_TIMING1_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_CANCTRL_BUS_TIMING1_BIT_T bf;
} NX51_CANCTRL_BUS_TIMING1_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_not_extended_data0 */
/* =>  */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_not_extended_data0     0x00000028U
#define Adr_NX51_canctrl_canctrl_not_extended_data0 0x1018C928U
#define Adr_NX51_canctrl_not_extended_data0         0x1018C928U

/* --------------------------------------------------------------------- */
/* Register canctrl_arb_lost_capture */
/* => CAN arbitration lost capture register */
/*    This register contains information about the bit position of losing arbitration. */
/*    reading the register will clear all bits */
/*    in not extended mode: data1 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_arb_lost_capture     0x0000002CU
#define Adr_NX51_canctrl_canctrl_arb_lost_capture 0x1018C92CU
#define Adr_NX51_canctrl_arb_lost_capture         0x1018C92CU

#define MSK_NX51_canctrl_arb_lost_capture_position 0x0000001fU
#define SRT_NX51_canctrl_arb_lost_capture_position 0

/* all used bits of 'NX51_canctrl_arb_lost_capture': */
#define MSK_USED_BITS_NX51_canctrl_arb_lost_capture 0x0000001fU

enum {
	BFW_NX51_canctrl_arb_lost_capture_position  = 5,  /* [4:0] */
	BFW_NX51_canctrl_arb_lost_capture_reserved1 = 27  /* [31:5] */
};

typedef struct NX51_CANCTRL_ARB_LOST_CAPTURE_BIT_Ttag {
	unsigned int position  : BFW_NX51_canctrl_arb_lost_capture_position;  /* Positon where arbitration was lost                                                       */
	                                                                      /* {              |                                                                         */
	                                                                      /*  Decimal value    Position                                                               */
	                                                                      /*        00         arbitration lost in bit 1 of identifier                                */
	                                                                      /*        01         arbitration lost in bit 2 of identifier                                */
	                                                                      /*        02         arbitration lost in bit 3 of identifier                                */
	                                                                      /*        03         arbitration lost in bit 4 of identifier                                */
	                                                                      /*        04         arbitration lost in bit 5 of identifier                                */
	                                                                      /*        05         arbitration lost in bit 6 of identifier                                */
	                                                                      /*        06         arbitration lost in bit 7 of identifier                                */
	                                                                      /*        07         arbitration lost in bit 8 of identifier                                */
	                                                                      /*        08         arbitration lost in bit 9 of identifier                                */
	                                                                      /*        09         arbitration lost in bit 10 of identifier                               */
	                                                                      /*        10         arbitration lost in bit 11 of identifier                               */
	                                                                      /*        11         arbitration lost in bit SRTR; (bit RTR for standard frame messages)    */
	                                                                      /*        12         arbitration lost in bit IDE                                            */
	                                                                      /*        13         arbitration lost in bit 12 of identifier; extended frame messages only */
	                                                                      /*        14         arbitration lost in bit 13 of identifier; extended frame messages only */
	                                                                      /*        15         arbitration lost in bit 14 of identifier; extended frame messages only */
	                                                                      /*        16         arbitration lost in bit 15 of identifier; extended frame messages only */
	                                                                      /*        17         arbitration lost in bit 16 of identifier; extended frame messages only */
	                                                                      /*        18         arbitration lost in bit 17 of identifier; extended frame messages only */
	                                                                      /*        19         arbitration lost in bit 18 of identifier; extended frame messages only */
	                                                                      /*        20         arbitration lost in bit 19 of identifier; extended frame messages only */
	                                                                      /*        21         arbitration lost in bit 20 of identifier; extended frame messages only */
	                                                                      /*        22         arbitration lost in bit 21 of identifier; extended frame messages only */
	                                                                      /*        23         arbitration lost in bit 22 of identifier; extended frame messages only */
	                                                                      /*        24         arbitration lost in bit 23 of identifier; extended frame messages only */
	                                                                      /*        25         arbitration lost in bit 24 of identifier; extended frame messages only */
	                                                                      /*        26         arbitration lost in bit 25 of identifier; extended frame messages only */
	                                                                      /*        27         arbitration lost in bit 26 of identifier; extended frame messages only */
	                                                                      /*        28         arbitration lost in bit 27 of identifier; extended frame messages only */
	                                                                      /*        29         arbitration lost in bit 28 of identifier; extended frame messages only */
	                                                                      /*        30         arbitration lost in bit 29 of identifier; extended frame messages only */
	                                                                      /*        31         arbitration lost in bit RTR; extended frame messages only  }           */
	unsigned int reserved1 : BFW_NX51_canctrl_arb_lost_capture_reserved1; /* reserved                                                                                 */
} NX51_CANCTRL_ARB_LOST_CAPTURE_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_CANCTRL_ARB_LOST_CAPTURE_BIT_T bf;
} NX51_CANCTRL_ARB_LOST_CAPTURE_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_err_code_capture */
/* => CAN error code capture register */
/*    This register contains information about the type and location of errors on the bus. */
/*    reading the register will clear all bits */
/*    in not extended mode: data2 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_err_code_capture     0x00000030U
#define Adr_NX51_canctrl_canctrl_err_code_capture 0x1018C930U
#define Adr_NX51_canctrl_err_code_capture         0x1018C930U

#define MSK_NX51_canctrl_err_code_capture_segment   0x0000001fU
#define SRT_NX51_canctrl_err_code_capture_segment   0
#define MSK_NX51_canctrl_err_code_capture_direction 0x00000020U
#define SRT_NX51_canctrl_err_code_capture_direction 5
#define MSK_NX51_canctrl_err_code_capture_err_code  0x000000c0U
#define SRT_NX51_canctrl_err_code_capture_err_code  6

/* all used bits of 'NX51_canctrl_err_code_capture': */
#define MSK_USED_BITS_NX51_canctrl_err_code_capture 0x000000ffU

enum {
	BFW_NX51_canctrl_err_code_capture_segment   = 5,  /* [4:0] */
	BFW_NX51_canctrl_err_code_capture_direction = 1,  /* [5] */
	BFW_NX51_canctrl_err_code_capture_err_code  = 2,  /* [7:6] */
	BFW_NX51_canctrl_err_code_capture_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_ERR_CODE_CAPTURE_BIT_Ttag {
	unsigned int segment   : BFW_NX51_canctrl_err_code_capture_segment;   /* Frame segment where error was detected        */
	                                                                      /* {                  |                          */
	                                                                      /*     Binary value       Segment                */
	                                                                      /*        00011           start of frame         */
	                                                                      /*        00010           ID.28 to ID.21         */
	                                                                      /*        00110           ID.20 to ID.18         */
	                                                                      /*        00100           bit SRTR               */
	                                                                      /*        00101           bit IDE                */
	                                                                      /*        00111           ID.17 to ID.13         */
	                                                                      /*        01111           ID.12 to ID.5          */
	                                                                      /*        01110           ID.4 to ID.0           */
	                                                                      /*        01100           bit RTR                */
	                                                                      /*        01101           reser ved bit 1        */
	                                                                      /*        01001           reser ved bit 0        */
	                                                                      /*        01011           data length code       */
	                                                                      /*        01010           data field             */
	                                                                      /*        01000           CRC sequence           */
	                                                                      /*        11000           CRC delimiter          */
	                                                                      /*        11001           acknowledge slot       */
	                                                                      /*        11011           acknowledge delimiter  */
	                                                                      /*        11010           end of frame           */
	                                                                      /*        10010           intermission           */
	                                                                      /*        10001           active error flag      */
	                                                                      /*        10110           passive error flag     */
	                                                                      /*        10011           tolerate dominant bits */
	                                                                      /*        10111           error delimiter        */
	                                                                      /*        11100           overload flag }        */
	unsigned int direction : BFW_NX51_canctrl_err_code_capture_direction; /* Direction                                     */
	                                                                      /* 1 RX; error occurred during reception         */
	                                                                      /* 0 TX; error occurred during transmission      */
	unsigned int err_code  : BFW_NX51_canctrl_err_code_capture_err_code;  /* Error code                                    */
	                                                                      /* {                  |                          */
	                                                                      /*     Binary value      Code                    */
	                                                                      /*         00            bit error               */
	                                                                      /*         01            form error              */
	                                                                      /*         10            stuff error             */
	                                                                      /*         11            other type of error }   */
	unsigned int reserved1 : BFW_NX51_canctrl_err_code_capture_reserved1; /* reserved                                      */
} NX51_CANCTRL_ERR_CODE_CAPTURE_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_CANCTRL_ERR_CODE_CAPTURE_BIT_T bf;
} NX51_CANCTRL_ERR_CODE_CAPTURE_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_err_warning_limit */
/* => CAN error warning limit register, only writeable in reset mode */
/*    in not extended mode: data3 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_err_warning_limit     0x00000034U
#define Adr_NX51_canctrl_canctrl_err_warning_limit 0x1018C934U
#define Adr_NX51_canctrl_err_warning_limit         0x1018C934U
#define DFLT_VAL_NX51_canctrl_err_warning_limit    0x00000060U

#define MSK_NX51_canctrl_err_warning_limit_limit         0x000000ffU
#define SRT_NX51_canctrl_err_warning_limit_limit         0
#define DFLT_VAL_NX51_canctrl_err_warning_limit_limit    0x00000060U
#define DFLT_BF_VAL_NX51_canctrl_err_warning_limit_limit 0x00000060U

/* all used bits of 'NX51_canctrl_err_warning_limit': */
#define MSK_USED_BITS_NX51_canctrl_err_warning_limit 0x000000ffU

enum {
	BFW_NX51_canctrl_err_warning_limit_limit     = 8,  /* [7:0] */
	BFW_NX51_canctrl_err_warning_limit_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_ERR_WARNING_LIMIT_BIT_Ttag {
	unsigned int limit     : BFW_NX51_canctrl_err_warning_limit_limit;     /* error warning limit */
	unsigned int reserved1 : BFW_NX51_canctrl_err_warning_limit_reserved1; /* reserved            */
} NX51_CANCTRL_ERR_WARNING_LIMIT_BIT_T;

typedef union {
	unsigned int                         val;
	NX51_CANCTRL_ERR_WARNING_LIMIT_BIT_T bf;
} NX51_CANCTRL_ERR_WARNING_LIMIT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_rx_error_cnt */
/* => CAN RX error counter register, only writeable in reset mode */
/*    The RX error counter register reflects the current value of the receive error counter. */
/*    If a bus-off event occurs, the RX error counter is initialized to logic 0. The time bus-off is valid, writing to this register has */
/*    no effect. */
/*    Note, that a CPU-forced content change of the RX error counter is only possible, if the reset mode was entered */
/*    previously. An error status change (see status register), an error warning or an error passive interrupt forced */
/*    by the new register content will not occur, until the reset mode is cancelled again. */
/*    in not extended mode: data4 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_rx_error_cnt     0x00000038U
#define Adr_NX51_canctrl_canctrl_rx_error_cnt 0x1018C938U
#define Adr_NX51_canctrl_rx_error_cnt         0x1018C938U
#define DFLT_VAL_NX51_canctrl_rx_error_cnt    0x00000000U

#define MSK_NX51_canctrl_rx_error_cnt_rx_err         0x000000ffU
#define SRT_NX51_canctrl_rx_error_cnt_rx_err         0
#define DFLT_VAL_NX51_canctrl_rx_error_cnt_rx_err    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_rx_error_cnt_rx_err 0x00000000U

/* all used bits of 'NX51_canctrl_rx_error_cnt': */
#define MSK_USED_BITS_NX51_canctrl_rx_error_cnt 0x000000ffU

enum {
	BFW_NX51_canctrl_rx_error_cnt_rx_err    = 8,  /* [7:0] */
	BFW_NX51_canctrl_rx_error_cnt_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_RX_ERROR_CNT_BIT_Ttag {
	unsigned int rx_err    : BFW_NX51_canctrl_rx_error_cnt_rx_err;    /* rx error counter */
	unsigned int reserved1 : BFW_NX51_canctrl_rx_error_cnt_reserved1; /* reserved         */
} NX51_CANCTRL_RX_ERROR_CNT_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_CANCTRL_RX_ERROR_CNT_BIT_T bf;
} NX51_CANCTRL_RX_ERROR_CNT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_tx_error_cnt */
/* => CAN TX error counter register, only writeable in reset mode */
/*    The TX error counter register reflects the current value of the transmit error counter. */
/*    If a bus-off event occurs, the TX error counter is initialized to 127 to count the minimum */
/*    protocol-defined time (128 occurrences of the bus-free signal). Reading */
/*    the TX error counter during this time gives information about the status of the bus-off recovery. */
/*    If bus-off is active, a write access to TXERR in the range from 0 to 254 clears the bus-off flag and the controller will wait */
/*    for one occurrence of 11 consecutive recessive bits (bus-free) after the reset mode has been cleared. */
/*    Writing 255 to TXERR allows to initiate a CPU-driven bus-off event. It should be noted that a CPU-forced content change */
/*    of the TX error counter is only possible, if the reset mode was entered previously. An error or bus status change (see */
/*    status register), an error warning or an error passive interrupt forced by the new register content will not occur */
/*    until the reset mode is cancelled again. After leaving the reset mode, the new TX counter content is interpreted and the */
/*    bus-off event is performed in the same way, as if it was forced by a bus error event. That means, that the reset mode is */
/*    entered again, the TX error counter is initialized to 127, the RX counter is cleared and all concerned status and interrupt */
/*    register bits are set. */
/*    Clearing of reset mode now will perform the protocol-defined bus-off recovery sequence (waiting for 128 occurrences of */
/*    the bus-free signal). */
/*    If the reset mode is entered again before the end of bus-off recovery (TXERR > 0), bus-off keeps active and TXERR is */
/*    frozen. */
/*    in not extended mode: data5 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_tx_error_cnt     0x0000003CU
#define Adr_NX51_canctrl_canctrl_tx_error_cnt 0x1018C93CU
#define Adr_NX51_canctrl_tx_error_cnt         0x1018C93CU
#define DFLT_VAL_NX51_canctrl_tx_error_cnt    0x00000000U

#define MSK_NX51_canctrl_tx_error_cnt_tx_err         0x000000ffU
#define SRT_NX51_canctrl_tx_error_cnt_tx_err         0
#define DFLT_VAL_NX51_canctrl_tx_error_cnt_tx_err    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_tx_error_cnt_tx_err 0x00000000U

/* all used bits of 'NX51_canctrl_tx_error_cnt': */
#define MSK_USED_BITS_NX51_canctrl_tx_error_cnt 0x000000ffU

enum {
	BFW_NX51_canctrl_tx_error_cnt_tx_err    = 8,  /* [7:0] */
	BFW_NX51_canctrl_tx_error_cnt_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_TX_ERROR_CNT_BIT_Ttag {
	unsigned int tx_err    : BFW_NX51_canctrl_tx_error_cnt_tx_err;    /* tx error counter */
	unsigned int reserved1 : BFW_NX51_canctrl_tx_error_cnt_reserved1; /* reserved         */
} NX51_CANCTRL_TX_ERROR_CNT_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_CANCTRL_TX_ERROR_CNT_BIT_T bf;
} NX51_CANCTRL_TX_ERROR_CNT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data0 */
/* => CAN data register 0 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 0 */
/*     Operating mode:   R:  Standard frame: Read RX frame information */
/*                           Extended frame: Read RX frame information */
/*                       W:  Standard frame: Write TX frame information */
/*                           Extended frame: Write TX frame information } */
/*    in not extended mode: data6 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data0     0x00000040U
#define Adr_NX51_canctrl_canctrl_data0 0x1018C940U
#define Adr_NX51_canctrl_data0         0x1018C940U
#define DFLT_VAL_NX51_canctrl_data0    0x00000000U

#define MSK_NX51_canctrl_data0_data         0x000000ffU
#define SRT_NX51_canctrl_data0_data         0
#define DFLT_VAL_NX51_canctrl_data0_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data0_data 0x00000000U

/* all used bits of 'NX51_canctrl_data0': */
#define MSK_USED_BITS_NX51_canctrl_data0 0x000000ffU

enum {
	BFW_NX51_canctrl_data0_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data0_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA0_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data0_data;      /* register content (rx data, tx data or acceptance code) */
	unsigned int reserved1 : BFW_NX51_canctrl_data0_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA0_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA0_BIT_T bf;
} NX51_CANCTRL_DATA0_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data1 */
/* => CAN data register 1 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 1 */
/*     Operating mode:   R:  Standard frame: Read RX identifier 1 */
/*                           Extended frame: Read RX identifier 1 */
/*                       W:  Standard frame: Write TX identifier 1 */
/*                           Extended frame: Write TX identifier 1 } */
/*    in not extended mode: data7 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data1     0x00000044U
#define Adr_NX51_canctrl_canctrl_data1 0x1018C944U
#define Adr_NX51_canctrl_data1         0x1018C944U
#define DFLT_VAL_NX51_canctrl_data1    0x00000000U

#define MSK_NX51_canctrl_data1_data         0x000000ffU
#define SRT_NX51_canctrl_data1_data         0
#define DFLT_VAL_NX51_canctrl_data1_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data1_data 0x00000000U

/* all used bits of 'NX51_canctrl_data1': */
#define MSK_USED_BITS_NX51_canctrl_data1 0x000000ffU

enum {
	BFW_NX51_canctrl_data1_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data1_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA1_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data1_data;      /* register content (rx data, tx data or acceptance code) */
	unsigned int reserved1 : BFW_NX51_canctrl_data1_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA1_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA1_BIT_T bf;
} NX51_CANCTRL_DATA1_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data2 */
/* => CAN data register 2 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 2 */
/*     Operating mode:   R:  Standard frame: Read RX identifier 2 */
/*                           Extended frame: Read RX identifier 2 */
/*                       W:  Standard frame: Write TX identifier 2 */
/*                           Extended frame: Write TX identifier 2 } */
/*    in not extended mode: data8 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data2     0x00000048U
#define Adr_NX51_canctrl_canctrl_data2 0x1018C948U
#define Adr_NX51_canctrl_data2         0x1018C948U
#define DFLT_VAL_NX51_canctrl_data2    0x00000000U

#define MSK_NX51_canctrl_data2_data         0x000000ffU
#define SRT_NX51_canctrl_data2_data         0
#define DFLT_VAL_NX51_canctrl_data2_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data2_data 0x00000000U

/* all used bits of 'NX51_canctrl_data2': */
#define MSK_USED_BITS_NX51_canctrl_data2 0x000000ffU

enum {
	BFW_NX51_canctrl_data2_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data2_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA2_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data2_data;      /* register content (rx data, tx data or acceptance code) */
	unsigned int reserved1 : BFW_NX51_canctrl_data2_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA2_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA2_BIT_T bf;
} NX51_CANCTRL_DATA2_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data3 */
/* => CAN data register 3 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance code 3 */
/*     Operating mode:   R:  Standard frame: Read RX data 1 */
/*                           Extended frame: Read RX identifier 3 */
/*                       W:  Standard frame: Write TX data 1 */
/*                           Extended frame: Write TX identifier 3 } */
/*    in not extended mode: data9 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data3     0x0000004CU
#define Adr_NX51_canctrl_canctrl_data3 0x1018C94CU
#define Adr_NX51_canctrl_data3         0x1018C94CU
#define DFLT_VAL_NX51_canctrl_data3    0x00000000U

#define MSK_NX51_canctrl_data3_data         0x000000ffU
#define SRT_NX51_canctrl_data3_data         0
#define DFLT_VAL_NX51_canctrl_data3_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data3_data 0x00000000U

/* all used bits of 'NX51_canctrl_data3': */
#define MSK_USED_BITS_NX51_canctrl_data3 0x000000ffU

enum {
	BFW_NX51_canctrl_data3_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data3_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA3_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data3_data;      /* register content (rx data, tx data or acceptance code) */
	unsigned int reserved1 : BFW_NX51_canctrl_data3_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA3_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA3_BIT_T bf;
} NX51_CANCTRL_DATA3_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data4 */
/* => CAN data register 4 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 0 */
/*     Operating mode:   R:  Standard frame: Read RX data 2 */
/*                           Extended frame: Read RX identifier 4 */
/*                       W:  Standard frame: Write TX data 2 */
/*                           Extended frame: Write TX identifier 4 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data4     0x00000050U
#define Adr_NX51_canctrl_canctrl_data4 0x1018C950U
#define Adr_NX51_canctrl_data4         0x1018C950U
#define DFLT_VAL_NX51_canctrl_data4    0x00000000U

#define MSK_NX51_canctrl_data4_data         0x000000ffU
#define SRT_NX51_canctrl_data4_data         0
#define DFLT_VAL_NX51_canctrl_data4_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data4_data 0x00000000U

/* all used bits of 'NX51_canctrl_data4': */
#define MSK_USED_BITS_NX51_canctrl_data4 0x000000ffU

enum {
	BFW_NX51_canctrl_data4_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data4_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA4_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data4_data;      /* register content (rx data, tx data or acceptance mask) */
	unsigned int reserved1 : BFW_NX51_canctrl_data4_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA4_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA4_BIT_T bf;
} NX51_CANCTRL_DATA4_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data5 */
/* => CAN data register 5 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 1 */
/*     Operating mode:   R:  Standard frame: Read RX data 3 */
/*                           Extended frame: Read RX data 1 */
/*                       W:  Standard frame: Write TX data 3 */
/*                           Extended frame: Write TX data 1 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data5     0x00000054U
#define Adr_NX51_canctrl_canctrl_data5 0x1018C954U
#define Adr_NX51_canctrl_data5         0x1018C954U
#define DFLT_VAL_NX51_canctrl_data5    0x00000000U

#define MSK_NX51_canctrl_data5_data         0x000000ffU
#define SRT_NX51_canctrl_data5_data         0
#define DFLT_VAL_NX51_canctrl_data5_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data5_data 0x00000000U

/* all used bits of 'NX51_canctrl_data5': */
#define MSK_USED_BITS_NX51_canctrl_data5 0x000000ffU

enum {
	BFW_NX51_canctrl_data5_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data5_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA5_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data5_data;      /* register content (rx data, tx data or acceptance mask) */
	unsigned int reserved1 : BFW_NX51_canctrl_data5_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA5_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA5_BIT_T bf;
} NX51_CANCTRL_DATA5_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data6 */
/* => CAN data register 6 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 2 */
/*     Operating mode:   R:  Standard frame: Read RX data 4 */
/*                           Extended frame: Read RX data 2 */
/*                       W:  Standard frame: Write TX data 4 */
/*                           Extended frame: Write TX data 2 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data6     0x00000058U
#define Adr_NX51_canctrl_canctrl_data6 0x1018C958U
#define Adr_NX51_canctrl_data6         0x1018C958U
#define DFLT_VAL_NX51_canctrl_data6    0x00000000U

#define MSK_NX51_canctrl_data6_data         0x000000ffU
#define SRT_NX51_canctrl_data6_data         0
#define DFLT_VAL_NX51_canctrl_data6_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data6_data 0x00000000U

/* all used bits of 'NX51_canctrl_data6': */
#define MSK_USED_BITS_NX51_canctrl_data6 0x000000ffU

enum {
	BFW_NX51_canctrl_data6_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data6_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA6_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data6_data;      /* register content (rx data, tx data or acceptance mask) */
	unsigned int reserved1 : BFW_NX51_canctrl_data6_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA6_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA6_BIT_T bf;
} NX51_CANCTRL_DATA6_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data7 */
/* => CAN data register 7 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: Read or write acceptance mask 3 */
/*     Operating mode:   R:  Standard frame: Read RX data 5 */
/*                           Extended frame: Read RX data 3 */
/*                       W:  Standard frame: Write TX data 5 */
/*                           Extended frame: Write TX data 3 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data7     0x0000005CU
#define Adr_NX51_canctrl_canctrl_data7 0x1018C95CU
#define Adr_NX51_canctrl_data7         0x1018C95CU
#define DFLT_VAL_NX51_canctrl_data7    0x00000000U

#define MSK_NX51_canctrl_data7_data         0x000000ffU
#define SRT_NX51_canctrl_data7_data         0
#define DFLT_VAL_NX51_canctrl_data7_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data7_data 0x00000000U

/* all used bits of 'NX51_canctrl_data7': */
#define MSK_USED_BITS_NX51_canctrl_data7 0x000000ffU

enum {
	BFW_NX51_canctrl_data7_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data7_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA7_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data7_data;      /* register content (rx data, tx data or acceptance mask) */
	unsigned int reserved1 : BFW_NX51_canctrl_data7_reserved1; /* reserved                                               */
} NX51_CANCTRL_DATA7_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA7_BIT_T bf;
} NX51_CANCTRL_DATA7_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data8 */
/* => CAN data register 8 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: Read RX data 6 */
/*                           Extended frame: Read RX data 4 */
/*                       W:  Standard frame: Write TX data 6 */
/*                           Extended frame: Write TX data 4 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data8     0x00000060U
#define Adr_NX51_canctrl_canctrl_data8 0x1018C960U
#define Adr_NX51_canctrl_data8         0x1018C960U
#define DFLT_VAL_NX51_canctrl_data8    0x00000000U

#define MSK_NX51_canctrl_data8_data         0x000000ffU
#define SRT_NX51_canctrl_data8_data         0
#define DFLT_VAL_NX51_canctrl_data8_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data8_data 0x00000000U

/* all used bits of 'NX51_canctrl_data8': */
#define MSK_USED_BITS_NX51_canctrl_data8 0x000000ffU

enum {
	BFW_NX51_canctrl_data8_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data8_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA8_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data8_data;      /* register content (rx data or tx data) */
	unsigned int reserved1 : BFW_NX51_canctrl_data8_reserved1; /* reserved                              */
} NX51_CANCTRL_DATA8_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA8_BIT_T bf;
} NX51_CANCTRL_DATA8_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data9 */
/* => CAN data register 9 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: Read RX data 7 */
/*                           Extended frame: Read RX data 5 */
/*                       W:  Standard frame: Write TX data 7 */
/*                           Extended frame: Write TX data 5 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data9     0x00000064U
#define Adr_NX51_canctrl_canctrl_data9 0x1018C964U
#define Adr_NX51_canctrl_data9         0x1018C964U
#define DFLT_VAL_NX51_canctrl_data9    0x00000000U

#define MSK_NX51_canctrl_data9_data         0x000000ffU
#define SRT_NX51_canctrl_data9_data         0
#define DFLT_VAL_NX51_canctrl_data9_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data9_data 0x00000000U

/* all used bits of 'NX51_canctrl_data9': */
#define MSK_USED_BITS_NX51_canctrl_data9 0x000000ffU

enum {
	BFW_NX51_canctrl_data9_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data9_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA9_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data9_data;      /* register content (rx data or tx data) */
	unsigned int reserved1 : BFW_NX51_canctrl_data9_reserved1; /* reserved                              */
} NX51_CANCTRL_DATA9_BIT_T;

typedef union {
	unsigned int             val;
	NX51_CANCTRL_DATA9_BIT_T bf;
} NX51_CANCTRL_DATA9_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data10 */
/* => CAN data register 10 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: Read RX data 8 */
/*                           Extended frame: Read RX data 6 */
/*                       W:  Standard frame: Write TX data 8 */
/*                           Extended frame: Write TX data 6 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data10     0x00000068U
#define Adr_NX51_canctrl_canctrl_data10 0x1018C968U
#define Adr_NX51_canctrl_data10         0x1018C968U
#define DFLT_VAL_NX51_canctrl_data10    0x00000000U

#define MSK_NX51_canctrl_data10_data         0x000000ffU
#define SRT_NX51_canctrl_data10_data         0
#define DFLT_VAL_NX51_canctrl_data10_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data10_data 0x00000000U

/* all used bits of 'NX51_canctrl_data10': */
#define MSK_USED_BITS_NX51_canctrl_data10 0x000000ffU

enum {
	BFW_NX51_canctrl_data10_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data10_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA10_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data10_data;      /* register content (rx data or tx data) */
	unsigned int reserved1 : BFW_NX51_canctrl_data10_reserved1; /* reserved                              */
} NX51_CANCTRL_DATA10_BIT_T;

typedef union {
	unsigned int              val;
	NX51_CANCTRL_DATA10_BIT_T bf;
} NX51_CANCTRL_DATA10_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data11 */
/* => CAN data register 11 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: reserved */
/*                           Extended frame: Read RX data 7 */
/*                       W:  Standard frame: reserved */
/*                           Extended frame: Write TX data 7 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data11     0x0000006CU
#define Adr_NX51_canctrl_canctrl_data11 0x1018C96CU
#define Adr_NX51_canctrl_data11         0x1018C96CU
#define DFLT_VAL_NX51_canctrl_data11    0x00000000U

#define MSK_NX51_canctrl_data11_data         0x000000ffU
#define SRT_NX51_canctrl_data11_data         0
#define DFLT_VAL_NX51_canctrl_data11_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data11_data 0x00000000U

/* all used bits of 'NX51_canctrl_data11': */
#define MSK_USED_BITS_NX51_canctrl_data11 0x000000ffU

enum {
	BFW_NX51_canctrl_data11_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data11_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA11_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data11_data;      /* register content (rx data or tx data) */
	unsigned int reserved1 : BFW_NX51_canctrl_data11_reserved1; /* reserved                              */
} NX51_CANCTRL_DATA11_BIT_T;

typedef union {
	unsigned int              val;
	NX51_CANCTRL_DATA11_BIT_T bf;
} NX51_CANCTRL_DATA11_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_data12 */
/* => CAN data register 12 */
/*    This register has multiple functions depending on reset mode and read or write access. */
/*    {               |     | */
/*     Reset mode:      R/W: reserved */
/*     Operating mode:   R:  Standard frame: reserved */
/*                           Extended frame: Read RX data 8 */
/*                       W:  Standard frame: reserved */
/*                           Extended frame: Write TX data 8 } */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_data12     0x00000070U
#define Adr_NX51_canctrl_canctrl_data12 0x1018C970U
#define Adr_NX51_canctrl_data12         0x1018C970U
#define DFLT_VAL_NX51_canctrl_data12    0x00000000U

#define MSK_NX51_canctrl_data12_data         0x000000ffU
#define SRT_NX51_canctrl_data12_data         0
#define DFLT_VAL_NX51_canctrl_data12_data    0x00000000U
#define DFLT_BF_VAL_NX51_canctrl_data12_data 0x00000000U

/* all used bits of 'NX51_canctrl_data12': */
#define MSK_USED_BITS_NX51_canctrl_data12 0x000000ffU

enum {
	BFW_NX51_canctrl_data12_data      = 8,  /* [7:0] */
	BFW_NX51_canctrl_data12_reserved1 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_DATA12_BIT_Ttag {
	unsigned int data      : BFW_NX51_canctrl_data12_data;      /* register content (rx data or tx data) */
	unsigned int reserved1 : BFW_NX51_canctrl_data12_reserved1; /* reserved                              */
} NX51_CANCTRL_DATA12_BIT_T;

typedef union {
	unsigned int              val;
	NX51_CANCTRL_DATA12_BIT_T bf;
} NX51_CANCTRL_DATA12_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_rx_message_cnt */
/* => CAN RX message counter register */
/*    Reflects the number of messages available within the RXFIFO. The value is */
/*    incremented with each receive event and decremented by the release receive */
/*    buffer command. After any reset event, this register is cleared. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_rx_message_cnt     0x00000074U
#define Adr_NX51_canctrl_canctrl_rx_message_cnt 0x1018C974U
#define Adr_NX51_canctrl_rx_message_cnt         0x1018C974U

#define MSK_NX51_canctrl_rx_message_cnt_rx_msg_cnt 0x0000007fU
#define SRT_NX51_canctrl_rx_message_cnt_rx_msg_cnt 0

/* all used bits of 'NX51_canctrl_rx_message_cnt': */
#define MSK_USED_BITS_NX51_canctrl_rx_message_cnt 0x0000007fU

enum {
	BFW_NX51_canctrl_rx_message_cnt_rx_msg_cnt = 7,  /* [6:0] */
	BFW_NX51_canctrl_rx_message_cnt_reserved1  = 25  /* [31:7] */
};

typedef struct NX51_CANCTRL_RX_MESSAGE_CNT_BIT_Ttag {
	unsigned int rx_msg_cnt : BFW_NX51_canctrl_rx_message_cnt_rx_msg_cnt; /* rx message counter */
	unsigned int reserved1  : BFW_NX51_canctrl_rx_message_cnt_reserved1;  /* reserved           */
} NX51_CANCTRL_RX_MESSAGE_CNT_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_CANCTRL_RX_MESSAGE_CNT_BIT_T bf;
} NX51_CANCTRL_RX_MESSAGE_CNT_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_mode_control */
/* => CAN mode control register, only writeable in reset mode */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_mode_control     0x0000007CU
#define Adr_NX51_canctrl_canctrl_mode_control 0x1018C97CU
#define Adr_NX51_canctrl_mode_control         0x1018C97CU

#define MSK_NX51_canctrl_mode_control_mode 0x00000080U
#define SRT_NX51_canctrl_mode_control_mode 7

/* all used bits of 'NX51_canctrl_mode_control': */
#define MSK_USED_BITS_NX51_canctrl_mode_control 0x00000080U

enum {
	BFW_NX51_canctrl_mode_control_reserved1 = 7,  /* [6:0] */
	BFW_NX51_canctrl_mode_control_mode      = 1,  /* [7] */
	BFW_NX51_canctrl_mode_control_reserved2 = 24  /* [31:8] */
};

typedef struct NX51_CANCTRL_MODE_CONTROL_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_canctrl_mode_control_reserved1; /* reserved                                                                                      */
	unsigned int mode      : BFW_NX51_canctrl_mode_control_mode;      /* 0: BasicCAN mode, 1: PeliCAN mode                                                             */
	                                                                  /* recommended value is 1 (PeliCAN mode),                                                        */
	                                                                  /* The here given register map of all registers of the CAN controller is valid for PeliCAN only. */
	unsigned int reserved2 : BFW_NX51_canctrl_mode_control_reserved2; /* reserved                                                                                      */
} NX51_CANCTRL_MODE_CONTROL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_CANCTRL_MODE_CONTROL_BIT_T bf;
} NX51_CANCTRL_MODE_CONTROL_T;

/* --------------------------------------------------------------------- */
/* Register canctrl_arm_xpic_irq_enable */
/* => CAN IRQ Enable register for ARM and XPIC */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_canctrl_arm_xpic_irq_enable     0x00000080U
#define Adr_NX51_canctrl_canctrl_arm_xpic_irq_enable 0x1018C980U
#define Adr_NX51_canctrl_arm_xpic_irq_enable         0x1018C980U
#define DFLT_VAL_NX51_canctrl_arm_xpic_irq_enable    0x00000003U

#define MSK_NX51_canctrl_arm_xpic_irq_enable_arm_irq_enable          0x00000001U
#define SRT_NX51_canctrl_arm_xpic_irq_enable_arm_irq_enable          0
#define DFLT_VAL_NX51_canctrl_arm_xpic_irq_enable_arm_irq_enable     0x00000001U
#define DFLT_BF_VAL_NX51_canctrl_arm_xpic_irq_enable_arm_irq_enable  0x00000001U
#define MSK_NX51_canctrl_arm_xpic_irq_enable_xpic_irq_enable         0x00000002U
#define SRT_NX51_canctrl_arm_xpic_irq_enable_xpic_irq_enable         1
#define DFLT_VAL_NX51_canctrl_arm_xpic_irq_enable_xpic_irq_enable    0x00000002U
#define DFLT_BF_VAL_NX51_canctrl_arm_xpic_irq_enable_xpic_irq_enable 0x00000001U

/* all used bits of 'NX51_canctrl_arm_xpic_irq_enable': */
#define MSK_USED_BITS_NX51_canctrl_arm_xpic_irq_enable 0x00000003U

enum {
	BFW_NX51_canctrl_arm_xpic_irq_enable_arm_irq_enable  = 1,  /* [0] */
	BFW_NX51_canctrl_arm_xpic_irq_enable_xpic_irq_enable = 1,  /* [1] */
	BFW_NX51_canctrl_arm_xpic_irq_enable_reserved1       = 30  /* [31:2] */
};

typedef struct NX51_CANCTRL_ARM_XPIC_IRQ_ENABLE_BIT_Ttag {
	unsigned int arm_irq_enable  : BFW_NX51_canctrl_arm_xpic_irq_enable_arm_irq_enable;  /* enable for ARM IRQ  */
	unsigned int xpic_irq_enable : BFW_NX51_canctrl_arm_xpic_irq_enable_xpic_irq_enable; /* enable for XPIC IRQ */
	unsigned int reserved1       : BFW_NX51_canctrl_arm_xpic_irq_enable_reserved1;       /* reserved            */
} NX51_CANCTRL_ARM_XPIC_IRQ_ENABLE_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_CANCTRL_ARM_XPIC_IRQ_ENABLE_BIT_T bf;
} NX51_CANCTRL_ARM_XPIC_IRQ_ENABLE_T;


/* ===================================================================== */

/* Area of dmac */

/* ===================================================================== */

#define Addr_NX51_dmac      0x1018D000U
#define NX51_NETX_DMAC_AREA 0x1018D000U

/* ===================================================================== */

/* AREA dmac_ch */
/* Area of dmac_ch0, dmac_ch1, dmac_ch2 */

/* ===================================================================== */

#define Addr_NX51_dmac_ch0      0x1018D100U
#define NX51_NETX_DMAC_CH0_AREA 0x1018D100U
#define Addr_NX51_dmac_ch1      0x1018D120U
#define NX51_NETX_DMAC_CH1_AREA 0x1018D120U
#define Addr_NX51_dmac_ch2      0x1018D140U
#define NX51_NETX_DMAC_CH2_AREA 0x1018D140U

/* --------------------------------------------------------------------- */
/* Register dmac_chsrc_ad */
/* => channel source address registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_chsrc_ad      0x00000000U
#define Adr_NX51_dmac_ch0_dmac_chsrc_ad 0x1018D100U
#define Adr_NX51_dmac_ch1_dmac_chsrc_ad 0x1018D120U
#define Adr_NX51_dmac_ch2_dmac_chsrc_ad 0x1018D140U
#define DFLT_VAL_NX51_dmac_chsrc_ad     0x00000000U

#define MSK_NX51_dmac_chsrc_ad_DMACCHSRCADDR         0xffffffffU
#define SRT_NX51_dmac_chsrc_ad_DMACCHSRCADDR         0
#define DFLT_VAL_NX51_dmac_chsrc_ad_DMACCHSRCADDR    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chsrc_ad_DMACCHSRCADDR 0x00000000U

/* all used bits of 'NX51_dmac_chsrc_ad': */
#define MSK_USED_BITS_NX51_dmac_chsrc_ad 0xffffffffU

enum {
	BFW_NX51_dmac_chsrc_ad_DMACCHSRCADDR = 32  /* [31:0] */
};

typedef struct NX51_DMAC_CHSRC_AD_BIT_Ttag {
	unsigned int DMACCHSRCADDR : BFW_NX51_dmac_chsrc_ad_DMACCHSRCADDR; /* DMA source address */
} NX51_DMAC_CHSRC_AD_BIT_T;

typedef union {
	unsigned int             val;
	NX51_DMAC_CHSRC_AD_BIT_T bf;
} NX51_DMAC_CHSRC_AD_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chdest_ad */
/* => channel destination address registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_chdest_ad      0x00000004U
#define Adr_NX51_dmac_ch0_dmac_chdest_ad 0x1018D104U
#define Adr_NX51_dmac_ch1_dmac_chdest_ad 0x1018D124U
#define Adr_NX51_dmac_ch2_dmac_chdest_ad 0x1018D144U
#define DFLT_VAL_NX51_dmac_chdest_ad     0x00000000U

#define MSK_NX51_dmac_chdest_ad_DMACCHDESTADDR         0xffffffffU
#define SRT_NX51_dmac_chdest_ad_DMACCHDESTADDR         0
#define DFLT_VAL_NX51_dmac_chdest_ad_DMACCHDESTADDR    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chdest_ad_DMACCHDESTADDR 0x00000000U

/* all used bits of 'NX51_dmac_chdest_ad': */
#define MSK_USED_BITS_NX51_dmac_chdest_ad 0xffffffffU

enum {
	BFW_NX51_dmac_chdest_ad_DMACCHDESTADDR = 32  /* [31:0] */
};

typedef struct NX51_DMAC_CHDEST_AD_BIT_Ttag {
	unsigned int DMACCHDESTADDR : BFW_NX51_dmac_chdest_ad_DMACCHDESTADDR; /* DMA destination address */
} NX51_DMAC_CHDEST_AD_BIT_T;

typedef union {
	unsigned int              val;
	NX51_DMAC_CHDEST_AD_BIT_T bf;
} NX51_DMAC_CHDEST_AD_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chlink */
/* => channel linked list item register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_chlink      0x00000008U
#define Adr_NX51_dmac_ch0_dmac_chlink 0x1018D108U
#define Adr_NX51_dmac_ch1_dmac_chlink 0x1018D128U
#define Adr_NX51_dmac_ch2_dmac_chlink 0x1018D148U
#define DFLT_VAL_NX51_dmac_chlink     0x00000000U

#define MSK_NX51_dmac_chlink_LLIADDR         0xfffffffcU
#define SRT_NX51_dmac_chlink_LLIADDR         2
#define DFLT_VAL_NX51_dmac_chlink_LLIADDR    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chlink_LLIADDR 0x00000000U

/* all used bits of 'NX51_dmac_chlink': */
#define MSK_USED_BITS_NX51_dmac_chlink 0xfffffffcU

enum {
	BFW_NX51_dmac_chlink_reserved1 = 2,  /* [1:0] */
	BFW_NX51_dmac_chlink_LLIADDR   = 30  /* [31:2] */
};

typedef struct NX51_DMAC_CHLINK_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_dmac_chlink_reserved1; /* reserved                                                                                 */
	unsigned int LLIADDR   : BFW_NX51_dmac_chlink_LLIADDR;   /* Linked list item. Bits [31:2] of the address for the next LLI. Address bits [1:0] are 0. */
} NX51_DMAC_CHLINK_BIT_T;

typedef union {
	unsigned int           val;
	NX51_DMAC_CHLINK_BIT_T bf;
} NX51_DMAC_CHLINK_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chctrl */
/* => channel control registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_chctrl      0x0000000CU
#define Adr_NX51_dmac_ch0_dmac_chctrl 0x1018D10CU
#define Adr_NX51_dmac_ch1_dmac_chctrl 0x1018D12CU
#define Adr_NX51_dmac_ch2_dmac_chctrl 0x1018D14CU
#define DFLT_VAL_NX51_dmac_chctrl     0x00000000U

#define MSK_NX51_dmac_chctrl_TransferSize         0x00000fffU
#define SRT_NX51_dmac_chctrl_TransferSize         0
#define DFLT_VAL_NX51_dmac_chctrl_TransferSize    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_TransferSize 0x00000000U
#define MSK_NX51_dmac_chctrl_SBSize               0x00007000U
#define SRT_NX51_dmac_chctrl_SBSize               12
#define DFLT_VAL_NX51_dmac_chctrl_SBSize          0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_SBSize       0x00000000U
#define MSK_NX51_dmac_chctrl_DBSize               0x00038000U
#define SRT_NX51_dmac_chctrl_DBSize               15
#define DFLT_VAL_NX51_dmac_chctrl_DBSize          0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_DBSize       0x00000000U
#define MSK_NX51_dmac_chctrl_SWidth               0x001c0000U
#define SRT_NX51_dmac_chctrl_SWidth               18
#define DFLT_VAL_NX51_dmac_chctrl_SWidth          0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_SWidth       0x00000000U
#define MSK_NX51_dmac_chctrl_DWidth               0x00e00000U
#define SRT_NX51_dmac_chctrl_DWidth               21
#define DFLT_VAL_NX51_dmac_chctrl_DWidth          0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_DWidth       0x00000000U
#define MSK_NX51_dmac_chctrl_ARM_EQ               0x01000000U
#define SRT_NX51_dmac_chctrl_ARM_EQ               24
#define DFLT_VAL_NX51_dmac_chctrl_ARM_EQ          0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_ARM_EQ       0x00000000U
#define MSK_NX51_dmac_chctrl_SI                   0x04000000U
#define SRT_NX51_dmac_chctrl_SI                   26
#define DFLT_VAL_NX51_dmac_chctrl_SI              0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_SI           0x00000000U
#define MSK_NX51_dmac_chctrl_DI                   0x08000000U
#define SRT_NX51_dmac_chctrl_DI                   27
#define DFLT_VAL_NX51_dmac_chctrl_DI              0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_DI           0x00000000U
#define MSK_NX51_dmac_chctrl_Prot                 0x70000000U
#define SRT_NX51_dmac_chctrl_Prot                 28
#define DFLT_VAL_NX51_dmac_chctrl_Prot            0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_Prot         0x00000000U
#define MSK_NX51_dmac_chctrl_I                    0x80000000U
#define SRT_NX51_dmac_chctrl_I                    31
#define DFLT_VAL_NX51_dmac_chctrl_I               0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chctrl_I            0x00000000U

/* all used bits of 'NX51_dmac_chctrl': */
#define MSK_USED_BITS_NX51_dmac_chctrl 0xfdffffffU

enum {
	BFW_NX51_dmac_chctrl_TransferSize = 12, /* [11:0] */
	BFW_NX51_dmac_chctrl_SBSize       = 3,  /* [14:12] */
	BFW_NX51_dmac_chctrl_DBSize       = 3,  /* [17:15] */
	BFW_NX51_dmac_chctrl_SWidth       = 3,  /* [20:18] */
	BFW_NX51_dmac_chctrl_DWidth       = 3,  /* [23:21] */
	BFW_NX51_dmac_chctrl_ARM_EQ       = 1,  /* [24] */
	BFW_NX51_dmac_chctrl_reserved1    = 1,  /* [25] */
	BFW_NX51_dmac_chctrl_SI           = 1,  /* [26] */
	BFW_NX51_dmac_chctrl_DI           = 1,  /* [27] */
	BFW_NX51_dmac_chctrl_Prot         = 3,  /* [30:28] */
	BFW_NX51_dmac_chctrl_I            = 1   /* [31] */
};

typedef struct NX51_DMAC_CHCTRL_BIT_Ttag {
	unsigned int TransferSize : BFW_NX51_dmac_chctrl_TransferSize; /* Transfer size:                                                                                                                                               */
	                                                               /* For writes, this field indicates the number of (Source width) transfers to perform when the DMAC is the flow controller.                                     */
	                                                               /* For reads, the transfer size indicates the number of transfers completed on the destination bus.                                                             */
	                                                               /* Reading the register when the channel is active does not give useful information,                                                                            */
	                                                               /* as by the time that the software has processed the value read,                                                                                               */
	                                                               /* the channel might have progressed.                                                                                                                           */
	                                                               /* It is intended to be used only when a channel is enabled and then disabled.                                                                                  */
	                                                               /* If the DMAC controller is not the flow controller the transfer size should be set to 0.                                                                      */
	unsigned int SBSize       : BFW_NX51_dmac_chctrl_SBSize;       /* Source burst size:                                                                                                                                           */
	                                                               /* Indicates the number of transfers which make up a source burst.                                                                                              */
	                                                               /* This value must be set to the burst size of the source peripheral, or if the source is memory, to the memory boundary size.                                  */
	                                                               /* The burst size is the amount of data that is transferred when the DMACxBREQ signal goes active in the source peripheral.                                     */
	                                                               /* The burst size is not related to the AHB HBURST signal.                                                                                                      */
	                                                               /* ________________________________                                                                                                                             */
	                                                               /* bit_value    burst_transfer_size                                                                                                                             */
	                                                               /* --------------------------------                                                                                                                             */
	                                                               /*  000         1                                                                                                                                               */
	                                                               /*  001         4                                                                                                                                               */
	                                                               /*  010         8                                                                                                                                               */
	                                                               /*  011         16                                                                                                                                              */
	                                                               /*  100         32                                                                                                                                              */
	                                                               /*  101         64                                                                                                                                              */
	                                                               /*  110         128                                                                                                                                             */
	                                                               /*  111         256                                                                                                                                             */
	                                                               /* ================================                                                                                                                             */
	unsigned int DBSize       : BFW_NX51_dmac_chctrl_DBSize;       /* Destination burst size:                                                                                                                                      */
	                                                               /* Indicates the number of transfers which make up a destination burst transfer request.                                                                        */
	                                                               /* This value must be set to the burst size of the destination peripheral, or if the destination is memory, to the memory boundary size.                        */
	                                                               /* The burst size is the amount of data that is transferred when the DMACxBREQ signal goes active in the destination peripheral.                                */
	                                                               /* The burst size is not related to the AHB HBURST signal.                                                                                                      */
	                                                               /* Note: If flow controller is DMAC and destination is a peripheral, only bursts are transferred to the peripheral (DMACxSREQ is ignored if set by peripheral). */
	                                                               /*       The source burst size has no such limitation.                                                                                                          */
	                                                               /* ________________________________                                                                                                                             */
	                                                               /* bit_value    burst_transfer_size                                                                                                                             */
	                                                               /* --------------------------------                                                                                                                             */
	                                                               /*  000         1                                                                                                                                               */
	                                                               /*  001         4                                                                                                                                               */
	                                                               /*  010         8                                                                                                                                               */
	                                                               /*  011         16                                                                                                                                              */
	                                                               /*  100         32                                                                                                                                              */
	                                                               /*  101         64                                                                                                                                              */
	                                                               /*  110         128                                                                                                                                             */
	                                                               /*  111         256                                                                                                                                             */
	                                                               /* ================================                                                                                                                             */
	unsigned int SWidth       : BFW_NX51_dmac_chctrl_SWidth;       /* Source transfer width:                                                                                                                                       */
	                                                               /* The source and destination widths can be different from each other.                                                                                          */
	                                                               /* The hardware automatically packs and unpacks the data as required.                                                                                           */
	                                                               /* _________________________                                                                                                                                    */
	                                                               /* bit_value      data_width                                                                                                                                    */
	                                                               /* -------------------------                                                                                                                                    */
	                                                               /*  000             8-bit                                                                                                                                       */
	                                                               /*  001            16-bit                                                                                                                                       */
	                                                               /*  010            32-bit                                                                                                                                       */
	                                                               /* =========================                                                                                                                                    */
	unsigned int DWidth       : BFW_NX51_dmac_chctrl_DWidth;       /* Destination transfer width:                                                                                                                                  */
	                                                               /* The source and destination widths can be different from each other.                                                                                          */
	                                                               /* The hardware automatically packs and unpacks the data as required.                                                                                           */
	                                                               /* _________________________                                                                                                                                    */
	                                                               /* bit_value      data_width                                                                                                                                    */
	                                                               /* -------------------------                                                                                                                                    */
	                                                               /*  000             8-bit                                                                                                                                       */
	                                                               /*  001            16-bit                                                                                                                                       */
	                                                               /*  010            32-bit                                                                                                                                       */
	                                                               /* =========================                                                                                                                                    */
	unsigned int ARM_EQ       : BFW_NX51_dmac_chctrl_ARM_EQ;       /* Set equal behavior to arm implementation                                                                                                                     */
	                                                               /* This bit should always be set to 1 (default of 0 is from historical reasons).                                                                                */
	                                                               /* This bit changes 2 behavioural details:                                                                                                                      */
	                                                               /* 1. ARM_EQ=1: ignore single requests in DMA-controlled Memory-to-Peripheral accesses.                                                                         */
	                                                               /*    ARM_EQ=0: handle single requests like burst requests (in this case DBSize should be 1 access).                                                            */
	                                                               /*    Note: In DMA-controlled Memory-to-Peripheral mode only burst request signals are allowed.                                                                 */
	                                                               /*          The behaviour of single requests (from peripheral to DMAC) is not defined.                                                                          */
	                                                               /*          Modules generating single requests anyways might use ARM_EQ=0 in combination with DBSize=000.                                                       */
	                                                               /* 2. ARM_EQ=1: Always read 0 from TransferSize in this register.                                                                                               */
	                                                               /*    ARM_EQ=0: Read some internal value for debug purposes                                                                                                     */
	unsigned int reserved1    : BFW_NX51_dmac_chctrl_reserved1;    /* reserved                                                                                                                                                     */
	unsigned int SI           : BFW_NX51_dmac_chctrl_SI;           /* Source increment. When set the source address is incremented after each transfer.                                                                            */
	unsigned int DI           : BFW_NX51_dmac_chctrl_DI;           /* Destination increment. When set the destination address is incremented after each transfer.                                                                  */
	unsigned int Prot         : BFW_NX51_dmac_chctrl_Prot;         /* Protection.                                                                                                                                                  */
	unsigned int I            : BFW_NX51_dmac_chctrl_I;            /* Terminal count interrupt enable bit. It controls whether the current LLI is expected to trigger the terminal count interrupt.                                */
} NX51_DMAC_CHCTRL_BIT_T;

typedef union {
	unsigned int           val;
	NX51_DMAC_CHCTRL_BIT_T bf;
} NX51_DMAC_CHCTRL_T;

/* --------------------------------------------------------------------- */
/* Register dmac_chcfg */
/* => channel configuration registers */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_chcfg      0x00000010U
#define Adr_NX51_dmac_ch0_dmac_chcfg 0x1018D110U
#define Adr_NX51_dmac_ch1_dmac_chcfg 0x1018D130U
#define Adr_NX51_dmac_ch2_dmac_chcfg 0x1018D150U
#define DFLT_VAL_NX51_dmac_chcfg     0x00000000U

#define MSK_NX51_dmac_chcfg_E                      0x00000001U
#define SRT_NX51_dmac_chcfg_E                      0
#define DFLT_VAL_NX51_dmac_chcfg_E                 0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_E              0x00000000U
#define MSK_NX51_dmac_chcfg_SrcPeripheral          0x0000001eU
#define SRT_NX51_dmac_chcfg_SrcPeripheral          1
#define DFLT_VAL_NX51_dmac_chcfg_SrcPeripheral     0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_SrcPeripheral  0x00000000U
#define MSK_NX51_dmac_chcfg_DestPeripheral         0x000003c0U
#define SRT_NX51_dmac_chcfg_DestPeripheral         6
#define DFLT_VAL_NX51_dmac_chcfg_DestPeripheral    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_DestPeripheral 0x00000000U
#define MSK_NX51_dmac_chcfg_FlowCntrl              0x00003800U
#define SRT_NX51_dmac_chcfg_FlowCntrl              11
#define DFLT_VAL_NX51_dmac_chcfg_FlowCntrl         0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_FlowCntrl      0x00000000U
#define MSK_NX51_dmac_chcfg_IE                     0x00004000U
#define SRT_NX51_dmac_chcfg_IE                     14
#define DFLT_VAL_NX51_dmac_chcfg_IE                0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_IE             0x00000000U
#define MSK_NX51_dmac_chcfg_ITC                    0x00008000U
#define SRT_NX51_dmac_chcfg_ITC                    15
#define DFLT_VAL_NX51_dmac_chcfg_ITC               0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_ITC            0x00000000U
#define MSK_NX51_dmac_chcfg_L                      0x00010000U
#define SRT_NX51_dmac_chcfg_L                      16
#define DFLT_VAL_NX51_dmac_chcfg_L                 0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_L              0x00000000U
#define MSK_NX51_dmac_chcfg_A                      0x00020000U
#define SRT_NX51_dmac_chcfg_A                      17
#define DFLT_VAL_NX51_dmac_chcfg_A                 0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_A              0x00000000U
#define MSK_NX51_dmac_chcfg_H                      0x00040000U
#define SRT_NX51_dmac_chcfg_H                      18
#define DFLT_VAL_NX51_dmac_chcfg_H                 0x00000000U
#define DFLT_BF_VAL_NX51_dmac_chcfg_H              0x00000000U

/* all used bits of 'NX51_dmac_chcfg': */
#define MSK_USED_BITS_NX51_dmac_chcfg 0x0007fbdfU

enum {
	BFW_NX51_dmac_chcfg_E              = 1,  /* [0] */
	BFW_NX51_dmac_chcfg_SrcPeripheral  = 4,  /* [4:1] */
	BFW_NX51_dmac_chcfg_reserved1      = 1,  /* [5] */
	BFW_NX51_dmac_chcfg_DestPeripheral = 4,  /* [9:6] */
	BFW_NX51_dmac_chcfg_reserved2      = 1,  /* [10] */
	BFW_NX51_dmac_chcfg_FlowCntrl      = 3,  /* [13:11] */
	BFW_NX51_dmac_chcfg_IE             = 1,  /* [14] */
	BFW_NX51_dmac_chcfg_ITC            = 1,  /* [15] */
	BFW_NX51_dmac_chcfg_L              = 1,  /* [16] */
	BFW_NX51_dmac_chcfg_A              = 1,  /* [17] */
	BFW_NX51_dmac_chcfg_H              = 1,  /* [18] */
	BFW_NX51_dmac_chcfg_reserved3      = 13  /* [31:19] */
};

typedef struct NX51_DMAC_CHCFG_BIT_Ttag {
	unsigned int E              : BFW_NX51_dmac_chcfg_E;              /* Channel enable. Reading this bit indicates whether a channel is currently enabled or disabled: 0 = channel disabled 1 = channel enabled.                                          */
	                                                                  /* The Channel Enable bit status can also be found by reading the DMACEnbldChns register.                                                                                            */
	                                                                  /* A channel is enabled by setting this bit. Before enabling a single channel the DMA controller must be enabled globally by setting the DMACENABLE bit in the dmac_config register. */
	                                                                  /* Enabling a channel while the controller is disabled leads to undefined behavior. A channel can be disabled by clearing the Enable bit.                                            */
	                                                                  /* This causes the current AHB transfer (if one is in progress) to complete and the channel is then disabled.                                                                        */
	                                                                  /* Any data in the channels FIFO is lost.                                                                                                                                            */
	                                                                  /* Restarting the channel by simply setting the Channel Enable bit has unpredictable effects and the channel must be fully re-initialized.                                           */
	                                                                  /* The channel is also disabled, and Channel Enable bit cleared, when the last LLI is reached or if a channel error is encountered.                                                  */
	                                                                  /* If a channel has to be disabled without losing data in a channels FIFO the Halt bit must be set so that further DMA requests are ignored.                                         */
	                                                                  /* The Active bit must then be polled until it reaches 0, indicating that there is no data left in the channels FIFO.                                                                */
	                                                                  /* Finally the Channel Enable bit can be cleared.                                                                                                                                    */
	unsigned int SrcPeripheral  : BFW_NX51_dmac_chcfg_SrcPeripheral;  /* Source peripheral. This value selects the DMA source request peripheral.                                                                                                          */
	                                                                  /* This field is ignored if the source of the transfer is from memory.                                                                                                               */
	                                                                  /* _____________________________                                                                                                                                                     */
	                                                                  /* select_value  module                                                                                                                                                              */
	                                                                  /* -----------------------------                                                                                                                                                     */
	                                                                  /* 0            sqi_rx                                                                                                                                                               */
	                                                                  /* 1            reserved                                                                                                                                                             */
	                                                                  /* 2            spi1_rx                                                                                                                                                              */
	                                                                  /* 3            reserved                                                                                                                                                             */
	                                                                  /* 4            uart0_rx                                                                                                                                                             */
	                                                                  /* 5            reserved                                                                                                                                                             */
	                                                                  /* 6            uart1_rx                                                                                                                                                             */
	                                                                  /* 7            reserved                                                                                                                                                             */
	                                                                  /* 8            uart2_rx                                                                                                                                                             */
	                                                                  /* 9            reserved                                                                                                                                                             */
	                                                                  /* 10           eth_rx                                                                                                                                                               */
	                                                                  /* 11           reserved                                                                                                                                                             */
	                                                                  /* 12           i2c_master_mode                                                                                                                                                      */
	                                                                  /* 13           i2c_slave_mode                                                                                                                                                       */
	                                                                  /* 14           usb_dev_uart_rx                                                                                                                                                      */
	                                                                  /* 15           reserved                                                                                                                                                             */
	                                                                  /* =============================                                                                                                                                                     */
	unsigned int reserved1      : BFW_NX51_dmac_chcfg_reserved1;      /* reserved                                                                                                                                                                          */
	unsigned int DestPeripheral : BFW_NX51_dmac_chcfg_DestPeripheral; /* Destination peripheral. This value selects the DMA destination request peripheral.                                                                                                */
	                                                                  /* This field is ignored if the destination of the transfer is to memory.                                                                                                            */
	                                                                  /* _____________________________                                                                                                                                                     */
	                                                                  /* select_value    module                                                                                                                                                            */
	                                                                  /* -----------------------------                                                                                                                                                     */
	                                                                  /* 0            reserved                                                                                                                                                             */
	                                                                  /* 1            sqi_tx                                                                                                                                                               */
	                                                                  /* 2            reserved                                                                                                                                                             */
	                                                                  /* 3            spi1_tx                                                                                                                                                              */
	                                                                  /* 4            reserved                                                                                                                                                             */
	                                                                  /* 5            uart0_tx                                                                                                                                                             */
	                                                                  /* 6            reserved                                                                                                                                                             */
	                                                                  /* 7            uart1_tx                                                                                                                                                             */
	                                                                  /* 8            reserved                                                                                                                                                             */
	                                                                  /* 9            uart2_tx                                                                                                                                                             */
	                                                                  /* 10           reserved                                                                                                                                                             */
	                                                                  /* 11           eth_tx                                                                                                                                                               */
	                                                                  /* 12           i2c_master_mode                                                                                                                                                      */
	                                                                  /* 13           i2c_slave_mode                                                                                                                                                       */
	                                                                  /* 14           reserved                                                                                                                                                             */
	                                                                  /* 15           usb_dev_uart_tx                                                                                                                                                      */
	                                                                  /* =============================                                                                                                                                                     */
	unsigned int reserved2      : BFW_NX51_dmac_chcfg_reserved2;      /* reserved                                                                                                                                                                          */
	unsigned int FlowCntrl      : BFW_NX51_dmac_chcfg_FlowCntrl;      /* Flow control and transfer type. This value is used to indicate the flow controller and transfer type.                                                                             */
	                                                                  /* The flow controller can be the DMAC, the source peripheral, or the destination peripheral.                                                                                        */
	                                                                  /* The transfer type can be either memory-to-memory, memory-to-peripheral, peripheral-to-memory, or peripheral-to-peripheral.                                                        */
	                                                                  /* _______________________________________________________________________                                                                                                           */
	                                                                  /* bit_value     transfer_type                                  controller                                                                                                           */
	                                                                  /* -----------------------------------------------------------------------                                                                                                           */
	                                                                  /* 000           Memory-to-memory                               DMAC                                                                                                                 */
	                                                                  /* 001           Memory-to-peripheral                           DMAC                                                                                                                 */
	                                                                  /* 010           Peripheral-to-memorys                          DMAC                                                                                                                 */
	                                                                  /* 011           Source peripheral-to-destination peripheral    DMAC                                                                                                                 */
	                                                                  /* 100           Source peripheral-to-destination peripheral    Destination peripheral                                                                                               */
	                                                                  /* 101           Memory-to-peripheral                           Peripheral                                                                                                           */
	                                                                  /* 110           Peripheral-to-memory                           Peripheral                                                                                                           */
	                                                                  /* 111           Source peripheral-to-destination peripheral    Source peripheral                                                                                                    */
	                                                                  /* ========================================================================                                                                                                          */
	unsigned int IE             : BFW_NX51_dmac_chcfg_IE;             /* Interrupt error mask. When cleared this bit masks out the error interrupt of the relevant channel.                                                                                */
	unsigned int ITC            : BFW_NX51_dmac_chcfg_ITC;            /* Terminal count interrupt mask. When cleared this bit masks out the terminal count interrupt of the relevant channel.                                                              */
	unsigned int L              : BFW_NX51_dmac_chcfg_L;              /* Lock. When set this bit enables locked transfers.                                                                                                                                 */
	unsigned int A              : BFW_NX51_dmac_chcfg_A;              /* Active: 0 = there is no data in the FIFO of the channel 1 = the FIFO of the channel has data. (ro)                                                                                */
	                                                                  /* This value can be used with the Halt and Channel Enable bits to cleanly disable a DMA channel.                                                                                    */
	unsigned int H              : BFW_NX51_dmac_chcfg_H;              /* Halt: 0 = allow DMA requests 1 = ignore further source DMA requests. The contents of the channels FIFO are drained.                                                               */
	                                                                  /* This value can be used with the Active and Channel Enable bits to cleanly disable a DMA channel.                                                                                  */
	unsigned int reserved3      : BFW_NX51_dmac_chcfg_reserved3;      /* reserved                                                                                                                                                                          */
} NX51_DMAC_CHCFG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_DMAC_CHCFG_BIT_T bf;
} NX51_DMAC_CHCFG_T;


/* ===================================================================== */

/* Area of dmac_reg */

/* ===================================================================== */

#define Addr_NX51_dmac_reg      0x1018D800U
#define NX51_NETX_DMAC_REG_AREA 0x1018D800U

/* --------------------------------------------------------------------- */
/* Register dmac_int_status */
/* => interrupt status register */
/*    reset value 0x0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_int_status      0x00000000U
#define Adr_NX51_dmac_reg_dmac_int_status 0x1018D800U
#define Adr_NX51_dmac_int_status          0x1018D800U

#define MSK_NX51_dmac_int_status_DMACINT_ch0 0x00000001U
#define SRT_NX51_dmac_int_status_DMACINT_ch0 0
#define MSK_NX51_dmac_int_status_DMACINT_ch1 0x00000002U
#define SRT_NX51_dmac_int_status_DMACINT_ch1 1
#define MSK_NX51_dmac_int_status_DMACINT_ch2 0x00000004U
#define SRT_NX51_dmac_int_status_DMACINT_ch2 2

/* all used bits of 'NX51_dmac_int_status': */
#define MSK_USED_BITS_NX51_dmac_int_status 0x00000007U

enum {
	BFW_NX51_dmac_int_status_DMACINT_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_int_status_DMACINT_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_int_status_DMACINT_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_int_status_reserved1   = 29  /* [31:3] */
};

typedef struct NX51_DMAC_INT_STATUS_BIT_Ttag {
	unsigned int DMACINT_ch0 : BFW_NX51_dmac_int_status_DMACINT_ch0; /* Status of DMA channel 0 - interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACINT_ch1 : BFW_NX51_dmac_int_status_DMACINT_ch1; /* Status of DMA channel 1 - interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACINT_ch2 : BFW_NX51_dmac_int_status_DMACINT_ch2; /* Status of DMA channel 2 - interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int reserved1   : BFW_NX51_dmac_int_status_reserved1;   /* reserved                                                                                       */
} NX51_DMAC_INT_STATUS_BIT_T;

typedef union {
	unsigned int               val;
	NX51_DMAC_INT_STATUS_BIT_T bf;
} NX51_DMAC_INT_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_inttc_status */
/* => interrupt terminal count status register */
/*    reset value 0x0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_inttc_status      0x00000004U
#define Adr_NX51_dmac_reg_dmac_inttc_status 0x1018D804U
#define Adr_NX51_dmac_inttc_status          0x1018D804U

#define MSK_NX51_dmac_inttc_status_DMACINTTC_ch0 0x00000001U
#define SRT_NX51_dmac_inttc_status_DMACINTTC_ch0 0
#define MSK_NX51_dmac_inttc_status_DMACINTTC_ch1 0x00000002U
#define SRT_NX51_dmac_inttc_status_DMACINTTC_ch1 1
#define MSK_NX51_dmac_inttc_status_DMACINTTC_ch2 0x00000004U
#define SRT_NX51_dmac_inttc_status_DMACINTTC_ch2 2

/* all used bits of 'NX51_dmac_inttc_status': */
#define MSK_USED_BITS_NX51_dmac_inttc_status 0x00000007U

enum {
	BFW_NX51_dmac_inttc_status_DMACINTTC_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_inttc_status_DMACINTTC_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_inttc_status_DMACINTTC_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_inttc_status_reserved1     = 29  /* [31:3] */
};

typedef struct NX51_DMAC_INTTC_STATUS_BIT_Ttag {
	unsigned int DMACINTTC_ch0 : BFW_NX51_dmac_inttc_status_DMACINTTC_ch0; /* Status of DMA channel 0 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACINTTC_ch1 : BFW_NX51_dmac_inttc_status_DMACINTTC_ch1; /* Status of DMA channel 1 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACINTTC_ch2 : BFW_NX51_dmac_inttc_status_DMACINTTC_ch2; /* Status of DMA channel 2 - terminal count interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int reserved1     : BFW_NX51_dmac_inttc_status_reserved1;     /* reserved                                                                                                      */
} NX51_DMAC_INTTC_STATUS_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_DMAC_INTTC_STATUS_BIT_T bf;
} NX51_DMAC_INTTC_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_inttc_clear */
/* => interrupt terminal count clear register */
/*    reset value 0x0 */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_inttc_clear      0x00000008U
#define Adr_NX51_dmac_reg_dmac_inttc_clear 0x1018D808U
#define Adr_NX51_dmac_inttc_clear          0x1018D808U
#define DFLT_VAL_NX51_dmac_inttc_clear     0x00000000U

#define MSK_NX51_dmac_inttc_clear_DMACINTTCCLR_ch0         0x00000001U
#define SRT_NX51_dmac_inttc_clear_DMACINTTCCLR_ch0         0
#define DFLT_VAL_NX51_dmac_inttc_clear_DMACINTTCCLR_ch0    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_inttc_clear_DMACINTTCCLR_ch0 0x00000000U
#define MSK_NX51_dmac_inttc_clear_DMACINTTCCLR_ch1         0x00000002U
#define SRT_NX51_dmac_inttc_clear_DMACINTTCCLR_ch1         1
#define DFLT_VAL_NX51_dmac_inttc_clear_DMACINTTCCLR_ch1    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_inttc_clear_DMACINTTCCLR_ch1 0x00000000U
#define MSK_NX51_dmac_inttc_clear_DMACINTTCCLR_ch2         0x00000004U
#define SRT_NX51_dmac_inttc_clear_DMACINTTCCLR_ch2         2
#define DFLT_VAL_NX51_dmac_inttc_clear_DMACINTTCCLR_ch2    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_inttc_clear_DMACINTTCCLR_ch2 0x00000000U

/* all used bits of 'NX51_dmac_inttc_clear': */
#define MSK_USED_BITS_NX51_dmac_inttc_clear 0x00000007U

enum {
	BFW_NX51_dmac_inttc_clear_DMACINTTCCLR_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_inttc_clear_DMACINTTCCLR_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_inttc_clear_DMACINTTCCLR_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_inttc_clear_reserved1        = 29  /* [31:3] */
};

typedef struct NX51_DMAC_INTTC_CLEAR_BIT_Ttag {
	unsigned int DMACINTTCCLR_ch0 : BFW_NX51_dmac_inttc_clear_DMACINTTCCLR_ch0; /* Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 0 ,1'b0 have no effect. */
	unsigned int DMACINTTCCLR_ch1 : BFW_NX51_dmac_inttc_clear_DMACINTTCCLR_ch1; /* Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 1 ,1'b0 have no effect. */
	unsigned int DMACINTTCCLR_ch2 : BFW_NX51_dmac_inttc_clear_DMACINTTCCLR_ch2; /* Writing a 1'b1 Bit clears the terminal count interrupt of the specific channel 2 ,1'b0 have no effect. */
	unsigned int reserved1        : BFW_NX51_dmac_inttc_clear_reserved1;        /* reserved                                                                                               */
} NX51_DMAC_INTTC_CLEAR_BIT_T;

typedef union {
	unsigned int                val;
	NX51_DMAC_INTTC_CLEAR_BIT_T bf;
} NX51_DMAC_INTTC_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register dmac_interr_status */
/* => interrupt error status register */
/*    reset value 0x0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_interr_status      0x0000000CU
#define Adr_NX51_dmac_reg_dmac_interr_status 0x1018D80CU
#define Adr_NX51_dmac_interr_status          0x1018D80CU

#define MSK_NX51_dmac_interr_status_DMACINTERR_ch0 0x00000001U
#define SRT_NX51_dmac_interr_status_DMACINTERR_ch0 0
#define MSK_NX51_dmac_interr_status_DMACINTERR_ch1 0x00000002U
#define SRT_NX51_dmac_interr_status_DMACINTERR_ch1 1
#define MSK_NX51_dmac_interr_status_DMACINTERR_ch2 0x00000004U
#define SRT_NX51_dmac_interr_status_DMACINTERR_ch2 2

/* all used bits of 'NX51_dmac_interr_status': */
#define MSK_USED_BITS_NX51_dmac_interr_status 0x00000007U

enum {
	BFW_NX51_dmac_interr_status_DMACINTERR_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_interr_status_DMACINTERR_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_interr_status_DMACINTERR_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_interr_status_reserved1      = 29  /* [31:3] */
};

typedef struct NX51_DMAC_INTERR_STATUS_BIT_Ttag {
	unsigned int DMACINTERR_ch0 : BFW_NX51_dmac_interr_status_DMACINTERR_ch0; /* Status of DMA channel 0 - error interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACINTERR_ch1 : BFW_NX51_dmac_interr_status_DMACINTERR_ch1; /* Status of DMA channel 1 - error interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACINTERR_ch2 : BFW_NX51_dmac_interr_status_DMACINTERR_ch2; /* Status of DMA channel 2 - error interrupt after masking. 1'b1 indicates an active interrupt request. */
	unsigned int reserved1      : BFW_NX51_dmac_interr_status_reserved1;      /* reserved                                                                                             */
} NX51_DMAC_INTERR_STATUS_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_DMAC_INTERR_STATUS_BIT_T bf;
} NX51_DMAC_INTERR_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_interr_clear */
/* => interrupt error clear register */
/*    reset value 0x0 */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_interr_clear      0x00000010U
#define Adr_NX51_dmac_reg_dmac_interr_clear 0x1018D810U
#define Adr_NX51_dmac_interr_clear          0x1018D810U
#define DFLT_VAL_NX51_dmac_interr_clear     0x00000000U

#define MSK_NX51_dmac_interr_clear_DMACINTERRCLR_ch0         0x00000001U
#define SRT_NX51_dmac_interr_clear_DMACINTERRCLR_ch0         0
#define DFLT_VAL_NX51_dmac_interr_clear_DMACINTERRCLR_ch0    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_interr_clear_DMACINTERRCLR_ch0 0x00000000U
#define MSK_NX51_dmac_interr_clear_DMACINTERRCLR_ch1         0x00000002U
#define SRT_NX51_dmac_interr_clear_DMACINTERRCLR_ch1         1
#define DFLT_VAL_NX51_dmac_interr_clear_DMACINTERRCLR_ch1    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_interr_clear_DMACINTERRCLR_ch1 0x00000000U
#define MSK_NX51_dmac_interr_clear_DMACINTERRCLR_ch2         0x00000004U
#define SRT_NX51_dmac_interr_clear_DMACINTERRCLR_ch2         2
#define DFLT_VAL_NX51_dmac_interr_clear_DMACINTERRCLR_ch2    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_interr_clear_DMACINTERRCLR_ch2 0x00000000U

/* all used bits of 'NX51_dmac_interr_clear': */
#define MSK_USED_BITS_NX51_dmac_interr_clear 0x00000007U

enum {
	BFW_NX51_dmac_interr_clear_DMACINTERRCLR_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_interr_clear_DMACINTERRCLR_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_interr_clear_DMACINTERRCLR_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_interr_clear_reserved1         = 29  /* [31:3] */
};

typedef struct NX51_DMAC_INTERR_CLEAR_BIT_Ttag {
	unsigned int DMACINTERRCLR_ch0 : BFW_NX51_dmac_interr_clear_DMACINTERRCLR_ch0; /* Writing a 1'b1 Bit clears the error interrupt of the specific channel 0 ,1'b0 have no effect. */
	unsigned int DMACINTERRCLR_ch1 : BFW_NX51_dmac_interr_clear_DMACINTERRCLR_ch1; /* Writing a 1'b1 Bit clears the error interrupt of the specific channel 1 ,1'b0 have no effect. */
	unsigned int DMACINTERRCLR_ch2 : BFW_NX51_dmac_interr_clear_DMACINTERRCLR_ch2; /* Writing a 1'b1 Bit clears the error interrupt of the specific channel 2 ,1'b0 have no effect. */
	unsigned int reserved1         : BFW_NX51_dmac_interr_clear_reserved1;         /* reserved                                                                                      */
} NX51_DMAC_INTERR_CLEAR_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_DMAC_INTERR_CLEAR_BIT_T bf;
} NX51_DMAC_INTERR_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register dmac_rawinttc_status */
/* => raw interrupt terminal count status register */
/*    reset value 0x0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_rawinttc_status      0x00000014U
#define Adr_NX51_dmac_reg_dmac_rawinttc_status 0x1018D814U
#define Adr_NX51_dmac_rawinttc_status          0x1018D814U

#define MSK_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch0 0x00000001U
#define SRT_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch0 0
#define MSK_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch1 0x00000002U
#define SRT_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch1 1
#define MSK_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch2 0x00000004U
#define SRT_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch2 2

/* all used bits of 'NX51_dmac_rawinttc_status': */
#define MSK_USED_BITS_NX51_dmac_rawinttc_status 0x00000007U

enum {
	BFW_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_rawinttc_status_reserved1        = 29  /* [31:3] */
};

typedef struct NX51_DMAC_RAWINTTC_STATUS_BIT_Ttag {
	unsigned int DMACRAWINTTC_ch0 : BFW_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch0; /* Status of DMA channel 0 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACRAWINTTC_ch1 : BFW_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch1; /* Status of DMA channel 1 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACRAWINTTC_ch2 : BFW_NX51_dmac_rawinttc_status_DMACRAWINTTC_ch2; /* Status of DMA channel 2 - terminal count interrupt prior to masking. 1'b1 indicates an active interrupt request. */
	unsigned int reserved1        : BFW_NX51_dmac_rawinttc_status_reserved1;        /* reserved                                                                                                         */
} NX51_DMAC_RAWINTTC_STATUS_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DMAC_RAWINTTC_STATUS_BIT_T bf;
} NX51_DMAC_RAWINTTC_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_rawinterr_status */
/* => raw interrupt error status register */
/*    reset value 0x0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_rawinterr_status      0x00000018U
#define Adr_NX51_dmac_reg_dmac_rawinterr_status 0x1018D818U
#define Adr_NX51_dmac_rawinterr_status          0x1018D818U

#define MSK_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch0 0x00000001U
#define SRT_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch0 0
#define MSK_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch1 0x00000002U
#define SRT_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch1 1
#define MSK_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch2 0x00000004U
#define SRT_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch2 2

/* all used bits of 'NX51_dmac_rawinterr_status': */
#define MSK_USED_BITS_NX51_dmac_rawinterr_status 0x00000007U

enum {
	BFW_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_rawinterr_status_reserved1         = 29  /* [31:3] */
};

typedef struct NX51_DMAC_RAWINTERR_STATUS_BIT_Ttag {
	unsigned int DMACRAWINTERR_ch0 : BFW_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch0; /* Status of DMA channel 0 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACRAWINTERR_ch1 : BFW_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch1; /* Status of DMA channel 1 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. */
	unsigned int DMACRAWINTERR_ch2 : BFW_NX51_dmac_rawinterr_status_DMACRAWINTERR_ch2; /* Status of DMA channel 2 - error interrupt prior to masking. 1'b1 indicates an active interrupt request. */
	unsigned int reserved1         : BFW_NX51_dmac_rawinterr_status_reserved1;         /* reserved                                                                                                */
} NX51_DMAC_RAWINTERR_STATUS_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_DMAC_RAWINTERR_STATUS_BIT_T bf;
} NX51_DMAC_RAWINTERR_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register dmac_enabled_channel */
/* => channel enable register */
/*    reset value 0x0 */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_enabled_channel      0x0000001CU
#define Adr_NX51_dmac_reg_dmac_enabled_channel 0x1018D81CU
#define Adr_NX51_dmac_enabled_channel          0x1018D81CU

#define MSK_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch0 0x00000001U
#define SRT_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch0 0
#define MSK_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch1 0x00000002U
#define SRT_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch1 1
#define MSK_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch2 0x00000004U
#define SRT_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch2 2

/* all used bits of 'NX51_dmac_enabled_channel': */
#define MSK_USED_BITS_NX51_dmac_enabled_channel 0x00000007U

enum {
	BFW_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch0 = 1,  /* [0] */
	BFW_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch1 = 1,  /* [1] */
	BFW_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch2 = 1,  /* [2] */
	BFW_NX51_dmac_enabled_channel_reserved1           = 29  /* [31:3] */
};

typedef struct NX51_DMAC_ENABLED_CHANNEL_BIT_Ttag {
	unsigned int DMACENABLEDCHNS_ch0 : BFW_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch0; /* Status DMA channel 0 enable */
	unsigned int DMACENABLEDCHNS_ch1 : BFW_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch1; /* Status DMA channel 1 enable */
	unsigned int DMACENABLEDCHNS_ch2 : BFW_NX51_dmac_enabled_channel_DMACENABLEDCHNS_ch2; /* Status DMA channel 2 enable */
	unsigned int reserved1           : BFW_NX51_dmac_enabled_channel_reserved1;           /* reserved                    */
} NX51_DMAC_ENABLED_CHANNEL_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_DMAC_ENABLED_CHANNEL_BIT_T bf;
} NX51_DMAC_ENABLED_CHANNEL_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softb_req */
/* => software burst request register */
/*    reset value 0x0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_softb_req      0x00000020U
#define Adr_NX51_dmac_reg_dmac_softb_req 0x1018D820U
#define Adr_NX51_dmac_softb_req          0x1018D820U
#define DFLT_VAL_NX51_dmac_softb_req     0x00000000U

#define MSK_NX51_dmac_softb_req_DMACSoftBReq         0x0000ffffU
#define SRT_NX51_dmac_softb_req_DMACSoftBReq         0
#define DFLT_VAL_NX51_dmac_softb_req_DMACSoftBReq    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_softb_req_DMACSoftBReq 0x00000000U

/* all used bits of 'NX51_dmac_softb_req': */
#define MSK_USED_BITS_NX51_dmac_softb_req 0x0000ffffU

enum {
	BFW_NX51_dmac_softb_req_DMACSoftBReq = 16, /* [15:0] */
	BFW_NX51_dmac_softb_req_reserved1    = 16  /* [31:16] */
};

typedef struct NX51_DMAC_SOFTB_REQ_BIT_Ttag {
	unsigned int DMACSoftBReq : BFW_NX51_dmac_softb_req_DMACSoftBReq; /* Software burst request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
	                                                                  /* Reading the register indicates which sources are requesting DMA burst transfers.                                            */
	unsigned int reserved1    : BFW_NX51_dmac_softb_req_reserved1;    /* reserved                                                                                                                    */
} NX51_DMAC_SOFTB_REQ_BIT_T;

typedef union {
	unsigned int              val;
	NX51_DMAC_SOFTB_REQ_BIT_T bf;
} NX51_DMAC_SOFTB_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softs_req */
/* => software single request register */
/*    reset value 0x0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_softs_req      0x00000024U
#define Adr_NX51_dmac_reg_dmac_softs_req 0x1018D824U
#define Adr_NX51_dmac_softs_req          0x1018D824U
#define DFLT_VAL_NX51_dmac_softs_req     0x00000000U

#define MSK_NX51_dmac_softs_req_DMACSoftSReq         0x0000ffffU
#define SRT_NX51_dmac_softs_req_DMACSoftSReq         0
#define DFLT_VAL_NX51_dmac_softs_req_DMACSoftSReq    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_softs_req_DMACSoftSReq 0x00000000U

/* all used bits of 'NX51_dmac_softs_req': */
#define MSK_USED_BITS_NX51_dmac_softs_req 0x0000ffffU

enum {
	BFW_NX51_dmac_softs_req_DMACSoftSReq = 16, /* [15:0] */
	BFW_NX51_dmac_softs_req_reserved1    = 16  /* [31:16] */
};

typedef struct NX51_DMAC_SOFTS_REQ_BIT_Ttag {
	unsigned int DMACSoftSReq : BFW_NX51_dmac_softs_req_DMACSoftSReq; /* Software single request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
	                                                                  /* Reading the register indicates which sources are requesting DMA single transfers.                                            */
	unsigned int reserved1    : BFW_NX51_dmac_softs_req_reserved1;    /* reserved                                                                                                                     */
} NX51_DMAC_SOFTS_REQ_BIT_T;

typedef union {
	unsigned int              val;
	NX51_DMAC_SOFTS_REQ_BIT_T bf;
} NX51_DMAC_SOFTS_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softlb_req */
/* => software last burst request register */
/*    reset value 0x0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_softlb_req      0x00000028U
#define Adr_NX51_dmac_reg_dmac_softlb_req 0x1018D828U
#define Adr_NX51_dmac_softlb_req          0x1018D828U
#define DFLT_VAL_NX51_dmac_softlb_req     0x00000000U

#define MSK_NX51_dmac_softlb_req_DMACSoftLBReq         0x0000ffffU
#define SRT_NX51_dmac_softlb_req_DMACSoftLBReq         0
#define DFLT_VAL_NX51_dmac_softlb_req_DMACSoftLBReq    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_softlb_req_DMACSoftLBReq 0x00000000U

/* all used bits of 'NX51_dmac_softlb_req': */
#define MSK_USED_BITS_NX51_dmac_softlb_req 0x0000ffffU

enum {
	BFW_NX51_dmac_softlb_req_DMACSoftLBReq = 16, /* [15:0] */
	BFW_NX51_dmac_softlb_req_reserved1     = 16  /* [31:16] */
};

typedef struct NX51_DMAC_SOFTLB_REQ_BIT_Ttag {
	unsigned int DMACSoftLBReq : BFW_NX51_dmac_softlb_req_DMACSoftLBReq; /* Software last burst request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
	                                                                     /* Reading the register indicates which sources are requesting DMA last burst transfers.                                            */
	unsigned int reserved1     : BFW_NX51_dmac_softlb_req_reserved1;     /* reserved                                                                                                                         */
} NX51_DMAC_SOFTLB_REQ_BIT_T;

typedef union {
	unsigned int               val;
	NX51_DMAC_SOFTLB_REQ_BIT_T bf;
} NX51_DMAC_SOFTLB_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_softls_req */
/* => software last single request register */
/*    reset value 0x0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_softls_req      0x0000002CU
#define Adr_NX51_dmac_reg_dmac_softls_req 0x1018D82CU
#define Adr_NX51_dmac_softls_req          0x1018D82CU
#define DFLT_VAL_NX51_dmac_softls_req     0x00000000U

#define MSK_NX51_dmac_softls_req_DMACSoftLSReq         0x0000ffffU
#define SRT_NX51_dmac_softls_req_DMACSoftLSReq         0
#define DFLT_VAL_NX51_dmac_softls_req_DMACSoftLSReq    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_softls_req_DMACSoftLSReq 0x00000000U

/* all used bits of 'NX51_dmac_softls_req': */
#define MSK_USED_BITS_NX51_dmac_softls_req 0x0000ffffU

enum {
	BFW_NX51_dmac_softls_req_DMACSoftLSReq = 16, /* [15:0] */
	BFW_NX51_dmac_softls_req_reserved1     = 16  /* [31:16] */
};

typedef struct NX51_DMAC_SOFTLS_REQ_BIT_Ttag {
	unsigned int DMACSoftLSReq : BFW_NX51_dmac_softls_req_DMACSoftLSReq; /* Software last single request. A DMA request can be generated for each source by writing a 1'b1 to the corresponding register bit. */
	                                                                     /* Reading the register indicates which sources are requesting DMA last single transfers.                                            */
	unsigned int reserved1     : BFW_NX51_dmac_softls_req_reserved1;     /* reserved                                                                                                                          */
} NX51_DMAC_SOFTLS_REQ_BIT_T;

typedef union {
	unsigned int               val;
	NX51_DMAC_SOFTLS_REQ_BIT_T bf;
} NX51_DMAC_SOFTLS_REQ_T;

/* --------------------------------------------------------------------- */
/* Register dmac_config */
/* => configuration register */
/*    reset value 0x0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_config      0x00000030U
#define Adr_NX51_dmac_reg_dmac_config 0x1018D830U
#define Adr_NX51_dmac_config          0x1018D830U
#define DFLT_VAL_NX51_dmac_config     0x00000000U

#define MSK_NX51_dmac_config_DMACENABLE         0x00000001U
#define SRT_NX51_dmac_config_DMACENABLE         0
#define DFLT_VAL_NX51_dmac_config_DMACENABLE    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_config_DMACENABLE 0x00000000U

/* all used bits of 'NX51_dmac_config': */
#define MSK_USED_BITS_NX51_dmac_config 0x00000001U

enum {
	BFW_NX51_dmac_config_DMACENABLE = 1,  /* [0] */
	BFW_NX51_dmac_config_reserved1  = 31  /* [31:1] */
};

typedef struct NX51_DMAC_CONFIG_BIT_Ttag {
	unsigned int DMACENABLE : BFW_NX51_dmac_config_DMACENABLE; /* DMAC enable: 0 = disabled 1 = enabled. This bit is reset to 0. Disabling the DMAC reduces power consumption. */
	unsigned int reserved1  : BFW_NX51_dmac_config_reserved1;  /* reserved                                                                                                     */
} NX51_DMAC_CONFIG_BIT_T;

typedef union {
	unsigned int           val;
	NX51_DMAC_CONFIG_BIT_T bf;
} NX51_DMAC_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register dmac_sync */
/* => sync register */
/*    DMA synchronization logic for DMA request signals enabled or disabled */
/*    A 1'b0 bit indicates that the synchronization logic for */
/*    the DMACBREQ[15:0], DMACSREQ[15:0], DMACLBREQ[15:0], and DMACLSREQ[15:0] request signals is enabled. */
/*    A HIGH bit indicates that the synchronization logic is disabled. */
/*    reset value 0x0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_dmac_sync      0x00000034U
#define Adr_NX51_dmac_reg_dmac_sync 0x1018D834U
#define Adr_NX51_dmac_sync          0x1018D834U
#define DFLT_VAL_NX51_dmac_sync     0x00000000U

#define MSK_NX51_dmac_sync_DIS_SYNC_SQI_RX           0x00000001U
#define SRT_NX51_dmac_sync_DIS_SYNC_SQI_RX           0
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_SQI_RX      0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_SQI_RX   0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_SQI_TX           0x00000002U
#define SRT_NX51_dmac_sync_DIS_SYNC_SQI_TX           1
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_SQI_TX      0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_SQI_TX   0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_SPI1_RX          0x00000004U
#define SRT_NX51_dmac_sync_DIS_SYNC_SPI1_RX          2
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_SPI1_RX     0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_SPI1_RX  0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_SPI1_TX          0x00000008U
#define SRT_NX51_dmac_sync_DIS_SYNC_SPI1_TX          3
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_SPI1_TX     0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_SPI1_TX  0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_UART0_RX         0x00000010U
#define SRT_NX51_dmac_sync_DIS_SYNC_UART0_RX         4
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_UART0_RX    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_UART0_RX 0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_UART0_TX         0x00000020U
#define SRT_NX51_dmac_sync_DIS_SYNC_UART0_TX         5
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_UART0_TX    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_UART0_TX 0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_UART1_RX         0x00000040U
#define SRT_NX51_dmac_sync_DIS_SYNC_UART1_RX         6
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_UART1_RX    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_UART1_RX 0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_UART1_TX         0x00000080U
#define SRT_NX51_dmac_sync_DIS_SYNC_UART1_TX         7
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_UART1_TX    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_UART1_TX 0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_UART2_RX         0x00000100U
#define SRT_NX51_dmac_sync_DIS_SYNC_UART2_RX         8
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_UART2_RX    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_UART2_RX 0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_UART2_TX         0x00000200U
#define SRT_NX51_dmac_sync_DIS_SYNC_UART2_TX         9
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_UART2_TX    0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_UART2_TX 0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_ETH_RX           0x00000400U
#define SRT_NX51_dmac_sync_DIS_SYNC_ETH_RX           10
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_ETH_RX      0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_ETH_RX   0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_ETH_TX           0x00000800U
#define SRT_NX51_dmac_sync_DIS_SYNC_ETH_TX           11
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_ETH_TX      0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_ETH_TX   0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_I2C0_RX          0x00001000U
#define SRT_NX51_dmac_sync_DIS_SYNC_I2C0_RX          12
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_I2C0_RX     0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_I2C0_RX  0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_I2C0_TX          0x00002000U
#define SRT_NX51_dmac_sync_DIS_SYNC_I2C0_TX          13
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_I2C0_TX     0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_I2C0_TX  0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_USB_RX           0x00004000U
#define SRT_NX51_dmac_sync_DIS_SYNC_USB_RX           14
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_USB_RX      0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_USB_RX   0x00000000U
#define MSK_NX51_dmac_sync_DIS_SYNC_USB_TX           0x00008000U
#define SRT_NX51_dmac_sync_DIS_SYNC_USB_TX           15
#define DFLT_VAL_NX51_dmac_sync_DIS_SYNC_USB_TX      0x00000000U
#define DFLT_BF_VAL_NX51_dmac_sync_DIS_SYNC_USB_TX   0x00000000U

/* all used bits of 'NX51_dmac_sync': */
#define MSK_USED_BITS_NX51_dmac_sync 0x0000ffffU

enum {
	BFW_NX51_dmac_sync_DIS_SYNC_SQI_RX   = 1,  /* [0] */
	BFW_NX51_dmac_sync_DIS_SYNC_SQI_TX   = 1,  /* [1] */
	BFW_NX51_dmac_sync_DIS_SYNC_SPI1_RX  = 1,  /* [2] */
	BFW_NX51_dmac_sync_DIS_SYNC_SPI1_TX  = 1,  /* [3] */
	BFW_NX51_dmac_sync_DIS_SYNC_UART0_RX = 1,  /* [4] */
	BFW_NX51_dmac_sync_DIS_SYNC_UART0_TX = 1,  /* [5] */
	BFW_NX51_dmac_sync_DIS_SYNC_UART1_RX = 1,  /* [6] */
	BFW_NX51_dmac_sync_DIS_SYNC_UART1_TX = 1,  /* [7] */
	BFW_NX51_dmac_sync_DIS_SYNC_UART2_RX = 1,  /* [8] */
	BFW_NX51_dmac_sync_DIS_SYNC_UART2_TX = 1,  /* [9] */
	BFW_NX51_dmac_sync_DIS_SYNC_ETH_RX   = 1,  /* [10] */
	BFW_NX51_dmac_sync_DIS_SYNC_ETH_TX   = 1,  /* [11] */
	BFW_NX51_dmac_sync_DIS_SYNC_I2C0_RX  = 1,  /* [12] */
	BFW_NX51_dmac_sync_DIS_SYNC_I2C0_TX  = 1,  /* [13] */
	BFW_NX51_dmac_sync_DIS_SYNC_USB_RX   = 1,  /* [14] */
	BFW_NX51_dmac_sync_DIS_SYNC_USB_TX   = 1,  /* [15] */
	BFW_NX51_dmac_sync_reserved1         = 16  /* [31:16] */
};

typedef struct NX51_DMAC_SYNC_BIT_Ttag {
	unsigned int DIS_SYNC_SQI_RX   : BFW_NX51_dmac_sync_DIS_SYNC_SQI_RX;   /* disable sync register for SPI0 receive requests   */
	unsigned int DIS_SYNC_SQI_TX   : BFW_NX51_dmac_sync_DIS_SYNC_SQI_TX;   /* disable sync register for SPI0 transmit requests  */
	unsigned int DIS_SYNC_SPI1_RX  : BFW_NX51_dmac_sync_DIS_SYNC_SPI1_RX;  /* disable sync register for SPI1 receive requests   */
	unsigned int DIS_SYNC_SPI1_TX  : BFW_NX51_dmac_sync_DIS_SYNC_SPI1_TX;  /* disable sync register for SPI1 transmit requests  */
	unsigned int DIS_SYNC_UART0_RX : BFW_NX51_dmac_sync_DIS_SYNC_UART0_RX; /* disable sync register for UART0 receive requests  */
	unsigned int DIS_SYNC_UART0_TX : BFW_NX51_dmac_sync_DIS_SYNC_UART0_TX; /* disable sync register for UART0 transmit requests */
	unsigned int DIS_SYNC_UART1_RX : BFW_NX51_dmac_sync_DIS_SYNC_UART1_RX; /* disable sync register for UART1 receive requests  */
	unsigned int DIS_SYNC_UART1_TX : BFW_NX51_dmac_sync_DIS_SYNC_UART1_TX; /* disable sync register for UART1 transmit requests */
	unsigned int DIS_SYNC_UART2_RX : BFW_NX51_dmac_sync_DIS_SYNC_UART2_RX; /* disable sync register for UART1 receive requests  */
	unsigned int DIS_SYNC_UART2_TX : BFW_NX51_dmac_sync_DIS_SYNC_UART2_TX; /* disable sync register for UART1 transmit requests */
	unsigned int DIS_SYNC_ETH_RX   : BFW_NX51_dmac_sync_DIS_SYNC_ETH_RX;   /* disable sync register for ETH receive requests    */
	unsigned int DIS_SYNC_ETH_TX   : BFW_NX51_dmac_sync_DIS_SYNC_ETH_TX;   /* disable sync register for ETH transmit requests   */
	unsigned int DIS_SYNC_I2C0_RX  : BFW_NX51_dmac_sync_DIS_SYNC_I2C0_RX;  /* disable sync register for I2C receive requests    */
	unsigned int DIS_SYNC_I2C0_TX  : BFW_NX51_dmac_sync_DIS_SYNC_I2C0_TX;  /* disable sync register for I2C transmit requests   */
	unsigned int DIS_SYNC_USB_RX   : BFW_NX51_dmac_sync_DIS_SYNC_USB_RX;   /* disable sync register for USB receive requests    */
	unsigned int DIS_SYNC_USB_TX   : BFW_NX51_dmac_sync_DIS_SYNC_USB_TX;   /* disable sync register for USB transmit requests   */
	unsigned int reserved1         : BFW_NX51_dmac_sync_reserved1;         /* reserved                                          */
} NX51_DMAC_SYNC_BIT_T;

typedef union {
	unsigned int         val;
	NX51_DMAC_SYNC_BIT_T bf;
} NX51_DMAC_SYNC_T;


/* ===================================================================== */

/* Area of extmemctrl */

/* ===================================================================== */

#define Addr_NX51_extmemctrl 0x101C0100U

/* ===================================================================== */

/* AREA ext_asyncmem_ctrl */
/* Area of ext_asyncmem_ctrl, hif_asyncmem_ctrl */

/* ===================================================================== */

#define Addr_NX51_ext_asyncmem_ctrl  0x101C0100U
#define NX51_NETX_MEM_SRAM_CTRL_AREA 0x101C0100U
#define Addr_NX51_hif_asyncmem_ctrl  0x101C0200U

/* --------------------------------------------------------------------- */
/* Register extsram0_ctrl */
/* => Control Register for external bus interface and wait-states for chip-select 0 area. */
/*    External addresses always be byte addresses. */
/*    For additional byte-enables/DQM signals view netX pinout documentation. */
/*    For all wait state configuration 1 cycle is 1 netx system clock cycle, i.e. 10ns for netX running on 100MHz at normal operation. */
/*    Note: Pause and data width configuration is compatible to netx500/100 and netx50. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extsram0_ctrl               0x00000000U
#define Adr_NX51_ext_asyncmem_ctrl_extsram0_ctrl 0x101C0100U
#define Adr_NX51_hif_asyncmem_ctrl_extsram0_ctrl 0x101C0200U
#define DFLT_VAL_NX51_extsram0_ctrl              0x0303033fU

#define MSK_NX51_extsram0_ctrl_ws                       0x0000003fU
#define SRT_NX51_extsram0_ctrl_ws                       0
#define DFLT_VAL_NX51_extsram0_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX51_extsram0_ctrl_ws               0x0000003fU
#define MSK_NX51_extsram0_ctrl_p_pre                    0x00000300U
#define SRT_NX51_extsram0_ctrl_p_pre                    8
#define DFLT_VAL_NX51_extsram0_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX51_extsram0_ctrl_p_pre            0x00000003U
#define MSK_NX51_extsram0_ctrl_p_post                   0x00030000U
#define SRT_NX51_extsram0_ctrl_p_post                   16
#define DFLT_VAL_NX51_extsram0_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX51_extsram0_ctrl_p_post           0x00000003U
#define MSK_NX51_extsram0_ctrl_dwidth                   0x03000000U
#define SRT_NX51_extsram0_ctrl_dwidth                   24
#define DFLT_VAL_NX51_extsram0_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX51_extsram0_ctrl_dwidth           0x00000003U
#define MSK_NX51_extsram0_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX51_extsram0_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX51_extsram0_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX51_extsram0_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX51_extsram0_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX51_extsram0_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX51_extsram0_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX51_extsram0_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX51_extsram0_ctrl_static_cs                0x40000000U
#define SRT_NX51_extsram0_ctrl_static_cs                30
#define DFLT_VAL_NX51_extsram0_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX51_extsram0_ctrl_static_cs        0x00000000U
#define MSK_NX51_extsram0_ctrl_ready_en                 0x80000000U
#define SRT_NX51_extsram0_ctrl_ready_en                 31
#define DFLT_VAL_NX51_extsram0_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX51_extsram0_ctrl_ready_en         0x00000000U

/* all used bits of 'NX51_extsram0_ctrl': */
#define MSK_USED_BITS_NX51_extsram0_ctrl 0xf303033fU

enum {
	BFW_NX51_extsram0_ctrl_ws               = 6, /* [5:0] */
	BFW_NX51_extsram0_ctrl_reserved1        = 2, /* [7:6] */
	BFW_NX51_extsram0_ctrl_p_pre            = 2, /* [9:8] */
	BFW_NX51_extsram0_ctrl_reserved2        = 6, /* [15:10] */
	BFW_NX51_extsram0_ctrl_p_post           = 2, /* [17:16] */
	BFW_NX51_extsram0_ctrl_reserved3        = 6, /* [23:18] */
	BFW_NX51_extsram0_ctrl_dwidth           = 2, /* [25:24] */
	BFW_NX51_extsram0_ctrl_reserved4        = 2, /* [27:26] */
	BFW_NX51_extsram0_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
	BFW_NX51_extsram0_ctrl_no_p_post_seq_rd = 1, /* [29] */
	BFW_NX51_extsram0_ctrl_static_cs        = 1, /* [30] */
	BFW_NX51_extsram0_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX51_EXTSRAM0_CTRL_BIT_Ttag {
	unsigned int ws               : BFW_NX51_extsram0_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem0 area.                                                      */
	                                                                         /* During read access nRD-signal active low phase is ws+1.                                           */
	                                                                         /* During write access nWR-signal active low phase is ws+1..                                         */
	                                                                         /* Address, chip-select and byte-enable signals remain stable in this phase.                         */
	                                                                         /* After ws wait-cycles have passed signals remain stable and final data-access cycle is done.       */
	                                                                         /* To match memory device data access time tACC: program  WS=ceil(tACC/10ns)-1.                      */
	unsigned int reserved1        : BFW_NX51_extsram0_ctrl_reserved1;        /* reserved                                                                                          */
	unsigned int p_pre            : BFW_NX51_extsram0_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem0 area.                                                         */
	                                                                         /* Additional wait-states to match memory device setup times.                                        */
	                                                                         /* If programmed value is not 0, this Pre-Pause will be inserted at external access start            */
	                                                                         /* before Wait-State phase is started.                                                               */
	                                                                         /* Address, chip-select and byte-enable signals will be stable in this phase.                        */
	                                                                         /* but nRD-signal and nWR-signal remains inactive high.                                              */
	                                                                         /* Note: The Pre-Pause could be extended by 1 cycle under certain conditions by                      */
	                                                                         /*       netX memory controller. E.g. this becomes necessary for some access sequences               */
	                                                                         /*       (e.g. write-after-read or chip-select area change) to avoid collisions on external          */
	                                                                         /*       data bus.                                                                                   */
	unsigned int reserved2        : BFW_NX51_extsram0_ctrl_reserved2;        /* reserved                                                                                          */
	unsigned int p_post           : BFW_NX51_extsram0_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem0 area.                                                        */
	                                                                         /* Additional wait-states to match memory device Output-Disable or Address-Hold times.               */
	                                                                         /* If programmed value is not 0, this Post-Pause will be inserted at external access end             */
	                                                                         /* after Wait-State phase and data access cycle.                                                     */
	                                                                         /* Address, chip-select and byte-enable signals will remain stable in this phase.                    */
	                                                                         /* but nRD-signal and nWR-signal will become inactive high.                                          */
	                                                                         /* After write access netX memory controller will always insert at least                             */
	                                                                         /* 1 Post-Pause cycle to generate positive edge on nWR-signal.                                       */
	unsigned int reserved3        : BFW_NX51_extsram0_ctrl_reserved3;        /* reserved                                                                                          */
	unsigned int dwidth           : BFW_NX51_extsram0_ctrl_dwidth;           /* Data bus width of ExtMem0 area.                                                                   */
	                                                                         /*  00 :  8bit memory device connected to this chip-select address area.                             */
	                                                                         /*  01 : 16bit memory device connected to this chip-select address area.                             */
	                                                                         /*  10 : 32bit memory device connected to this chip-select address area.                             */
	                                                                         /*  11 : memory is disabled, related chip-select signal can be used for other purpose (e.g. as PIO). */
	                                                                         /* Note: Chip-selects are disabled by default. However it could be possible                          */
	                                                                         /*       that they are enabled during netX boot phase to search for boot device.                     */
	                                                                         /*       View bootloader information for this.                                                       */
	                                                                         /* Note: When chip-select is disabled related netX IO can be used for other                          */
	                                                                         /*       functions. View memory interface multiplex options or netX pinning for more information.    */
	                                                                         /* Note: All access to disabled chip-select area will be ignored. No wait will be                    */
	                                                                         /*       generated to requesting master. Read data will be unvalid. External MI signal states        */
	                                                                         /*       will not change.                                                                            */
	unsigned int reserved4        : BFW_NX51_extsram0_ctrl_reserved4;        /* reserved                                                                                          */
	unsigned int no_p_pre_seq_rd  : BFW_NX51_extsram0_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                                  */
	                                                                         /* 0: Pre-Pause will be inserted after each read access.                                             */
	                                                                         /* 1: Disable Pre-Pause between sequential reads.                                                    */
	                                                                         /* Note: default setting '0' is for netx100/50 compatibility only. Typically there is                */
	                                                                         /*       no need of Pre-Pause insertion between sequential reads.                                    */
	unsigned int no_p_post_seq_rd : BFW_NX51_extsram0_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                                 */
	                                                                         /* 0: Post-Pause will be inserted after each read access.                                            */
	                                                                         /* 1: Disable Post-Pause between sequential reads.                                                   */
	                                                                         /* Note: Default setting '0' is for netx100/50 compatibility only. Typically there is                */
	                                                                         /*       no need of Post-Pause insertion between sequential reads. A Post-Pause will                 */
	                                                                         /*       always be inserted if the next access addresses another chip-select area, is a write        */
	                                                                         /*       access or is not predictable by the memory controller.                                      */
	unsigned int static_cs        : BFW_NX51_extsram0_ctrl_static_cs;        /* Static chip-select signal generation.                                                             */
	                                                                         /* 0: No static chip-select signal generation                                                        */
	                                                                         /* 1: Static chip-select signal generation enabled (e.g. for i80 displays).                          */
	                                                                         /* All chip-select signals will return to inactive (high) level when no access is performed          */
	                                                                         /* by default (when this bit is not set). However some devices (e.g. some i80 displays) require      */
	                                                                         /* subsequent access without chip-select becoming inactive in between. For that purpose              */
	                                                                         /* 'static_cs' bit can be set. Chip-select will remain active once an access was performed           */
	                                                                         /* to this chip-select address-area until an access targets another chip-select address-area.        */
	                                                                         /* Hence, for proper i80 sequence, software must avoid that the current access sequence is           */
	                                                                         /* interrupted by an access to another chip-select area (including SDRAM access of this memory       */
	                                                                         /* interface), e.g. cause by interrupt execution, other masters or SDRAM refresh generation.         */
	                                                                         /* To release chip-select to idle state,                                                             */
	                                                                         /* - access another chip-select area of this memory interface or                                     */
	                                                                         /* - clear the 'static_cs' bit of this chip-select area or                                           */
	                                                                         /* - disable this chip-select area (set 'dwidth' to '11').                                           */
	                                                                         /* Note: Clearing the 'static_cs'-bit while an access is running to this chip-select area            */
	                                                                         /*       will have no impact on the current access. However disabling the whole chip-select area     */
	                                                                         /*       while an access is running could lead to an invalid access.                                 */
	                                                                         /* Note: This is a new feature since netx51.                                                         */
	unsigned int ready_en         : BFW_NX51_extsram0_ctrl_ready_en;         /* Ready Signal Enable.                                                                              */
	                                                                         /* 0: Access timing is only controlled by Wait-State and Pre/Post-Pause configuration above.         */
	                                                                         /* 1: Use external ready input to stretch Wait-State phase.                                          */
	                                                                         /*    Wait-States and Pre/Post-Pauses will be done according to configuration above. However         */
	                                                                         /*    Wait-State phase can be extended by an external device by holding netX ready input             */
	                                                                         /*    inactive. Data access cycle is done after external device sets netX ready input to             */
	                                                                         /*    active state.                                                                                  */
	                                                                         /* Note: An external device must assert ready to inactive state while                                */
	                                                                         /*       Wait-States phase is running (defined by ws in this register). Ready input                  */
	                                                                         /*       sampling and latency takes 20ns. Hence ws must be set to a value greater                    */
	                                                                         /*       than 2 for proper functionality using ready. The value must be increased                    */
	                                                                         /*       if there is a ready setup time of the ready generating external device.                     */
	                                                                         /* Note: For detailed ready input configuration and handling view ext_rdy_cfg register description.  */
} NX51_EXTSRAM0_CTRL_BIT_T;

typedef union {
	unsigned int             val;
	NX51_EXTSRAM0_CTRL_BIT_T bf;
} NX51_EXTSRAM0_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extsram1_ctrl */
/* => Control Register for external bus interface and wait-states for chip-select 1 area. */
/*    For detailed register description view extsram0_ctrl register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extsram1_ctrl               0x00000004U
#define Adr_NX51_ext_asyncmem_ctrl_extsram1_ctrl 0x101C0104U
#define Adr_NX51_hif_asyncmem_ctrl_extsram1_ctrl 0x101C0204U
#define DFLT_VAL_NX51_extsram1_ctrl              0x0303033fU

#define MSK_NX51_extsram1_ctrl_ws                       0x0000003fU
#define SRT_NX51_extsram1_ctrl_ws                       0
#define DFLT_VAL_NX51_extsram1_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX51_extsram1_ctrl_ws               0x0000003fU
#define MSK_NX51_extsram1_ctrl_p_pre                    0x00000300U
#define SRT_NX51_extsram1_ctrl_p_pre                    8
#define DFLT_VAL_NX51_extsram1_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX51_extsram1_ctrl_p_pre            0x00000003U
#define MSK_NX51_extsram1_ctrl_p_post                   0x00030000U
#define SRT_NX51_extsram1_ctrl_p_post                   16
#define DFLT_VAL_NX51_extsram1_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX51_extsram1_ctrl_p_post           0x00000003U
#define MSK_NX51_extsram1_ctrl_dwidth                   0x03000000U
#define SRT_NX51_extsram1_ctrl_dwidth                   24
#define DFLT_VAL_NX51_extsram1_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX51_extsram1_ctrl_dwidth           0x00000003U
#define MSK_NX51_extsram1_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX51_extsram1_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX51_extsram1_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX51_extsram1_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX51_extsram1_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX51_extsram1_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX51_extsram1_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX51_extsram1_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX51_extsram1_ctrl_static_cs                0x40000000U
#define SRT_NX51_extsram1_ctrl_static_cs                30
#define DFLT_VAL_NX51_extsram1_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX51_extsram1_ctrl_static_cs        0x00000000U
#define MSK_NX51_extsram1_ctrl_ready_en                 0x80000000U
#define SRT_NX51_extsram1_ctrl_ready_en                 31
#define DFLT_VAL_NX51_extsram1_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX51_extsram1_ctrl_ready_en         0x00000000U

/* all used bits of 'NX51_extsram1_ctrl': */
#define MSK_USED_BITS_NX51_extsram1_ctrl 0xf303033fU

enum {
	BFW_NX51_extsram1_ctrl_ws               = 6, /* [5:0] */
	BFW_NX51_extsram1_ctrl_reserved1        = 2, /* [7:6] */
	BFW_NX51_extsram1_ctrl_p_pre            = 2, /* [9:8] */
	BFW_NX51_extsram1_ctrl_reserved2        = 6, /* [15:10] */
	BFW_NX51_extsram1_ctrl_p_post           = 2, /* [17:16] */
	BFW_NX51_extsram1_ctrl_reserved3        = 6, /* [23:18] */
	BFW_NX51_extsram1_ctrl_dwidth           = 2, /* [25:24] */
	BFW_NX51_extsram1_ctrl_reserved4        = 2, /* [27:26] */
	BFW_NX51_extsram1_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
	BFW_NX51_extsram1_ctrl_no_p_post_seq_rd = 1, /* [29] */
	BFW_NX51_extsram1_ctrl_static_cs        = 1, /* [30] */
	BFW_NX51_extsram1_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX51_EXTSRAM1_CTRL_BIT_Ttag {
	unsigned int ws               : BFW_NX51_extsram1_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem1 area.                                          */
	unsigned int reserved1        : BFW_NX51_extsram1_ctrl_reserved1;        /* reserved                                                                              */
	unsigned int p_pre            : BFW_NX51_extsram1_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem1 area.                                             */
	unsigned int reserved2        : BFW_NX51_extsram1_ctrl_reserved2;        /* reserved                                                                              */
	unsigned int p_post           : BFW_NX51_extsram1_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem1 area.                                            */
	unsigned int reserved3        : BFW_NX51_extsram1_ctrl_reserved3;        /* reserved                                                                              */
	unsigned int dwidth           : BFW_NX51_extsram1_ctrl_dwidth;           /* Data bus width of ExtMem1 area.                                                       */
	                                                                         /* Note: This chip-select is disabled by default and may be shared with other functions. */
	                                                                         /*       View memory interface multiplex options for more information.                   */
	unsigned int reserved4        : BFW_NX51_extsram1_ctrl_reserved4;        /* reserved                                                                              */
	unsigned int no_p_pre_seq_rd  : BFW_NX51_extsram1_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                      */
	unsigned int no_p_post_seq_rd : BFW_NX51_extsram1_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                     */
	unsigned int static_cs        : BFW_NX51_extsram1_ctrl_static_cs;        /* Static chip-select signal generation.                                                 */
	unsigned int ready_en         : BFW_NX51_extsram1_ctrl_ready_en;         /* Ready Signal Enable.                                                                  */
} NX51_EXTSRAM1_CTRL_BIT_T;

typedef union {
	unsigned int             val;
	NX51_EXTSRAM1_CTRL_BIT_T bf;
} NX51_EXTSRAM1_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extsram2_ctrl */
/* => Control Register for external bus interface and wait-states for chip-select 2 area. */
/*    For detailed register description view extsram0_ctrl register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extsram2_ctrl               0x00000008U
#define Adr_NX51_ext_asyncmem_ctrl_extsram2_ctrl 0x101C0108U
#define Adr_NX51_hif_asyncmem_ctrl_extsram2_ctrl 0x101C0208U
#define DFLT_VAL_NX51_extsram2_ctrl              0x0303033fU

#define MSK_NX51_extsram2_ctrl_ws                       0x0000003fU
#define SRT_NX51_extsram2_ctrl_ws                       0
#define DFLT_VAL_NX51_extsram2_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX51_extsram2_ctrl_ws               0x0000003fU
#define MSK_NX51_extsram2_ctrl_p_pre                    0x00000300U
#define SRT_NX51_extsram2_ctrl_p_pre                    8
#define DFLT_VAL_NX51_extsram2_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX51_extsram2_ctrl_p_pre            0x00000003U
#define MSK_NX51_extsram2_ctrl_p_post                   0x00030000U
#define SRT_NX51_extsram2_ctrl_p_post                   16
#define DFLT_VAL_NX51_extsram2_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX51_extsram2_ctrl_p_post           0x00000003U
#define MSK_NX51_extsram2_ctrl_dwidth                   0x03000000U
#define SRT_NX51_extsram2_ctrl_dwidth                   24
#define DFLT_VAL_NX51_extsram2_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX51_extsram2_ctrl_dwidth           0x00000003U
#define MSK_NX51_extsram2_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX51_extsram2_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX51_extsram2_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX51_extsram2_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX51_extsram2_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX51_extsram2_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX51_extsram2_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX51_extsram2_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX51_extsram2_ctrl_static_cs                0x40000000U
#define SRT_NX51_extsram2_ctrl_static_cs                30
#define DFLT_VAL_NX51_extsram2_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX51_extsram2_ctrl_static_cs        0x00000000U
#define MSK_NX51_extsram2_ctrl_ready_en                 0x80000000U
#define SRT_NX51_extsram2_ctrl_ready_en                 31
#define DFLT_VAL_NX51_extsram2_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX51_extsram2_ctrl_ready_en         0x00000000U

/* all used bits of 'NX51_extsram2_ctrl': */
#define MSK_USED_BITS_NX51_extsram2_ctrl 0xf303033fU

enum {
	BFW_NX51_extsram2_ctrl_ws               = 6, /* [5:0] */
	BFW_NX51_extsram2_ctrl_reserved1        = 2, /* [7:6] */
	BFW_NX51_extsram2_ctrl_p_pre            = 2, /* [9:8] */
	BFW_NX51_extsram2_ctrl_reserved2        = 6, /* [15:10] */
	BFW_NX51_extsram2_ctrl_p_post           = 2, /* [17:16] */
	BFW_NX51_extsram2_ctrl_reserved3        = 6, /* [23:18] */
	BFW_NX51_extsram2_ctrl_dwidth           = 2, /* [25:24] */
	BFW_NX51_extsram2_ctrl_reserved4        = 2, /* [27:26] */
	BFW_NX51_extsram2_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
	BFW_NX51_extsram2_ctrl_no_p_post_seq_rd = 1, /* [29] */
	BFW_NX51_extsram2_ctrl_static_cs        = 1, /* [30] */
	BFW_NX51_extsram2_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX51_EXTSRAM2_CTRL_BIT_Ttag {
	unsigned int ws               : BFW_NX51_extsram2_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem2 area.                                          */
	unsigned int reserved1        : BFW_NX51_extsram2_ctrl_reserved1;        /* reserved                                                                              */
	unsigned int p_pre            : BFW_NX51_extsram2_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem2 area.                                             */
	unsigned int reserved2        : BFW_NX51_extsram2_ctrl_reserved2;        /* reserved                                                                              */
	unsigned int p_post           : BFW_NX51_extsram2_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem2 area.                                            */
	unsigned int reserved3        : BFW_NX51_extsram2_ctrl_reserved3;        /* reserved                                                                              */
	unsigned int dwidth           : BFW_NX51_extsram2_ctrl_dwidth;           /* Data bus width of ExtMem2 area.                                                       */
	                                                                         /* Note: This chip-select is disabled by default and may be shared with other functions. */
	                                                                         /*       View memory interface multiplex options for more information.                   */
	unsigned int reserved4        : BFW_NX51_extsram2_ctrl_reserved4;        /* reserved                                                                              */
	unsigned int no_p_pre_seq_rd  : BFW_NX51_extsram2_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                      */
	unsigned int no_p_post_seq_rd : BFW_NX51_extsram2_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                     */
	unsigned int static_cs        : BFW_NX51_extsram2_ctrl_static_cs;        /* Static chip-select signal generation.                                                 */
	unsigned int ready_en         : BFW_NX51_extsram2_ctrl_ready_en;         /* Ready Signal Enable.                                                                  */
} NX51_EXTSRAM2_CTRL_BIT_T;

typedef union {
	unsigned int             val;
	NX51_EXTSRAM2_CTRL_BIT_T bf;
} NX51_EXTSRAM2_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extsram3_ctrl */
/* => Control Register for external bus interface and wait-states for ExtMem1 chip-select 3 area. */
/*    For detailed register description view extsram0_ctrl register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extsram3_ctrl               0x0000000CU
#define Adr_NX51_ext_asyncmem_ctrl_extsram3_ctrl 0x101C010CU
#define Adr_NX51_hif_asyncmem_ctrl_extsram3_ctrl 0x101C020CU
#define DFLT_VAL_NX51_extsram3_ctrl              0x0303033fU

#define MSK_NX51_extsram3_ctrl_ws                       0x0000003fU
#define SRT_NX51_extsram3_ctrl_ws                       0
#define DFLT_VAL_NX51_extsram3_ctrl_ws                  0x0000003fU
#define DFLT_BF_VAL_NX51_extsram3_ctrl_ws               0x0000003fU
#define MSK_NX51_extsram3_ctrl_p_pre                    0x00000300U
#define SRT_NX51_extsram3_ctrl_p_pre                    8
#define DFLT_VAL_NX51_extsram3_ctrl_p_pre               0x00000300U
#define DFLT_BF_VAL_NX51_extsram3_ctrl_p_pre            0x00000003U
#define MSK_NX51_extsram3_ctrl_p_post                   0x00030000U
#define SRT_NX51_extsram3_ctrl_p_post                   16
#define DFLT_VAL_NX51_extsram3_ctrl_p_post              0x00030000U
#define DFLT_BF_VAL_NX51_extsram3_ctrl_p_post           0x00000003U
#define MSK_NX51_extsram3_ctrl_dwidth                   0x03000000U
#define SRT_NX51_extsram3_ctrl_dwidth                   24
#define DFLT_VAL_NX51_extsram3_ctrl_dwidth              0x03000000U
#define DFLT_BF_VAL_NX51_extsram3_ctrl_dwidth           0x00000003U
#define MSK_NX51_extsram3_ctrl_no_p_pre_seq_rd          0x10000000U
#define SRT_NX51_extsram3_ctrl_no_p_pre_seq_rd          28
#define DFLT_VAL_NX51_extsram3_ctrl_no_p_pre_seq_rd     0x00000000U
#define DFLT_BF_VAL_NX51_extsram3_ctrl_no_p_pre_seq_rd  0x00000000U
#define MSK_NX51_extsram3_ctrl_no_p_post_seq_rd         0x20000000U
#define SRT_NX51_extsram3_ctrl_no_p_post_seq_rd         29
#define DFLT_VAL_NX51_extsram3_ctrl_no_p_post_seq_rd    0x00000000U
#define DFLT_BF_VAL_NX51_extsram3_ctrl_no_p_post_seq_rd 0x00000000U
#define MSK_NX51_extsram3_ctrl_static_cs                0x40000000U
#define SRT_NX51_extsram3_ctrl_static_cs                30
#define DFLT_VAL_NX51_extsram3_ctrl_static_cs           0x00000000U
#define DFLT_BF_VAL_NX51_extsram3_ctrl_static_cs        0x00000000U
#define MSK_NX51_extsram3_ctrl_ready_en                 0x80000000U
#define SRT_NX51_extsram3_ctrl_ready_en                 31
#define DFLT_VAL_NX51_extsram3_ctrl_ready_en            0x00000000U
#define DFLT_BF_VAL_NX51_extsram3_ctrl_ready_en         0x00000000U

/* all used bits of 'NX51_extsram3_ctrl': */
#define MSK_USED_BITS_NX51_extsram3_ctrl 0xf303033fU

enum {
	BFW_NX51_extsram3_ctrl_ws               = 6, /* [5:0] */
	BFW_NX51_extsram3_ctrl_reserved1        = 2, /* [7:6] */
	BFW_NX51_extsram3_ctrl_p_pre            = 2, /* [9:8] */
	BFW_NX51_extsram3_ctrl_reserved2        = 6, /* [15:10] */
	BFW_NX51_extsram3_ctrl_p_post           = 2, /* [17:16] */
	BFW_NX51_extsram3_ctrl_reserved3        = 6, /* [23:18] */
	BFW_NX51_extsram3_ctrl_dwidth           = 2, /* [25:24] */
	BFW_NX51_extsram3_ctrl_reserved4        = 2, /* [27:26] */
	BFW_NX51_extsram3_ctrl_no_p_pre_seq_rd  = 1, /* [28] */
	BFW_NX51_extsram3_ctrl_no_p_post_seq_rd = 1, /* [29] */
	BFW_NX51_extsram3_ctrl_static_cs        = 1, /* [30] */
	BFW_NX51_extsram3_ctrl_ready_en         = 1  /* [31] */
};

typedef struct NX51_EXTSRAM3_CTRL_BIT_Ttag {
	unsigned int ws               : BFW_NX51_extsram3_ctrl_ws;               /* Wait-States (0 - 63 cycles) of ExtMem3 area.                                          */
	unsigned int reserved1        : BFW_NX51_extsram3_ctrl_reserved1;        /* reserved                                                                              */
	unsigned int p_pre            : BFW_NX51_extsram3_ctrl_p_pre;            /* Pre-Pause (0 - 3 cycles) of ExtMem3 area.                                             */
	unsigned int reserved2        : BFW_NX51_extsram3_ctrl_reserved2;        /* reserved                                                                              */
	unsigned int p_post           : BFW_NX51_extsram3_ctrl_p_post;           /* Post-Pause (0 - 3 cycles) of ExtMem3 area.                                            */
	unsigned int reserved3        : BFW_NX51_extsram3_ctrl_reserved3;        /* reserved                                                                              */
	unsigned int dwidth           : BFW_NX51_extsram3_ctrl_dwidth;           /* Data bus width of ExtMem3 area.                                                       */
	                                                                         /* Note: This chip-select is disabled by default and may be shared with other functions. */
	                                                                         /*       View memory interface multiplex options for more information.                   */
	unsigned int reserved4        : BFW_NX51_extsram3_ctrl_reserved4;        /* reserved                                                                              */
	unsigned int no_p_pre_seq_rd  : BFW_NX51_extsram3_ctrl_no_p_pre_seq_rd;  /* No Pre-Pause insertion between sequential reads.                                      */
	unsigned int no_p_post_seq_rd : BFW_NX51_extsram3_ctrl_no_p_post_seq_rd; /* No Post-Pause insertion between sequential reads.                                     */
	unsigned int static_cs        : BFW_NX51_extsram3_ctrl_static_cs;        /* Static chip-select signal generation.                                                 */
	unsigned int ready_en         : BFW_NX51_extsram3_ctrl_ready_en;         /* Ready Signal Enable.                                                                  */
} NX51_EXTSRAM3_CTRL_BIT_T;

typedef union {
	unsigned int             val;
	NX51_EXTSRAM3_CTRL_BIT_T bf;
} NX51_EXTSRAM3_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ext_cs0_apm_ctrl */
/* => Asynchronous Page Mode (APM) Control Register for ExtMem0 chip-select area. */
/*    Only ExtMem0 chip-select area supports fast Asynchronous-Page-Mode (APM) Access. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ext_cs0_apm_ctrl               0x00000010U
#define Adr_NX51_ext_asyncmem_ctrl_ext_cs0_apm_ctrl 0x101C0110U
#define Adr_NX51_hif_asyncmem_ctrl_ext_cs0_apm_ctrl 0x101C0210U
#define DFLT_VAL_NX51_ext_cs0_apm_ctrl              0x0000000fU

#define MSK_NX51_ext_cs0_apm_ctrl_ws_apm          0x0000000fU
#define SRT_NX51_ext_cs0_apm_ctrl_ws_apm          0
#define DFLT_VAL_NX51_ext_cs0_apm_ctrl_ws_apm     0x0000000fU
#define DFLT_BF_VAL_NX51_ext_cs0_apm_ctrl_ws_apm  0x0000000fU
#define MSK_NX51_ext_cs0_apm_ctrl_apm_cfg         0x00000700U
#define SRT_NX51_ext_cs0_apm_ctrl_apm_cfg         8
#define DFLT_VAL_NX51_ext_cs0_apm_ctrl_apm_cfg    0x00000000U
#define DFLT_BF_VAL_NX51_ext_cs0_apm_ctrl_apm_cfg 0x00000000U

/* all used bits of 'NX51_ext_cs0_apm_ctrl': */
#define MSK_USED_BITS_NX51_ext_cs0_apm_ctrl 0x0000070fU

enum {
	BFW_NX51_ext_cs0_apm_ctrl_ws_apm    = 4,  /* [3:0] */
	BFW_NX51_ext_cs0_apm_ctrl_reserved1 = 4,  /* [7:4] */
	BFW_NX51_ext_cs0_apm_ctrl_apm_cfg   = 3,  /* [10:8] */
	BFW_NX51_ext_cs0_apm_ctrl_reserved2 = 21  /* [31:11] */
};

typedef struct NX51_EXT_CS0_APM_CTRL_BIT_Ttag {
	unsigned int ws_apm    : BFW_NX51_ext_cs0_apm_ctrl_ws_apm;    /* APM read burst wait-states (0 - 15 cycles).                                                                        */
	                                                              /* If APM is enabled by apm_cfg-bits, first read access is done                                                       */
	                                                              /* with number of wait-states programmed in extsram0_ctrl register. Following read accesses to                        */
	                                                              /* ExtMem0 chip-select area are done with wait-states programmed here until APM-accesses are terminated.              */
	                                                              /* If netX runs internal read bursts only netX address lines will change. chip-select and nRD signals                 */
	                                                              /* will remain active low.                                                                                            */
	                                                              /* APM accesses are terminated if chip-select of ExtMem0 address area becomes inactive, if write access               */
	                                                              /* is done between read accesses or if read access is leaving APM address boundary.                                   */
	                                                              /* Note:                                                                                                              */
	                                                              /*    Chip-select remains active low after read even if no further access is currently requested by netX. Chip-select */
	                                                              /*    will become inactive, if access to another external chip-select area is requested or if external memory         */
	                                                              /*    bus is shared with SDRAM and netX SDRAM controller performs access or refresh cycles.                           */
	unsigned int reserved1 : BFW_NX51_ext_cs0_apm_ctrl_reserved1; /* reserved                                                                                                           */
	unsigned int apm_cfg   : BFW_NX51_ext_cs0_apm_ctrl_apm_cfg;   /* APM configuration.                                                                                                 */
	                                                              /* 000 : read bursts are disabled                                                                                     */
	                                                              /* 001 :  1 D-word (4 byte) address boundary for APM                                                                  */
	                                                              /* 010 :  2 D-word (8 byte) address boundary for APM                                                                  */
	                                                              /* 011 :  4 D-word (16 byte) address boundary for APM                                                                 */
	                                                              /* 100 :  8 D-word (32 byte) address boundary for APM                                                                 */
	                                                              /* 101 : 16 D-word (64 byte) address boundary for APM                                                                 */
	                                                              /* 110 : 32 D-word (128 byte) address boundary for APM                                                                */
	                                                              /* all other settings are reserved.                                                                                   */
	                                                              /* APM burst length programming is related to system address boundaries. For                                          */
	                                                              /* correct programming device data width and page size must be considdered.                                           */
	                                                              /* Examples:                                                                                                          */
	                                                              /* 8 bit device providing 4 word page: Page size is 1 D-word. Hence program '000'.                                    */
	                                                              /* 16 bit device providing 8 word page: Page size is 4 D-word. Hence program '011'.                                   */
	                                                              /* 32 bit device providing 32 word page: Page size is 32 D-word. Hence program '110'.                                 */
	                                                              /* Note:                                                                                                              */
	                                                              /*   When device page size exceeds 32 D-words (128 byte), set 'apm_cfg' bit field to '110'.                           */
	unsigned int reserved2 : BFW_NX51_ext_cs0_apm_ctrl_reserved2; /* reserved                                                                                                           */
} NX51_EXT_CS0_APM_CTRL_BIT_T;

typedef union {
	unsigned int                val;
	NX51_EXT_CS0_APM_CTRL_BIT_T bf;
} NX51_EXT_CS0_APM_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register ext_rdy_cfg */
/* => External Memory Ready Control Register. */
/*    Note: Timeout is generated if ready usage is enabled by the extsramX_ctrl registers and is not asserted to active state within 10us. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ext_rdy_cfg               0x00000020U
#define Adr_NX51_ext_asyncmem_ctrl_ext_rdy_cfg 0x101C0120U
#define Adr_NX51_hif_asyncmem_ctrl_ext_rdy_cfg 0x101C0220U
#define DFLT_VAL_NX51_ext_rdy_cfg              0x00000001U

#define MSK_NX51_ext_rdy_cfg_rdy_act_level         0x00000001U
#define SRT_NX51_ext_rdy_cfg_rdy_act_level         0
#define DFLT_VAL_NX51_ext_rdy_cfg_rdy_act_level    0x00000001U
#define DFLT_BF_VAL_NX51_ext_rdy_cfg_rdy_act_level 0x00000001U
#define MSK_NX51_ext_rdy_cfg_rdy_filter            0x00000030U
#define SRT_NX51_ext_rdy_cfg_rdy_filter            4
#define DFLT_VAL_NX51_ext_rdy_cfg_rdy_filter       0x00000000U
#define DFLT_BF_VAL_NX51_ext_rdy_cfg_rdy_filter    0x00000000U
#define MSK_NX51_ext_rdy_cfg_rdy_to_irq_en         0x00000100U
#define SRT_NX51_ext_rdy_cfg_rdy_to_irq_en         8
#define DFLT_VAL_NX51_ext_rdy_cfg_rdy_to_irq_en    0x00000000U
#define DFLT_BF_VAL_NX51_ext_rdy_cfg_rdy_to_irq_en 0x00000000U
#define MSK_NX51_ext_rdy_cfg_rdy_to_dis            0x00000800U
#define SRT_NX51_ext_rdy_cfg_rdy_to_dis            11
#define DFLT_VAL_NX51_ext_rdy_cfg_rdy_to_dis       0x00000000U
#define DFLT_BF_VAL_NX51_ext_rdy_cfg_rdy_to_dis    0x00000000U

/* all used bits of 'NX51_ext_rdy_cfg': */
#define MSK_USED_BITS_NX51_ext_rdy_cfg 0x00000931U

enum {
	BFW_NX51_ext_rdy_cfg_rdy_act_level = 1,  /* [0] */
	BFW_NX51_ext_rdy_cfg_reserved1     = 3,  /* [3:1] */
	BFW_NX51_ext_rdy_cfg_rdy_filter    = 2,  /* [5:4] */
	BFW_NX51_ext_rdy_cfg_reserved2     = 2,  /* [7:6] */
	BFW_NX51_ext_rdy_cfg_rdy_to_irq_en = 1,  /* [8] */
	BFW_NX51_ext_rdy_cfg_reserved3     = 2,  /* [10:9] */
	BFW_NX51_ext_rdy_cfg_rdy_to_dis    = 1,  /* [11] */
	BFW_NX51_ext_rdy_cfg_reserved4     = 20  /* [31:12] */
};

typedef struct NX51_EXT_RDY_CFG_BIT_Ttag {
	unsigned int rdy_act_level : BFW_NX51_ext_rdy_cfg_rdy_act_level; /* Ready Active Level                                                                                                          */
	                                                                 /* 0: Ready is active low / stall access while ready input is high.                                                            */
	                                                                 /* 1: Ready is active high / stall access while ready input is low.                                                            */
	unsigned int reserved1     : BFW_NX51_ext_rdy_cfg_reserved1;     /* reserved                                                                                                                    */
	unsigned int rdy_filter    : BFW_NX51_ext_rdy_cfg_rdy_filter;    /* Ready Input Filter.                                                                                                         */
	                                                                 /* Ready input filtering is implemented to avoid false ready active detection especially if                                    */
	                                                                 /* ready signal is not always driven and ready active state is realized by pull-up or down resistors.                          */
	                                                                 /*  00: Ready active state is detected after ready signal is sampled once in active state (no filtering).                      */
	                                                                 /*  01: Ready active state is detected after ready signal is consecutively sampled twice in active state.                      */
	                                                                 /*  10: Ready active state is detected after ready signal is consecutively sampled 3 times in active state.                    */
	                                                                 /*  11: Ready active state is detected after ready signal is consecutively sampled 4 times in active state.                    */
	                                                                 /* Note: If ready is sampled in inactive state, active state counting will restart at zero.                                    */
	                                                                 /* Note: If ready input filering is enabled, access time will be increased at least                                            */
	                                                                 /*       by filer time (ready is sampled any 10ns).                                                                            */
	unsigned int reserved2     : BFW_NX51_ext_rdy_cfg_reserved2;     /* reserved                                                                                                                    */
	unsigned int rdy_to_irq_en : BFW_NX51_ext_rdy_cfg_rdy_to_irq_en; /* Ready Timeout IRQ Enable                                                                                                    */
	                                                                 /* 0: No IRQ generation in case of ready timeout.                                                                              */
	                                                                 /* 1: generate an IRQ in case of ready timeout.                                                                                */
	                                                                 /* Note: Ready Timeout IRQ is part of netX System Status IRQ (view system_status register in area asic_ctrl and VIC registers) */
	unsigned int reserved3     : BFW_NX51_ext_rdy_cfg_reserved3;     /* reserved                                                                                                                    */
	unsigned int rdy_to_dis    : BFW_NX51_ext_rdy_cfg_rdy_to_dis;    /* Ready Timeout Disable                                                                                                       */
	                                                                 /* By default ready timeout is enabled. Timeout is generated if ready usage is enabled                                         */
	                                                                 /* by the extsramX_ctrl registers and is not asserted to active state within 10us (1024 system clocks).                        */
	                                                                 /* If an external device requires even longer response time, ready timeout can be disabled                                     */
	                                                                 /* by setting this bit. However be careful: If ready is not asserted anytime, netX system will stall. Escape                   */
	                                                                 /* from this can only be achieved by Hardware Reset (e.g. by system watchdog timeout).                                         */
	                                                                 /* 0: Ready timeout is enabled.                                                                                                */
	                                                                 /* 1: Ready timeout is disabled.                                                                                               */
	unsigned int reserved4     : BFW_NX51_ext_rdy_cfg_reserved4;     /* reserved                                                                                                                    */
} NX51_EXT_RDY_CFG_BIT_T;

typedef union {
	unsigned int           val;
	NX51_EXT_RDY_CFG_BIT_T bf;
} NX51_EXT_RDY_CFG_T;

/* --------------------------------------------------------------------- */
/* Register ext_rdy_status */
/* => External Memory Ready Status Register. */
/*    Note: Timeout is generated if ready usage is enabled by the extsramX_ctrl registers and is not asserted to active state within 10us. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_ext_rdy_status               0x00000024U
#define Adr_NX51_ext_asyncmem_ctrl_ext_rdy_status 0x101C0124U
#define Adr_NX51_hif_asyncmem_ctrl_ext_rdy_status 0x101C0224U

#define MSK_NX51_ext_rdy_status_rdy_to_err_adr 0x07ffffffU
#define SRT_NX51_ext_rdy_status_rdy_to_err_adr 0
#define MSK_NX51_ext_rdy_status_rdy_to_err_cs  0x30000000U
#define SRT_NX51_ext_rdy_status_rdy_to_err_cs  28
#define MSK_NX51_ext_rdy_status_rdy_to_err     0x80000000U
#define SRT_NX51_ext_rdy_status_rdy_to_err     31

/* all used bits of 'NX51_ext_rdy_status': */
#define MSK_USED_BITS_NX51_ext_rdy_status 0xb7ffffffU

enum {
	BFW_NX51_ext_rdy_status_rdy_to_err_adr = 27, /* [26:0] */
	BFW_NX51_ext_rdy_status_reserved1      = 1,  /* [27] */
	BFW_NX51_ext_rdy_status_rdy_to_err_cs  = 2,  /* [29:28] */
	BFW_NX51_ext_rdy_status_reserved2      = 1,  /* [30] */
	BFW_NX51_ext_rdy_status_rdy_to_err     = 1   /* [31] */
};

typedef struct NX51_EXT_RDY_STATUS_BIT_Ttag {
	unsigned int rdy_to_err_adr : BFW_NX51_ext_rdy_status_rdy_to_err_adr; /* Ready timeout error address logging.                                                                                        */
	unsigned int reserved1      : BFW_NX51_ext_rdy_status_reserved1;      /* reserved                                                                                                                    */
	unsigned int rdy_to_err_cs  : BFW_NX51_ext_rdy_status_rdy_to_err_cs;  /* Ready timeout error chip-select logging.                                                                                    */
	unsigned int reserved2      : BFW_NX51_ext_rdy_status_reserved2;      /* reserved                                                                                                                    */
	unsigned int rdy_to_err     : BFW_NX51_ext_rdy_status_rdy_to_err;     /* Ready Timeout Error.                                                                                                        */
	                                                                      /* This bit is set if a ready timeout error is detected. The external address                                                  */
	                                                                      /* and chip-select will be logged then in the lower bits of this register. An IRQ/Abort will be generated if                   */
	                                                                      /* enabled by the ext_rdy_cfg register.                                                                                        */
	                                                                      /* Writing a '1' here will reset this bit and the IRQ.                                                                         */
	                                                                      /* Note: If multiple timeouts are detected, the first timeout address and chip-select will be logged.                          */
	                                                                      /* Note: Ready Timeout IRQ is part of netX System Status IRQ (view system_status register in area asic_ctrl and VIC registers) */
} NX51_EXT_RDY_STATUS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_EXT_RDY_STATUS_BIT_T bf;
} NX51_EXT_RDY_STATUS_T;


/* ===================================================================== */

/* AREA ext_sdram_ctrl */
/* Area of ext_sdram_ctrl, hif_sdram_ctrl */

/* ===================================================================== */

#define Addr_NX51_ext_sdram_ctrl      0x101C0140U
#define NX51_NETX_MEM_SDRAM_CTRL_AREA 0x101C0140U
#define Addr_NX51_hif_sdram_ctrl      0x101C0240U

/* --------------------------------------------------------------------- */
/* Register sdram_general_ctrl */
/* => Control Register for external SDRAM access. */
/*    For initializing procedure netX SDRAM controller view description of 'ctrl_en' bit inside this register. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sdram_general_ctrl            0x00000000U
#define Adr_NX51_ext_sdram_ctrl_sdram_general_ctrl 0x101C0140U
#define Adr_NX51_hif_sdram_ctrl_sdram_general_ctrl 0x101C0240U
#define DFLT_VAL_NX51_sdram_general_ctrl           0x01000001U

#define MSK_NX51_sdram_general_ctrl_banks                  0x00000003U
#define SRT_NX51_sdram_general_ctrl_banks                  0
#define DFLT_VAL_NX51_sdram_general_ctrl_banks             0x00000001U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_banks          0x00000001U
#define MSK_NX51_sdram_general_ctrl_rows                   0x00000030U
#define SRT_NX51_sdram_general_ctrl_rows                   4
#define DFLT_VAL_NX51_sdram_general_ctrl_rows              0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_rows           0x00000000U
#define MSK_NX51_sdram_general_ctrl_columns                0x00000700U
#define SRT_NX51_sdram_general_ctrl_columns                8
#define DFLT_VAL_NX51_sdram_general_ctrl_columns           0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_columns        0x00000000U
#define MSK_NX51_sdram_general_ctrl_dbus32                 0x00010000U
#define SRT_NX51_sdram_general_ctrl_dbus32                 16
#define DFLT_VAL_NX51_sdram_general_ctrl_dbus32            0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_dbus32         0x00000000U
#define MSK_NX51_sdram_general_ctrl_sdram_pwdn             0x00020000U
#define SRT_NX51_sdram_general_ctrl_sdram_pwdn             17
#define DFLT_VAL_NX51_sdram_general_ctrl_sdram_pwdn        0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_sdram_pwdn     0x00000000U
#define MSK_NX51_sdram_general_ctrl_extclk_en              0x00040000U
#define SRT_NX51_sdram_general_ctrl_extclk_en              18
#define DFLT_VAL_NX51_sdram_general_ctrl_extclk_en         0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_extclk_en      0x00000000U
#define MSK_NX51_sdram_general_ctrl_ctrl_en                0x00080000U
#define SRT_NX51_sdram_general_ctrl_ctrl_en                19
#define DFLT_VAL_NX51_sdram_general_ctrl_ctrl_en           0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_ctrl_en        0x00000000U
#define MSK_NX51_sdram_general_ctrl_refresh_mode           0x03000000U
#define SRT_NX51_sdram_general_ctrl_refresh_mode           24
#define DFLT_VAL_NX51_sdram_general_ctrl_refresh_mode      0x01000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_refresh_mode   0x00000001U
#define MSK_NX51_sdram_general_ctrl_sdram_ready            0x40000000U
#define SRT_NX51_sdram_general_ctrl_sdram_ready            30
#define DFLT_VAL_NX51_sdram_general_ctrl_sdram_ready       0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_sdram_ready    0x00000000U
#define MSK_NX51_sdram_general_ctrl_refresh_status         0x80000000U
#define SRT_NX51_sdram_general_ctrl_refresh_status         31
#define DFLT_VAL_NX51_sdram_general_ctrl_refresh_status    0x00000000U
#define DFLT_BF_VAL_NX51_sdram_general_ctrl_refresh_status 0x00000000U

/* all used bits of 'NX51_sdram_general_ctrl': */
#define MSK_USED_BITS_NX51_sdram_general_ctrl 0xc30f0733U

enum {
	BFW_NX51_sdram_general_ctrl_banks          = 2, /* [1:0] */
	BFW_NX51_sdram_general_ctrl_reserved1      = 2, /* [3:2] */
	BFW_NX51_sdram_general_ctrl_rows           = 2, /* [5:4] */
	BFW_NX51_sdram_general_ctrl_reserved2      = 2, /* [7:6] */
	BFW_NX51_sdram_general_ctrl_columns        = 3, /* [10:8] */
	BFW_NX51_sdram_general_ctrl_reserved3      = 5, /* [15:11] */
	BFW_NX51_sdram_general_ctrl_dbus32         = 1, /* [16] */
	BFW_NX51_sdram_general_ctrl_sdram_pwdn     = 1, /* [17] */
	BFW_NX51_sdram_general_ctrl_extclk_en      = 1, /* [18] */
	BFW_NX51_sdram_general_ctrl_ctrl_en        = 1, /* [19] */
	BFW_NX51_sdram_general_ctrl_reserved4      = 4, /* [23:20] */
	BFW_NX51_sdram_general_ctrl_refresh_mode   = 2, /* [25:24] */
	BFW_NX51_sdram_general_ctrl_reserved5      = 4, /* [29:26] */
	BFW_NX51_sdram_general_ctrl_sdram_ready    = 1, /* [30] */
	BFW_NX51_sdram_general_ctrl_refresh_status = 1  /* [31] */
};

typedef struct NX51_SDRAM_GENERAL_CTRL_BIT_Ttag {
	unsigned int banks          : BFW_NX51_sdram_general_ctrl_banks;          /* Number of SDRAM device banks and address lines.                                                                   */
	                                                                          /*  00 : 2 banks, address line A14 (=BA0)                                                                            */
	                                                                          /*  01 : 4 banks, address lines A15, A14 (=BA1, BA0)(default)                                                        */
	                                                                          /* All others: reserved                                                                                              */
	unsigned int reserved1      : BFW_NX51_sdram_general_ctrl_reserved1;      /* reserved                                                                                                          */
	unsigned int rows           : BFW_NX51_sdram_general_ctrl_rows;           /* Number of SDRAM device rows and address lines.                                                                    */
	                                                                          /*   00 : 2k rows, address lines A0..A10 (default)                                                                   */
	                                                                          /*   01 : 4k rows, address lines A0..A11                                                                             */
	                                                                          /*   10 : 8k rows, address lines A0..A12                                                                             */
	                                                                          /*   11 : 16k rows, address lines A0..A13                                                                            */
	unsigned int reserved2      : BFW_NX51_sdram_general_ctrl_reserved2;      /* reserved                                                                                                          */
	unsigned int columns        : BFW_NX51_sdram_general_ctrl_columns;        /* Number of SDRAM device columns and address lines.                                                                 */
	                                                                          /*  000 : 256 columns, address lines A0..A7 (default)                                                                */
	                                                                          /*  001 : 512 columns, address lines A0..A8                                                                          */
	                                                                          /*  010 : 1k columns, address lines A0..A9                                                                           */
	                                                                          /*  011 : 2k columns, address lines A0..A9,A11                                                                       */
	                                                                          /*  100 : 4k columns, address lines A0..A9,A11,A12                                                                   */
	                                                                          /* All others: reserved                                                                                              */
	unsigned int reserved3      : BFW_NX51_sdram_general_ctrl_reserved3;      /* reserved                                                                                                          */
	unsigned int dbus32         : BFW_NX51_sdram_general_ctrl_dbus32;         /* SDRAM data bus width                                                                                              */
	                                                                          /*  0 : SDRAM data bus is 16 bit wide  (default)                                                                     */
	                                                                          /*  1 : SDRAM data bus is 32 bit wide                                                                                */
	unsigned int sdram_pwdn     : BFW_NX51_sdram_general_ctrl_sdram_pwdn;     /* SDRAM power down                                                                                                  */
	                                                                          /* If this bit is set, the controller will move SDRAM to power down self refresh mode (no data loss)                 */
	                                                                          /* and stop the external SDRAM clock. Return from power-down mode can be done by clearing this bit.                  */
	unsigned int extclk_en      : BFW_NX51_sdram_general_ctrl_extclk_en;      /* external SDRAM clock enable                                                                                       */
	                                                                          /*  0 : SDRAM clock disabled  (default)                                                                              */
	                                                                          /*  1 : SDRAM clock enabled                                                                                          */
	                                                                          /* Note:                                                                                                             */
	                                                                          /*    The external SDRAM clock will not run if the controller is disabled.                                           */
	unsigned int ctrl_en        : BFW_NX51_sdram_general_ctrl_ctrl_en;        /* Global SDRAM controller enable.                                                                                   */
	                                                                          /* Note:                                                                                                             */
	                                                                          /*    The sdram_timing_ctrl and the sdram_mr register can only be changed while this bit is 0.                       */
	                                                                          /* Initializing and enabling SDRAM should be done as follows:                                                        */
	                                                                          /* {  |                                                                                                              */
	                                                                          /*  A. Special attention must be done before enabling SDRAM after netX reset without power supply                    */
	                                                                          /*     was disabled (e.g. pressing some kind of reset button). In this case a reset could be done                    */
	                                                                          /*     while a SDRAM read burst was performed. As SDRAM clock will be disabled immediately in case                   */
	                                                                          /*     of reset external SDRAM device will keep driving data-lines. To free data lines at least 10                   */
	                                                                          /*     SDRAM clock cycles must be performed. This should be done by enabling (extclk_en-bit set and                  */
	                                                                          /*     ctrl_en-bit set) the controller and disabling again (ctrl_en-bit cleared) before really enabling              */
	                                                                          /*     SDRAM and before any other access to external memory devices sharing SDRAM data-lines (e.g.                   */
	                                                                          /*     parallel flash devices).                                                                                      */
	                                                                          /*  B. If SDRAM was already enabled: Disable SDRAM controller by setting the ctrl_en-bit to 0.                       */
	                                                                          /*     Ensure that no netX system master is trying to access SDRAM address area. Otherwise related                   */
	                                                                          /*     master will be stalled (no ready) until re-enabling SDRAM.                                                    */
	                                                                          /*  1. Configure the sdram_timing_ctrl register:                                                                     */
	                                                                          /*     All timing parameters of the t_* bit fields must be taken from SDRAM device data sheet.                       */
	                                                                          /*     All other timing parameters like clock and sample phases are provided by Hilscher.                            */
	                                                                          /*  2. Configure the sdram_mr register:                                                                              */
	                                                                          /*     Typically only setting of correct CAS-Latency is required (CL2 or CL3 supported                               */
	                                                                          /*     by netX SDRAM controller). CL2 provides better performance an should be preferred.                            */
	                                                                          /*     Please read description of the sdram_mr register for further details.                                         */
	                                                                          /*  3. Configure the sdram_general_ctrl (this) register and enable the controller by setting the 'ctrl_en' bit.      */
	                                                                          /*     The values for 'banks', 'rows' and 'columns' depend on the used SDRAM device and                              */
	                                                                          /*     must be taken from the related data sheet.                                                                    */
	                                                                          /*  4. Wait until 'sdram_ready' status bit is set before accessing SDRAM device. }                                   */
	                                                                          /* ------------------------------------                                                                              */
	                                                                          /* After enable, the controller will run the following SDRAM initialisation procedure (100MHz, 1 cycle = 10ns).      */
	                                                                          /* {                  |        |                 |                                                                   */
	                                                                          /* command             cycles   time              comment                                                            */
	                                                                          /* NOP                 20050    200.5us           running sd_clk (if extclk_en), *cs low, cke high)                  */
	                                                                          /* PRECH ALL, NOP      1+15     10ns + 150ns                                                                         */
	                                                                          /* 7x(AUTO REF, NOP)   7x(1+31) 7x(10ns + 310ns)                                                                     */
	                                                                          /* AUTO REF, NOP       1+22     10ns + 220ns                                                                         */
	                                                                          /* LOAD MREG, NOP      1+3      10ns + 30ns       with settings done by the sdram_mr registers                       */
	                                                                          /* ACTIVATE            1        10ns              first access if requested, sdram_ready will be set to 1 here }     */
	                                                                          /* ------------------------------------                                                                              */
	                                                                          /* Attention:                                                                                                        */
	                                                                          /*    Accesses requested to SDRAM address area when the controller is not enabled                                    */
	                                                                          /*    or before SDRAM initialisation procedure was finished (before sdram_ready                                      */
	                                                                          /*    bit is 1) will be blocked (no ready). This could cause system freezing.                                        */
	                                                                          /* Note:                                                                                                             */
	                                                                          /*    The external SDRAM clock will not run if the controller is disabled.                                           */
	unsigned int reserved4      : BFW_NX51_sdram_general_ctrl_reserved4;      /* reserved                                                                                                          */
	unsigned int refresh_mode   : BFW_NX51_sdram_general_ctrl_refresh_mode;   /* Refresh request generation mode.                                                                                  */
	                                                                          /* Refresh behaviour changed from netx100/500/50: SDRAM controller now has an additional high priority refresh mode. */
	                                                                          /* Refresh generation has lower priority than accesses on external memory interface normally. That means refreshes   */
	                                                                          /* do not block data access. To avoid data loss under all conditions without checking critical situations by         */
	                                                                          /* software a high priority refresh mode is implemented for netX10 and later: If there was too much traffic          */
	                                                                          /* to SDRAM to run refreshes according to programmed refresh_mode the controller changes to high                     */
	                                                                          /* priority refresh mode automatically. In this mode the controller generates immediately as many refreshes          */
	                                                                          /* as required to avoid imminent data loss. After that the controller falls back to low priority refresh             */
	                                                                          /* generation automatically.                                                                                         */
	                                                                          /* In normal low priority refresh mode refreshes can be collected. That means single refreshes are not               */
	                                                                          /* necessarily done in programmed average refresh interval (t_REFI in sdram_timing_ctrl register). However           */
	                                                                          /* the controller ensures by hardware that t_REFI is kept as mean refresh interval for a certain number              */
	                                                                          /* of subsequent refreshes. This number of refreshes that will be collected to a long term refresh sequence          */
	                                                                          /* can be programmed in this bit field.                                                                              */
	                                                                          /* The following refresh request generation mode can be programmed:                                                  */
	                                                                          /*  00 : fix interval: expect one refresh any programmed refresh period (sdram_timing_ctrl.t_REFI)                   */
	                                                                          /*  01 : collect up to 8 refreshes (default)                                                                         */
	                                                                          /*  10 : collect up to 16 refreshes                                                                                  */
	                                                                          /*  11 : collect up to 2047 refreshes                                                                                */
	                                                                          /* Note:                                                                                                             */
	                                                                          /* Typically SDRAM devices do not require a fix refresh interval. Collecting more refreshes will lead                */
	                                                                          /* to improved performance (as high priority refresh mode blocking normal access is entered more                     */
	                                                                          /* often when only few refreshes can be collected). Hence, it is recommended setting this bit field                  */
	                                                                          /* to '11' (collecting up to 2047 refreshes).                                                                        */
	                                                                          /* Note:                                                                                                             */
	                                                                          /* Entering high priority refresh mode typically occurs when SDRAM becomes system performance                        */
	                                                                          /* bottleneck. To detect this, a status bit (refresh_status) will be set when high priority                          */
	                                                                          /* refresh mode was entered. It can be used for debugging or system status information purpose.                      */
	unsigned int reserved5      : BFW_NX51_sdram_general_ctrl_reserved5;      /* reserved                                                                                                          */
	unsigned int sdram_ready    : BFW_NX51_sdram_general_ctrl_sdram_ready;    /* SDRAM ready.                                                                                                      */
	                                                                          /* This bit is set to 1 if SDRAM is ready for access. If sdram_general_ctrl.ctrl_en == 0 or                          */
	                                                                          /* sdram_general_ctrl.sdram_pwdn == 0 sdram_ready will be low. It will be set to 1 after                             */
	                                                                          /* SDRAM has been initialized or after power down wake up.                                                           */
	                                                                          /* Note: This bit is a read only status flag.                                                                        */
	unsigned int refresh_status : BFW_NX51_sdram_general_ctrl_refresh_status; /* Refresh status flag.                                                                                              */
	                                                                          /* Refresh behaviour changed from netx100/500/50: SDRAM controller now has an additional high                        */
	                                                                          /* priority refresh mode (view refresh_mode bit description).                                                        */
	                                                                          /* There is no need to guarantee sufficient SDRAM refresh generation by checking this bit by                         */
	                                                                          /* software any longer (necessary for netx100/500/50 depending on application). It is only for                       */
	                                                                          /* information purpose for netX10 or later.                                                                          */
	                                                                          /* This bit can be reset by writing '0' to it.                                                                       */
	                                                                          /* Note: This bit is writable but can also be changed by hardware.                                                   */
} NX51_SDRAM_GENERAL_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_SDRAM_GENERAL_CTRL_BIT_T bf;
} NX51_SDRAM_GENERAL_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register sdram_timing_ctrl */
/* => Control Register for external SDRAM access. */
/*    Changes can only be done, if the SDRAM controller is disabled (sdram_general_ctrl.ctrl_en == 0) */
/*    to avoid configuration problems. */
/*    Please view description of 'ctrl_en' bit inside sdram_general_ctrl register for initializing-procedure of netX SDRAM controller. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sdram_timing_ctrl            0x00000004U
#define Adr_NX51_ext_sdram_ctrl_sdram_timing_ctrl 0x101C0144U
#define Adr_NX51_hif_sdram_ctrl_sdram_timing_ctrl 0x101C0244U
#define DFLT_VAL_NX51_sdram_timing_ctrl           0x0381f7f3U

#define MSK_NX51_sdram_timing_ctrl_t_RCD                     0x00000003U
#define SRT_NX51_sdram_timing_ctrl_t_RCD                     0
#define DFLT_VAL_NX51_sdram_timing_ctrl_t_RCD                0x00000003U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_t_RCD             0x00000003U
#define MSK_NX51_sdram_timing_ctrl_t_WR                      0x00000030U
#define SRT_NX51_sdram_timing_ctrl_t_WR                      4
#define DFLT_VAL_NX51_sdram_timing_ctrl_t_WR                 0x00000030U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_t_WR              0x00000003U
#define MSK_NX51_sdram_timing_ctrl_t_RP                      0x000000c0U
#define SRT_NX51_sdram_timing_ctrl_t_RP                      6
#define DFLT_VAL_NX51_sdram_timing_ctrl_t_RP                 0x000000c0U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_t_RP              0x00000003U
#define MSK_NX51_sdram_timing_ctrl_t_RAS                     0x00000700U
#define SRT_NX51_sdram_timing_ctrl_t_RAS                     8
#define DFLT_VAL_NX51_sdram_timing_ctrl_t_RAS                0x00000700U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_t_RAS             0x00000007U
#define MSK_NX51_sdram_timing_ctrl_t_RFC                     0x0000f000U
#define SRT_NX51_sdram_timing_ctrl_t_RFC                     12
#define DFLT_VAL_NX51_sdram_timing_ctrl_t_RFC                0x0000f000U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_t_RFC             0x0000000fU
#define MSK_NX51_sdram_timing_ctrl_t_REFI                    0x00030000U
#define SRT_NX51_sdram_timing_ctrl_t_REFI                    16
#define DFLT_VAL_NX51_sdram_timing_ctrl_t_REFI               0x00010000U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_t_REFI            0x00000001U
#define MSK_NX51_sdram_timing_ctrl_mem_sdclk_phase           0x00700000U
#define SRT_NX51_sdram_timing_ctrl_mem_sdclk_phase           20
#define DFLT_VAL_NX51_sdram_timing_ctrl_mem_sdclk_phase      0x00000000U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_mem_sdclk_phase   0x00000000U
#define MSK_NX51_sdram_timing_ctrl_mem_sdclk_ssneg           0x00800000U
#define SRT_NX51_sdram_timing_ctrl_mem_sdclk_ssneg           23
#define DFLT_VAL_NX51_sdram_timing_ctrl_mem_sdclk_ssneg      0x00800000U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_mem_sdclk_ssneg   0x00000001U
#define MSK_NX51_sdram_timing_ctrl_data_sample_phase         0x07000000U
#define SRT_NX51_sdram_timing_ctrl_data_sample_phase         24
#define DFLT_VAL_NX51_sdram_timing_ctrl_data_sample_phase    0x03000000U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_data_sample_phase 0x00000003U
#define MSK_NX51_sdram_timing_ctrl_bypass_neg_delay          0x10000000U
#define SRT_NX51_sdram_timing_ctrl_bypass_neg_delay          28
#define DFLT_VAL_NX51_sdram_timing_ctrl_bypass_neg_delay     0x00000000U
#define DFLT_BF_VAL_NX51_sdram_timing_ctrl_bypass_neg_delay  0x00000000U

/* all used bits of 'NX51_sdram_timing_ctrl': */
#define MSK_USED_BITS_NX51_sdram_timing_ctrl 0x17f3f7f3U

enum {
	BFW_NX51_sdram_timing_ctrl_t_RCD             = 2, /* [1:0] */
	BFW_NX51_sdram_timing_ctrl_reserved1         = 2, /* [3:2] */
	BFW_NX51_sdram_timing_ctrl_t_WR              = 2, /* [5:4] */
	BFW_NX51_sdram_timing_ctrl_t_RP              = 2, /* [7:6] */
	BFW_NX51_sdram_timing_ctrl_t_RAS             = 3, /* [10:8] */
	BFW_NX51_sdram_timing_ctrl_reserved2         = 1, /* [11] */
	BFW_NX51_sdram_timing_ctrl_t_RFC             = 4, /* [15:12] */
	BFW_NX51_sdram_timing_ctrl_t_REFI            = 2, /* [17:16] */
	BFW_NX51_sdram_timing_ctrl_reserved3         = 2, /* [19:18] */
	BFW_NX51_sdram_timing_ctrl_mem_sdclk_phase   = 3, /* [22:20] */
	BFW_NX51_sdram_timing_ctrl_mem_sdclk_ssneg   = 1, /* [23] */
	BFW_NX51_sdram_timing_ctrl_data_sample_phase = 3, /* [26:24] */
	BFW_NX51_sdram_timing_ctrl_reserved4         = 1, /* [27] */
	BFW_NX51_sdram_timing_ctrl_bypass_neg_delay  = 1, /* [28] */
	BFW_NX51_sdram_timing_ctrl_reserved5         = 3  /* [31:29] */
};

typedef struct NX51_SDRAM_TIMING_CTRL_BIT_Ttag {
	unsigned int t_RCD             : BFW_NX51_sdram_timing_ctrl_t_RCD;             /* ACTIVE to READ or WRITE time (RAS to CAS, clk = t_RCD)                                                                                          */
	                                                                               /* This value will be also taken as t_RRD (ACTIVE bank A to ACTIVE bank B time)                                                                    */
	                                                                               /*  00 : 1 clk                                                                                                                                     */
	                                                                               /*  01 : 2 clks                                                                                                                                    */
	                                                                               /*  10 : 3 clks (default)                                                                                                                          */
	                                                                               /*  11 : reserved                                                                                                                                  */
	unsigned int reserved1         : BFW_NX51_sdram_timing_ctrl_reserved1;         /* reserved                                                                                                                                        */
	unsigned int t_WR              : BFW_NX51_sdram_timing_ctrl_t_WR;              /* Write recovery time (last write data to PRECHARGE)                                                                                              */
	                                                                               /*  00 : 1 clk                                                                                                                                     */
	                                                                               /*  01 : 2 clks                                                                                                                                    */
	                                                                               /*  10 : 3 clks (default)                                                                                                                          */
	                                                                               /*  11 : reserved                                                                                                                                  */
	unsigned int t_RP              : BFW_NX51_sdram_timing_ctrl_t_RP;              /* Precharge command period time (PRECHARGE to next command)                                                                                       */
	                                                                               /*  00 : 1 clk                                                                                                                                     */
	                                                                               /*  01 : 2 clks                                                                                                                                    */
	                                                                               /*  10 : 3 clks (default)                                                                                                                          */
	                                                                               /*  11 : reserved                                                                                                                                  */
	                                                                               /* Note:                                                                                                                                           */
	                                                                               /* For Active-to-Active-command-period (t_RC) view note at t_RAS.                                                                                  */
	unsigned int t_RAS             : BFW_NX51_sdram_timing_ctrl_t_RAS;             /* ACTIVE to PRECHARGE command time (clk = t_RAS + 3)                                                                                              */
	                                                                               /*  000 :  3 clks                                                                                                                                  */
	                                                                               /*  001 :  4 clks                                                                                                                                  */
	                                                                               /*  and so on                                                                                                                                      */
	                                                                               /*  111 : 10 clks (default)                                                                                                                        */
	                                                                               /* Note:                                                                                                                                           */
	                                                                               /* If Active-to-Active-command-period (t_RC) exceeds t_RAS+t_RP, set t_RAS and t_RP                                                                */
	                                                                               /* in a way that the following condition is met: t_RAS+t_RP>=t_RC.                                                                                 */
	unsigned int reserved2         : BFW_NX51_sdram_timing_ctrl_reserved2;         /* reserved                                                                                                                                        */
	unsigned int t_RFC             : BFW_NX51_sdram_timing_ctrl_t_RFC;             /* REFRESH to next command time (clk = tRFC + 4)                                                                                                   */
	                                                                               /*  0000 :  4 clks                                                                                                                                 */
	                                                                               /*  0001 :  5 clks                                                                                                                                 */
	                                                                               /*  and so on                                                                                                                                      */
	                                                                               /*  1111 :  19 clks (default)                                                                                                                      */
	unsigned int t_REFI            : BFW_NX51_sdram_timing_ctrl_t_REFI;            /* Average periodic refresh interval (3.90 us * 2^t_REFI                                                                                           */
	                                                                               /*  00 :   3.90 us                                                                                                                                 */
	                                                                               /*  01 :   7.80 us (default)                                                                                                                       */
	                                                                               /*  10 :  15.60 us                                                                                                                                 */
	                                                                               /*  11 :  31.20 us                                                                                                                                 */
	                                                                               /* Note:                                                                                                                                           */
	                                                                               /* Typically refresh of SDRAM devices is specified by a certain number of refreshes that must be                                                   */
	                                                                               /* performed within a certain time. E.g. 8192 refreshes for 64ms. Dividing the time by the                                                         */
	                                                                               /* number of refreshes leads to the average periodic refresh interval. E.g. 64ms/8192 = 7.8us.                                                     */
	                                                                               /* Please view also description of 'refresh_mode' of 'sdram_general_ctrl' register for details.                                                    */
	unsigned int reserved3         : BFW_NX51_sdram_timing_ctrl_reserved3;         /* reserved                                                                                                                                        */
	unsigned int mem_sdclk_phase   : BFW_NX51_sdram_timing_ctrl_mem_sdclk_phase;   /* MEM_SDCLK phase shift.                                                                                                                          */
	                                                                               /* 0..5: adjustable phase-shift for external SDRAM clock depending on external capacitive                                                          */
	                                                                               /* load on MEM_SDCLK-signal to match SDRAM signals setup times. The phase can be shifted in 1.25ns steps.                                          */
	                                                                               /* MEM_SDCLK will internally rise at the mem_sdclk_phase+2nd clk400 edge after internal changes of                                                 */
	                                                                               /* SDRAM signals (MEM_SD*-signals, MI address and data buses driven by clk_memsig), where the 1st egde is defined by the                           */
	                                                                               /* mem_sdclk_ssneg-bit.                                                                                                                            */
	                                                                               /* For correct settings delays depending on external capacitive load have to be respected.                                                         */
	unsigned int mem_sdclk_ssneg   : BFW_NX51_sdram_timing_ctrl_mem_sdclk_ssneg;   /* MEM_SDCLK start sample with negative clk400 edge for MEM_SDCLK phase shift                                                                      */
	                                                                               /* 1: clk_memsig will be sampled for MEM_SDCLK-generation internally first on negedge of clk400                                                    */
	                                                                               /* 0: clk_memsig will be sampled for MEM_SDCLK-generation internally first on posedge of clk400. Evaluation purpose only - don't use this setting! */
	unsigned int data_sample_phase : BFW_NX51_sdram_timing_ctrl_data_sample_phase; /* Data sample clock phase shift.                                                                                                                  */
	                                                                               /* 0..5: adjustable phase-shift for data sampling SDRAM loopback clock (clk_sdloopback)                                                            */
	                                                                               /* depending on external capacitive load and SDRAM access time (t_AC). The phase can be shifted in 1.25ns steps.                                   */
	                                                                               /* clk_sdloopback will internally rise (sample SDRAM read data) at the data_sample_phase+4th clk400 edge                                           */
	                                                                               /* after rise of external MEM_SDCLK (including external capacitive load).                                                                          */
	                                                                               /* For correct settings, the delays depending on external capacitive have to be respected.                                                         */
	                                                                               /* Data sampling has to be done at least 8ns after internal changes of SDRAM ctrl-signals (MEM_SD*-signals,                                        */
	                                                                               /* driven by clk_memsig).                                                                                                                          */
	unsigned int reserved4         : BFW_NX51_sdram_timing_ctrl_reserved4;         /* reserved                                                                                                                                        */
	unsigned int bypass_neg_delay  : BFW_NX51_sdram_timing_ctrl_bypass_neg_delay;  /* Bypass data sample clock phase shift.                                                                                                           */
	                                                                               /*  0: use phase shifted (negative delayed) SDRAM loopback clock for data sampling.                                                                */
	                                                                               /*  1: bypass phase shift logic for SDRAM data sampling. Use SDRAM loopback clock for data sampling.                                               */
	                                                                               /* Bypass must be used for system clock frequencies <= 80MHz (rate_mull_add <= 0xC0).                                                              */
	                                                                               /* If this bit is programmed with '0' by software but system clock frequency is below                                                              */
	                                                                               /* 80MHz, it will be changed to '1' to enable bypass automatically. When system                                                                    */
	                                                                               /* frequency is changed to a rate more than 80MHz, the bit is released to '0' again.                                                               */
	                                                                               /* This allows entering netX power save mode entry and leave without reconfiguring                                                                 */
	                                                                               /* this bit by software. However take care that no SDRAM access is running                                                                         */
	                                                                               /* at the moment of system clock frequency change around the 80MHz border.                                                                         */
	                                                                               /* Note: The bit will always remain '1' if it is programmed high.                                                                                  */
	                                                                               /* Note: This bit is writable but can also be changed by hardware.                                                                                 */
	unsigned int reserved5         : BFW_NX51_sdram_timing_ctrl_reserved5;         /* reserved                                                                                                                                        */
} NX51_SDRAM_TIMING_CTRL_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_SDRAM_TIMING_CTRL_BIT_T bf;
} NX51_SDRAM_TIMING_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register sdram_mr */
/* => Mode Register for SDRAM device. */
/*    Changes can only be done, if the SDRAM controller is disabled (sdram_general_ctrl.ctrl_en == 0) */
/*    to avoid configuration problems. */
/*    The SDRAM Mode Registers of the used SDRAM device will be set after enabling the SDRAM controller in the 200us */
/*    SDRAM memory initialisation procedure. It is part of the SDRAM device and programmed by the LOAD MODE REGISTER command. */
/*    For details of SDRAM Mode Register view datasheet of used SDRAM device. */
/*    Please view description of 'ctrl_en' bit inside sdram_general_ctrl register for initializing-procedure of netX SDRAM controller. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sdram_mr            0x00000008U
#define Adr_NX51_ext_sdram_ctrl_sdram_mr 0x101C0148U
#define Adr_NX51_hif_sdram_ctrl_sdram_mr 0x101C0248U
#define DFLT_VAL_NX51_sdram_mr           0x00000033U

#define MSK_NX51_sdram_mr_MR         0x00003fffU
#define SRT_NX51_sdram_mr_MR         0
#define DFLT_VAL_NX51_sdram_mr_MR    0x00000033U
#define DFLT_BF_VAL_NX51_sdram_mr_MR 0x00000033U

/* all used bits of 'NX51_sdram_mr': */
#define MSK_USED_BITS_NX51_sdram_mr 0x00003fffU

enum {
	BFW_NX51_sdram_mr_MR        = 14, /* [13:0] */
	BFW_NX51_sdram_mr_reserved1 = 18  /* [31:14] */
};

typedef struct NX51_SDRAM_MR_BIT_Ttag {
	unsigned int MR        : BFW_NX51_sdram_mr_MR;        /* SDRAM Mode Register.                                                                                       */
	                                                      /* CAS latency bits are typically located in MR[6:4]. Only CL2 and CL3 are supported, not CL1; default is CL3 */
	                                                      /* Burst Length in MR[2:0] is read only here. Burst length                                                    */
	                                                      /* depends on data bus width programmed in sdram_general_ctrl.dbus16 register bit                             */
	                                                      /* The netX10 controller supports only Burst Length 8 (default) for 8bit SDRAM interface and 4 for            */
	                                                      /* 16bit SDRAM interface.                                                                                     */
	                                                      /* Note:                                                                                                      */
	                                                      /*    SDRAM devices where burst length is not located in Mode Register bits MR[2:0] are not                   */
	                                                      /*    supported by netX SDRAM controller. However these devices are not common.                               */
	                                                      /* Note: This bit is writable but can also be changed by hardware.                                            */
	unsigned int reserved1 : BFW_NX51_sdram_mr_reserved1; /* reserved                                                                                                   */
} NX51_SDRAM_MR_BIT_T;

typedef union {
	unsigned int        val;
	NX51_SDRAM_MR_BIT_T bf;
} NX51_SDRAM_MR_T;


/* ===================================================================== */

/* Area of extmem_priority_ctrl */

/* ===================================================================== */

#define Addr_NX51_extmem_priority_ctrl 0x101C0180U
#define NX51_NETX_MEM_PRIO_CTRL_AREA   0x101C0180U

/* --------------------------------------------------------------------- */
/* Register extmem_prio_timslot_ctrl */
/* =>  Memory interface master timeslot priority control register. */
/*     This register may be partially locked by the exmem_priority_lock-register in asic_ctrl-address area. */
/*     Note: */
/*     Any master can access in one timeslot ((ts_accessrate_mX*ts_length_mX)/64) + 1 times (i.e. at */
/*     maximum (ts_accessrate_mX)/64 bandwidth on external memory bus, ts_accessrate_mX is programmed */
/*     by extmem_prio_accesstime_ctrl-register). */
/*     Priority control will watch data accesses on external memory data bus (SDRAM and non SDRAM), */
/*     including pauses on non SDRAM-accesses, not including control commands to SDRAM. */
/*     Any master requesting more accesses will be forced to wait for the remaining timeslot. */
/*    -------------------------------------------------------- */
/*     Programmable timeslots are: */
/*        ts_length =  0 :             64 systen clock cycles (i.e  0.64us at 100MHz) */
/*        ts_length =  1 :            128 systen clock cycles (i.e  1.28us at 100MHz) */
/*        ts_length =  2 :            256 systen clock cycles (i.e  2.56us at 100MHz) */
/*        ts_length =  3 :            512 systen clock cycles (i.e  5.12us at 100MHz) */
/*        ts_length =  4 :           1024 systen clock cycles (i.e 10.24us at 100MHz) */
/*        ts_length =  5 :           2048 systen clock cycles (i.e 20.48us at 100MHz) */
/*        ts_length =  6 :           4096 systen clock cycles (i.e 40.96us at 100MHz) */
/*        ts_length =  7 :           8192 systen clock cycles (i.e 81.92us at 100MHz) */
/*    -------------------------------------------------------- */
/*     For netX51 only SDRAM accesses are regarded for timeslot priority, SRAM/FLASH accesses are not. */
/*     Master numbering here is not identical with global system master numbering as external memory is */
/*     not available for all masters (not available for DPM, XC data and system channel and ARM TCM channels) */
/*     Master channel m0: xPIC data channel  (highest priority) */
/*     Master channel m1: xPIC instruction channel */
/*     Master channel m2: ARM AHB channel - data access */
/*     Master channel m3: ARM AHB channel - instruction fetch */
/*     Master channel m4: Shared channel for OSAC, SYSDEBUG and System DMA (lowest priority) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extmem_prio_timslot_ctrl                  0x00000000U
#define Adr_NX51_extmem_priority_ctrl_extmem_prio_timslot_ctrl 0x101C0180U
#define Adr_NX51_extmem_prio_timslot_ctrl                      0x101C0180U
#define DFLT_VAL_NX51_extmem_prio_timslot_ctrl                 0x00077777U

#define MSK_NX51_extmem_prio_timslot_ctrl_ts_length_xpicd_mi          0x00000007U
#define SRT_NX51_extmem_prio_timslot_ctrl_ts_length_xpicd_mi          0
#define DFLT_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_xpicd_mi     0x00000007U
#define DFLT_BF_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_xpicd_mi  0x00000007U
#define MSK_NX51_extmem_prio_timslot_ctrl_ts_length_xpici_mi          0x00000070U
#define SRT_NX51_extmem_prio_timslot_ctrl_ts_length_xpici_mi          4
#define DFLT_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_xpici_mi     0x00000070U
#define DFLT_BF_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_xpici_mi  0x00000007U
#define MSK_NX51_extmem_prio_timslot_ctrl_ts_length_armd_mi           0x00000700U
#define SRT_NX51_extmem_prio_timslot_ctrl_ts_length_armd_mi           8
#define DFLT_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_armd_mi      0x00000700U
#define DFLT_BF_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_armd_mi   0x00000007U
#define MSK_NX51_extmem_prio_timslot_ctrl_ts_length_armi_mi           0x00007000U
#define SRT_NX51_extmem_prio_timslot_ctrl_ts_length_armi_mi           12
#define DFLT_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_armi_mi      0x00007000U
#define DFLT_BF_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_armi_mi   0x00000007U
#define MSK_NX51_extmem_prio_timslot_ctrl_ts_length_shared_mi         0x00070000U
#define SRT_NX51_extmem_prio_timslot_ctrl_ts_length_shared_mi         16
#define DFLT_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_shared_mi    0x00070000U
#define DFLT_BF_VAL_NX51_extmem_prio_timslot_ctrl_ts_length_shared_mi 0x00000007U

/* all used bits of 'NX51_extmem_prio_timslot_ctrl': */
#define MSK_USED_BITS_NX51_extmem_prio_timslot_ctrl 0x00077777U

enum {
	BFW_NX51_extmem_prio_timslot_ctrl_ts_length_xpicd_mi  = 3,  /* [2:0] */
	BFW_NX51_extmem_prio_timslot_ctrl_reserved1           = 1,  /* [3] */
	BFW_NX51_extmem_prio_timslot_ctrl_ts_length_xpici_mi  = 3,  /* [6:4] */
	BFW_NX51_extmem_prio_timslot_ctrl_reserved2           = 1,  /* [7] */
	BFW_NX51_extmem_prio_timslot_ctrl_ts_length_armd_mi   = 3,  /* [10:8] */
	BFW_NX51_extmem_prio_timslot_ctrl_reserved3           = 1,  /* [11] */
	BFW_NX51_extmem_prio_timslot_ctrl_ts_length_armi_mi   = 3,  /* [14:12] */
	BFW_NX51_extmem_prio_timslot_ctrl_reserved4           = 1,  /* [15] */
	BFW_NX51_extmem_prio_timslot_ctrl_ts_length_shared_mi = 3,  /* [18:16] */
	BFW_NX51_extmem_prio_timslot_ctrl_reserved5           = 13  /* [31:19] */
};

typedef struct NX51_EXTMEM_PRIO_TIMSLOT_CTRL_BIT_Ttag {
	unsigned int ts_length_xpicd_mi  : BFW_NX51_extmem_prio_timslot_ctrl_ts_length_xpicd_mi;  /* 0..7: the timeslot of master m0 is on external memory interface 64*2^ts_length_xpicd_mi systen clock cycles  */
	unsigned int reserved1           : BFW_NX51_extmem_prio_timslot_ctrl_reserved1;           /* reserved                                                                                                     */
	unsigned int ts_length_xpici_mi  : BFW_NX51_extmem_prio_timslot_ctrl_ts_length_xpici_mi;  /* 0..7: the timeslot of master m1 is on external memory interface 64*2^ts_length_xpici_mi systen clock cycles  */
	unsigned int reserved2           : BFW_NX51_extmem_prio_timslot_ctrl_reserved2;           /* reserved                                                                                                     */
	unsigned int ts_length_armd_mi   : BFW_NX51_extmem_prio_timslot_ctrl_ts_length_armd_mi;   /* 0..7: the timeslot of master m2 is on external memory interface 64*2^ts_length_armd_mi systen clock cycles   */
	unsigned int reserved3           : BFW_NX51_extmem_prio_timslot_ctrl_reserved3;           /* reserved                                                                                                     */
	unsigned int ts_length_armi_mi   : BFW_NX51_extmem_prio_timslot_ctrl_ts_length_armi_mi;   /* 0..7: the timeslot of master m3 is on external memory interface 64*2^ts_length_armi_mi systen clock cycles   */
	unsigned int reserved4           : BFW_NX51_extmem_prio_timslot_ctrl_reserved4;           /* reserved                                                                                                     */
	unsigned int ts_length_shared_mi : BFW_NX51_extmem_prio_timslot_ctrl_ts_length_shared_mi; /* 0..7: the timeslot of master m4 is on external memory interface 64*2^ts_length_shared_mi systen clock cycles */
	unsigned int reserved5           : BFW_NX51_extmem_prio_timslot_ctrl_reserved5;           /* reserved                                                                                                     */
} NX51_EXTMEM_PRIO_TIMSLOT_CTRL_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_EXTMEM_PRIO_TIMSLOT_CTRL_BIT_T bf;
} NX51_EXTMEM_PRIO_TIMSLOT_CTRL_T;

/* --------------------------------------------------------------------- */
/* Register extmem_prio_accesstime_ctrl */
/* =>  Control Register for master channel accesses per timeslot on external meory interface. */
/*     This register may be partially locked by the exmem_priority_lock-register in asic_ctrl-address area. */
/*     For detailed priority controlling read note at extmem_prio_timslot_ctrl-register description. */
/*    -------------------------------------------------------- */
/*     For netX51 only SDRAM accesses are regarded for timeslot priority, SRAM/FLASH accesses are not. */
/*     Master numbering here is not identical with global system master numbering as external memory is */
/*     not available for all masters (not available for DPM, XC data and system channel and ARM TCM channels) */
/*     Master channel m0: xPIC data channel  (highest priority) */
/*     Master channel m1: xPIC instruction channel */
/*     Master channel m2: ARM AHB channel - data access */
/*     Master channel m3: ARM AHB channel - instruction fetch */
/*     Master channel m4: Shared channel for OSAC, SYSDEBUG and System DMA (lowest priority) */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extmem_prio_accesstime_ctrl                  0x00000004U
#define Adr_NX51_extmem_priority_ctrl_extmem_prio_accesstime_ctrl 0x101C0184U
#define Adr_NX51_extmem_prio_accesstime_ctrl                      0x101C0184U
#define DFLT_VAL_NX51_extmem_prio_accesstime_ctrl                 0x3fffffffU

#define MSK_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpicd_mi          0x0000003fU
#define SRT_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpicd_mi          0
#define DFLT_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpicd_mi     0x0000003fU
#define DFLT_BF_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpicd_mi  0x0000003fU
#define MSK_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpici_mi          0x00000fc0U
#define SRT_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpici_mi          6
#define DFLT_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpici_mi     0x00000fc0U
#define DFLT_BF_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpici_mi  0x0000003fU
#define MSK_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armd_mi           0x0003f000U
#define SRT_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armd_mi           12
#define DFLT_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armd_mi      0x0003f000U
#define DFLT_BF_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armd_mi   0x0000003fU
#define MSK_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armi_mi           0x00fc0000U
#define SRT_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armi_mi           18
#define DFLT_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armi_mi      0x00fc0000U
#define DFLT_BF_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armi_mi   0x0000003fU
#define MSK_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi         0x3f000000U
#define SRT_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi         24
#define DFLT_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi    0x3f000000U
#define DFLT_BF_VAL_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi 0x0000003fU

/* all used bits of 'NX51_extmem_prio_accesstime_ctrl': */
#define MSK_USED_BITS_NX51_extmem_prio_accesstime_ctrl 0x3fffffffU

enum {
	BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpicd_mi  = 6, /* [5:0] */
	BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpici_mi  = 6, /* [11:6] */
	BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armd_mi   = 6, /* [17:12] */
	BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armi_mi   = 6, /* [23:18] */
	BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi = 6, /* [29:24] */
	BFW_NX51_extmem_prio_accesstime_ctrl_reserved1               = 2  /* [31:30] */
};

typedef struct NX51_EXTMEM_PRIO_ACCESSTIME_CTRL_BIT_Ttag {
	unsigned int ts_accessrate_xpicd_mi  : BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpicd_mi;  /* 0..63: master m0 is alowed to request ((ts_accessrate_xpicd_mi*ts_length_xpicd_mi)/64) + 1 accesses on external memory   */
	unsigned int ts_accessrate_xpici_mi  : BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_xpici_mi;  /* 0..63: master m1 is alowed to request ((ts_accessrate_xpici_mi*ts_length_xpici_mi)/64) + 1 accesses on external memory   */
	unsigned int ts_accessrate_armd_mi   : BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armd_mi;   /* 0..63: master m2 is alowed to request ((ts_accessrate_armd_mi*ts_length_armd_mi)/64) + 1 accesses on external memory     */
	unsigned int ts_accessrate_armi_mi   : BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_armi_mi;   /* 0..63: master m3 is alowed to request ((ts_accessrate_armi_mi*ts_length_armi_mi)/64) + 1 accesses on external memory     */
	unsigned int ts_accessrate_shared_mi : BFW_NX51_extmem_prio_accesstime_ctrl_ts_accessrate_shared_mi; /* 0..63: master m4 is alowed to request ((ts_accessrate_shared_mi*ts_length_shared_mi)/64) + 1 accesses on external memory */
	unsigned int reserved1               : BFW_NX51_extmem_prio_accesstime_ctrl_reserved1;               /* reserved                                                                                                                 */
} NX51_EXTMEM_PRIO_ACCESSTIME_CTRL_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_EXTMEM_PRIO_ACCESSTIME_CTRL_BIT_T bf;
} NX51_EXTMEM_PRIO_ACCESSTIME_CTRL_T;


/* ===================================================================== */

/* Area of extmem_pio_ctrl */

/* ===================================================================== */

#define Addr_NX51_extmem_pio_ctrl 0x101C01C0U

/* --------------------------------------------------------------------- */
/* Register extmem_pio_ctrl_mem_d_pio_oe_set_clear */
/* => PIO mode output-enable set and clear register for MEM_D_31..16 IOs. */
/*    Output enables can be set or cleared by writing ones to the appropriate bit-field. PIO */
/*    function can be shared easily by different tasks or CPUs that way. */
/*    Reading this register will return the current PIO driving state in both bit fields. */
/*    ------------------------------------------------------------------------ */
/*    Attention: */
/*       Hardware could be damaged when any CS-area of MEM-interface is in 32bit mode and PIO mode is enabled! */
/*       ------------------------------------------------------------------------ */
/*       Before using MEM_D31..16 as PIOs, this must be enabled inside ASIC_CTRL.io_config first. Be careful */
/*       doing this: PIO settings will have higher priority on MEM-Interface when PIO mode is enabled inside */
/*       'io_config' and SDRAM or any Extmem CS-area is in 32bit mode (i.e. using MEM_D32..16 at the same */
/*       time for memory access). */
/*       Only upper 16 data MEM_D_31..16 lines can be used as PIOs. Hence it is allowed to configure SDRAM and */
/*       Extmem of MEM-Interface  in a way where MEM_D31 to 16 are not used: i.e. SDRAM can be disabled or in 16 bit */
/*       mode (ext_sdram_ctrl.sdram_general_ctrl) and Extmem CS areas can be disabled, in 8bit or in 16bit */
/*       mode (ext_asyncmem_ctrl.extsram0_ctrl to extsram3_ctrl). However all 32bit modes are forbidden. */
/*       HIF-memory interface is not effected by all this. */
/*    ------------------------------------------------------------------------ */
/*    Note: */
/*       If 'set' and 'clear' is programmed to '1' for the same IO in a single access, clear will win. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear             0x00000000U
#define Adr_NX51_extmem_pio_ctrl_extmem_pio_ctrl_mem_d_pio_oe_set_clear 0x101C01C0U
#define Adr_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear                 0x101C01C0U
#define DFLT_VAL_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear            0x00000000U

#define MSK_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_set           0x0000ffffU
#define SRT_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_set           0
#define DFLT_VAL_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_set      0x00000000U
#define DFLT_BF_VAL_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_set   0x00000000U
#define MSK_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_clear         0xffff0000U
#define SRT_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_clear         16
#define DFLT_VAL_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_clear    0x00000000U
#define DFLT_BF_VAL_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_clear 0x00000000U

/* all used bits of 'NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear': */
#define MSK_USED_BITS_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear 0xffffffffU

enum {
	BFW_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_set   = 16, /* [15:0] */
	BFW_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_clear = 16  /* [31:16] */
};

typedef struct NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OE_SET_CLEAR_BIT_Ttag {
	unsigned int set   : BFW_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_set;   /* Enable PIO output driving of related MEM_D31..16 signal by writing a 1 here.  */
	unsigned int clear : BFW_NX51_extmem_pio_ctrl_mem_d_pio_oe_set_clear_clear; /* Disable PIO output driving of related MEM_D31..16 signal by writing a 1 here. */
} NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OE_SET_CLEAR_BIT_T;

typedef union {
	unsigned int                                      val;
	NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OE_SET_CLEAR_BIT_T bf;
} NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OE_SET_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register extmem_pio_ctrl_mem_d_pio_out_set_clear */
/* => PIO mode output-level set and clear register for MEM_D_31..16 IOs. */
/*    View attention-note of 'extmem_pio_ctrl_mem_d_pio_oe_set_clear' register. */
/*    Output levels can be set or cleared by writing ones to the appropriate bit-field. PIO */
/*    function can be shared easily by different tasks or CPUs that way. */
/*    Reading this register will return the current PIO output level in both bit fields. */
/*    MEM_D IOs will be driven to programmed output-level, when PIO mode is selected form MEM_D31..16 by */
/*    extmem_pio_ctrl_mem_pio_cfg register and output-enable is set for related IO (extmem_pio_ctrl_mem_d_pio_oe_set_clear). */
/*    Note: */
/*       If 'set' and 'clear' is programmed to '1' for the same IO in a single access, clear will win. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear             0x00000004U
#define Adr_NX51_extmem_pio_ctrl_extmem_pio_ctrl_mem_d_pio_out_set_clear 0x101C01C4U
#define Adr_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear                 0x101C01C4U
#define DFLT_VAL_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear            0x00000000U

#define MSK_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_set           0x0000ffffU
#define SRT_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_set           0
#define DFLT_VAL_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_set      0x00000000U
#define DFLT_BF_VAL_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_set   0x00000000U
#define MSK_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_clear         0xffff0000U
#define SRT_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_clear         16
#define DFLT_VAL_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_clear    0x00000000U
#define DFLT_BF_VAL_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_clear 0x00000000U

/* all used bits of 'NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear': */
#define MSK_USED_BITS_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear 0xffffffffU

enum {
	BFW_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_set   = 16, /* [15:0] */
	BFW_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_clear = 16  /* [31:16] */
};

typedef struct NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OUT_SET_CLEAR_BIT_Ttag {
	unsigned int set   : BFW_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_set;   /* Enable PIO output level of related MEM_D31..16 signal by writing a 1 here.  */
	unsigned int clear : BFW_NX51_extmem_pio_ctrl_mem_d_pio_out_set_clear_clear; /* Disable PIO output level of related MEM_D31..16 signal by writing a 1 here. */
} NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OUT_SET_CLEAR_BIT_T;

typedef union {
	unsigned int                                       val;
	NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OUT_SET_CLEAR_BIT_T bf;
} NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_OUT_SET_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register extmem_pio_ctrl_mem_d_pio_in */
/* => PIO input status register for MEM_D IOs. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_extmem_pio_ctrl_mem_d_pio_in             0x00000008U
#define Adr_NX51_extmem_pio_ctrl_extmem_pio_ctrl_mem_d_pio_in 0x101C01C8U
#define Adr_NX51_extmem_pio_ctrl_mem_d_pio_in                 0x101C01C8U

#define MSK_NX51_extmem_pio_ctrl_mem_d_pio_in_in 0xffff0000U
#define SRT_NX51_extmem_pio_ctrl_mem_d_pio_in_in 16

/* all used bits of 'NX51_extmem_pio_ctrl_mem_d_pio_in': */
#define MSK_USED_BITS_NX51_extmem_pio_ctrl_mem_d_pio_in 0xffff0000U

enum {
	BFW_NX51_extmem_pio_ctrl_mem_d_pio_in_reserved1 = 16, /* [15:0] */
	BFW_NX51_extmem_pio_ctrl_mem_d_pio_in_in        = 16  /* [31:16] */
};

typedef struct NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_IN_BIT_Ttag {
	unsigned int reserved1 : BFW_NX51_extmem_pio_ctrl_mem_d_pio_in_reserved1; /* reserved                                        */
	unsigned int in        : BFW_NX51_extmem_pio_ctrl_mem_d_pio_in_in;        /* Current input-status of related MEM_D31..16 IO. */
} NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_IN_BIT_T;

typedef union {
	unsigned int                            val;
	NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_IN_BIT_T bf;
} NX51_EXTMEM_PIO_CTRL_MEM_D_PIO_IN_T;


/* ===================================================================== */

/* Area of hifmemctrl */

/* ===================================================================== */

#define Addr_NX51_hifmemctrl 0x101C0200U

/* ===================================================================== */

/* Area of abort */

/* ===================================================================== */

#define Addr_NX51_abort      0x101C0300U
#define NX51_NETX_ABORT_AREA 0x101C0300U

/* ===================================================================== */

/* Area of arm_timer */

/* ===================================================================== */

#define Addr_NX51_arm_timer 0x101C0380U

/* --------------------------------------------------------------------- */
/* Register arm_timer_config_timer0 */
/* => ARM TIMER Config register0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_config_timer0       0x00000000U
#define Adr_NX51_arm_timer_arm_timer_config_timer0 0x101C0380U
#define Adr_NX51_arm_timer_config_timer0           0x101C0380U
#define DFLT_VAL_NX51_arm_timer_config_timer0      0x00000000U

#define MSK_NX51_arm_timer_config_timer0_mode         0x00000003U
#define SRT_NX51_arm_timer_config_timer0_mode         0
#define DFLT_VAL_NX51_arm_timer_config_timer0_mode    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_config_timer0_mode 0x00000000U

/* all used bits of 'NX51_arm_timer_config_timer0': */
#define MSK_USED_BITS_NX51_arm_timer_config_timer0 0x00000003U

enum {
	BFW_NX51_arm_timer_config_timer0_mode      = 2,  /* [1:0] */
	BFW_NX51_arm_timer_config_timer0_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_ARM_TIMER_CONFIG_TIMER0_BIT_Ttag {
	unsigned int mode      : BFW_NX51_arm_timer_config_timer0_mode;      /* Timer0                                                               */
	                                                                     /*       2'b00 : Timer stops at 0                                       */
	                                                                     /*       2'b01 : Timer is preload with value from preload register at 0 */
	                                                                     /*       2'b10 : Timer (value) compare with systime (once)              */
	                                                                     /*       2'b11 : Timer (value) compare with systime_uc (once)           */
	unsigned int reserved1 : BFW_NX51_arm_timer_config_timer0_reserved1; /* reserved                                                             */
} NX51_ARM_TIMER_CONFIG_TIMER0_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_ARM_TIMER_CONFIG_TIMER0_BIT_T bf;
} NX51_ARM_TIMER_CONFIG_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_config_timer1 */
/* => ARM TIMER Config register1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_config_timer1       0x00000004U
#define Adr_NX51_arm_timer_arm_timer_config_timer1 0x101C0384U
#define Adr_NX51_arm_timer_config_timer1           0x101C0384U
#define DFLT_VAL_NX51_arm_timer_config_timer1      0x00000000U

#define MSK_NX51_arm_timer_config_timer1_mode         0x00000003U
#define SRT_NX51_arm_timer_config_timer1_mode         0
#define DFLT_VAL_NX51_arm_timer_config_timer1_mode    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_config_timer1_mode 0x00000000U

/* all used bits of 'NX51_arm_timer_config_timer1': */
#define MSK_USED_BITS_NX51_arm_timer_config_timer1 0x00000003U

enum {
	BFW_NX51_arm_timer_config_timer1_mode      = 2,  /* [1:0] */
	BFW_NX51_arm_timer_config_timer1_reserved1 = 30  /* [31:2] */
};

typedef struct NX51_ARM_TIMER_CONFIG_TIMER1_BIT_Ttag {
	unsigned int mode      : BFW_NX51_arm_timer_config_timer1_mode;      /* Timer1                                                               */
	                                                                     /*       2'b00 : Timer stops at 0                                       */
	                                                                     /*       2'b01 : Timer is preload with value from preload register at 0 */
	                                                                     /*       2'b10 : Timer (value) compare with systime (once)              */
	                                                                     /*       2'b11 : Timer (value) compare with systime_uc (once)           */
	unsigned int reserved1 : BFW_NX51_arm_timer_config_timer1_reserved1; /* reserved                                                             */
} NX51_ARM_TIMER_CONFIG_TIMER1_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_ARM_TIMER_CONFIG_TIMER1_BIT_T bf;
} NX51_ARM_TIMER_CONFIG_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_preload_timer0 */
/* => ARM TIMER Timer 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_preload_timer0       0x00000008U
#define Adr_NX51_arm_timer_arm_timer_preload_timer0 0x101C0388U
#define Adr_NX51_arm_timer_preload_timer0           0x101C0388U
#define DFLT_VAL_NX51_arm_timer_preload_timer0      0x00000000U

#define MSK_NX51_arm_timer_preload_timer0_val         0xffffffffU
#define SRT_NX51_arm_timer_preload_timer0_val         0
#define DFLT_VAL_NX51_arm_timer_preload_timer0_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_preload_timer0_val 0x00000000U

/* all used bits of 'NX51_arm_timer_preload_timer0': */
#define MSK_USED_BITS_NX51_arm_timer_preload_timer0 0xffffffffU

enum {
	BFW_NX51_arm_timer_preload_timer0_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_PRELOAD_TIMER0_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_preload_timer0_val; /* preload value */
} NX51_ARM_TIMER_PRELOAD_TIMER0_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_ARM_TIMER_PRELOAD_TIMER0_BIT_T bf;
} NX51_ARM_TIMER_PRELOAD_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_preload_timer1 */
/* => ARM TIMER Timer 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_preload_timer1       0x0000000CU
#define Adr_NX51_arm_timer_arm_timer_preload_timer1 0x101C038CU
#define Adr_NX51_arm_timer_preload_timer1           0x101C038CU
#define DFLT_VAL_NX51_arm_timer_preload_timer1      0x00000000U

#define MSK_NX51_arm_timer_preload_timer1_val         0xffffffffU
#define SRT_NX51_arm_timer_preload_timer1_val         0
#define DFLT_VAL_NX51_arm_timer_preload_timer1_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_preload_timer1_val 0x00000000U

/* all used bits of 'NX51_arm_timer_preload_timer1': */
#define MSK_USED_BITS_NX51_arm_timer_preload_timer1 0xffffffffU

enum {
	BFW_NX51_arm_timer_preload_timer1_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_PRELOAD_TIMER1_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_preload_timer1_val; /* preload value */
} NX51_ARM_TIMER_PRELOAD_TIMER1_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_ARM_TIMER_PRELOAD_TIMER1_BIT_T bf;
} NX51_ARM_TIMER_PRELOAD_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_timer0 */
/* => ARM TIMER Timer 0 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_timer0       0x00000010U
#define Adr_NX51_arm_timer_arm_timer_timer0 0x101C0390U
#define Adr_NX51_arm_timer_timer0           0x101C0390U
#define DFLT_VAL_NX51_arm_timer_timer0      0x00000000U

#define MSK_NX51_arm_timer_timer0_val         0xffffffffU
#define SRT_NX51_arm_timer_timer0_val         0
#define DFLT_VAL_NX51_arm_timer_timer0_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_timer0_val 0x00000000U

/* all used bits of 'NX51_arm_timer_timer0': */
#define MSK_USED_BITS_NX51_arm_timer_timer0 0xffffffffU

enum {
	BFW_NX51_arm_timer_timer0_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_TIMER0_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_timer0_val; /* actual value of timer / systime compare value */
} NX51_ARM_TIMER_TIMER0_BIT_T;

typedef union {
	unsigned int                val;
	NX51_ARM_TIMER_TIMER0_BIT_T bf;
} NX51_ARM_TIMER_TIMER0_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_timer1 */
/* => ARM TIMER Timer 1 */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_timer1       0x00000014U
#define Adr_NX51_arm_timer_arm_timer_timer1 0x101C0394U
#define Adr_NX51_arm_timer_timer1           0x101C0394U
#define DFLT_VAL_NX51_arm_timer_timer1      0x00000000U

#define MSK_NX51_arm_timer_timer1_val         0xffffffffU
#define SRT_NX51_arm_timer_timer1_val         0
#define DFLT_VAL_NX51_arm_timer_timer1_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_timer1_val 0x00000000U

/* all used bits of 'NX51_arm_timer_timer1': */
#define MSK_USED_BITS_NX51_arm_timer_timer1 0xffffffffU

enum {
	BFW_NX51_arm_timer_timer1_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_TIMER1_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_timer1_val; /* actual value of timer / systime compare value */
} NX51_ARM_TIMER_TIMER1_BIT_T;

typedef union {
	unsigned int                val;
	NX51_ARM_TIMER_TIMER1_BIT_T bf;
} NX51_ARM_TIMER_TIMER1_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_s */
/* => ARM_TIMER upper SYSTIME register */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    This register should be dedicated to accesses via ARM. */
/*    xPIC software should access systime via xpic_timer_systime_s. */
/*    Host software should access systime via DPM at systime_s. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_s       0x00000018U
#define Adr_NX51_arm_timer_arm_timer_systime_s 0x101C0398U
#define Adr_NX51_arm_timer_systime_s           0x101C0398U

#define MSK_NX51_arm_timer_systime_s_val 0xffffffffU
#define SRT_NX51_arm_timer_systime_s_val 0

/* all used bits of 'NX51_arm_timer_systime_s': */
#define MSK_USED_BITS_NX51_arm_timer_systime_s 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_s_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_S_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_s_val; /* Systime high:                                               */
	                                                     /* Sample systime_ns at read access to systime_s.              */
	                                                     /* Value is incremented, if systime_ns reaches systime_border. */
} NX51_ARM_TIMER_SYSTIME_S_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_ARM_TIMER_SYSTIME_S_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_S_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_ns */
/* => ARM_TIMER lower SYSTIME register */
/*    To allow consistent values of systime_s and systime_ns, lower bits of systime is latched to systime_ns, when systime_s is read. */
/*    If no systime_s is read before (e.g. at 2nd read access of systime_ns), the actual value of systime_ns is read. */
/*    This register should be dedicated to accesses via ARM. */
/*    xPIC software should access systime via xpic_timer_systime_ns. */
/*    Host software should access systime via DPM at systime_ns. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_ns       0x0000001CU
#define Adr_NX51_arm_timer_arm_timer_systime_ns 0x101C039CU
#define Adr_NX51_arm_timer_systime_ns           0x101C039CU

#define MSK_NX51_arm_timer_systime_ns_val 0xffffffffU
#define SRT_NX51_arm_timer_systime_ns_val 0

/* all used bits of 'NX51_arm_timer_systime_ns': */
#define MSK_USED_BITS_NX51_arm_timer_systime_ns 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_ns_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_NS_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_ns_val; /* Systime low:                                                        */
	                                                      /* Sample systime_ns at read access to systime_s.                      */
	                                                      /* Without sample read systime_s, read the actual value of systime_ns. */
} NX51_ARM_TIMER_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_ARM_TIMER_SYSTIME_NS_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_ns_compare */
/* => SYSTIME nano sec compare value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_ns_compare       0x00000020U
#define Adr_NX51_arm_timer_arm_timer_systime_ns_compare 0x101C03A0U
#define Adr_NX51_arm_timer_systime_ns_compare           0x101C03A0U
#define DFLT_VAL_NX51_arm_timer_systime_ns_compare      0x00000000U

#define MSK_NX51_arm_timer_systime_ns_compare_val         0xffffffffU
#define SRT_NX51_arm_timer_systime_ns_compare_val         0
#define DFLT_VAL_NX51_arm_timer_systime_ns_compare_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_systime_ns_compare_val 0x00000000U

/* all used bits of 'NX51_arm_timer_systime_ns_compare': */
#define MSK_USED_BITS_NX51_arm_timer_systime_ns_compare 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_ns_compare_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_NS_COMPARE_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_ns_compare_val; /* compare value with systime_ns (nano seconds)                      */
	                                                              /* set adr_arm_timer_irq_raw-systime_ns_irq if systime_ns is reached */
} NX51_ARM_TIMER_SYSTIME_NS_COMPARE_BIT_T;

typedef union {
	unsigned int                            val;
	NX51_ARM_TIMER_SYSTIME_NS_COMPARE_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_NS_COMPARE_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_s_compare */
/* => SYSTIME sec compare value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_s_compare       0x00000024U
#define Adr_NX51_arm_timer_arm_timer_systime_s_compare 0x101C03A4U
#define Adr_NX51_arm_timer_systime_s_compare           0x101C03A4U
#define DFLT_VAL_NX51_arm_timer_systime_s_compare      0x00000000U

#define MSK_NX51_arm_timer_systime_s_compare_val         0xffffffffU
#define SRT_NX51_arm_timer_systime_s_compare_val         0
#define DFLT_VAL_NX51_arm_timer_systime_s_compare_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_systime_s_compare_val 0x00000000U

/* all used bits of 'NX51_arm_timer_systime_s_compare': */
#define MSK_USED_BITS_NX51_arm_timer_systime_s_compare 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_s_compare_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_S_COMPARE_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_s_compare_val; /* Compare value with systime_s (seconds):                                    */
	                                                             /* Write value, then reset irq_raw-systime_s_irq to activate compare machine. */
	                                                             /* adr_arm_timer_irq_raw-systime_s_irq is set, if systime_s matches.          */
} NX51_ARM_TIMER_SYSTIME_S_COMPARE_BIT_T;

typedef union {
	unsigned int                           val;
	NX51_ARM_TIMER_SYSTIME_S_COMPARE_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_S_COMPARE_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_uc_s */
/* => ARM_TIMER upper SYSTIME_UC register */
/*    To allow consistent values of systime_uc_s and systime_uc_ns, lower bits of systime_uc is latched to systime_uc_ns, when systime_uc_s is read. */
/*    This register should be dedicated to accesses via ARM. */
/*    xPIC software should access systime_uc via xpic_timer_systime_uc_s. */
/*    Host software should access systime_uc via DPM at systime_uc_s. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_uc_s       0x00000028U
#define Adr_NX51_arm_timer_arm_timer_systime_uc_s 0x101C03A8U
#define Adr_NX51_arm_timer_systime_uc_s           0x101C03A8U

#define MSK_NX51_arm_timer_systime_uc_s_val 0xffffffffU
#define SRT_NX51_arm_timer_systime_uc_s_val 0

/* all used bits of 'NX51_arm_timer_systime_uc_s': */
#define MSK_USED_BITS_NX51_arm_timer_systime_uc_s 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_uc_s_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_UC_S_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_uc_s_val; /* Systime_uc high:                                                  */
	                                                        /* Sample systime_uc_ns at read access to systime_uc_s.              */
	                                                        /* Value is incremented, if systime_uc_ns reaches systime_uc_border. */
} NX51_ARM_TIMER_SYSTIME_UC_S_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_ARM_TIMER_SYSTIME_UC_S_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_UC_S_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_uc_ns */
/* => ARM_TIMER lower SYSTIME_UC register */
/*    To allow consistent values of systime_uc_s and systime_uc_ns, lower bits of systime_uc is latched to systime_uc_ns, when systime_uc_s is read. */
/*    If no systime_uc_s is read before (e.g. at 2nd read access of systime_uc_ns), the actual value of systime_uc_ns is read. */
/*    This register should be dedicated to accesses via ARM. */
/*    xPIC software should access systime_uc via xpic_timer_systime_uc_ns. */
/*    Host software should access systime_uc via DPM at systime_uc_ns. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_uc_ns       0x0000002CU
#define Adr_NX51_arm_timer_arm_timer_systime_uc_ns 0x101C03ACU
#define Adr_NX51_arm_timer_systime_uc_ns           0x101C03ACU

#define MSK_NX51_arm_timer_systime_uc_ns_val 0xffffffffU
#define SRT_NX51_arm_timer_systime_uc_ns_val 0

/* all used bits of 'NX51_arm_timer_systime_uc_ns': */
#define MSK_USED_BITS_NX51_arm_timer_systime_uc_ns 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_uc_ns_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_UC_NS_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_uc_ns_val; /* Systime_uc low:                                                           */
	                                                         /* Sample systime_uc_ns at read access to systime_uc_s.                      */
	                                                         /* Without sample read systime_uc_s, read the actual value of systime_uc_ns. */
} NX51_ARM_TIMER_SYSTIME_UC_NS_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_ARM_TIMER_SYSTIME_UC_NS_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_UC_NS_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_uc_ns_compare */
/* => SYSTIME_UC nano sec compare value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_uc_ns_compare       0x00000030U
#define Adr_NX51_arm_timer_arm_timer_systime_uc_ns_compare 0x101C03B0U
#define Adr_NX51_arm_timer_systime_uc_ns_compare           0x101C03B0U
#define DFLT_VAL_NX51_arm_timer_systime_uc_ns_compare      0x00000000U

#define MSK_NX51_arm_timer_systime_uc_ns_compare_val         0xffffffffU
#define SRT_NX51_arm_timer_systime_uc_ns_compare_val         0
#define DFLT_VAL_NX51_arm_timer_systime_uc_ns_compare_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_systime_uc_ns_compare_val 0x00000000U

/* all used bits of 'NX51_arm_timer_systime_uc_ns_compare': */
#define MSK_USED_BITS_NX51_arm_timer_systime_uc_ns_compare 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_uc_ns_compare_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_UC_NS_COMPARE_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_uc_ns_compare_val; /* compare value with systime_uc_ns (nano seconds)                         */
	                                                                 /* set adr_arm_timer_irq_raw-systime_uc_ns_irq if systime_uc_ns is reached */
} NX51_ARM_TIMER_SYSTIME_UC_NS_COMPARE_BIT_T;

typedef union {
	unsigned int                               val;
	NX51_ARM_TIMER_SYSTIME_UC_NS_COMPARE_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_UC_NS_COMPARE_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_systime_uc_s_compare */
/* => SYSTIME_UC sec compare value */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_systime_uc_s_compare       0x00000034U
#define Adr_NX51_arm_timer_arm_timer_systime_uc_s_compare 0x101C03B4U
#define Adr_NX51_arm_timer_systime_uc_s_compare           0x101C03B4U
#define DFLT_VAL_NX51_arm_timer_systime_uc_s_compare      0x00000000U

#define MSK_NX51_arm_timer_systime_uc_s_compare_val         0xffffffffU
#define SRT_NX51_arm_timer_systime_uc_s_compare_val         0
#define DFLT_VAL_NX51_arm_timer_systime_uc_s_compare_val    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_systime_uc_s_compare_val 0x00000000U

/* all used bits of 'NX51_arm_timer_systime_uc_s_compare': */
#define MSK_USED_BITS_NX51_arm_timer_systime_uc_s_compare 0xffffffffU

enum {
	BFW_NX51_arm_timer_systime_uc_s_compare_val = 32  /* [31:0] */
};

typedef struct NX51_ARM_TIMER_SYSTIME_UC_S_COMPARE_BIT_Ttag {
	unsigned int val : BFW_NX51_arm_timer_systime_uc_s_compare_val; /* Compare value with systime_uc_s (seconds):                                    */
	                                                                /* Write value, then reset irq_raw-systime_uc_s_irq to activate compare machine. */
	                                                                /* adr_arm_timer_irq_raw-systime_uc_s_irq is set, if systime_uc_s matches.       */
} NX51_ARM_TIMER_SYSTIME_UC_S_COMPARE_BIT_T;

typedef union {
	unsigned int                              val;
	NX51_ARM_TIMER_SYSTIME_UC_S_COMPARE_BIT_T bf;
} NX51_ARM_TIMER_SYSTIME_UC_S_COMPARE_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_irq_raw */
/* => ARM_TIMER Raw IRQ register: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_irq_raw       0x00000038U
#define Adr_NX51_arm_timer_arm_timer_irq_raw 0x101C03B8U
#define Adr_NX51_arm_timer_irq_raw           0x101C03B8U
#define DFLT_VAL_NX51_arm_timer_irq_raw      0x00000000U

#define MSK_NX51_arm_timer_irq_raw_timer0_irq                0x00000001U
#define SRT_NX51_arm_timer_irq_raw_timer0_irq                0
#define DFLT_VAL_NX51_arm_timer_irq_raw_timer0_irq           0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_raw_timer0_irq        0x00000000U
#define MSK_NX51_arm_timer_irq_raw_timer1_irq                0x00000002U
#define SRT_NX51_arm_timer_irq_raw_timer1_irq                1
#define DFLT_VAL_NX51_arm_timer_irq_raw_timer1_irq           0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_raw_timer1_irq        0x00000000U
#define MSK_NX51_arm_timer_irq_raw_systime_ns_irq            0x00000004U
#define SRT_NX51_arm_timer_irq_raw_systime_ns_irq            2
#define DFLT_VAL_NX51_arm_timer_irq_raw_systime_ns_irq       0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_raw_systime_ns_irq    0x00000000U
#define MSK_NX51_arm_timer_irq_raw_systime_s_irq             0x00000008U
#define SRT_NX51_arm_timer_irq_raw_systime_s_irq             3
#define DFLT_VAL_NX51_arm_timer_irq_raw_systime_s_irq        0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_raw_systime_s_irq     0x00000000U
#define MSK_NX51_arm_timer_irq_raw_systime_uc_ns_irq         0x00000010U
#define SRT_NX51_arm_timer_irq_raw_systime_uc_ns_irq         4
#define DFLT_VAL_NX51_arm_timer_irq_raw_systime_uc_ns_irq    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_raw_systime_uc_ns_irq 0x00000000U
#define MSK_NX51_arm_timer_irq_raw_systime_uc_s_irq          0x00000020U
#define SRT_NX51_arm_timer_irq_raw_systime_uc_s_irq          5
#define DFLT_VAL_NX51_arm_timer_irq_raw_systime_uc_s_irq     0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_raw_systime_uc_s_irq  0x00000000U

/* all used bits of 'NX51_arm_timer_irq_raw': */
#define MSK_USED_BITS_NX51_arm_timer_irq_raw 0x0000003fU

enum {
	BFW_NX51_arm_timer_irq_raw_timer0_irq        = 1,  /* [0] */
	BFW_NX51_arm_timer_irq_raw_timer1_irq        = 1,  /* [1] */
	BFW_NX51_arm_timer_irq_raw_systime_ns_irq    = 1,  /* [2] */
	BFW_NX51_arm_timer_irq_raw_systime_s_irq     = 1,  /* [3] */
	BFW_NX51_arm_timer_irq_raw_systime_uc_ns_irq = 1,  /* [4] */
	BFW_NX51_arm_timer_irq_raw_systime_uc_s_irq  = 1,  /* [5] */
	BFW_NX51_arm_timer_irq_raw_reserved1         = 26  /* [31:6] */
};

typedef struct NX51_ARM_TIMER_IRQ_RAW_BIT_Ttag {
	unsigned int timer0_irq        : BFW_NX51_arm_timer_irq_raw_timer0_irq;        /* Timer 0 Interrupt        */
	unsigned int timer1_irq        : BFW_NX51_arm_timer_irq_raw_timer1_irq;        /* Timer 1 Interrupt        */
	unsigned int systime_ns_irq    : BFW_NX51_arm_timer_irq_raw_systime_ns_irq;    /* Systime ns Interrupt     */
	unsigned int systime_s_irq     : BFW_NX51_arm_timer_irq_raw_systime_s_irq;     /* Systime sec Interrupt    */
	unsigned int systime_uc_ns_irq : BFW_NX51_arm_timer_irq_raw_systime_uc_ns_irq; /* Systime_uc ns Interrupt  */
	unsigned int systime_uc_s_irq  : BFW_NX51_arm_timer_irq_raw_systime_uc_s_irq;  /* Systime_uc sec Interrupt */
	unsigned int reserved1         : BFW_NX51_arm_timer_irq_raw_reserved1;         /* reserved                 */
} NX51_ARM_TIMER_IRQ_RAW_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_ARM_TIMER_IRQ_RAW_BIT_T bf;
} NX51_ARM_TIMER_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_irq_masked */
/* => ARM_TIMER Masked IRQ register: */
/*    Shows status of masked IRQs (as connected to ARM/xPIC) */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_irq_masked       0x0000003CU
#define Adr_NX51_arm_timer_arm_timer_irq_masked 0x101C03BCU
#define Adr_NX51_arm_timer_irq_masked           0x101C03BCU

#define MSK_NX51_arm_timer_irq_masked_timer0_irq        0x00000001U
#define SRT_NX51_arm_timer_irq_masked_timer0_irq        0
#define MSK_NX51_arm_timer_irq_masked_timer1_irq        0x00000002U
#define SRT_NX51_arm_timer_irq_masked_timer1_irq        1
#define MSK_NX51_arm_timer_irq_masked_systime_ns_irq    0x00000004U
#define SRT_NX51_arm_timer_irq_masked_systime_ns_irq    2
#define MSK_NX51_arm_timer_irq_masked_systime_s_irq     0x00000008U
#define SRT_NX51_arm_timer_irq_masked_systime_s_irq     3
#define MSK_NX51_arm_timer_irq_masked_systime_uc_ns_irq 0x00000010U
#define SRT_NX51_arm_timer_irq_masked_systime_uc_ns_irq 4
#define MSK_NX51_arm_timer_irq_masked_systime_uc_s_irq  0x00000020U
#define SRT_NX51_arm_timer_irq_masked_systime_uc_s_irq  5

/* all used bits of 'NX51_arm_timer_irq_masked': */
#define MSK_USED_BITS_NX51_arm_timer_irq_masked 0x0000003fU

enum {
	BFW_NX51_arm_timer_irq_masked_timer0_irq        = 1,  /* [0] */
	BFW_NX51_arm_timer_irq_masked_timer1_irq        = 1,  /* [1] */
	BFW_NX51_arm_timer_irq_masked_systime_ns_irq    = 1,  /* [2] */
	BFW_NX51_arm_timer_irq_masked_systime_s_irq     = 1,  /* [3] */
	BFW_NX51_arm_timer_irq_masked_systime_uc_ns_irq = 1,  /* [4] */
	BFW_NX51_arm_timer_irq_masked_systime_uc_s_irq  = 1,  /* [5] */
	BFW_NX51_arm_timer_irq_masked_reserved1         = 26  /* [31:6] */
};

typedef struct NX51_ARM_TIMER_IRQ_MASKED_BIT_Ttag {
	unsigned int timer0_irq        : BFW_NX51_arm_timer_irq_masked_timer0_irq;        /* Timer 0 Interrupt        */
	unsigned int timer1_irq        : BFW_NX51_arm_timer_irq_masked_timer1_irq;        /* Timer 1 Interrupt        */
	unsigned int systime_ns_irq    : BFW_NX51_arm_timer_irq_masked_systime_ns_irq;    /* Systime ns Interrupt     */
	unsigned int systime_s_irq     : BFW_NX51_arm_timer_irq_masked_systime_s_irq;     /* Systime sec Interrupt    */
	unsigned int systime_uc_ns_irq : BFW_NX51_arm_timer_irq_masked_systime_uc_ns_irq; /* Systime_uc ns Interrupt  */
	unsigned int systime_uc_s_irq  : BFW_NX51_arm_timer_irq_masked_systime_uc_s_irq;  /* Systime_uc sec Interrupt */
	unsigned int reserved1         : BFW_NX51_arm_timer_irq_masked_reserved1;         /* reserved                 */
} NX51_ARM_TIMER_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_ARM_TIMER_IRQ_MASKED_BIT_T bf;
} NX51_ARM_TIMER_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_irq_msk_set */
/* => ARM_TIMER interrupt mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit (enables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to arm_timer_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_irq_msk_set       0x00000040U
#define Adr_NX51_arm_timer_arm_timer_irq_msk_set 0x101C03C0U
#define Adr_NX51_arm_timer_irq_msk_set           0x101C03C0U
#define DFLT_VAL_NX51_arm_timer_irq_msk_set      0x00000000U

#define MSK_NX51_arm_timer_irq_msk_set_timer0_irq                0x00000001U
#define SRT_NX51_arm_timer_irq_msk_set_timer0_irq                0
#define DFLT_VAL_NX51_arm_timer_irq_msk_set_timer0_irq           0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_set_timer0_irq        0x00000000U
#define MSK_NX51_arm_timer_irq_msk_set_timer1_irq                0x00000002U
#define SRT_NX51_arm_timer_irq_msk_set_timer1_irq                1
#define DFLT_VAL_NX51_arm_timer_irq_msk_set_timer1_irq           0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_set_timer1_irq        0x00000000U
#define MSK_NX51_arm_timer_irq_msk_set_systime_ns_irq            0x00000004U
#define SRT_NX51_arm_timer_irq_msk_set_systime_ns_irq            2
#define DFLT_VAL_NX51_arm_timer_irq_msk_set_systime_ns_irq       0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_set_systime_ns_irq    0x00000000U
#define MSK_NX51_arm_timer_irq_msk_set_systime_s_irq             0x00000008U
#define SRT_NX51_arm_timer_irq_msk_set_systime_s_irq             3
#define DFLT_VAL_NX51_arm_timer_irq_msk_set_systime_s_irq        0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_set_systime_s_irq     0x00000000U
#define MSK_NX51_arm_timer_irq_msk_set_systime_uc_ns_irq         0x00000010U
#define SRT_NX51_arm_timer_irq_msk_set_systime_uc_ns_irq         4
#define DFLT_VAL_NX51_arm_timer_irq_msk_set_systime_uc_ns_irq    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_set_systime_uc_ns_irq 0x00000000U
#define MSK_NX51_arm_timer_irq_msk_set_systime_uc_s_irq          0x00000020U
#define SRT_NX51_arm_timer_irq_msk_set_systime_uc_s_irq          5
#define DFLT_VAL_NX51_arm_timer_irq_msk_set_systime_uc_s_irq     0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_set_systime_uc_s_irq  0x00000000U

/* all used bits of 'NX51_arm_timer_irq_msk_set': */
#define MSK_USED_BITS_NX51_arm_timer_irq_msk_set 0x0000003fU

enum {
	BFW_NX51_arm_timer_irq_msk_set_timer0_irq        = 1,  /* [0] */
	BFW_NX51_arm_timer_irq_msk_set_timer1_irq        = 1,  /* [1] */
	BFW_NX51_arm_timer_irq_msk_set_systime_ns_irq    = 1,  /* [2] */
	BFW_NX51_arm_timer_irq_msk_set_systime_s_irq     = 1,  /* [3] */
	BFW_NX51_arm_timer_irq_msk_set_systime_uc_ns_irq = 1,  /* [4] */
	BFW_NX51_arm_timer_irq_msk_set_systime_uc_s_irq  = 1,  /* [5] */
	BFW_NX51_arm_timer_irq_msk_set_reserved1         = 26  /* [31:6] */
};

typedef struct NX51_ARM_TIMER_IRQ_MSK_SET_BIT_Ttag {
	unsigned int timer0_irq        : BFW_NX51_arm_timer_irq_msk_set_timer0_irq;        /* Timer 0 Interrupt        */
	unsigned int timer1_irq        : BFW_NX51_arm_timer_irq_msk_set_timer1_irq;        /* Timer 1 Interrupt        */
	unsigned int systime_ns_irq    : BFW_NX51_arm_timer_irq_msk_set_systime_ns_irq;    /* Systime ns Interrupt     */
	unsigned int systime_s_irq     : BFW_NX51_arm_timer_irq_msk_set_systime_s_irq;     /* Systime sec Interrupt    */
	unsigned int systime_uc_ns_irq : BFW_NX51_arm_timer_irq_msk_set_systime_uc_ns_irq; /* Systime_uc ns Interrupt  */
	unsigned int systime_uc_s_irq  : BFW_NX51_arm_timer_irq_msk_set_systime_uc_s_irq;  /* Systime_uc sec Interrupt */
	unsigned int reserved1         : BFW_NX51_arm_timer_irq_msk_set_reserved1;         /* reserved                 */
} NX51_ARM_TIMER_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_ARM_TIMER_IRQ_MSK_SET_BIT_T bf;
} NX51_ARM_TIMER_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register arm_timer_irq_msk_reset */
/* => ARM_TIMER interrupt mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit (disables interrupt request for corresponding interrupt source). */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_arm_timer_irq_msk_reset       0x00000044U
#define Adr_NX51_arm_timer_arm_timer_irq_msk_reset 0x101C03C4U
#define Adr_NX51_arm_timer_irq_msk_reset           0x101C03C4U
#define DFLT_VAL_NX51_arm_timer_irq_msk_reset      0x00000000U

#define MSK_NX51_arm_timer_irq_msk_reset_timer0_irq                0x00000001U
#define SRT_NX51_arm_timer_irq_msk_reset_timer0_irq                0
#define DFLT_VAL_NX51_arm_timer_irq_msk_reset_timer0_irq           0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_reset_timer0_irq        0x00000000U
#define MSK_NX51_arm_timer_irq_msk_reset_timer1_irq                0x00000002U
#define SRT_NX51_arm_timer_irq_msk_reset_timer1_irq                1
#define DFLT_VAL_NX51_arm_timer_irq_msk_reset_timer1_irq           0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_reset_timer1_irq        0x00000000U
#define MSK_NX51_arm_timer_irq_msk_reset_systime_ns_irq            0x00000004U
#define SRT_NX51_arm_timer_irq_msk_reset_systime_ns_irq            2
#define DFLT_VAL_NX51_arm_timer_irq_msk_reset_systime_ns_irq       0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_reset_systime_ns_irq    0x00000000U
#define MSK_NX51_arm_timer_irq_msk_reset_systime_s_irq             0x00000008U
#define SRT_NX51_arm_timer_irq_msk_reset_systime_s_irq             3
#define DFLT_VAL_NX51_arm_timer_irq_msk_reset_systime_s_irq        0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_reset_systime_s_irq     0x00000000U
#define MSK_NX51_arm_timer_irq_msk_reset_systime_uc_ns_irq         0x00000010U
#define SRT_NX51_arm_timer_irq_msk_reset_systime_uc_ns_irq         4
#define DFLT_VAL_NX51_arm_timer_irq_msk_reset_systime_uc_ns_irq    0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_reset_systime_uc_ns_irq 0x00000000U
#define MSK_NX51_arm_timer_irq_msk_reset_systime_uc_s_irq          0x00000020U
#define SRT_NX51_arm_timer_irq_msk_reset_systime_uc_s_irq          5
#define DFLT_VAL_NX51_arm_timer_irq_msk_reset_systime_uc_s_irq     0x00000000U
#define DFLT_BF_VAL_NX51_arm_timer_irq_msk_reset_systime_uc_s_irq  0x00000000U

/* all used bits of 'NX51_arm_timer_irq_msk_reset': */
#define MSK_USED_BITS_NX51_arm_timer_irq_msk_reset 0x0000003fU

enum {
	BFW_NX51_arm_timer_irq_msk_reset_timer0_irq        = 1,  /* [0] */
	BFW_NX51_arm_timer_irq_msk_reset_timer1_irq        = 1,  /* [1] */
	BFW_NX51_arm_timer_irq_msk_reset_systime_ns_irq    = 1,  /* [2] */
	BFW_NX51_arm_timer_irq_msk_reset_systime_s_irq     = 1,  /* [3] */
	BFW_NX51_arm_timer_irq_msk_reset_systime_uc_ns_irq = 1,  /* [4] */
	BFW_NX51_arm_timer_irq_msk_reset_systime_uc_s_irq  = 1,  /* [5] */
	BFW_NX51_arm_timer_irq_msk_reset_reserved1         = 26  /* [31:6] */
};

typedef struct NX51_ARM_TIMER_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int timer0_irq        : BFW_NX51_arm_timer_irq_msk_reset_timer0_irq;        /* Timer 0 Interrupt        */
	unsigned int timer1_irq        : BFW_NX51_arm_timer_irq_msk_reset_timer1_irq;        /* Timer 1 Interrupt        */
	unsigned int systime_ns_irq    : BFW_NX51_arm_timer_irq_msk_reset_systime_ns_irq;    /* Systime ns Interrupt     */
	unsigned int systime_s_irq     : BFW_NX51_arm_timer_irq_msk_reset_systime_s_irq;     /* Systime sec Interrupt    */
	unsigned int systime_uc_ns_irq : BFW_NX51_arm_timer_irq_msk_reset_systime_uc_ns_irq; /* Systime_uc ns Interrupt  */
	unsigned int systime_uc_s_irq  : BFW_NX51_arm_timer_irq_msk_reset_systime_uc_s_irq;  /* Systime_uc sec Interrupt */
	unsigned int reserved1         : BFW_NX51_arm_timer_irq_msk_reset_reserved1;         /* reserved                 */
} NX51_ARM_TIMER_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_ARM_TIMER_IRQ_MSK_RESET_BIT_T bf;
} NX51_ARM_TIMER_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* Area of vic */

/* ===================================================================== */

#define Addr_NX51_vic      0x101FF000U
#define NX51_NETX_VIC_AREA 0x101FF000U

/* --------------------------------------------------------------------- */
/* Register vic_irq_status */
/* => VIC IRQ status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_irq_status 0x00000000U
#define Adr_NX51_vic_vic_irq_status 0x101FF000U
#define Adr_NX51_vic_irq_status     0x101FF000U

#define MSK_NX51_vic_irq_status_sw0        0x00000001U
#define SRT_NX51_vic_irq_status_sw0        0
#define MSK_NX51_vic_irq_status_timer0     0x00000002U
#define SRT_NX51_vic_irq_status_timer0     1
#define MSK_NX51_vic_irq_status_timer1     0x00000004U
#define SRT_NX51_vic_irq_status_timer1     2
#define MSK_NX51_vic_irq_status_gpio_timer 0x00000008U
#define SRT_NX51_vic_irq_status_gpio_timer 3
#define MSK_NX51_vic_irq_status_systime_ns 0x00000010U
#define SRT_NX51_vic_irq_status_systime_ns 4
#define MSK_NX51_vic_irq_status_systime_s  0x00000020U
#define SRT_NX51_vic_irq_status_systime_s  5
#define MSK_NX51_vic_irq_status_gpio31     0x00000040U
#define SRT_NX51_vic_irq_status_gpio31     6
#define MSK_NX51_vic_irq_status_watchdog   0x00000080U
#define SRT_NX51_vic_irq_status_watchdog   7
#define MSK_NX51_vic_irq_status_uart0      0x00000100U
#define SRT_NX51_vic_irq_status_uart0      8
#define MSK_NX51_vic_irq_status_uart1      0x00000200U
#define SRT_NX51_vic_irq_status_uart1      9
#define MSK_NX51_vic_irq_status_uart2      0x00000400U
#define SRT_NX51_vic_irq_status_uart2      10
#define MSK_NX51_vic_irq_status_usb        0x00000800U
#define SRT_NX51_vic_irq_status_usb        11
#define MSK_NX51_vic_irq_status_spi        0x00001000U
#define SRT_NX51_vic_irq_status_spi        12
#define MSK_NX51_vic_irq_status_i2c        0x00002000U
#define SRT_NX51_vic_irq_status_i2c        13
#define MSK_NX51_vic_irq_status_reserved14 0x00004000U
#define SRT_NX51_vic_irq_status_reserved14 14
#define MSK_NX51_vic_irq_status_hif        0x00008000U
#define SRT_NX51_vic_irq_status_hif        15
#define MSK_NX51_vic_irq_status_gpio       0x00010000U
#define SRT_NX51_vic_irq_status_gpio       16
#define MSK_NX51_vic_irq_status_com0       0x00020000U
#define SRT_NX51_vic_irq_status_com0       17
#define MSK_NX51_vic_irq_status_com1       0x00040000U
#define SRT_NX51_vic_irq_status_com1       18
#define MSK_NX51_vic_irq_status_com2       0x00080000U
#define SRT_NX51_vic_irq_status_com2       19
#define MSK_NX51_vic_irq_status_com3       0x00100000U
#define SRT_NX51_vic_irq_status_com3       20
#define MSK_NX51_vic_irq_status_msync0     0x00200000U
#define SRT_NX51_vic_irq_status_msync0     21
#define MSK_NX51_vic_irq_status_msync1     0x00400000U
#define SRT_NX51_vic_irq_status_msync1     22
#define MSK_NX51_vic_irq_status_msync2     0x00800000U
#define SRT_NX51_vic_irq_status_msync2     23
#define MSK_NX51_vic_irq_status_msync3     0x01000000U
#define SRT_NX51_vic_irq_status_msync3     24
#define MSK_NX51_vic_irq_status_int_phy    0x02000000U
#define SRT_NX51_vic_irq_status_int_phy    25
#define MSK_NX51_vic_irq_status_sysstate   0x04000000U
#define SRT_NX51_vic_irq_status_sysstate   26
#define MSK_NX51_vic_irq_status_dmac       0x08000000U
#define SRT_NX51_vic_irq_status_dmac       27
#define MSK_NX51_vic_irq_status_trigger_lt 0x10000000U
#define SRT_NX51_vic_irq_status_trigger_lt 28
#define MSK_NX51_vic_irq_status_can        0x20000000U
#define SRT_NX51_vic_irq_status_can        29
#define MSK_NX51_vic_irq_status_osac       0x40000000U
#define SRT_NX51_vic_irq_status_osac       30
#define MSK_NX51_vic_irq_status_reserved31 0x80000000U
#define SRT_NX51_vic_irq_status_reserved31 31

/* all used bits of 'NX51_vic_irq_status': */
#define MSK_USED_BITS_NX51_vic_irq_status 0xffffffffU

enum {
	BFW_NX51_vic_irq_status_sw0        = 1, /* [0] */
	BFW_NX51_vic_irq_status_timer0     = 1, /* [1] */
	BFW_NX51_vic_irq_status_timer1     = 1, /* [2] */
	BFW_NX51_vic_irq_status_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_irq_status_systime_ns = 1, /* [4] */
	BFW_NX51_vic_irq_status_systime_s  = 1, /* [5] */
	BFW_NX51_vic_irq_status_gpio31     = 1, /* [6] */
	BFW_NX51_vic_irq_status_watchdog   = 1, /* [7] */
	BFW_NX51_vic_irq_status_uart0      = 1, /* [8] */
	BFW_NX51_vic_irq_status_uart1      = 1, /* [9] */
	BFW_NX51_vic_irq_status_uart2      = 1, /* [10] */
	BFW_NX51_vic_irq_status_usb        = 1, /* [11] */
	BFW_NX51_vic_irq_status_spi        = 1, /* [12] */
	BFW_NX51_vic_irq_status_i2c        = 1, /* [13] */
	BFW_NX51_vic_irq_status_reserved14 = 1, /* [14] */
	BFW_NX51_vic_irq_status_hif        = 1, /* [15] */
	BFW_NX51_vic_irq_status_gpio       = 1, /* [16] */
	BFW_NX51_vic_irq_status_com0       = 1, /* [17] */
	BFW_NX51_vic_irq_status_com1       = 1, /* [18] */
	BFW_NX51_vic_irq_status_com2       = 1, /* [19] */
	BFW_NX51_vic_irq_status_com3       = 1, /* [20] */
	BFW_NX51_vic_irq_status_msync0     = 1, /* [21] */
	BFW_NX51_vic_irq_status_msync1     = 1, /* [22] */
	BFW_NX51_vic_irq_status_msync2     = 1, /* [23] */
	BFW_NX51_vic_irq_status_msync3     = 1, /* [24] */
	BFW_NX51_vic_irq_status_int_phy    = 1, /* [25] */
	BFW_NX51_vic_irq_status_sysstate   = 1, /* [26] */
	BFW_NX51_vic_irq_status_dmac       = 1, /* [27] */
	BFW_NX51_vic_irq_status_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_irq_status_can        = 1, /* [29] */
	BFW_NX51_vic_irq_status_osac       = 1, /* [30] */
	BFW_NX51_vic_irq_status_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_IRQ_STATUS_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_irq_status_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_irq_status_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                              /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_irq_status_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_irq_status_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                              /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_irq_status_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_irq_status_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_irq_status_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_irq_status_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_irq_status_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_irq_status_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_irq_status_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_irq_status_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_irq_status_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_irq_status_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_irq_status_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_irq_status_hif;        /* combined HIF interrupt:                                               */
	                                                              /*  - DPM module IRQs for ARM,                                           */
	                                                              /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                              /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                              /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_irq_status_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_irq_status_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_irq_status_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_irq_status_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_irq_status_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_irq_status_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_irq_status_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_irq_status_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_irq_status_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_irq_status_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_irq_status_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                              /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_irq_status_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_irq_status_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_irq_status_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_irq_status_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_irq_status_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_IRQ_STATUS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_IRQ_STATUS_BIT_T bf;
} NX51_VIC_IRQ_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register vic_fiq_status */
/* => VIC FIQ status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_fiq_status 0x00000004U
#define Adr_NX51_vic_vic_fiq_status 0x101FF004U
#define Adr_NX51_vic_fiq_status     0x101FF004U

#define MSK_NX51_vic_fiq_status_sw0        0x00000001U
#define SRT_NX51_vic_fiq_status_sw0        0
#define MSK_NX51_vic_fiq_status_timer0     0x00000002U
#define SRT_NX51_vic_fiq_status_timer0     1
#define MSK_NX51_vic_fiq_status_timer1     0x00000004U
#define SRT_NX51_vic_fiq_status_timer1     2
#define MSK_NX51_vic_fiq_status_gpio_timer 0x00000008U
#define SRT_NX51_vic_fiq_status_gpio_timer 3
#define MSK_NX51_vic_fiq_status_systime_ns 0x00000010U
#define SRT_NX51_vic_fiq_status_systime_ns 4
#define MSK_NX51_vic_fiq_status_systime_s  0x00000020U
#define SRT_NX51_vic_fiq_status_systime_s  5
#define MSK_NX51_vic_fiq_status_gpio31     0x00000040U
#define SRT_NX51_vic_fiq_status_gpio31     6
#define MSK_NX51_vic_fiq_status_watchdog   0x00000080U
#define SRT_NX51_vic_fiq_status_watchdog   7
#define MSK_NX51_vic_fiq_status_uart0      0x00000100U
#define SRT_NX51_vic_fiq_status_uart0      8
#define MSK_NX51_vic_fiq_status_uart1      0x00000200U
#define SRT_NX51_vic_fiq_status_uart1      9
#define MSK_NX51_vic_fiq_status_uart2      0x00000400U
#define SRT_NX51_vic_fiq_status_uart2      10
#define MSK_NX51_vic_fiq_status_usb        0x00000800U
#define SRT_NX51_vic_fiq_status_usb        11
#define MSK_NX51_vic_fiq_status_spi        0x00001000U
#define SRT_NX51_vic_fiq_status_spi        12
#define MSK_NX51_vic_fiq_status_i2c        0x00002000U
#define SRT_NX51_vic_fiq_status_i2c        13
#define MSK_NX51_vic_fiq_status_reserved14 0x00004000U
#define SRT_NX51_vic_fiq_status_reserved14 14
#define MSK_NX51_vic_fiq_status_hif        0x00008000U
#define SRT_NX51_vic_fiq_status_hif        15
#define MSK_NX51_vic_fiq_status_gpio       0x00010000U
#define SRT_NX51_vic_fiq_status_gpio       16
#define MSK_NX51_vic_fiq_status_com0       0x00020000U
#define SRT_NX51_vic_fiq_status_com0       17
#define MSK_NX51_vic_fiq_status_com1       0x00040000U
#define SRT_NX51_vic_fiq_status_com1       18
#define MSK_NX51_vic_fiq_status_com2       0x00080000U
#define SRT_NX51_vic_fiq_status_com2       19
#define MSK_NX51_vic_fiq_status_com3       0x00100000U
#define SRT_NX51_vic_fiq_status_com3       20
#define MSK_NX51_vic_fiq_status_msync0     0x00200000U
#define SRT_NX51_vic_fiq_status_msync0     21
#define MSK_NX51_vic_fiq_status_msync1     0x00400000U
#define SRT_NX51_vic_fiq_status_msync1     22
#define MSK_NX51_vic_fiq_status_msync2     0x00800000U
#define SRT_NX51_vic_fiq_status_msync2     23
#define MSK_NX51_vic_fiq_status_msync3     0x01000000U
#define SRT_NX51_vic_fiq_status_msync3     24
#define MSK_NX51_vic_fiq_status_int_phy    0x02000000U
#define SRT_NX51_vic_fiq_status_int_phy    25
#define MSK_NX51_vic_fiq_status_sysstate   0x04000000U
#define SRT_NX51_vic_fiq_status_sysstate   26
#define MSK_NX51_vic_fiq_status_dmac       0x08000000U
#define SRT_NX51_vic_fiq_status_dmac       27
#define MSK_NX51_vic_fiq_status_trigger_lt 0x10000000U
#define SRT_NX51_vic_fiq_status_trigger_lt 28
#define MSK_NX51_vic_fiq_status_can        0x20000000U
#define SRT_NX51_vic_fiq_status_can        29
#define MSK_NX51_vic_fiq_status_osac       0x40000000U
#define SRT_NX51_vic_fiq_status_osac       30
#define MSK_NX51_vic_fiq_status_reserved31 0x80000000U
#define SRT_NX51_vic_fiq_status_reserved31 31

/* all used bits of 'NX51_vic_fiq_status': */
#define MSK_USED_BITS_NX51_vic_fiq_status 0xffffffffU

enum {
	BFW_NX51_vic_fiq_status_sw0        = 1, /* [0] */
	BFW_NX51_vic_fiq_status_timer0     = 1, /* [1] */
	BFW_NX51_vic_fiq_status_timer1     = 1, /* [2] */
	BFW_NX51_vic_fiq_status_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_fiq_status_systime_ns = 1, /* [4] */
	BFW_NX51_vic_fiq_status_systime_s  = 1, /* [5] */
	BFW_NX51_vic_fiq_status_gpio31     = 1, /* [6] */
	BFW_NX51_vic_fiq_status_watchdog   = 1, /* [7] */
	BFW_NX51_vic_fiq_status_uart0      = 1, /* [8] */
	BFW_NX51_vic_fiq_status_uart1      = 1, /* [9] */
	BFW_NX51_vic_fiq_status_uart2      = 1, /* [10] */
	BFW_NX51_vic_fiq_status_usb        = 1, /* [11] */
	BFW_NX51_vic_fiq_status_spi        = 1, /* [12] */
	BFW_NX51_vic_fiq_status_i2c        = 1, /* [13] */
	BFW_NX51_vic_fiq_status_reserved14 = 1, /* [14] */
	BFW_NX51_vic_fiq_status_hif        = 1, /* [15] */
	BFW_NX51_vic_fiq_status_gpio       = 1, /* [16] */
	BFW_NX51_vic_fiq_status_com0       = 1, /* [17] */
	BFW_NX51_vic_fiq_status_com1       = 1, /* [18] */
	BFW_NX51_vic_fiq_status_com2       = 1, /* [19] */
	BFW_NX51_vic_fiq_status_com3       = 1, /* [20] */
	BFW_NX51_vic_fiq_status_msync0     = 1, /* [21] */
	BFW_NX51_vic_fiq_status_msync1     = 1, /* [22] */
	BFW_NX51_vic_fiq_status_msync2     = 1, /* [23] */
	BFW_NX51_vic_fiq_status_msync3     = 1, /* [24] */
	BFW_NX51_vic_fiq_status_int_phy    = 1, /* [25] */
	BFW_NX51_vic_fiq_status_sysstate   = 1, /* [26] */
	BFW_NX51_vic_fiq_status_dmac       = 1, /* [27] */
	BFW_NX51_vic_fiq_status_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_fiq_status_can        = 1, /* [29] */
	BFW_NX51_vic_fiq_status_osac       = 1, /* [30] */
	BFW_NX51_vic_fiq_status_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_FIQ_STATUS_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_fiq_status_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_fiq_status_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                              /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_fiq_status_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_fiq_status_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                              /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_fiq_status_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_fiq_status_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_fiq_status_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_fiq_status_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_fiq_status_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_fiq_status_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_fiq_status_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_fiq_status_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_fiq_status_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_fiq_status_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_fiq_status_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_fiq_status_hif;        /* combined HIF interrupt:                                               */
	                                                              /*  - DPM module IRQs for ARM,                                           */
	                                                              /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                              /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                              /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_fiq_status_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_fiq_status_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_fiq_status_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_fiq_status_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_fiq_status_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_fiq_status_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_fiq_status_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_fiq_status_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_fiq_status_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_fiq_status_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_fiq_status_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                              /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_fiq_status_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_fiq_status_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_fiq_status_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_fiq_status_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_fiq_status_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_FIQ_STATUS_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_FIQ_STATUS_BIT_T bf;
} NX51_VIC_FIQ_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register vic_raw_intr */
/* => VIC Raw interrupt status register */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_raw_intr 0x00000008U
#define Adr_NX51_vic_vic_raw_intr 0x101FF008U
#define Adr_NX51_vic_raw_intr     0x101FF008U

#define MSK_NX51_vic_raw_intr_sw0        0x00000001U
#define SRT_NX51_vic_raw_intr_sw0        0
#define MSK_NX51_vic_raw_intr_timer0     0x00000002U
#define SRT_NX51_vic_raw_intr_timer0     1
#define MSK_NX51_vic_raw_intr_timer1     0x00000004U
#define SRT_NX51_vic_raw_intr_timer1     2
#define MSK_NX51_vic_raw_intr_gpio_timer 0x00000008U
#define SRT_NX51_vic_raw_intr_gpio_timer 3
#define MSK_NX51_vic_raw_intr_systime_ns 0x00000010U
#define SRT_NX51_vic_raw_intr_systime_ns 4
#define MSK_NX51_vic_raw_intr_systime_s  0x00000020U
#define SRT_NX51_vic_raw_intr_systime_s  5
#define MSK_NX51_vic_raw_intr_gpio31     0x00000040U
#define SRT_NX51_vic_raw_intr_gpio31     6
#define MSK_NX51_vic_raw_intr_watchdog   0x00000080U
#define SRT_NX51_vic_raw_intr_watchdog   7
#define MSK_NX51_vic_raw_intr_uart0      0x00000100U
#define SRT_NX51_vic_raw_intr_uart0      8
#define MSK_NX51_vic_raw_intr_uart1      0x00000200U
#define SRT_NX51_vic_raw_intr_uart1      9
#define MSK_NX51_vic_raw_intr_uart2      0x00000400U
#define SRT_NX51_vic_raw_intr_uart2      10
#define MSK_NX51_vic_raw_intr_usb        0x00000800U
#define SRT_NX51_vic_raw_intr_usb        11
#define MSK_NX51_vic_raw_intr_spi        0x00001000U
#define SRT_NX51_vic_raw_intr_spi        12
#define MSK_NX51_vic_raw_intr_i2c        0x00002000U
#define SRT_NX51_vic_raw_intr_i2c        13
#define MSK_NX51_vic_raw_intr_reserved14 0x00004000U
#define SRT_NX51_vic_raw_intr_reserved14 14
#define MSK_NX51_vic_raw_intr_hif        0x00008000U
#define SRT_NX51_vic_raw_intr_hif        15
#define MSK_NX51_vic_raw_intr_gpio       0x00010000U
#define SRT_NX51_vic_raw_intr_gpio       16
#define MSK_NX51_vic_raw_intr_com0       0x00020000U
#define SRT_NX51_vic_raw_intr_com0       17
#define MSK_NX51_vic_raw_intr_com1       0x00040000U
#define SRT_NX51_vic_raw_intr_com1       18
#define MSK_NX51_vic_raw_intr_com2       0x00080000U
#define SRT_NX51_vic_raw_intr_com2       19
#define MSK_NX51_vic_raw_intr_com3       0x00100000U
#define SRT_NX51_vic_raw_intr_com3       20
#define MSK_NX51_vic_raw_intr_msync0     0x00200000U
#define SRT_NX51_vic_raw_intr_msync0     21
#define MSK_NX51_vic_raw_intr_msync1     0x00400000U
#define SRT_NX51_vic_raw_intr_msync1     22
#define MSK_NX51_vic_raw_intr_msync2     0x00800000U
#define SRT_NX51_vic_raw_intr_msync2     23
#define MSK_NX51_vic_raw_intr_msync3     0x01000000U
#define SRT_NX51_vic_raw_intr_msync3     24
#define MSK_NX51_vic_raw_intr_int_phy    0x02000000U
#define SRT_NX51_vic_raw_intr_int_phy    25
#define MSK_NX51_vic_raw_intr_sysstate   0x04000000U
#define SRT_NX51_vic_raw_intr_sysstate   26
#define MSK_NX51_vic_raw_intr_dmac       0x08000000U
#define SRT_NX51_vic_raw_intr_dmac       27
#define MSK_NX51_vic_raw_intr_trigger_lt 0x10000000U
#define SRT_NX51_vic_raw_intr_trigger_lt 28
#define MSK_NX51_vic_raw_intr_can        0x20000000U
#define SRT_NX51_vic_raw_intr_can        29
#define MSK_NX51_vic_raw_intr_osac       0x40000000U
#define SRT_NX51_vic_raw_intr_osac       30
#define MSK_NX51_vic_raw_intr_reserved31 0x80000000U
#define SRT_NX51_vic_raw_intr_reserved31 31

/* all used bits of 'NX51_vic_raw_intr': */
#define MSK_USED_BITS_NX51_vic_raw_intr 0xffffffffU

enum {
	BFW_NX51_vic_raw_intr_sw0        = 1, /* [0] */
	BFW_NX51_vic_raw_intr_timer0     = 1, /* [1] */
	BFW_NX51_vic_raw_intr_timer1     = 1, /* [2] */
	BFW_NX51_vic_raw_intr_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_raw_intr_systime_ns = 1, /* [4] */
	BFW_NX51_vic_raw_intr_systime_s  = 1, /* [5] */
	BFW_NX51_vic_raw_intr_gpio31     = 1, /* [6] */
	BFW_NX51_vic_raw_intr_watchdog   = 1, /* [7] */
	BFW_NX51_vic_raw_intr_uart0      = 1, /* [8] */
	BFW_NX51_vic_raw_intr_uart1      = 1, /* [9] */
	BFW_NX51_vic_raw_intr_uart2      = 1, /* [10] */
	BFW_NX51_vic_raw_intr_usb        = 1, /* [11] */
	BFW_NX51_vic_raw_intr_spi        = 1, /* [12] */
	BFW_NX51_vic_raw_intr_i2c        = 1, /* [13] */
	BFW_NX51_vic_raw_intr_reserved14 = 1, /* [14] */
	BFW_NX51_vic_raw_intr_hif        = 1, /* [15] */
	BFW_NX51_vic_raw_intr_gpio       = 1, /* [16] */
	BFW_NX51_vic_raw_intr_com0       = 1, /* [17] */
	BFW_NX51_vic_raw_intr_com1       = 1, /* [18] */
	BFW_NX51_vic_raw_intr_com2       = 1, /* [19] */
	BFW_NX51_vic_raw_intr_com3       = 1, /* [20] */
	BFW_NX51_vic_raw_intr_msync0     = 1, /* [21] */
	BFW_NX51_vic_raw_intr_msync1     = 1, /* [22] */
	BFW_NX51_vic_raw_intr_msync2     = 1, /* [23] */
	BFW_NX51_vic_raw_intr_msync3     = 1, /* [24] */
	BFW_NX51_vic_raw_intr_int_phy    = 1, /* [25] */
	BFW_NX51_vic_raw_intr_sysstate   = 1, /* [26] */
	BFW_NX51_vic_raw_intr_dmac       = 1, /* [27] */
	BFW_NX51_vic_raw_intr_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_raw_intr_can        = 1, /* [29] */
	BFW_NX51_vic_raw_intr_osac       = 1, /* [30] */
	BFW_NX51_vic_raw_intr_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_RAW_INTR_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_raw_intr_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_raw_intr_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                            /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_raw_intr_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_raw_intr_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                            /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_raw_intr_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_raw_intr_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_raw_intr_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_raw_intr_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_raw_intr_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_raw_intr_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_raw_intr_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_raw_intr_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_raw_intr_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_raw_intr_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_raw_intr_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_raw_intr_hif;        /* combined HIF interrupt:                                               */
	                                                            /*  - DPM module IRQs for ARM,                                           */
	                                                            /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                            /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                            /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_raw_intr_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_raw_intr_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_raw_intr_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_raw_intr_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_raw_intr_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_raw_intr_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_raw_intr_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_raw_intr_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_raw_intr_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_raw_intr_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_raw_intr_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                            /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_raw_intr_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_raw_intr_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_raw_intr_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_raw_intr_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_raw_intr_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_RAW_INTR_BIT_T;

typedef union {
	unsigned int            val;
	NX51_VIC_RAW_INTR_BIT_T bf;
} NX51_VIC_RAW_INTR_T;

/* --------------------------------------------------------------------- */
/* Register vic_int_select */
/* => VIC Interrupt select register */
/*    1 = FIQ interrupt */
/*    0 = IRQ interrupt */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_int_select  0x0000000CU
#define Adr_NX51_vic_vic_int_select  0x101FF00CU
#define Adr_NX51_vic_int_select      0x101FF00CU
#define DFLT_VAL_NX51_vic_int_select 0x00000000U

#define MSK_NX51_vic_int_select_sw0                0x00000001U
#define SRT_NX51_vic_int_select_sw0                0
#define DFLT_VAL_NX51_vic_int_select_sw0           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_sw0        0x00000000U
#define MSK_NX51_vic_int_select_timer0             0x00000002U
#define SRT_NX51_vic_int_select_timer0             1
#define DFLT_VAL_NX51_vic_int_select_timer0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_timer0     0x00000000U
#define MSK_NX51_vic_int_select_timer1             0x00000004U
#define SRT_NX51_vic_int_select_timer1             2
#define DFLT_VAL_NX51_vic_int_select_timer1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_timer1     0x00000000U
#define MSK_NX51_vic_int_select_gpio_timer         0x00000008U
#define SRT_NX51_vic_int_select_gpio_timer         3
#define DFLT_VAL_NX51_vic_int_select_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_gpio_timer 0x00000000U
#define MSK_NX51_vic_int_select_systime_ns         0x00000010U
#define SRT_NX51_vic_int_select_systime_ns         4
#define DFLT_VAL_NX51_vic_int_select_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_systime_ns 0x00000000U
#define MSK_NX51_vic_int_select_systime_s          0x00000020U
#define SRT_NX51_vic_int_select_systime_s          5
#define DFLT_VAL_NX51_vic_int_select_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_systime_s  0x00000000U
#define MSK_NX51_vic_int_select_gpio31             0x00000040U
#define SRT_NX51_vic_int_select_gpio31             6
#define DFLT_VAL_NX51_vic_int_select_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_gpio31     0x00000000U
#define MSK_NX51_vic_int_select_watchdog           0x00000080U
#define SRT_NX51_vic_int_select_watchdog           7
#define DFLT_VAL_NX51_vic_int_select_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_watchdog   0x00000000U
#define MSK_NX51_vic_int_select_uart0              0x00000100U
#define SRT_NX51_vic_int_select_uart0              8
#define DFLT_VAL_NX51_vic_int_select_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_uart0      0x00000000U
#define MSK_NX51_vic_int_select_uart1              0x00000200U
#define SRT_NX51_vic_int_select_uart1              9
#define DFLT_VAL_NX51_vic_int_select_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_uart1      0x00000000U
#define MSK_NX51_vic_int_select_uart2              0x00000400U
#define SRT_NX51_vic_int_select_uart2              10
#define DFLT_VAL_NX51_vic_int_select_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_uart2      0x00000000U
#define MSK_NX51_vic_int_select_usb                0x00000800U
#define SRT_NX51_vic_int_select_usb                11
#define DFLT_VAL_NX51_vic_int_select_usb           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_usb        0x00000000U
#define MSK_NX51_vic_int_select_spi                0x00001000U
#define SRT_NX51_vic_int_select_spi                12
#define DFLT_VAL_NX51_vic_int_select_spi           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_spi        0x00000000U
#define MSK_NX51_vic_int_select_i2c                0x00002000U
#define SRT_NX51_vic_int_select_i2c                13
#define DFLT_VAL_NX51_vic_int_select_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_i2c        0x00000000U
#define MSK_NX51_vic_int_select_reserved14         0x00004000U
#define SRT_NX51_vic_int_select_reserved14         14
#define DFLT_VAL_NX51_vic_int_select_reserved14    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_reserved14 0x00000000U
#define MSK_NX51_vic_int_select_hif                0x00008000U
#define SRT_NX51_vic_int_select_hif                15
#define DFLT_VAL_NX51_vic_int_select_hif           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_hif        0x00000000U
#define MSK_NX51_vic_int_select_gpio               0x00010000U
#define SRT_NX51_vic_int_select_gpio               16
#define DFLT_VAL_NX51_vic_int_select_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_gpio       0x00000000U
#define MSK_NX51_vic_int_select_com0               0x00020000U
#define SRT_NX51_vic_int_select_com0               17
#define DFLT_VAL_NX51_vic_int_select_com0          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_com0       0x00000000U
#define MSK_NX51_vic_int_select_com1               0x00040000U
#define SRT_NX51_vic_int_select_com1               18
#define DFLT_VAL_NX51_vic_int_select_com1          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_com1       0x00000000U
#define MSK_NX51_vic_int_select_com2               0x00080000U
#define SRT_NX51_vic_int_select_com2               19
#define DFLT_VAL_NX51_vic_int_select_com2          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_com2       0x00000000U
#define MSK_NX51_vic_int_select_com3               0x00100000U
#define SRT_NX51_vic_int_select_com3               20
#define DFLT_VAL_NX51_vic_int_select_com3          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_com3       0x00000000U
#define MSK_NX51_vic_int_select_msync0             0x00200000U
#define SRT_NX51_vic_int_select_msync0             21
#define DFLT_VAL_NX51_vic_int_select_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_msync0     0x00000000U
#define MSK_NX51_vic_int_select_msync1             0x00400000U
#define SRT_NX51_vic_int_select_msync1             22
#define DFLT_VAL_NX51_vic_int_select_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_msync1     0x00000000U
#define MSK_NX51_vic_int_select_msync2             0x00800000U
#define SRT_NX51_vic_int_select_msync2             23
#define DFLT_VAL_NX51_vic_int_select_msync2        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_msync2     0x00000000U
#define MSK_NX51_vic_int_select_msync3             0x01000000U
#define SRT_NX51_vic_int_select_msync3             24
#define DFLT_VAL_NX51_vic_int_select_msync3        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_msync3     0x00000000U
#define MSK_NX51_vic_int_select_int_phy            0x02000000U
#define SRT_NX51_vic_int_select_int_phy            25
#define DFLT_VAL_NX51_vic_int_select_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_int_phy    0x00000000U
#define MSK_NX51_vic_int_select_sysstate           0x04000000U
#define SRT_NX51_vic_int_select_sysstate           26
#define DFLT_VAL_NX51_vic_int_select_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_sysstate   0x00000000U
#define MSK_NX51_vic_int_select_dmac               0x08000000U
#define SRT_NX51_vic_int_select_dmac               27
#define DFLT_VAL_NX51_vic_int_select_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_dmac       0x00000000U
#define MSK_NX51_vic_int_select_trigger_lt         0x10000000U
#define SRT_NX51_vic_int_select_trigger_lt         28
#define DFLT_VAL_NX51_vic_int_select_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_trigger_lt 0x00000000U
#define MSK_NX51_vic_int_select_can                0x20000000U
#define SRT_NX51_vic_int_select_can                29
#define DFLT_VAL_NX51_vic_int_select_can           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_can        0x00000000U
#define MSK_NX51_vic_int_select_osac               0x40000000U
#define SRT_NX51_vic_int_select_osac               30
#define DFLT_VAL_NX51_vic_int_select_osac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_osac       0x00000000U
#define MSK_NX51_vic_int_select_reserved31         0x80000000U
#define SRT_NX51_vic_int_select_reserved31         31
#define DFLT_VAL_NX51_vic_int_select_reserved31    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_select_reserved31 0x00000000U

/* all used bits of 'NX51_vic_int_select': */
#define MSK_USED_BITS_NX51_vic_int_select 0xffffffffU

enum {
	BFW_NX51_vic_int_select_sw0        = 1, /* [0] */
	BFW_NX51_vic_int_select_timer0     = 1, /* [1] */
	BFW_NX51_vic_int_select_timer1     = 1, /* [2] */
	BFW_NX51_vic_int_select_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_int_select_systime_ns = 1, /* [4] */
	BFW_NX51_vic_int_select_systime_s  = 1, /* [5] */
	BFW_NX51_vic_int_select_gpio31     = 1, /* [6] */
	BFW_NX51_vic_int_select_watchdog   = 1, /* [7] */
	BFW_NX51_vic_int_select_uart0      = 1, /* [8] */
	BFW_NX51_vic_int_select_uart1      = 1, /* [9] */
	BFW_NX51_vic_int_select_uart2      = 1, /* [10] */
	BFW_NX51_vic_int_select_usb        = 1, /* [11] */
	BFW_NX51_vic_int_select_spi        = 1, /* [12] */
	BFW_NX51_vic_int_select_i2c        = 1, /* [13] */
	BFW_NX51_vic_int_select_reserved14 = 1, /* [14] */
	BFW_NX51_vic_int_select_hif        = 1, /* [15] */
	BFW_NX51_vic_int_select_gpio       = 1, /* [16] */
	BFW_NX51_vic_int_select_com0       = 1, /* [17] */
	BFW_NX51_vic_int_select_com1       = 1, /* [18] */
	BFW_NX51_vic_int_select_com2       = 1, /* [19] */
	BFW_NX51_vic_int_select_com3       = 1, /* [20] */
	BFW_NX51_vic_int_select_msync0     = 1, /* [21] */
	BFW_NX51_vic_int_select_msync1     = 1, /* [22] */
	BFW_NX51_vic_int_select_msync2     = 1, /* [23] */
	BFW_NX51_vic_int_select_msync3     = 1, /* [24] */
	BFW_NX51_vic_int_select_int_phy    = 1, /* [25] */
	BFW_NX51_vic_int_select_sysstate   = 1, /* [26] */
	BFW_NX51_vic_int_select_dmac       = 1, /* [27] */
	BFW_NX51_vic_int_select_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_int_select_can        = 1, /* [29] */
	BFW_NX51_vic_int_select_osac       = 1, /* [30] */
	BFW_NX51_vic_int_select_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_INT_SELECT_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_int_select_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_int_select_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                              /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_int_select_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_int_select_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                              /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_int_select_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_int_select_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_int_select_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_int_select_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_int_select_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_int_select_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_int_select_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_int_select_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_int_select_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_int_select_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_int_select_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_int_select_hif;        /* combined HIF interrupt:                                               */
	                                                              /*  - DPM module IRQs for ARM,                                           */
	                                                              /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                              /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                              /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_int_select_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_int_select_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_int_select_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_int_select_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_int_select_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_int_select_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_int_select_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_int_select_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_int_select_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_int_select_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_int_select_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                              /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_int_select_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_int_select_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_int_select_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_int_select_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_int_select_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_INT_SELECT_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_INT_SELECT_BIT_T bf;
} NX51_VIC_INT_SELECT_T;

/* --------------------------------------------------------------------- */
/* Register vic_int_enable */
/* => VIC Interrupt enable register */
/*    1 = Interrupt enabled */
/*    0 = Interrupt disabled */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_int_enable  0x00000010U
#define Adr_NX51_vic_vic_int_enable  0x101FF010U
#define Adr_NX51_vic_int_enable      0x101FF010U
#define DFLT_VAL_NX51_vic_int_enable 0x00000000U

#define MSK_NX51_vic_int_enable_sw0                0x00000001U
#define SRT_NX51_vic_int_enable_sw0                0
#define DFLT_VAL_NX51_vic_int_enable_sw0           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_sw0        0x00000000U
#define MSK_NX51_vic_int_enable_timer0             0x00000002U
#define SRT_NX51_vic_int_enable_timer0             1
#define DFLT_VAL_NX51_vic_int_enable_timer0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_timer0     0x00000000U
#define MSK_NX51_vic_int_enable_timer1             0x00000004U
#define SRT_NX51_vic_int_enable_timer1             2
#define DFLT_VAL_NX51_vic_int_enable_timer1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_timer1     0x00000000U
#define MSK_NX51_vic_int_enable_gpio_timer         0x00000008U
#define SRT_NX51_vic_int_enable_gpio_timer         3
#define DFLT_VAL_NX51_vic_int_enable_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_gpio_timer 0x00000000U
#define MSK_NX51_vic_int_enable_systime_ns         0x00000010U
#define SRT_NX51_vic_int_enable_systime_ns         4
#define DFLT_VAL_NX51_vic_int_enable_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_systime_ns 0x00000000U
#define MSK_NX51_vic_int_enable_systime_s          0x00000020U
#define SRT_NX51_vic_int_enable_systime_s          5
#define DFLT_VAL_NX51_vic_int_enable_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_systime_s  0x00000000U
#define MSK_NX51_vic_int_enable_gpio31             0x00000040U
#define SRT_NX51_vic_int_enable_gpio31             6
#define DFLT_VAL_NX51_vic_int_enable_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_gpio31     0x00000000U
#define MSK_NX51_vic_int_enable_watchdog           0x00000080U
#define SRT_NX51_vic_int_enable_watchdog           7
#define DFLT_VAL_NX51_vic_int_enable_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_watchdog   0x00000000U
#define MSK_NX51_vic_int_enable_uart0              0x00000100U
#define SRT_NX51_vic_int_enable_uart0              8
#define DFLT_VAL_NX51_vic_int_enable_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_uart0      0x00000000U
#define MSK_NX51_vic_int_enable_uart1              0x00000200U
#define SRT_NX51_vic_int_enable_uart1              9
#define DFLT_VAL_NX51_vic_int_enable_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_uart1      0x00000000U
#define MSK_NX51_vic_int_enable_uart2              0x00000400U
#define SRT_NX51_vic_int_enable_uart2              10
#define DFLT_VAL_NX51_vic_int_enable_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_uart2      0x00000000U
#define MSK_NX51_vic_int_enable_usb                0x00000800U
#define SRT_NX51_vic_int_enable_usb                11
#define DFLT_VAL_NX51_vic_int_enable_usb           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_usb        0x00000000U
#define MSK_NX51_vic_int_enable_spi                0x00001000U
#define SRT_NX51_vic_int_enable_spi                12
#define DFLT_VAL_NX51_vic_int_enable_spi           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_spi        0x00000000U
#define MSK_NX51_vic_int_enable_i2c                0x00002000U
#define SRT_NX51_vic_int_enable_i2c                13
#define DFLT_VAL_NX51_vic_int_enable_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_i2c        0x00000000U
#define MSK_NX51_vic_int_enable_reserved14         0x00004000U
#define SRT_NX51_vic_int_enable_reserved14         14
#define DFLT_VAL_NX51_vic_int_enable_reserved14    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_reserved14 0x00000000U
#define MSK_NX51_vic_int_enable_hif                0x00008000U
#define SRT_NX51_vic_int_enable_hif                15
#define DFLT_VAL_NX51_vic_int_enable_hif           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_hif        0x00000000U
#define MSK_NX51_vic_int_enable_gpio               0x00010000U
#define SRT_NX51_vic_int_enable_gpio               16
#define DFLT_VAL_NX51_vic_int_enable_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_gpio       0x00000000U
#define MSK_NX51_vic_int_enable_com0               0x00020000U
#define SRT_NX51_vic_int_enable_com0               17
#define DFLT_VAL_NX51_vic_int_enable_com0          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_com0       0x00000000U
#define MSK_NX51_vic_int_enable_com1               0x00040000U
#define SRT_NX51_vic_int_enable_com1               18
#define DFLT_VAL_NX51_vic_int_enable_com1          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_com1       0x00000000U
#define MSK_NX51_vic_int_enable_com2               0x00080000U
#define SRT_NX51_vic_int_enable_com2               19
#define DFLT_VAL_NX51_vic_int_enable_com2          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_com2       0x00000000U
#define MSK_NX51_vic_int_enable_com3               0x00100000U
#define SRT_NX51_vic_int_enable_com3               20
#define DFLT_VAL_NX51_vic_int_enable_com3          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_com3       0x00000000U
#define MSK_NX51_vic_int_enable_msync0             0x00200000U
#define SRT_NX51_vic_int_enable_msync0             21
#define DFLT_VAL_NX51_vic_int_enable_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_msync0     0x00000000U
#define MSK_NX51_vic_int_enable_msync1             0x00400000U
#define SRT_NX51_vic_int_enable_msync1             22
#define DFLT_VAL_NX51_vic_int_enable_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_msync1     0x00000000U
#define MSK_NX51_vic_int_enable_msync2             0x00800000U
#define SRT_NX51_vic_int_enable_msync2             23
#define DFLT_VAL_NX51_vic_int_enable_msync2        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_msync2     0x00000000U
#define MSK_NX51_vic_int_enable_msync3             0x01000000U
#define SRT_NX51_vic_int_enable_msync3             24
#define DFLT_VAL_NX51_vic_int_enable_msync3        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_msync3     0x00000000U
#define MSK_NX51_vic_int_enable_int_phy            0x02000000U
#define SRT_NX51_vic_int_enable_int_phy            25
#define DFLT_VAL_NX51_vic_int_enable_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_int_phy    0x00000000U
#define MSK_NX51_vic_int_enable_sysstate           0x04000000U
#define SRT_NX51_vic_int_enable_sysstate           26
#define DFLT_VAL_NX51_vic_int_enable_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_sysstate   0x00000000U
#define MSK_NX51_vic_int_enable_dmac               0x08000000U
#define SRT_NX51_vic_int_enable_dmac               27
#define DFLT_VAL_NX51_vic_int_enable_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_dmac       0x00000000U
#define MSK_NX51_vic_int_enable_trigger_lt         0x10000000U
#define SRT_NX51_vic_int_enable_trigger_lt         28
#define DFLT_VAL_NX51_vic_int_enable_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_trigger_lt 0x00000000U
#define MSK_NX51_vic_int_enable_can                0x20000000U
#define SRT_NX51_vic_int_enable_can                29
#define DFLT_VAL_NX51_vic_int_enable_can           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_can        0x00000000U
#define MSK_NX51_vic_int_enable_osac               0x40000000U
#define SRT_NX51_vic_int_enable_osac               30
#define DFLT_VAL_NX51_vic_int_enable_osac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_osac       0x00000000U
#define MSK_NX51_vic_int_enable_reserved31         0x80000000U
#define SRT_NX51_vic_int_enable_reserved31         31
#define DFLT_VAL_NX51_vic_int_enable_reserved31    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enable_reserved31 0x00000000U

/* all used bits of 'NX51_vic_int_enable': */
#define MSK_USED_BITS_NX51_vic_int_enable 0xffffffffU

enum {
	BFW_NX51_vic_int_enable_sw0        = 1, /* [0] */
	BFW_NX51_vic_int_enable_timer0     = 1, /* [1] */
	BFW_NX51_vic_int_enable_timer1     = 1, /* [2] */
	BFW_NX51_vic_int_enable_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_int_enable_systime_ns = 1, /* [4] */
	BFW_NX51_vic_int_enable_systime_s  = 1, /* [5] */
	BFW_NX51_vic_int_enable_gpio31     = 1, /* [6] */
	BFW_NX51_vic_int_enable_watchdog   = 1, /* [7] */
	BFW_NX51_vic_int_enable_uart0      = 1, /* [8] */
	BFW_NX51_vic_int_enable_uart1      = 1, /* [9] */
	BFW_NX51_vic_int_enable_uart2      = 1, /* [10] */
	BFW_NX51_vic_int_enable_usb        = 1, /* [11] */
	BFW_NX51_vic_int_enable_spi        = 1, /* [12] */
	BFW_NX51_vic_int_enable_i2c        = 1, /* [13] */
	BFW_NX51_vic_int_enable_reserved14 = 1, /* [14] */
	BFW_NX51_vic_int_enable_hif        = 1, /* [15] */
	BFW_NX51_vic_int_enable_gpio       = 1, /* [16] */
	BFW_NX51_vic_int_enable_com0       = 1, /* [17] */
	BFW_NX51_vic_int_enable_com1       = 1, /* [18] */
	BFW_NX51_vic_int_enable_com2       = 1, /* [19] */
	BFW_NX51_vic_int_enable_com3       = 1, /* [20] */
	BFW_NX51_vic_int_enable_msync0     = 1, /* [21] */
	BFW_NX51_vic_int_enable_msync1     = 1, /* [22] */
	BFW_NX51_vic_int_enable_msync2     = 1, /* [23] */
	BFW_NX51_vic_int_enable_msync3     = 1, /* [24] */
	BFW_NX51_vic_int_enable_int_phy    = 1, /* [25] */
	BFW_NX51_vic_int_enable_sysstate   = 1, /* [26] */
	BFW_NX51_vic_int_enable_dmac       = 1, /* [27] */
	BFW_NX51_vic_int_enable_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_int_enable_can        = 1, /* [29] */
	BFW_NX51_vic_int_enable_osac       = 1, /* [30] */
	BFW_NX51_vic_int_enable_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_INT_ENABLE_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_int_enable_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_int_enable_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                              /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_int_enable_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_int_enable_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                              /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_int_enable_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_int_enable_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_int_enable_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_int_enable_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_int_enable_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_int_enable_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_int_enable_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_int_enable_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_int_enable_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_int_enable_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_int_enable_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_int_enable_hif;        /* combined HIF interrupt:                                               */
	                                                              /*  - DPM module IRQs for ARM,                                           */
	                                                              /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                              /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                              /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_int_enable_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_int_enable_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_int_enable_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_int_enable_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_int_enable_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_int_enable_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_int_enable_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_int_enable_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_int_enable_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_int_enable_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_int_enable_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                              /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_int_enable_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_int_enable_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_int_enable_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_int_enable_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_int_enable_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_INT_ENABLE_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_INT_ENABLE_BIT_T bf;
} NX51_VIC_INT_ENABLE_T;

/* --------------------------------------------------------------------- */
/* Register vic_int_enclear */
/* => VIC Interrupt enable clear register: */
/*    clear interrupt enable bits */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_int_enclear  0x00000014U
#define Adr_NX51_vic_vic_int_enclear  0x101FF014U
#define Adr_NX51_vic_int_enclear      0x101FF014U
#define DFLT_VAL_NX51_vic_int_enclear 0x00000000U

#define MSK_NX51_vic_int_enclear_sw0                0x00000001U
#define SRT_NX51_vic_int_enclear_sw0                0
#define DFLT_VAL_NX51_vic_int_enclear_sw0           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_sw0        0x00000000U
#define MSK_NX51_vic_int_enclear_timer0             0x00000002U
#define SRT_NX51_vic_int_enclear_timer0             1
#define DFLT_VAL_NX51_vic_int_enclear_timer0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_timer0     0x00000000U
#define MSK_NX51_vic_int_enclear_timer1             0x00000004U
#define SRT_NX51_vic_int_enclear_timer1             2
#define DFLT_VAL_NX51_vic_int_enclear_timer1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_timer1     0x00000000U
#define MSK_NX51_vic_int_enclear_gpio_timer         0x00000008U
#define SRT_NX51_vic_int_enclear_gpio_timer         3
#define DFLT_VAL_NX51_vic_int_enclear_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_gpio_timer 0x00000000U
#define MSK_NX51_vic_int_enclear_systime_ns         0x00000010U
#define SRT_NX51_vic_int_enclear_systime_ns         4
#define DFLT_VAL_NX51_vic_int_enclear_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_systime_ns 0x00000000U
#define MSK_NX51_vic_int_enclear_systime_s          0x00000020U
#define SRT_NX51_vic_int_enclear_systime_s          5
#define DFLT_VAL_NX51_vic_int_enclear_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_systime_s  0x00000000U
#define MSK_NX51_vic_int_enclear_gpio31             0x00000040U
#define SRT_NX51_vic_int_enclear_gpio31             6
#define DFLT_VAL_NX51_vic_int_enclear_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_gpio31     0x00000000U
#define MSK_NX51_vic_int_enclear_watchdog           0x00000080U
#define SRT_NX51_vic_int_enclear_watchdog           7
#define DFLT_VAL_NX51_vic_int_enclear_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_watchdog   0x00000000U
#define MSK_NX51_vic_int_enclear_uart0              0x00000100U
#define SRT_NX51_vic_int_enclear_uart0              8
#define DFLT_VAL_NX51_vic_int_enclear_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_uart0      0x00000000U
#define MSK_NX51_vic_int_enclear_uart1              0x00000200U
#define SRT_NX51_vic_int_enclear_uart1              9
#define DFLT_VAL_NX51_vic_int_enclear_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_uart1      0x00000000U
#define MSK_NX51_vic_int_enclear_uart2              0x00000400U
#define SRT_NX51_vic_int_enclear_uart2              10
#define DFLT_VAL_NX51_vic_int_enclear_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_uart2      0x00000000U
#define MSK_NX51_vic_int_enclear_usb                0x00000800U
#define SRT_NX51_vic_int_enclear_usb                11
#define DFLT_VAL_NX51_vic_int_enclear_usb           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_usb        0x00000000U
#define MSK_NX51_vic_int_enclear_spi                0x00001000U
#define SRT_NX51_vic_int_enclear_spi                12
#define DFLT_VAL_NX51_vic_int_enclear_spi           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_spi        0x00000000U
#define MSK_NX51_vic_int_enclear_i2c                0x00002000U
#define SRT_NX51_vic_int_enclear_i2c                13
#define DFLT_VAL_NX51_vic_int_enclear_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_i2c        0x00000000U
#define MSK_NX51_vic_int_enclear_reserved14         0x00004000U
#define SRT_NX51_vic_int_enclear_reserved14         14
#define DFLT_VAL_NX51_vic_int_enclear_reserved14    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_reserved14 0x00000000U
#define MSK_NX51_vic_int_enclear_hif                0x00008000U
#define SRT_NX51_vic_int_enclear_hif                15
#define DFLT_VAL_NX51_vic_int_enclear_hif           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_hif        0x00000000U
#define MSK_NX51_vic_int_enclear_gpio               0x00010000U
#define SRT_NX51_vic_int_enclear_gpio               16
#define DFLT_VAL_NX51_vic_int_enclear_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_gpio       0x00000000U
#define MSK_NX51_vic_int_enclear_com0               0x00020000U
#define SRT_NX51_vic_int_enclear_com0               17
#define DFLT_VAL_NX51_vic_int_enclear_com0          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_com0       0x00000000U
#define MSK_NX51_vic_int_enclear_com1               0x00040000U
#define SRT_NX51_vic_int_enclear_com1               18
#define DFLT_VAL_NX51_vic_int_enclear_com1          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_com1       0x00000000U
#define MSK_NX51_vic_int_enclear_com2               0x00080000U
#define SRT_NX51_vic_int_enclear_com2               19
#define DFLT_VAL_NX51_vic_int_enclear_com2          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_com2       0x00000000U
#define MSK_NX51_vic_int_enclear_com3               0x00100000U
#define SRT_NX51_vic_int_enclear_com3               20
#define DFLT_VAL_NX51_vic_int_enclear_com3          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_com3       0x00000000U
#define MSK_NX51_vic_int_enclear_msync0             0x00200000U
#define SRT_NX51_vic_int_enclear_msync0             21
#define DFLT_VAL_NX51_vic_int_enclear_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_msync0     0x00000000U
#define MSK_NX51_vic_int_enclear_msync1             0x00400000U
#define SRT_NX51_vic_int_enclear_msync1             22
#define DFLT_VAL_NX51_vic_int_enclear_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_msync1     0x00000000U
#define MSK_NX51_vic_int_enclear_msync2             0x00800000U
#define SRT_NX51_vic_int_enclear_msync2             23
#define DFLT_VAL_NX51_vic_int_enclear_msync2        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_msync2     0x00000000U
#define MSK_NX51_vic_int_enclear_msync3             0x01000000U
#define SRT_NX51_vic_int_enclear_msync3             24
#define DFLT_VAL_NX51_vic_int_enclear_msync3        0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_msync3     0x00000000U
#define MSK_NX51_vic_int_enclear_int_phy            0x02000000U
#define SRT_NX51_vic_int_enclear_int_phy            25
#define DFLT_VAL_NX51_vic_int_enclear_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_int_phy    0x00000000U
#define MSK_NX51_vic_int_enclear_sysstate           0x04000000U
#define SRT_NX51_vic_int_enclear_sysstate           26
#define DFLT_VAL_NX51_vic_int_enclear_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_sysstate   0x00000000U
#define MSK_NX51_vic_int_enclear_dmac               0x08000000U
#define SRT_NX51_vic_int_enclear_dmac               27
#define DFLT_VAL_NX51_vic_int_enclear_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_dmac       0x00000000U
#define MSK_NX51_vic_int_enclear_trigger_lt         0x10000000U
#define SRT_NX51_vic_int_enclear_trigger_lt         28
#define DFLT_VAL_NX51_vic_int_enclear_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_trigger_lt 0x00000000U
#define MSK_NX51_vic_int_enclear_can                0x20000000U
#define SRT_NX51_vic_int_enclear_can                29
#define DFLT_VAL_NX51_vic_int_enclear_can           0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_can        0x00000000U
#define MSK_NX51_vic_int_enclear_osac               0x40000000U
#define SRT_NX51_vic_int_enclear_osac               30
#define DFLT_VAL_NX51_vic_int_enclear_osac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_osac       0x00000000U
#define MSK_NX51_vic_int_enclear_reserved31         0x80000000U
#define SRT_NX51_vic_int_enclear_reserved31         31
#define DFLT_VAL_NX51_vic_int_enclear_reserved31    0x00000000U
#define DFLT_BF_VAL_NX51_vic_int_enclear_reserved31 0x00000000U

/* all used bits of 'NX51_vic_int_enclear': */
#define MSK_USED_BITS_NX51_vic_int_enclear 0xffffffffU

enum {
	BFW_NX51_vic_int_enclear_sw0        = 1, /* [0] */
	BFW_NX51_vic_int_enclear_timer0     = 1, /* [1] */
	BFW_NX51_vic_int_enclear_timer1     = 1, /* [2] */
	BFW_NX51_vic_int_enclear_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_int_enclear_systime_ns = 1, /* [4] */
	BFW_NX51_vic_int_enclear_systime_s  = 1, /* [5] */
	BFW_NX51_vic_int_enclear_gpio31     = 1, /* [6] */
	BFW_NX51_vic_int_enclear_watchdog   = 1, /* [7] */
	BFW_NX51_vic_int_enclear_uart0      = 1, /* [8] */
	BFW_NX51_vic_int_enclear_uart1      = 1, /* [9] */
	BFW_NX51_vic_int_enclear_uart2      = 1, /* [10] */
	BFW_NX51_vic_int_enclear_usb        = 1, /* [11] */
	BFW_NX51_vic_int_enclear_spi        = 1, /* [12] */
	BFW_NX51_vic_int_enclear_i2c        = 1, /* [13] */
	BFW_NX51_vic_int_enclear_reserved14 = 1, /* [14] */
	BFW_NX51_vic_int_enclear_hif        = 1, /* [15] */
	BFW_NX51_vic_int_enclear_gpio       = 1, /* [16] */
	BFW_NX51_vic_int_enclear_com0       = 1, /* [17] */
	BFW_NX51_vic_int_enclear_com1       = 1, /* [18] */
	BFW_NX51_vic_int_enclear_com2       = 1, /* [19] */
	BFW_NX51_vic_int_enclear_com3       = 1, /* [20] */
	BFW_NX51_vic_int_enclear_msync0     = 1, /* [21] */
	BFW_NX51_vic_int_enclear_msync1     = 1, /* [22] */
	BFW_NX51_vic_int_enclear_msync2     = 1, /* [23] */
	BFW_NX51_vic_int_enclear_msync3     = 1, /* [24] */
	BFW_NX51_vic_int_enclear_int_phy    = 1, /* [25] */
	BFW_NX51_vic_int_enclear_sysstate   = 1, /* [26] */
	BFW_NX51_vic_int_enclear_dmac       = 1, /* [27] */
	BFW_NX51_vic_int_enclear_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_int_enclear_can        = 1, /* [29] */
	BFW_NX51_vic_int_enclear_osac       = 1, /* [30] */
	BFW_NX51_vic_int_enclear_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_INT_ENCLEAR_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_int_enclear_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_int_enclear_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                               /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_int_enclear_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_int_enclear_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                               /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_int_enclear_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_int_enclear_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_int_enclear_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_int_enclear_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_int_enclear_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_int_enclear_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_int_enclear_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_int_enclear_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_int_enclear_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_int_enclear_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_int_enclear_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_int_enclear_hif;        /* combined HIF interrupt:                                               */
	                                                               /*  - DPM module IRQs for ARM,                                           */
	                                                               /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                               /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                               /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_int_enclear_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_int_enclear_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_int_enclear_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_int_enclear_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_int_enclear_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_int_enclear_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_int_enclear_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_int_enclear_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_int_enclear_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_int_enclear_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_int_enclear_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                               /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_int_enclear_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_int_enclear_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_int_enclear_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_int_enclear_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_int_enclear_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_INT_ENCLEAR_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_INT_ENCLEAR_BIT_T bf;
} NX51_VIC_INT_ENCLEAR_T;

/* --------------------------------------------------------------------- */
/* Register vic_softint */
/* => VIC Software interrupt register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_softint  0x00000018U
#define Adr_NX51_vic_vic_softint  0x101FF018U
#define Adr_NX51_vic_softint      0x101FF018U
#define DFLT_VAL_NX51_vic_softint 0x00000000U

#define MSK_NX51_vic_softint_sw0                0x00000001U
#define SRT_NX51_vic_softint_sw0                0
#define DFLT_VAL_NX51_vic_softint_sw0           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_sw0        0x00000000U
#define MSK_NX51_vic_softint_timer0             0x00000002U
#define SRT_NX51_vic_softint_timer0             1
#define DFLT_VAL_NX51_vic_softint_timer0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_timer0     0x00000000U
#define MSK_NX51_vic_softint_timer1             0x00000004U
#define SRT_NX51_vic_softint_timer1             2
#define DFLT_VAL_NX51_vic_softint_timer1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_timer1     0x00000000U
#define MSK_NX51_vic_softint_gpio_timer         0x00000008U
#define SRT_NX51_vic_softint_gpio_timer         3
#define DFLT_VAL_NX51_vic_softint_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_gpio_timer 0x00000000U
#define MSK_NX51_vic_softint_systime_ns         0x00000010U
#define SRT_NX51_vic_softint_systime_ns         4
#define DFLT_VAL_NX51_vic_softint_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_systime_ns 0x00000000U
#define MSK_NX51_vic_softint_systime_s          0x00000020U
#define SRT_NX51_vic_softint_systime_s          5
#define DFLT_VAL_NX51_vic_softint_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_systime_s  0x00000000U
#define MSK_NX51_vic_softint_gpio31             0x00000040U
#define SRT_NX51_vic_softint_gpio31             6
#define DFLT_VAL_NX51_vic_softint_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_gpio31     0x00000000U
#define MSK_NX51_vic_softint_watchdog           0x00000080U
#define SRT_NX51_vic_softint_watchdog           7
#define DFLT_VAL_NX51_vic_softint_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_watchdog   0x00000000U
#define MSK_NX51_vic_softint_uart0              0x00000100U
#define SRT_NX51_vic_softint_uart0              8
#define DFLT_VAL_NX51_vic_softint_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_uart0      0x00000000U
#define MSK_NX51_vic_softint_uart1              0x00000200U
#define SRT_NX51_vic_softint_uart1              9
#define DFLT_VAL_NX51_vic_softint_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_uart1      0x00000000U
#define MSK_NX51_vic_softint_uart2              0x00000400U
#define SRT_NX51_vic_softint_uart2              10
#define DFLT_VAL_NX51_vic_softint_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_uart2      0x00000000U
#define MSK_NX51_vic_softint_usb                0x00000800U
#define SRT_NX51_vic_softint_usb                11
#define DFLT_VAL_NX51_vic_softint_usb           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_usb        0x00000000U
#define MSK_NX51_vic_softint_spi                0x00001000U
#define SRT_NX51_vic_softint_spi                12
#define DFLT_VAL_NX51_vic_softint_spi           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_spi        0x00000000U
#define MSK_NX51_vic_softint_i2c                0x00002000U
#define SRT_NX51_vic_softint_i2c                13
#define DFLT_VAL_NX51_vic_softint_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_i2c        0x00000000U
#define MSK_NX51_vic_softint_reserved14         0x00004000U
#define SRT_NX51_vic_softint_reserved14         14
#define DFLT_VAL_NX51_vic_softint_reserved14    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_reserved14 0x00000000U
#define MSK_NX51_vic_softint_hif                0x00008000U
#define SRT_NX51_vic_softint_hif                15
#define DFLT_VAL_NX51_vic_softint_hif           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_hif        0x00000000U
#define MSK_NX51_vic_softint_gpio               0x00010000U
#define SRT_NX51_vic_softint_gpio               16
#define DFLT_VAL_NX51_vic_softint_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_gpio       0x00000000U
#define MSK_NX51_vic_softint_com0               0x00020000U
#define SRT_NX51_vic_softint_com0               17
#define DFLT_VAL_NX51_vic_softint_com0          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_com0       0x00000000U
#define MSK_NX51_vic_softint_com1               0x00040000U
#define SRT_NX51_vic_softint_com1               18
#define DFLT_VAL_NX51_vic_softint_com1          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_com1       0x00000000U
#define MSK_NX51_vic_softint_com2               0x00080000U
#define SRT_NX51_vic_softint_com2               19
#define DFLT_VAL_NX51_vic_softint_com2          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_com2       0x00000000U
#define MSK_NX51_vic_softint_com3               0x00100000U
#define SRT_NX51_vic_softint_com3               20
#define DFLT_VAL_NX51_vic_softint_com3          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_com3       0x00000000U
#define MSK_NX51_vic_softint_msync0             0x00200000U
#define SRT_NX51_vic_softint_msync0             21
#define DFLT_VAL_NX51_vic_softint_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_msync0     0x00000000U
#define MSK_NX51_vic_softint_msync1             0x00400000U
#define SRT_NX51_vic_softint_msync1             22
#define DFLT_VAL_NX51_vic_softint_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_msync1     0x00000000U
#define MSK_NX51_vic_softint_msync2             0x00800000U
#define SRT_NX51_vic_softint_msync2             23
#define DFLT_VAL_NX51_vic_softint_msync2        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_msync2     0x00000000U
#define MSK_NX51_vic_softint_msync3             0x01000000U
#define SRT_NX51_vic_softint_msync3             24
#define DFLT_VAL_NX51_vic_softint_msync3        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_msync3     0x00000000U
#define MSK_NX51_vic_softint_int_phy            0x02000000U
#define SRT_NX51_vic_softint_int_phy            25
#define DFLT_VAL_NX51_vic_softint_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_int_phy    0x00000000U
#define MSK_NX51_vic_softint_sysstate           0x04000000U
#define SRT_NX51_vic_softint_sysstate           26
#define DFLT_VAL_NX51_vic_softint_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_sysstate   0x00000000U
#define MSK_NX51_vic_softint_dmac               0x08000000U
#define SRT_NX51_vic_softint_dmac               27
#define DFLT_VAL_NX51_vic_softint_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_dmac       0x00000000U
#define MSK_NX51_vic_softint_trigger_lt         0x10000000U
#define SRT_NX51_vic_softint_trigger_lt         28
#define DFLT_VAL_NX51_vic_softint_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_trigger_lt 0x00000000U
#define MSK_NX51_vic_softint_can                0x20000000U
#define SRT_NX51_vic_softint_can                29
#define DFLT_VAL_NX51_vic_softint_can           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_can        0x00000000U
#define MSK_NX51_vic_softint_osac               0x40000000U
#define SRT_NX51_vic_softint_osac               30
#define DFLT_VAL_NX51_vic_softint_osac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_osac       0x00000000U
#define MSK_NX51_vic_softint_reserved31         0x80000000U
#define SRT_NX51_vic_softint_reserved31         31
#define DFLT_VAL_NX51_vic_softint_reserved31    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_reserved31 0x00000000U

/* all used bits of 'NX51_vic_softint': */
#define MSK_USED_BITS_NX51_vic_softint 0xffffffffU

enum {
	BFW_NX51_vic_softint_sw0        = 1, /* [0] */
	BFW_NX51_vic_softint_timer0     = 1, /* [1] */
	BFW_NX51_vic_softint_timer1     = 1, /* [2] */
	BFW_NX51_vic_softint_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_softint_systime_ns = 1, /* [4] */
	BFW_NX51_vic_softint_systime_s  = 1, /* [5] */
	BFW_NX51_vic_softint_gpio31     = 1, /* [6] */
	BFW_NX51_vic_softint_watchdog   = 1, /* [7] */
	BFW_NX51_vic_softint_uart0      = 1, /* [8] */
	BFW_NX51_vic_softint_uart1      = 1, /* [9] */
	BFW_NX51_vic_softint_uart2      = 1, /* [10] */
	BFW_NX51_vic_softint_usb        = 1, /* [11] */
	BFW_NX51_vic_softint_spi        = 1, /* [12] */
	BFW_NX51_vic_softint_i2c        = 1, /* [13] */
	BFW_NX51_vic_softint_reserved14 = 1, /* [14] */
	BFW_NX51_vic_softint_hif        = 1, /* [15] */
	BFW_NX51_vic_softint_gpio       = 1, /* [16] */
	BFW_NX51_vic_softint_com0       = 1, /* [17] */
	BFW_NX51_vic_softint_com1       = 1, /* [18] */
	BFW_NX51_vic_softint_com2       = 1, /* [19] */
	BFW_NX51_vic_softint_com3       = 1, /* [20] */
	BFW_NX51_vic_softint_msync0     = 1, /* [21] */
	BFW_NX51_vic_softint_msync1     = 1, /* [22] */
	BFW_NX51_vic_softint_msync2     = 1, /* [23] */
	BFW_NX51_vic_softint_msync3     = 1, /* [24] */
	BFW_NX51_vic_softint_int_phy    = 1, /* [25] */
	BFW_NX51_vic_softint_sysstate   = 1, /* [26] */
	BFW_NX51_vic_softint_dmac       = 1, /* [27] */
	BFW_NX51_vic_softint_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_softint_can        = 1, /* [29] */
	BFW_NX51_vic_softint_osac       = 1, /* [30] */
	BFW_NX51_vic_softint_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_SOFTINT_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_softint_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_softint_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                           /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_softint_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_softint_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                           /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_softint_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_softint_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_softint_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_softint_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_softint_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_softint_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_softint_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_softint_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_softint_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_softint_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_softint_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_softint_hif;        /* combined HIF interrupt:                                               */
	                                                           /*  - DPM module IRQs for ARM,                                           */
	                                                           /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                           /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                           /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_softint_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_softint_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_softint_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_softint_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_softint_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_softint_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_softint_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_softint_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_softint_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_softint_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_softint_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                           /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_softint_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_softint_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_softint_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_softint_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_softint_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_SOFTINT_BIT_T;

typedef union {
	unsigned int           val;
	NX51_VIC_SOFTINT_BIT_T bf;
} NX51_VIC_SOFTINT_T;

/* --------------------------------------------------------------------- */
/* Register vic_softint_clear */
/* => VIC Software interrupt clear register: */
/*    clear software interrupt bits */
/* => Mode: W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_softint_clear  0x0000001CU
#define Adr_NX51_vic_vic_softint_clear  0x101FF01CU
#define Adr_NX51_vic_softint_clear      0x101FF01CU
#define DFLT_VAL_NX51_vic_softint_clear 0x00000000U

#define MSK_NX51_vic_softint_clear_sw0                0x00000001U
#define SRT_NX51_vic_softint_clear_sw0                0
#define DFLT_VAL_NX51_vic_softint_clear_sw0           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_sw0        0x00000000U
#define MSK_NX51_vic_softint_clear_timer0             0x00000002U
#define SRT_NX51_vic_softint_clear_timer0             1
#define DFLT_VAL_NX51_vic_softint_clear_timer0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_timer0     0x00000000U
#define MSK_NX51_vic_softint_clear_timer1             0x00000004U
#define SRT_NX51_vic_softint_clear_timer1             2
#define DFLT_VAL_NX51_vic_softint_clear_timer1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_timer1     0x00000000U
#define MSK_NX51_vic_softint_clear_gpio_timer         0x00000008U
#define SRT_NX51_vic_softint_clear_gpio_timer         3
#define DFLT_VAL_NX51_vic_softint_clear_gpio_timer    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_gpio_timer 0x00000000U
#define MSK_NX51_vic_softint_clear_systime_ns         0x00000010U
#define SRT_NX51_vic_softint_clear_systime_ns         4
#define DFLT_VAL_NX51_vic_softint_clear_systime_ns    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_systime_ns 0x00000000U
#define MSK_NX51_vic_softint_clear_systime_s          0x00000020U
#define SRT_NX51_vic_softint_clear_systime_s          5
#define DFLT_VAL_NX51_vic_softint_clear_systime_s     0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_systime_s  0x00000000U
#define MSK_NX51_vic_softint_clear_gpio31             0x00000040U
#define SRT_NX51_vic_softint_clear_gpio31             6
#define DFLT_VAL_NX51_vic_softint_clear_gpio31        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_gpio31     0x00000000U
#define MSK_NX51_vic_softint_clear_watchdog           0x00000080U
#define SRT_NX51_vic_softint_clear_watchdog           7
#define DFLT_VAL_NX51_vic_softint_clear_watchdog      0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_watchdog   0x00000000U
#define MSK_NX51_vic_softint_clear_uart0              0x00000100U
#define SRT_NX51_vic_softint_clear_uart0              8
#define DFLT_VAL_NX51_vic_softint_clear_uart0         0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_uart0      0x00000000U
#define MSK_NX51_vic_softint_clear_uart1              0x00000200U
#define SRT_NX51_vic_softint_clear_uart1              9
#define DFLT_VAL_NX51_vic_softint_clear_uart1         0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_uart1      0x00000000U
#define MSK_NX51_vic_softint_clear_uart2              0x00000400U
#define SRT_NX51_vic_softint_clear_uart2              10
#define DFLT_VAL_NX51_vic_softint_clear_uart2         0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_uart2      0x00000000U
#define MSK_NX51_vic_softint_clear_usb                0x00000800U
#define SRT_NX51_vic_softint_clear_usb                11
#define DFLT_VAL_NX51_vic_softint_clear_usb           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_usb        0x00000000U
#define MSK_NX51_vic_softint_clear_spi                0x00001000U
#define SRT_NX51_vic_softint_clear_spi                12
#define DFLT_VAL_NX51_vic_softint_clear_spi           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_spi        0x00000000U
#define MSK_NX51_vic_softint_clear_i2c                0x00002000U
#define SRT_NX51_vic_softint_clear_i2c                13
#define DFLT_VAL_NX51_vic_softint_clear_i2c           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_i2c        0x00000000U
#define MSK_NX51_vic_softint_clear_reserved14         0x00004000U
#define SRT_NX51_vic_softint_clear_reserved14         14
#define DFLT_VAL_NX51_vic_softint_clear_reserved14    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_reserved14 0x00000000U
#define MSK_NX51_vic_softint_clear_hif                0x00008000U
#define SRT_NX51_vic_softint_clear_hif                15
#define DFLT_VAL_NX51_vic_softint_clear_hif           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_hif        0x00000000U
#define MSK_NX51_vic_softint_clear_gpio               0x00010000U
#define SRT_NX51_vic_softint_clear_gpio               16
#define DFLT_VAL_NX51_vic_softint_clear_gpio          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_gpio       0x00000000U
#define MSK_NX51_vic_softint_clear_com0               0x00020000U
#define SRT_NX51_vic_softint_clear_com0               17
#define DFLT_VAL_NX51_vic_softint_clear_com0          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_com0       0x00000000U
#define MSK_NX51_vic_softint_clear_com1               0x00040000U
#define SRT_NX51_vic_softint_clear_com1               18
#define DFLT_VAL_NX51_vic_softint_clear_com1          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_com1       0x00000000U
#define MSK_NX51_vic_softint_clear_com2               0x00080000U
#define SRT_NX51_vic_softint_clear_com2               19
#define DFLT_VAL_NX51_vic_softint_clear_com2          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_com2       0x00000000U
#define MSK_NX51_vic_softint_clear_com3               0x00100000U
#define SRT_NX51_vic_softint_clear_com3               20
#define DFLT_VAL_NX51_vic_softint_clear_com3          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_com3       0x00000000U
#define MSK_NX51_vic_softint_clear_msync0             0x00200000U
#define SRT_NX51_vic_softint_clear_msync0             21
#define DFLT_VAL_NX51_vic_softint_clear_msync0        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_msync0     0x00000000U
#define MSK_NX51_vic_softint_clear_msync1             0x00400000U
#define SRT_NX51_vic_softint_clear_msync1             22
#define DFLT_VAL_NX51_vic_softint_clear_msync1        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_msync1     0x00000000U
#define MSK_NX51_vic_softint_clear_msync2             0x00800000U
#define SRT_NX51_vic_softint_clear_msync2             23
#define DFLT_VAL_NX51_vic_softint_clear_msync2        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_msync2     0x00000000U
#define MSK_NX51_vic_softint_clear_msync3             0x01000000U
#define SRT_NX51_vic_softint_clear_msync3             24
#define DFLT_VAL_NX51_vic_softint_clear_msync3        0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_msync3     0x00000000U
#define MSK_NX51_vic_softint_clear_int_phy            0x02000000U
#define SRT_NX51_vic_softint_clear_int_phy            25
#define DFLT_VAL_NX51_vic_softint_clear_int_phy       0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_int_phy    0x00000000U
#define MSK_NX51_vic_softint_clear_sysstate           0x04000000U
#define SRT_NX51_vic_softint_clear_sysstate           26
#define DFLT_VAL_NX51_vic_softint_clear_sysstate      0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_sysstate   0x00000000U
#define MSK_NX51_vic_softint_clear_dmac               0x08000000U
#define SRT_NX51_vic_softint_clear_dmac               27
#define DFLT_VAL_NX51_vic_softint_clear_dmac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_dmac       0x00000000U
#define MSK_NX51_vic_softint_clear_trigger_lt         0x10000000U
#define SRT_NX51_vic_softint_clear_trigger_lt         28
#define DFLT_VAL_NX51_vic_softint_clear_trigger_lt    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_trigger_lt 0x00000000U
#define MSK_NX51_vic_softint_clear_can                0x20000000U
#define SRT_NX51_vic_softint_clear_can                29
#define DFLT_VAL_NX51_vic_softint_clear_can           0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_can        0x00000000U
#define MSK_NX51_vic_softint_clear_osac               0x40000000U
#define SRT_NX51_vic_softint_clear_osac               30
#define DFLT_VAL_NX51_vic_softint_clear_osac          0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_osac       0x00000000U
#define MSK_NX51_vic_softint_clear_reserved31         0x80000000U
#define SRT_NX51_vic_softint_clear_reserved31         31
#define DFLT_VAL_NX51_vic_softint_clear_reserved31    0x00000000U
#define DFLT_BF_VAL_NX51_vic_softint_clear_reserved31 0x00000000U

/* all used bits of 'NX51_vic_softint_clear': */
#define MSK_USED_BITS_NX51_vic_softint_clear 0xffffffffU

enum {
	BFW_NX51_vic_softint_clear_sw0        = 1, /* [0] */
	BFW_NX51_vic_softint_clear_timer0     = 1, /* [1] */
	BFW_NX51_vic_softint_clear_timer1     = 1, /* [2] */
	BFW_NX51_vic_softint_clear_gpio_timer = 1, /* [3] */
	BFW_NX51_vic_softint_clear_systime_ns = 1, /* [4] */
	BFW_NX51_vic_softint_clear_systime_s  = 1, /* [5] */
	BFW_NX51_vic_softint_clear_gpio31     = 1, /* [6] */
	BFW_NX51_vic_softint_clear_watchdog   = 1, /* [7] */
	BFW_NX51_vic_softint_clear_uart0      = 1, /* [8] */
	BFW_NX51_vic_softint_clear_uart1      = 1, /* [9] */
	BFW_NX51_vic_softint_clear_uart2      = 1, /* [10] */
	BFW_NX51_vic_softint_clear_usb        = 1, /* [11] */
	BFW_NX51_vic_softint_clear_spi        = 1, /* [12] */
	BFW_NX51_vic_softint_clear_i2c        = 1, /* [13] */
	BFW_NX51_vic_softint_clear_reserved14 = 1, /* [14] */
	BFW_NX51_vic_softint_clear_hif        = 1, /* [15] */
	BFW_NX51_vic_softint_clear_gpio       = 1, /* [16] */
	BFW_NX51_vic_softint_clear_com0       = 1, /* [17] */
	BFW_NX51_vic_softint_clear_com1       = 1, /* [18] */
	BFW_NX51_vic_softint_clear_com2       = 1, /* [19] */
	BFW_NX51_vic_softint_clear_com3       = 1, /* [20] */
	BFW_NX51_vic_softint_clear_msync0     = 1, /* [21] */
	BFW_NX51_vic_softint_clear_msync1     = 1, /* [22] */
	BFW_NX51_vic_softint_clear_msync2     = 1, /* [23] */
	BFW_NX51_vic_softint_clear_msync3     = 1, /* [24] */
	BFW_NX51_vic_softint_clear_int_phy    = 1, /* [25] */
	BFW_NX51_vic_softint_clear_sysstate   = 1, /* [26] */
	BFW_NX51_vic_softint_clear_dmac       = 1, /* [27] */
	BFW_NX51_vic_softint_clear_trigger_lt = 1, /* [28] */
	BFW_NX51_vic_softint_clear_can        = 1, /* [29] */
	BFW_NX51_vic_softint_clear_osac       = 1, /* [30] */
	BFW_NX51_vic_softint_clear_reserved31 = 1  /* [31] */
};

typedef struct NX51_VIC_SOFTINT_CLEAR_BIT_Ttag {
	unsigned int sw0        : BFW_NX51_vic_softint_clear_sw0;        /* Reserved for Software Interrupt                                       */
	unsigned int timer0     : BFW_NX51_vic_softint_clear_timer0;     /* ARM Timer0 from ARM_TIMER Module                                      */
	                                                                 /* Real time operating system timer, Windows CE required                 */
	unsigned int timer1     : BFW_NX51_vic_softint_clear_timer1;     /* ARM Timer1 from ARM_TIMER Module                                      */
	unsigned int gpio_timer : BFW_NX51_vic_softint_clear_gpio_timer; /* GPIO Timer 0..4                                                       */
	                                                                 /* (sep. gpio_irq registers for ARM(intlogic) and xPIC(intlogic_motion)) */
	unsigned int systime_ns : BFW_NX51_vic_softint_clear_systime_ns; /* systime_ns/systime_uc_ns IRQ from ARM_TIMER module                    */
	unsigned int systime_s  : BFW_NX51_vic_softint_clear_systime_s;  /* systime_s/systime_uc_s IRQ from ARM_TIMER module                      */
	unsigned int gpio31     : BFW_NX51_vic_softint_clear_gpio31;     /* external interrupt 31, Windows CE required (NMI)                      */
	unsigned int watchdog   : BFW_NX51_vic_softint_clear_watchdog;   /* Watchdog IRQ from WDG_SYS and XPIC_WDG module                         */
	unsigned int uart0      : BFW_NX51_vic_softint_clear_uart0;      /* UART 0 -> Diagnostic channel, Windows CE required                     */
	unsigned int uart1      : BFW_NX51_vic_softint_clear_uart1;      /* UART 1                                                                */
	unsigned int uart2      : BFW_NX51_vic_softint_clear_uart2;      /* UART 2                                                                */
	unsigned int usb        : BFW_NX51_vic_softint_clear_usb;        /* USB interrupt                                                         */
	unsigned int spi        : BFW_NX51_vic_softint_clear_spi;        /* combined SPI0, SPI1 interrupt                                         */
	unsigned int i2c        : BFW_NX51_vic_softint_clear_i2c;        /* combined I2C0, I2C1 interrupt                                         */
	unsigned int reserved14 : BFW_NX51_vic_softint_clear_reserved14; /* reserved                                                              */
	unsigned int hif        : BFW_NX51_vic_softint_clear_hif;        /* combined HIF interrupt:                                               */
	                                                                 /*  - DPM module IRQs for ARM,                                           */
	                                                                 /*  - Handshake-Cells for ARM (HANDSHAKE_CTRL),                          */
	                                                                 /*  - HIF PIOs (HIF_IO_CTRL)                                             */
	                                                                 /*  - HIF ETH (ETH)                                                      */
	unsigned int gpio       : BFW_NX51_vic_softint_clear_gpio;       /* other external Interrupts from GPIO 0-30 / IOLINK                     */
	unsigned int com0       : BFW_NX51_vic_softint_clear_com0;       /* Communication channel 0 (= |xpec0_irq[11:0])                          */
	unsigned int com1       : BFW_NX51_vic_softint_clear_com1;       /* Communication channel 1 (= |xpec1_irq[11:0])                          */
	unsigned int com2       : BFW_NX51_vic_softint_clear_com2;       /* reserved for netX compatibility (com2)                                */
	unsigned int com3       : BFW_NX51_vic_softint_clear_com3;       /* xPIC Debug                                                            */
	unsigned int msync0     : BFW_NX51_vic_softint_clear_msync0;     /* Motion synchronization channel 0 (= |xpec0_irq[15:12])                */
	unsigned int msync1     : BFW_NX51_vic_softint_clear_msync1;     /* Motion synchronization channel 1 (= |xpec1_irq[15:12])                */
	unsigned int msync2     : BFW_NX51_vic_softint_clear_msync2;     /* reserved for netX compatibility (msync2)                              */
	unsigned int msync3     : BFW_NX51_vic_softint_clear_msync3;     /* reserved for SW IRQ from xPIC to ARM                                  */
	unsigned int int_phy    : BFW_NX51_vic_softint_clear_int_phy;    /* Interrupt from internal Phy                                           */
	unsigned int sysstate   : BFW_NX51_vic_softint_clear_sysstate;   /* License error or extmem_timeout or parity error                       */
	                                                                 /* see asic_ctrl-system_status                                           */
	unsigned int dmac       : BFW_NX51_vic_softint_clear_dmac;       /* DMA controller                                                        */
	unsigned int trigger_lt : BFW_NX51_vic_softint_clear_trigger_lt; /* trigger_lt                                                            */
	unsigned int can        : BFW_NX51_vic_softint_clear_can;        /* CAN IRQ                                                               */
	unsigned int osac       : BFW_NX51_vic_softint_clear_osac;       /* OSAC                                                                  */
	unsigned int reserved31 : BFW_NX51_vic_softint_clear_reserved31; /* reserved for netX compatibility for ADC0 or ADC1                      */
} NX51_VIC_SOFTINT_CLEAR_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_VIC_SOFTINT_CLEAR_BIT_T bf;
} NX51_VIC_SOFTINT_CLEAR_T;

/* --------------------------------------------------------------------- */
/* Register vic_protection */
/* => VIC Protection enable register */
/*    netX does not support protected mode, so this register is unused. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_protection  0x00000020U
#define Adr_NX51_vic_vic_protection  0x101FF020U
#define Adr_NX51_vic_protection      0x101FF020U
#define DFLT_VAL_NX51_vic_protection 0x00000000U

#define MSK_NX51_vic_protection_PROTECTION         0x00000001U
#define SRT_NX51_vic_protection_PROTECTION         0
#define DFLT_VAL_NX51_vic_protection_PROTECTION    0x00000000U
#define DFLT_BF_VAL_NX51_vic_protection_PROTECTION 0x00000000U

/* all used bits of 'NX51_vic_protection': */
#define MSK_USED_BITS_NX51_vic_protection 0x00000001U

enum {
	BFW_NX51_vic_protection_PROTECTION = 1,  /* [0] */
	BFW_NX51_vic_protection_reserved1  = 31  /* [31:1] */
};

typedef struct NX51_VIC_PROTECTION_BIT_Ttag {
	unsigned int PROTECTION : BFW_NX51_vic_protection_PROTECTION; /* enables or disables protected register access */
	unsigned int reserved1  : BFW_NX51_vic_protection_reserved1;  /* reserved                                      */
} NX51_VIC_PROTECTION_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_PROTECTION_BIT_T bf;
} NX51_VIC_PROTECTION_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr */
/* => VIC Vector address register */
/*    Any writes to this register clear the interrupt. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr  0x00000030U
#define Adr_NX51_vic_vic_vect_addr  0x101FF030U
#define Adr_NX51_vic_vect_addr      0x101FF030U
#define DFLT_VAL_NX51_vic_vect_addr 0x00000000U

#define MSK_NX51_vic_vect_addr_VECT_ADDR         0xffffffffU
#define SRT_NX51_vic_vect_addr_VECT_ADDR         0
#define DFLT_VAL_NX51_vic_vect_addr_VECT_ADDR    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr_VECT_ADDR 0x00000000U

/* all used bits of 'NX51_vic_vect_addr': */
#define MSK_USED_BITS_NX51_vic_vect_addr 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr_VECT_ADDR = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR_BIT_Ttag {
	unsigned int VECT_ADDR : BFW_NX51_vic_vect_addr_VECT_ADDR; /* address of the currently active ISR handler */
} NX51_VIC_VECT_ADDR_BIT_T;

typedef union {
	unsigned int             val;
	NX51_VIC_VECT_ADDR_BIT_T bf;
} NX51_VIC_VECT_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register vic_def_vect_addr */
/* => VIC Default vector address register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_def_vect_addr  0x00000034U
#define Adr_NX51_vic_vic_def_vect_addr  0x101FF034U
#define Adr_NX51_vic_def_vect_addr      0x101FF034U
#define DFLT_VAL_NX51_vic_def_vect_addr 0x00000000U

#define MSK_NX51_vic_def_vect_addr_DEF_VECT_ADDR         0xffffffffU
#define SRT_NX51_vic_def_vect_addr_DEF_VECT_ADDR         0
#define DFLT_VAL_NX51_vic_def_vect_addr_DEF_VECT_ADDR    0x00000000U
#define DFLT_BF_VAL_NX51_vic_def_vect_addr_DEF_VECT_ADDR 0x00000000U

/* all used bits of 'NX51_vic_def_vect_addr': */
#define MSK_USED_BITS_NX51_vic_def_vect_addr 0xffffffffU

enum {
	BFW_NX51_vic_def_vect_addr_DEF_VECT_ADDR = 32  /* [31:0] */
};

typedef struct NX51_VIC_DEF_VECT_ADDR_BIT_Ttag {
	unsigned int DEF_VECT_ADDR : BFW_NX51_vic_def_vect_addr_DEF_VECT_ADDR; /* address of the default ISR handler */
} NX51_VIC_DEF_VECT_ADDR_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_VIC_DEF_VECT_ADDR_BIT_T bf;
} NX51_VIC_DEF_VECT_ADDR_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr0 */
/* => VIC Vector address 0 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr0  0x00000100U
#define Adr_NX51_vic_vic_vect_addr0  0x101FF100U
#define Adr_NX51_vic_vect_addr0      0x101FF100U
#define DFLT_VAL_NX51_vic_vect_addr0 0x00000000U

#define MSK_NX51_vic_vect_addr0_VECT_ADDR0         0xffffffffU
#define SRT_NX51_vic_vect_addr0_VECT_ADDR0         0
#define DFLT_VAL_NX51_vic_vect_addr0_VECT_ADDR0    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr0_VECT_ADDR0 0x00000000U

/* all used bits of 'NX51_vic_vect_addr0': */
#define MSK_USED_BITS_NX51_vic_vect_addr0 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr0_VECT_ADDR0 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR0_BIT_Ttag {
	unsigned int VECT_ADDR0 : BFW_NX51_vic_vect_addr0_VECT_ADDR0; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR0_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR0_BIT_T bf;
} NX51_VIC_VECT_ADDR0_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr1 */
/* => VIC Vector address 1 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr1  0x00000104U
#define Adr_NX51_vic_vic_vect_addr1  0x101FF104U
#define Adr_NX51_vic_vect_addr1      0x101FF104U
#define DFLT_VAL_NX51_vic_vect_addr1 0x00000000U

#define MSK_NX51_vic_vect_addr1_VECT_ADDR1         0xffffffffU
#define SRT_NX51_vic_vect_addr1_VECT_ADDR1         0
#define DFLT_VAL_NX51_vic_vect_addr1_VECT_ADDR1    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr1_VECT_ADDR1 0x00000000U

/* all used bits of 'NX51_vic_vect_addr1': */
#define MSK_USED_BITS_NX51_vic_vect_addr1 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr1_VECT_ADDR1 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR1_BIT_Ttag {
	unsigned int VECT_ADDR1 : BFW_NX51_vic_vect_addr1_VECT_ADDR1; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR1_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR1_BIT_T bf;
} NX51_VIC_VECT_ADDR1_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr2 */
/* => VIC Vector address 2 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr2  0x00000108U
#define Adr_NX51_vic_vic_vect_addr2  0x101FF108U
#define Adr_NX51_vic_vect_addr2      0x101FF108U
#define DFLT_VAL_NX51_vic_vect_addr2 0x00000000U

#define MSK_NX51_vic_vect_addr2_VECT_ADDR2         0xffffffffU
#define SRT_NX51_vic_vect_addr2_VECT_ADDR2         0
#define DFLT_VAL_NX51_vic_vect_addr2_VECT_ADDR2    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr2_VECT_ADDR2 0x00000000U

/* all used bits of 'NX51_vic_vect_addr2': */
#define MSK_USED_BITS_NX51_vic_vect_addr2 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr2_VECT_ADDR2 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR2_BIT_Ttag {
	unsigned int VECT_ADDR2 : BFW_NX51_vic_vect_addr2_VECT_ADDR2; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR2_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR2_BIT_T bf;
} NX51_VIC_VECT_ADDR2_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr3 */
/* => VIC Vector address 3 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr3  0x0000010CU
#define Adr_NX51_vic_vic_vect_addr3  0x101FF10CU
#define Adr_NX51_vic_vect_addr3      0x101FF10CU
#define DFLT_VAL_NX51_vic_vect_addr3 0x00000000U

#define MSK_NX51_vic_vect_addr3_VECT_ADDR3         0xffffffffU
#define SRT_NX51_vic_vect_addr3_VECT_ADDR3         0
#define DFLT_VAL_NX51_vic_vect_addr3_VECT_ADDR3    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr3_VECT_ADDR3 0x00000000U

/* all used bits of 'NX51_vic_vect_addr3': */
#define MSK_USED_BITS_NX51_vic_vect_addr3 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr3_VECT_ADDR3 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR3_BIT_Ttag {
	unsigned int VECT_ADDR3 : BFW_NX51_vic_vect_addr3_VECT_ADDR3; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR3_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR3_BIT_T bf;
} NX51_VIC_VECT_ADDR3_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr4 */
/* => VIC Vector address 4 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr4  0x00000110U
#define Adr_NX51_vic_vic_vect_addr4  0x101FF110U
#define Adr_NX51_vic_vect_addr4      0x101FF110U
#define DFLT_VAL_NX51_vic_vect_addr4 0x00000000U

#define MSK_NX51_vic_vect_addr4_VECT_ADDR4         0xffffffffU
#define SRT_NX51_vic_vect_addr4_VECT_ADDR4         0
#define DFLT_VAL_NX51_vic_vect_addr4_VECT_ADDR4    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr4_VECT_ADDR4 0x00000000U

/* all used bits of 'NX51_vic_vect_addr4': */
#define MSK_USED_BITS_NX51_vic_vect_addr4 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr4_VECT_ADDR4 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR4_BIT_Ttag {
	unsigned int VECT_ADDR4 : BFW_NX51_vic_vect_addr4_VECT_ADDR4; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR4_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR4_BIT_T bf;
} NX51_VIC_VECT_ADDR4_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr5 */
/* => VIC Vector address 5 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr5  0x00000114U
#define Adr_NX51_vic_vic_vect_addr5  0x101FF114U
#define Adr_NX51_vic_vect_addr5      0x101FF114U
#define DFLT_VAL_NX51_vic_vect_addr5 0x00000000U

#define MSK_NX51_vic_vect_addr5_VECT_ADDR5         0xffffffffU
#define SRT_NX51_vic_vect_addr5_VECT_ADDR5         0
#define DFLT_VAL_NX51_vic_vect_addr5_VECT_ADDR5    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr5_VECT_ADDR5 0x00000000U

/* all used bits of 'NX51_vic_vect_addr5': */
#define MSK_USED_BITS_NX51_vic_vect_addr5 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr5_VECT_ADDR5 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR5_BIT_Ttag {
	unsigned int VECT_ADDR5 : BFW_NX51_vic_vect_addr5_VECT_ADDR5; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR5_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR5_BIT_T bf;
} NX51_VIC_VECT_ADDR5_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr6 */
/* => VIC Vector address 6 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr6  0x00000118U
#define Adr_NX51_vic_vic_vect_addr6  0x101FF118U
#define Adr_NX51_vic_vect_addr6      0x101FF118U
#define DFLT_VAL_NX51_vic_vect_addr6 0x00000000U

#define MSK_NX51_vic_vect_addr6_VECT_ADDR6         0xffffffffU
#define SRT_NX51_vic_vect_addr6_VECT_ADDR6         0
#define DFLT_VAL_NX51_vic_vect_addr6_VECT_ADDR6    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr6_VECT_ADDR6 0x00000000U

/* all used bits of 'NX51_vic_vect_addr6': */
#define MSK_USED_BITS_NX51_vic_vect_addr6 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr6_VECT_ADDR6 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR6_BIT_Ttag {
	unsigned int VECT_ADDR6 : BFW_NX51_vic_vect_addr6_VECT_ADDR6; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR6_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR6_BIT_T bf;
} NX51_VIC_VECT_ADDR6_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr7 */
/* => VIC Vector address 7 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr7  0x0000011CU
#define Adr_NX51_vic_vic_vect_addr7  0x101FF11CU
#define Adr_NX51_vic_vect_addr7      0x101FF11CU
#define DFLT_VAL_NX51_vic_vect_addr7 0x00000000U

#define MSK_NX51_vic_vect_addr7_VECT_ADDR7         0xffffffffU
#define SRT_NX51_vic_vect_addr7_VECT_ADDR7         0
#define DFLT_VAL_NX51_vic_vect_addr7_VECT_ADDR7    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr7_VECT_ADDR7 0x00000000U

/* all used bits of 'NX51_vic_vect_addr7': */
#define MSK_USED_BITS_NX51_vic_vect_addr7 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr7_VECT_ADDR7 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR7_BIT_Ttag {
	unsigned int VECT_ADDR7 : BFW_NX51_vic_vect_addr7_VECT_ADDR7; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR7_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR7_BIT_T bf;
} NX51_VIC_VECT_ADDR7_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr8 */
/* => VIC Vector address 8 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr8  0x00000120U
#define Adr_NX51_vic_vic_vect_addr8  0x101FF120U
#define Adr_NX51_vic_vect_addr8      0x101FF120U
#define DFLT_VAL_NX51_vic_vect_addr8 0x00000000U

#define MSK_NX51_vic_vect_addr8_VECT_ADDR8         0xffffffffU
#define SRT_NX51_vic_vect_addr8_VECT_ADDR8         0
#define DFLT_VAL_NX51_vic_vect_addr8_VECT_ADDR8    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr8_VECT_ADDR8 0x00000000U

/* all used bits of 'NX51_vic_vect_addr8': */
#define MSK_USED_BITS_NX51_vic_vect_addr8 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr8_VECT_ADDR8 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR8_BIT_Ttag {
	unsigned int VECT_ADDR8 : BFW_NX51_vic_vect_addr8_VECT_ADDR8; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR8_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR8_BIT_T bf;
} NX51_VIC_VECT_ADDR8_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr9 */
/* => VIC Vector address 9 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr9  0x00000124U
#define Adr_NX51_vic_vic_vect_addr9  0x101FF124U
#define Adr_NX51_vic_vect_addr9      0x101FF124U
#define DFLT_VAL_NX51_vic_vect_addr9 0x00000000U

#define MSK_NX51_vic_vect_addr9_VECT_ADDR9         0xffffffffU
#define SRT_NX51_vic_vect_addr9_VECT_ADDR9         0
#define DFLT_VAL_NX51_vic_vect_addr9_VECT_ADDR9    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr9_VECT_ADDR9 0x00000000U

/* all used bits of 'NX51_vic_vect_addr9': */
#define MSK_USED_BITS_NX51_vic_vect_addr9 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr9_VECT_ADDR9 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR9_BIT_Ttag {
	unsigned int VECT_ADDR9 : BFW_NX51_vic_vect_addr9_VECT_ADDR9; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR9_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_ADDR9_BIT_T bf;
} NX51_VIC_VECT_ADDR9_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr10 */
/* => VIC Vector address 10 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr10  0x00000128U
#define Adr_NX51_vic_vic_vect_addr10  0x101FF128U
#define Adr_NX51_vic_vect_addr10      0x101FF128U
#define DFLT_VAL_NX51_vic_vect_addr10 0x00000000U

#define MSK_NX51_vic_vect_addr10_VECT_ADDR10         0xffffffffU
#define SRT_NX51_vic_vect_addr10_VECT_ADDR10         0
#define DFLT_VAL_NX51_vic_vect_addr10_VECT_ADDR10    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr10_VECT_ADDR10 0x00000000U

/* all used bits of 'NX51_vic_vect_addr10': */
#define MSK_USED_BITS_NX51_vic_vect_addr10 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr10_VECT_ADDR10 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR10_BIT_Ttag {
	unsigned int VECT_ADDR10 : BFW_NX51_vic_vect_addr10_VECT_ADDR10; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR10_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_ADDR10_BIT_T bf;
} NX51_VIC_VECT_ADDR10_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr11 */
/* => VIC Vector address 11 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr11  0x0000012CU
#define Adr_NX51_vic_vic_vect_addr11  0x101FF12CU
#define Adr_NX51_vic_vect_addr11      0x101FF12CU
#define DFLT_VAL_NX51_vic_vect_addr11 0x00000000U

#define MSK_NX51_vic_vect_addr11_VECT_ADDR11         0xffffffffU
#define SRT_NX51_vic_vect_addr11_VECT_ADDR11         0
#define DFLT_VAL_NX51_vic_vect_addr11_VECT_ADDR11    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr11_VECT_ADDR11 0x00000000U

/* all used bits of 'NX51_vic_vect_addr11': */
#define MSK_USED_BITS_NX51_vic_vect_addr11 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr11_VECT_ADDR11 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR11_BIT_Ttag {
	unsigned int VECT_ADDR11 : BFW_NX51_vic_vect_addr11_VECT_ADDR11; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR11_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_ADDR11_BIT_T bf;
} NX51_VIC_VECT_ADDR11_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr12 */
/* => VIC Vector address 12 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr12  0x00000130U
#define Adr_NX51_vic_vic_vect_addr12  0x101FF130U
#define Adr_NX51_vic_vect_addr12      0x101FF130U
#define DFLT_VAL_NX51_vic_vect_addr12 0x00000000U

#define MSK_NX51_vic_vect_addr12_VECT_ADDR12         0xffffffffU
#define SRT_NX51_vic_vect_addr12_VECT_ADDR12         0
#define DFLT_VAL_NX51_vic_vect_addr12_VECT_ADDR12    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr12_VECT_ADDR12 0x00000000U

/* all used bits of 'NX51_vic_vect_addr12': */
#define MSK_USED_BITS_NX51_vic_vect_addr12 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr12_VECT_ADDR12 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR12_BIT_Ttag {
	unsigned int VECT_ADDR12 : BFW_NX51_vic_vect_addr12_VECT_ADDR12; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR12_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_ADDR12_BIT_T bf;
} NX51_VIC_VECT_ADDR12_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr13 */
/* => VIC Vector address 13 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr13  0x00000134U
#define Adr_NX51_vic_vic_vect_addr13  0x101FF134U
#define Adr_NX51_vic_vect_addr13      0x101FF134U
#define DFLT_VAL_NX51_vic_vect_addr13 0x00000000U

#define MSK_NX51_vic_vect_addr13_VECT_ADDR13         0xffffffffU
#define SRT_NX51_vic_vect_addr13_VECT_ADDR13         0
#define DFLT_VAL_NX51_vic_vect_addr13_VECT_ADDR13    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr13_VECT_ADDR13 0x00000000U

/* all used bits of 'NX51_vic_vect_addr13': */
#define MSK_USED_BITS_NX51_vic_vect_addr13 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr13_VECT_ADDR13 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR13_BIT_Ttag {
	unsigned int VECT_ADDR13 : BFW_NX51_vic_vect_addr13_VECT_ADDR13; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR13_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_ADDR13_BIT_T bf;
} NX51_VIC_VECT_ADDR13_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr14 */
/* => VIC Vector address 14 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr14  0x00000138U
#define Adr_NX51_vic_vic_vect_addr14  0x101FF138U
#define Adr_NX51_vic_vect_addr14      0x101FF138U
#define DFLT_VAL_NX51_vic_vect_addr14 0x00000000U

#define MSK_NX51_vic_vect_addr14_VECT_ADDR14         0xffffffffU
#define SRT_NX51_vic_vect_addr14_VECT_ADDR14         0
#define DFLT_VAL_NX51_vic_vect_addr14_VECT_ADDR14    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr14_VECT_ADDR14 0x00000000U

/* all used bits of 'NX51_vic_vect_addr14': */
#define MSK_USED_BITS_NX51_vic_vect_addr14 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr14_VECT_ADDR14 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR14_BIT_Ttag {
	unsigned int VECT_ADDR14 : BFW_NX51_vic_vect_addr14_VECT_ADDR14; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR14_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_ADDR14_BIT_T bf;
} NX51_VIC_VECT_ADDR14_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_addr15 */
/* => VIC Vector address 15 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_addr15  0x0000013CU
#define Adr_NX51_vic_vic_vect_addr15  0x101FF13CU
#define Adr_NX51_vic_vect_addr15      0x101FF13CU
#define DFLT_VAL_NX51_vic_vect_addr15 0x00000000U

#define MSK_NX51_vic_vect_addr15_VECT_ADDR15         0xffffffffU
#define SRT_NX51_vic_vect_addr15_VECT_ADDR15         0
#define DFLT_VAL_NX51_vic_vect_addr15_VECT_ADDR15    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_addr15_VECT_ADDR15 0x00000000U

/* all used bits of 'NX51_vic_vect_addr15': */
#define MSK_USED_BITS_NX51_vic_vect_addr15 0xffffffffU

enum {
	BFW_NX51_vic_vect_addr15_VECT_ADDR15 = 32  /* [31:0] */
};

typedef struct NX51_VIC_VECT_ADDR15_BIT_Ttag {
	unsigned int VECT_ADDR15 : BFW_NX51_vic_vect_addr15_VECT_ADDR15; /* ISR vector addresses */
} NX51_VIC_VECT_ADDR15_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_ADDR15_BIT_T bf;
} NX51_VIC_VECT_ADDR15_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl0 */
/* => VIC Vector control 0 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl0  0x00000200U
#define Adr_NX51_vic_vic_vect_cntl0  0x101FF200U
#define Adr_NX51_vic_vect_cntl0      0x101FF200U
#define DFLT_VAL_NX51_vic_vect_cntl0 0x00000000U

#define MSK_NX51_vic_vect_cntl0_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl0_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl0_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl0_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl0_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl0_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl0_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl0_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl0': */
#define MSK_USED_BITS_NX51_vic_vect_cntl0 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl0_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl0_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl0_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL0_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl0_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl0_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl0_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL0_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL0_BIT_T bf;
} NX51_VIC_VECT_CNTL0_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl1 */
/* => VIC Vector control 1 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl1  0x00000204U
#define Adr_NX51_vic_vic_vect_cntl1  0x101FF204U
#define Adr_NX51_vic_vect_cntl1      0x101FF204U
#define DFLT_VAL_NX51_vic_vect_cntl1 0x00000000U

#define MSK_NX51_vic_vect_cntl1_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl1_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl1_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl1_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl1_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl1_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl1_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl1_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl1': */
#define MSK_USED_BITS_NX51_vic_vect_cntl1 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl1_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl1_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl1_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL1_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl1_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl1_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl1_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL1_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL1_BIT_T bf;
} NX51_VIC_VECT_CNTL1_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl2 */
/* => VIC Vector control 2 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl2  0x00000208U
#define Adr_NX51_vic_vic_vect_cntl2  0x101FF208U
#define Adr_NX51_vic_vect_cntl2      0x101FF208U
#define DFLT_VAL_NX51_vic_vect_cntl2 0x00000000U

#define MSK_NX51_vic_vect_cntl2_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl2_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl2_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl2_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl2_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl2_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl2_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl2_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl2': */
#define MSK_USED_BITS_NX51_vic_vect_cntl2 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl2_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl2_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl2_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL2_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl2_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl2_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl2_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL2_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL2_BIT_T bf;
} NX51_VIC_VECT_CNTL2_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl3 */
/* => VIC Vector control 3 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl3  0x0000020CU
#define Adr_NX51_vic_vic_vect_cntl3  0x101FF20CU
#define Adr_NX51_vic_vect_cntl3      0x101FF20CU
#define DFLT_VAL_NX51_vic_vect_cntl3 0x00000000U

#define MSK_NX51_vic_vect_cntl3_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl3_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl3_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl3_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl3_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl3_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl3_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl3_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl3': */
#define MSK_USED_BITS_NX51_vic_vect_cntl3 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl3_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl3_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl3_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL3_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl3_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl3_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl3_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL3_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL3_BIT_T bf;
} NX51_VIC_VECT_CNTL3_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl4 */
/* => VIC Vector control 4 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl4  0x00000210U
#define Adr_NX51_vic_vic_vect_cntl4  0x101FF210U
#define Adr_NX51_vic_vect_cntl4      0x101FF210U
#define DFLT_VAL_NX51_vic_vect_cntl4 0x00000000U

#define MSK_NX51_vic_vect_cntl4_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl4_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl4_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl4_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl4_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl4_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl4_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl4_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl4': */
#define MSK_USED_BITS_NX51_vic_vect_cntl4 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl4_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl4_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl4_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL4_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl4_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl4_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl4_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL4_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL4_BIT_T bf;
} NX51_VIC_VECT_CNTL4_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl5 */
/* => VIC Vector control 5 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl5  0x00000214U
#define Adr_NX51_vic_vic_vect_cntl5  0x101FF214U
#define Adr_NX51_vic_vect_cntl5      0x101FF214U
#define DFLT_VAL_NX51_vic_vect_cntl5 0x00000000U

#define MSK_NX51_vic_vect_cntl5_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl5_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl5_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl5_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl5_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl5_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl5_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl5_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl5': */
#define MSK_USED_BITS_NX51_vic_vect_cntl5 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl5_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl5_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl5_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL5_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl5_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl5_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl5_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL5_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL5_BIT_T bf;
} NX51_VIC_VECT_CNTL5_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl6 */
/* => VIC Vector control 6 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl6  0x00000218U
#define Adr_NX51_vic_vic_vect_cntl6  0x101FF218U
#define Adr_NX51_vic_vect_cntl6      0x101FF218U
#define DFLT_VAL_NX51_vic_vect_cntl6 0x00000000U

#define MSK_NX51_vic_vect_cntl6_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl6_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl6_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl6_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl6_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl6_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl6_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl6_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl6': */
#define MSK_USED_BITS_NX51_vic_vect_cntl6 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl6_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl6_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl6_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL6_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl6_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl6_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl6_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL6_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL6_BIT_T bf;
} NX51_VIC_VECT_CNTL6_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl7 */
/* => VIC Vector control 7 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl7  0x0000021CU
#define Adr_NX51_vic_vic_vect_cntl7  0x101FF21CU
#define Adr_NX51_vic_vect_cntl7      0x101FF21CU
#define DFLT_VAL_NX51_vic_vect_cntl7 0x00000000U

#define MSK_NX51_vic_vect_cntl7_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl7_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl7_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl7_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl7_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl7_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl7_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl7_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl7': */
#define MSK_USED_BITS_NX51_vic_vect_cntl7 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl7_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl7_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl7_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL7_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl7_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl7_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl7_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL7_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL7_BIT_T bf;
} NX51_VIC_VECT_CNTL7_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl8 */
/* => VIC Vector control 8 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl8  0x00000220U
#define Adr_NX51_vic_vic_vect_cntl8  0x101FF220U
#define Adr_NX51_vic_vect_cntl8      0x101FF220U
#define DFLT_VAL_NX51_vic_vect_cntl8 0x00000000U

#define MSK_NX51_vic_vect_cntl8_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl8_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl8_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl8_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl8_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl8_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl8_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl8_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl8': */
#define MSK_USED_BITS_NX51_vic_vect_cntl8 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl8_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl8_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl8_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL8_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl8_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl8_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl8_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL8_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL8_BIT_T bf;
} NX51_VIC_VECT_CNTL8_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl9 */
/* => VIC Vector control 9 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl9  0x00000224U
#define Adr_NX51_vic_vic_vect_cntl9  0x101FF224U
#define Adr_NX51_vic_vect_cntl9      0x101FF224U
#define DFLT_VAL_NX51_vic_vect_cntl9 0x00000000U

#define MSK_NX51_vic_vect_cntl9_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl9_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl9_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl9_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl9_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl9_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl9_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl9_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl9': */
#define MSK_USED_BITS_NX51_vic_vect_cntl9 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl9_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl9_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl9_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL9_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl9_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl9_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl9_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL9_BIT_T;

typedef union {
	unsigned int              val;
	NX51_VIC_VECT_CNTL9_BIT_T bf;
} NX51_VIC_VECT_CNTL9_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl10 */
/* => VIC Vector control 10 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl10  0x00000228U
#define Adr_NX51_vic_vic_vect_cntl10  0x101FF228U
#define Adr_NX51_vic_vect_cntl10      0x101FF228U
#define DFLT_VAL_NX51_vic_vect_cntl10 0x00000000U

#define MSK_NX51_vic_vect_cntl10_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl10_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl10_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl10_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl10_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl10_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl10_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl10_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl10': */
#define MSK_USED_BITS_NX51_vic_vect_cntl10 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl10_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl10_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl10_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL10_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl10_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl10_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl10_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL10_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_CNTL10_BIT_T bf;
} NX51_VIC_VECT_CNTL10_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl11 */
/* => VIC Vector control 11 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl11  0x0000022CU
#define Adr_NX51_vic_vic_vect_cntl11  0x101FF22CU
#define Adr_NX51_vic_vect_cntl11      0x101FF22CU
#define DFLT_VAL_NX51_vic_vect_cntl11 0x00000000U

#define MSK_NX51_vic_vect_cntl11_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl11_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl11_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl11_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl11_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl11_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl11_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl11_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl11': */
#define MSK_USED_BITS_NX51_vic_vect_cntl11 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl11_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl11_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl11_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL11_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl11_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl11_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl11_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL11_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_CNTL11_BIT_T bf;
} NX51_VIC_VECT_CNTL11_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl12 */
/* => VIC Vector control 12 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl12  0x00000230U
#define Adr_NX51_vic_vic_vect_cntl12  0x101FF230U
#define Adr_NX51_vic_vect_cntl12      0x101FF230U
#define DFLT_VAL_NX51_vic_vect_cntl12 0x00000000U

#define MSK_NX51_vic_vect_cntl12_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl12_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl12_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl12_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl12_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl12_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl12_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl12_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl12': */
#define MSK_USED_BITS_NX51_vic_vect_cntl12 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl12_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl12_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl12_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL12_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl12_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl12_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl12_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL12_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_CNTL12_BIT_T bf;
} NX51_VIC_VECT_CNTL12_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl13 */
/* => VIC Vector control 13 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl13  0x00000234U
#define Adr_NX51_vic_vic_vect_cntl13  0x101FF234U
#define Adr_NX51_vic_vect_cntl13      0x101FF234U
#define DFLT_VAL_NX51_vic_vect_cntl13 0x00000000U

#define MSK_NX51_vic_vect_cntl13_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl13_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl13_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl13_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl13_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl13_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl13_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl13_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl13': */
#define MSK_USED_BITS_NX51_vic_vect_cntl13 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl13_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl13_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl13_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL13_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl13_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl13_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl13_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL13_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_CNTL13_BIT_T bf;
} NX51_VIC_VECT_CNTL13_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl14 */
/* => VIC Vector control 14 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl14  0x00000238U
#define Adr_NX51_vic_vic_vect_cntl14  0x101FF238U
#define Adr_NX51_vic_vect_cntl14      0x101FF238U
#define DFLT_VAL_NX51_vic_vect_cntl14 0x00000000U

#define MSK_NX51_vic_vect_cntl14_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl14_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl14_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl14_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl14_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl14_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl14_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl14_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl14': */
#define MSK_USED_BITS_NX51_vic_vect_cntl14 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl14_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl14_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl14_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL14_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl14_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl14_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl14_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL14_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_CNTL14_BIT_T bf;
} NX51_VIC_VECT_CNTL14_T;

/* --------------------------------------------------------------------- */
/* Register vic_vect_cntl15 */
/* => VIC Vector control 15 register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_vic_vect_cntl15  0x0000023CU
#define Adr_NX51_vic_vic_vect_cntl15  0x101FF23CU
#define Adr_NX51_vic_vect_cntl15      0x101FF23CU
#define DFLT_VAL_NX51_vic_vect_cntl15 0x00000000U

#define MSK_NX51_vic_vect_cntl15_INT_SOURCE         0x0000001fU
#define SRT_NX51_vic_vect_cntl15_INT_SOURCE         0
#define DFLT_VAL_NX51_vic_vect_cntl15_INT_SOURCE    0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl15_INT_SOURCE 0x00000000U
#define MSK_NX51_vic_vect_cntl15_ENABLE             0x00000020U
#define SRT_NX51_vic_vect_cntl15_ENABLE             5
#define DFLT_VAL_NX51_vic_vect_cntl15_ENABLE        0x00000000U
#define DFLT_BF_VAL_NX51_vic_vect_cntl15_ENABLE     0x00000000U

/* all used bits of 'NX51_vic_vect_cntl15': */
#define MSK_USED_BITS_NX51_vic_vect_cntl15 0x0000003fU

enum {
	BFW_NX51_vic_vect_cntl15_INT_SOURCE = 5,  /* [4:0] */
	BFW_NX51_vic_vect_cntl15_ENABLE     = 1,  /* [5] */
	BFW_NX51_vic_vect_cntl15_reserved1  = 26  /* [31:6] */
};

typedef struct NX51_VIC_VECT_CNTL15_BIT_Ttag {
	unsigned int INT_SOURCE : BFW_NX51_vic_vect_cntl15_INT_SOURCE; /* interrupt source select */
	unsigned int ENABLE     : BFW_NX51_vic_vect_cntl15_ENABLE;     /* vector interrupt enable */
	unsigned int reserved1  : BFW_NX51_vic_vect_cntl15_reserved1;  /* reserved                */
} NX51_VIC_VECT_CNTL15_BIT_T;

typedef union {
	unsigned int               val;
	NX51_VIC_VECT_CNTL15_BIT_T bf;
} NX51_VIC_VECT_CNTL15_T;


/* ===================================================================== */

/* Area of nfifo */

/* ===================================================================== */

#define Addr_NX51_nfifo 0x10200000U

/* --------------------------------------------------------------------- */
/* Register nfifo_config */
/* => NFIFO config register */
/*    'base_config' is a pointer to start of NFIFO configuration area in memory. */
/*    The configuration area must be setup by software, before using a FIFO. */
/*    Each FIFO-configuration entry consists of 3 DW and contains the following: */
/*    {       | */
/*    mem-DW0: base(31:2),mas(1:0) */
/*    mem-DW1: wr_sen(31:30),wr_swc(29),watm(28:16),rd_sen(15:14),rd_swc(13),bottom(12:0) */
/*    mem-DW2: undr(31),emw(30),empty(29),write(28:16),ovfl(15),fmw(14),full(13),fill(12:0) } */
/*    This allows FIFOs of up to 8k entries each. */
/*    The first DWords mem-DW0 and mem-DW1 are only read by NFIFO controller. */
/*    To reset a FIFO, reinit the configuration entries mem-DW0..2. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_config   0x00000000U
#define Adr_NX51_nfifo_nfifo_config 0x10200000U
#define Adr_NX51_nfifo_config       0x10200000U
#define DFLT_VAL_NX51_nfifo_config  0x00000000U

#define MSK_NX51_nfifo_config_base_config         0xfffffffcU
#define SRT_NX51_nfifo_config_base_config         2
#define DFLT_VAL_NX51_nfifo_config_base_config    0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_config_base_config 0x00000000U

/* all used bits of 'NX51_nfifo_config': */
#define MSK_USED_BITS_NX51_nfifo_config 0xfffffffcU

enum {
	BFW_NX51_nfifo_config_reserved1   = 2,  /* [1:0] */
	BFW_NX51_nfifo_config_base_config = 30  /* [31:2] */
};

typedef struct NX51_NFIFO_CONFIG_BIT_Ttag {
	unsigned int reserved1   : BFW_NX51_nfifo_config_reserved1;   /* reserved               */
	unsigned int base_config : BFW_NX51_nfifo_config_base_config; /* Pointer to base_config */
} NX51_NFIFO_CONFIG_BIT_T;

typedef union {
	unsigned int            val;
	NX51_NFIFO_CONFIG_BIT_T bf;
} NX51_NFIFO_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_scheduler_req */
/* => NFIFO scheduler request register: */
/*    When working with the netXACCOS scheduler, the read or write accesses */
/*    to a certain FIFO must be requested first in this register. */
/*    This allows the scheduler to change the task, */
/*    if a FIFO does not contain the requested data or free entries. */
/*    Read access to this register delivers the lastly requested fifo_nr and wr. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_scheduler_req   0x00000004U
#define Adr_NX51_nfifo_nfifo_scheduler_req 0x10200004U
#define Adr_NX51_nfifo_scheduler_req       0x10200004U
#define DFLT_VAL_NX51_nfifo_scheduler_req  0x00000000U

#define MSK_NX51_nfifo_scheduler_req_fifo_nr         0x000003ffU
#define SRT_NX51_nfifo_scheduler_req_fifo_nr         0
#define DFLT_VAL_NX51_nfifo_scheduler_req_fifo_nr    0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_scheduler_req_fifo_nr 0x00000000U
#define MSK_NX51_nfifo_scheduler_req_wr              0x80000000U
#define SRT_NX51_nfifo_scheduler_req_wr              31
#define DFLT_VAL_NX51_nfifo_scheduler_req_wr         0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_scheduler_req_wr      0x00000000U

/* all used bits of 'NX51_nfifo_scheduler_req': */
#define MSK_USED_BITS_NX51_nfifo_scheduler_req 0x800003ffU

enum {
	BFW_NX51_nfifo_scheduler_req_fifo_nr   = 10, /* [9:0] */
	BFW_NX51_nfifo_scheduler_req_reserved1 = 21, /* [30:10] */
	BFW_NX51_nfifo_scheduler_req_wr        = 1   /* [31] */
};

typedef struct NX51_NFIFO_SCHEDULER_REQ_BIT_Ttag {
	unsigned int fifo_nr   : BFW_NX51_nfifo_scheduler_req_fifo_nr;   /* FIFO number (= (fifo_adr/4) - 8) */
	unsigned int reserved1 : BFW_NX51_nfifo_scheduler_req_reserved1; /* reserved                         */
	unsigned int wr        : BFW_NX51_nfifo_scheduler_req_wr;        /* Write(1) or read(0) request      */
} NX51_NFIFO_SCHEDULER_REQ_BIT_T;

typedef union {
	unsigned int                   val;
	NX51_NFIFO_SCHEDULER_REQ_BIT_T bf;
} NX51_NFIFO_SCHEDULER_REQ_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_last_access */
/* => NFIFO last access register: */
/*    This register shows the last access, that generated an interrupt. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_last_access   0x00000008U
#define Adr_NX51_nfifo_nfifo_last_access 0x10200008U
#define Adr_NX51_nfifo_last_access       0x10200008U

#define MSK_NX51_nfifo_last_access_fifo_nr 0x000003ffU
#define SRT_NX51_nfifo_last_access_fifo_nr 0
#define MSK_NX51_nfifo_last_access_rd_rdy  0x20000000U
#define SRT_NX51_nfifo_last_access_rd_rdy  29
#define MSK_NX51_nfifo_last_access_wr_rdy  0x40000000U
#define SRT_NX51_nfifo_last_access_wr_rdy  30
#define MSK_NX51_nfifo_last_access_wr      0x80000000U
#define SRT_NX51_nfifo_last_access_wr      31

/* all used bits of 'NX51_nfifo_last_access': */
#define MSK_USED_BITS_NX51_nfifo_last_access 0xe00003ffU

enum {
	BFW_NX51_nfifo_last_access_fifo_nr   = 10, /* [9:0] */
	BFW_NX51_nfifo_last_access_reserved1 = 19, /* [28:10] */
	BFW_NX51_nfifo_last_access_rd_rdy    = 1,  /* [29] */
	BFW_NX51_nfifo_last_access_wr_rdy    = 1,  /* [30] */
	BFW_NX51_nfifo_last_access_wr        = 1   /* [31] */
};

typedef struct NX51_NFIFO_LAST_ACCESS_BIT_Ttag {
	unsigned int fifo_nr   : BFW_NX51_nfifo_last_access_fifo_nr;   /* FIFO number (= (fifo_adr/4) - 8)                                */
	unsigned int reserved1 : BFW_NX51_nfifo_last_access_reserved1; /* reserved                                                        */
	unsigned int rd_rdy    : BFW_NX51_nfifo_last_access_rd_rdy;    /* The last access lead to the FIFO being ready for read accesses  */
	unsigned int wr_rdy    : BFW_NX51_nfifo_last_access_wr_rdy;    /* The last access lead to the FIFO being ready for write accesses */
	unsigned int wr        : BFW_NX51_nfifo_last_access_wr;        /* Write(1) or read(0) request                                     */
} NX51_NFIFO_LAST_ACCESS_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_NFIFO_LAST_ACCESS_BIT_T bf;
} NX51_NFIFO_LAST_ACCESS_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_raw */
/* => Raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_irq_raw   0x0000000CU
#define Adr_NX51_nfifo_nfifo_irq_raw 0x1020000CU
#define Adr_NX51_nfifo_irq_raw       0x1020000CU
#define DFLT_VAL_NX51_nfifo_irq_raw  0x00000000U

#define MSK_NX51_nfifo_irq_raw_reprogram_wait_req          0x00000001U
#define SRT_NX51_nfifo_irq_raw_reprogram_wait_req          0
#define DFLT_VAL_NX51_nfifo_irq_raw_reprogram_wait_req     0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_reprogram_wait_req  0x00000000U
#define MSK_NX51_nfifo_irq_raw_reschedule_wait_req         0x00000002U
#define SRT_NX51_nfifo_irq_raw_reschedule_wait_req         1
#define DFLT_VAL_NX51_nfifo_irq_raw_reschedule_wait_req    0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_reschedule_wait_req 0x00000000U
#define MSK_NX51_nfifo_irq_raw_reschedule_req              0x00000004U
#define SRT_NX51_nfifo_irq_raw_reschedule_req              2
#define DFLT_VAL_NX51_nfifo_irq_raw_reschedule_req         0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_reschedule_req      0x00000000U
#define MSK_NX51_nfifo_irq_raw_update_req                  0x00000008U
#define SRT_NX51_nfifo_irq_raw_update_req                  3
#define DFLT_VAL_NX51_nfifo_irq_raw_update_req             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_update_req          0x00000000U
#define MSK_NX51_nfifo_irq_raw_locking_req                 0x00000010U
#define SRT_NX51_nfifo_irq_raw_locking_req                 4
#define DFLT_VAL_NX51_nfifo_irq_raw_locking_req            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_locking_req         0x00000000U
#define MSK_NX51_nfifo_irq_raw_fifo_active                 0x00000020U
#define SRT_NX51_nfifo_irq_raw_fifo_active                 5
#define DFLT_VAL_NX51_nfifo_irq_raw_fifo_active            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_fifo_active         0x00000000U
#define MSK_NX51_nfifo_irq_raw_read                        0x00000040U
#define SRT_NX51_nfifo_irq_raw_read                        6
#define DFLT_VAL_NX51_nfifo_irq_raw_read                   0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_read                0x00000000U
#define MSK_NX51_nfifo_irq_raw_write                       0x00000080U
#define SRT_NX51_nfifo_irq_raw_write                       7
#define DFLT_VAL_NX51_nfifo_irq_raw_write                  0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_write               0x00000000U
#define MSK_NX51_nfifo_irq_raw_ahbl_error                  0x00000100U
#define SRT_NX51_nfifo_irq_raw_ahbl_error                  8
#define DFLT_VAL_NX51_nfifo_irq_raw_ahbl_error             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_raw_ahbl_error          0x00000000U

/* all used bits of 'NX51_nfifo_irq_raw': */
#define MSK_USED_BITS_NX51_nfifo_irq_raw 0x000001ffU

enum {
	BFW_NX51_nfifo_irq_raw_reprogram_wait_req  = 1,  /* [0] */
	BFW_NX51_nfifo_irq_raw_reschedule_wait_req = 1,  /* [1] */
	BFW_NX51_nfifo_irq_raw_reschedule_req      = 1,  /* [2] */
	BFW_NX51_nfifo_irq_raw_update_req          = 1,  /* [3] */
	BFW_NX51_nfifo_irq_raw_locking_req         = 1,  /* [4] */
	BFW_NX51_nfifo_irq_raw_fifo_active         = 1,  /* [5] */
	BFW_NX51_nfifo_irq_raw_read                = 1,  /* [6] */
	BFW_NX51_nfifo_irq_raw_write               = 1,  /* [7] */
	BFW_NX51_nfifo_irq_raw_ahbl_error          = 1,  /* [8] */
	BFW_NX51_nfifo_irq_raw_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_NFIFO_IRQ_RAW_BIT_Ttag {
	unsigned int reprogram_wait_req  : BFW_NX51_nfifo_irq_raw_reprogram_wait_req;  /* request for reprogram and reschedule (used when requesting a FIFO)                                     */
	unsigned int reschedule_wait_req : BFW_NX51_nfifo_irq_raw_reschedule_wait_req; /* request for determine most prior task to be executed,                                                  */
	                                                                               /* then acknowledge request and activate locking mechanism at reentry (multi-user-mode rdy-signal)        */
	unsigned int reschedule_req      : BFW_NX51_nfifo_irq_raw_reschedule_req;      /* request for determine most prior task to be executed, no acknowledge (wm/single-user-mode rdy-signal)  */
	unsigned int update_req          : BFW_NX51_nfifo_irq_raw_update_req;          /* request for only update scheduler tables, no new rescheduling (multi-user-mode not-rdy-signal)         */
	unsigned int locking_req         : BFW_NX51_nfifo_irq_raw_locking_req;         /* request for lock the scheduler until fifo_active unlocks it (used in multi-user-mode when FIFO is rdy) */
	unsigned int fifo_active         : BFW_NX51_nfifo_irq_raw_fifo_active;         /* to unlock the scheduler after locking_req                                                              */
	unsigned int read                : BFW_NX51_nfifo_irq_raw_read;                /* any read access happened to any FIFO                                                                   */
	unsigned int write               : BFW_NX51_nfifo_irq_raw_write;               /* any write access happened to any FIFO                                                                  */
	unsigned int ahbl_error          : BFW_NX51_nfifo_irq_raw_ahbl_error;          /* AHBL returned HRESP=1 (abort)                                                                          */
	unsigned int reserved1           : BFW_NX51_nfifo_irq_raw_reserved1;           /* reserved                                                                                               */
} NX51_NFIFO_IRQ_RAW_BIT_T;

typedef union {
	unsigned int             val;
	NX51_NFIFO_IRQ_RAW_BIT_T bf;
} NX51_NFIFO_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_arm_masked */
/* => Masked IRQ of ARM: */
/*    Shows status of masked IRQs as connected to ARM. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_irq_arm_masked   0x00000010U
#define Adr_NX51_nfifo_nfifo_irq_arm_masked 0x10200010U
#define Adr_NX51_nfifo_irq_arm_masked       0x10200010U

#define MSK_NX51_nfifo_irq_arm_masked_reprogram_wait_req  0x00000001U
#define SRT_NX51_nfifo_irq_arm_masked_reprogram_wait_req  0
#define MSK_NX51_nfifo_irq_arm_masked_reschedule_wait_req 0x00000002U
#define SRT_NX51_nfifo_irq_arm_masked_reschedule_wait_req 1
#define MSK_NX51_nfifo_irq_arm_masked_reschedule_req      0x00000004U
#define SRT_NX51_nfifo_irq_arm_masked_reschedule_req      2
#define MSK_NX51_nfifo_irq_arm_masked_update_req          0x00000008U
#define SRT_NX51_nfifo_irq_arm_masked_update_req          3
#define MSK_NX51_nfifo_irq_arm_masked_locking_req         0x00000010U
#define SRT_NX51_nfifo_irq_arm_masked_locking_req         4
#define MSK_NX51_nfifo_irq_arm_masked_fifo_active         0x00000020U
#define SRT_NX51_nfifo_irq_arm_masked_fifo_active         5
#define MSK_NX51_nfifo_irq_arm_masked_read                0x00000040U
#define SRT_NX51_nfifo_irq_arm_masked_read                6
#define MSK_NX51_nfifo_irq_arm_masked_write               0x00000080U
#define SRT_NX51_nfifo_irq_arm_masked_write               7
#define MSK_NX51_nfifo_irq_arm_masked_ahbl_error          0x00000100U
#define SRT_NX51_nfifo_irq_arm_masked_ahbl_error          8

/* all used bits of 'NX51_nfifo_irq_arm_masked': */
#define MSK_USED_BITS_NX51_nfifo_irq_arm_masked 0x000001ffU

enum {
	BFW_NX51_nfifo_irq_arm_masked_reprogram_wait_req  = 1,  /* [0] */
	BFW_NX51_nfifo_irq_arm_masked_reschedule_wait_req = 1,  /* [1] */
	BFW_NX51_nfifo_irq_arm_masked_reschedule_req      = 1,  /* [2] */
	BFW_NX51_nfifo_irq_arm_masked_update_req          = 1,  /* [3] */
	BFW_NX51_nfifo_irq_arm_masked_locking_req         = 1,  /* [4] */
	BFW_NX51_nfifo_irq_arm_masked_fifo_active         = 1,  /* [5] */
	BFW_NX51_nfifo_irq_arm_masked_read                = 1,  /* [6] */
	BFW_NX51_nfifo_irq_arm_masked_write               = 1,  /* [7] */
	BFW_NX51_nfifo_irq_arm_masked_ahbl_error          = 1,  /* [8] */
	BFW_NX51_nfifo_irq_arm_masked_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_NFIFO_IRQ_ARM_MASKED_BIT_Ttag {
	unsigned int reprogram_wait_req  : BFW_NX51_nfifo_irq_arm_masked_reprogram_wait_req;  /* request for reprogram and reschedule (used when requesting a FIFO)                                     */
	unsigned int reschedule_wait_req : BFW_NX51_nfifo_irq_arm_masked_reschedule_wait_req; /* request for determine most prior task to be executed,                                                  */
	                                                                                      /* then acknowledge request and activate locking mechanism at reentry (multi-user-mode rdy-signal)        */
	unsigned int reschedule_req      : BFW_NX51_nfifo_irq_arm_masked_reschedule_req;      /* request for determine most prior task to be executed, no acknowledge (wm/single-user-mode rdy-signal)  */
	unsigned int update_req          : BFW_NX51_nfifo_irq_arm_masked_update_req;          /* request for only update scheduler tables, no new rescheduling (multi-user-mode not-rdy-signal)         */
	unsigned int locking_req         : BFW_NX51_nfifo_irq_arm_masked_locking_req;         /* request for lock the scheduler until fifo_active unlocks it (used in multi-user-mode when FIFO is rdy) */
	unsigned int fifo_active         : BFW_NX51_nfifo_irq_arm_masked_fifo_active;         /* to unlock the scheduler after locking_req                                                              */
	unsigned int read                : BFW_NX51_nfifo_irq_arm_masked_read;                /* any read access happened to any FIFO                                                                   */
	unsigned int write               : BFW_NX51_nfifo_irq_arm_masked_write;               /* any write access happened to any FIFO                                                                  */
	unsigned int ahbl_error          : BFW_NX51_nfifo_irq_arm_masked_ahbl_error;          /* AHBL returned HRESP=1 (abort)                                                                          */
	unsigned int reserved1           : BFW_NX51_nfifo_irq_arm_masked_reserved1;           /* reserved                                                                                               */
} NX51_NFIFO_IRQ_ARM_MASKED_BIT_T;

typedef union {
	unsigned int                    val;
	NX51_NFIFO_IRQ_ARM_MASKED_BIT_T bf;
} NX51_NFIFO_IRQ_ARM_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_arm_msk_set */
/* => ARM IRQ mask set: */
/*    The ARM IRQ mask enables interrupt requests for corresponding interrupt sources to the ARM processor. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_nfifo_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_irq_arm_msk_set   0x00000014U
#define Adr_NX51_nfifo_nfifo_irq_arm_msk_set 0x10200014U
#define Adr_NX51_nfifo_irq_arm_msk_set       0x10200014U
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set  0x00000000U

#define MSK_NX51_nfifo_irq_arm_msk_set_reprogram_wait_req          0x00000001U
#define SRT_NX51_nfifo_irq_arm_msk_set_reprogram_wait_req          0
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_reprogram_wait_req     0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_reprogram_wait_req  0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_reschedule_wait_req         0x00000002U
#define SRT_NX51_nfifo_irq_arm_msk_set_reschedule_wait_req         1
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_reschedule_wait_req    0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_reschedule_wait_req 0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_reschedule_req              0x00000004U
#define SRT_NX51_nfifo_irq_arm_msk_set_reschedule_req              2
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_reschedule_req         0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_reschedule_req      0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_update_req                  0x00000008U
#define SRT_NX51_nfifo_irq_arm_msk_set_update_req                  3
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_update_req             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_update_req          0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_locking_req                 0x00000010U
#define SRT_NX51_nfifo_irq_arm_msk_set_locking_req                 4
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_locking_req            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_locking_req         0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_fifo_active                 0x00000020U
#define SRT_NX51_nfifo_irq_arm_msk_set_fifo_active                 5
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_fifo_active            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_fifo_active         0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_read                        0x00000040U
#define SRT_NX51_nfifo_irq_arm_msk_set_read                        6
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_read                   0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_read                0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_write                       0x00000080U
#define SRT_NX51_nfifo_irq_arm_msk_set_write                       7
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_write                  0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_write               0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_set_ahbl_error                  0x00000100U
#define SRT_NX51_nfifo_irq_arm_msk_set_ahbl_error                  8
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_set_ahbl_error             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_set_ahbl_error          0x00000000U

/* all used bits of 'NX51_nfifo_irq_arm_msk_set': */
#define MSK_USED_BITS_NX51_nfifo_irq_arm_msk_set 0x000001ffU

enum {
	BFW_NX51_nfifo_irq_arm_msk_set_reprogram_wait_req  = 1,  /* [0] */
	BFW_NX51_nfifo_irq_arm_msk_set_reschedule_wait_req = 1,  /* [1] */
	BFW_NX51_nfifo_irq_arm_msk_set_reschedule_req      = 1,  /* [2] */
	BFW_NX51_nfifo_irq_arm_msk_set_update_req          = 1,  /* [3] */
	BFW_NX51_nfifo_irq_arm_msk_set_locking_req         = 1,  /* [4] */
	BFW_NX51_nfifo_irq_arm_msk_set_fifo_active         = 1,  /* [5] */
	BFW_NX51_nfifo_irq_arm_msk_set_read                = 1,  /* [6] */
	BFW_NX51_nfifo_irq_arm_msk_set_write               = 1,  /* [7] */
	BFW_NX51_nfifo_irq_arm_msk_set_ahbl_error          = 1,  /* [8] */
	BFW_NX51_nfifo_irq_arm_msk_set_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_NFIFO_IRQ_ARM_MSK_SET_BIT_Ttag {
	unsigned int reprogram_wait_req  : BFW_NX51_nfifo_irq_arm_msk_set_reprogram_wait_req;  /* request for reprogram and reschedule (used when requesting a FIFO)                                     */
	unsigned int reschedule_wait_req : BFW_NX51_nfifo_irq_arm_msk_set_reschedule_wait_req; /* request for determine most prior task to be executed,                                                  */
	                                                                                       /* then acknowledge request and activate locking mechanism at reentry (multi-user-mode rdy-signal)        */
	unsigned int reschedule_req      : BFW_NX51_nfifo_irq_arm_msk_set_reschedule_req;      /* request for determine most prior task to be executed, no acknowledge (wm/single-user-mode rdy-signal)  */
	unsigned int update_req          : BFW_NX51_nfifo_irq_arm_msk_set_update_req;          /* request for only update scheduler tables, no new rescheduling (multi-user-mode not-rdy-signal)         */
	unsigned int locking_req         : BFW_NX51_nfifo_irq_arm_msk_set_locking_req;         /* request for lock the scheduler until fifo_active unlocks it (used in multi-user-mode when FIFO is rdy) */
	unsigned int fifo_active         : BFW_NX51_nfifo_irq_arm_msk_set_fifo_active;         /* to unlock the scheduler after locking_req                                                              */
	unsigned int read                : BFW_NX51_nfifo_irq_arm_msk_set_read;                /* any read access happened to any FIFO                                                                   */
	unsigned int write               : BFW_NX51_nfifo_irq_arm_msk_set_write;               /* any write access happened to any FIFO                                                                  */
	unsigned int ahbl_error          : BFW_NX51_nfifo_irq_arm_msk_set_ahbl_error;          /* AHBL returned HRESP=1 (abort)                                                                          */
	unsigned int reserved1           : BFW_NX51_nfifo_irq_arm_msk_set_reserved1;           /* reserved                                                                                               */
} NX51_NFIFO_IRQ_ARM_MSK_SET_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_NFIFO_IRQ_ARM_MSK_SET_BIT_T bf;
} NX51_NFIFO_IRQ_ARM_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_arm_msk_reset */
/* => ARM IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_irq_arm_msk_reset   0x00000018U
#define Adr_NX51_nfifo_nfifo_irq_arm_msk_reset 0x10200018U
#define Adr_NX51_nfifo_irq_arm_msk_reset       0x10200018U
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset  0x00000000U

#define MSK_NX51_nfifo_irq_arm_msk_reset_reprogram_wait_req          0x00000001U
#define SRT_NX51_nfifo_irq_arm_msk_reset_reprogram_wait_req          0
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_reprogram_wait_req     0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_reprogram_wait_req  0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_reschedule_wait_req         0x00000002U
#define SRT_NX51_nfifo_irq_arm_msk_reset_reschedule_wait_req         1
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_reschedule_wait_req    0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_reschedule_wait_req 0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_reschedule_req              0x00000004U
#define SRT_NX51_nfifo_irq_arm_msk_reset_reschedule_req              2
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_reschedule_req         0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_reschedule_req      0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_update_req                  0x00000008U
#define SRT_NX51_nfifo_irq_arm_msk_reset_update_req                  3
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_update_req             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_update_req          0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_locking_req                 0x00000010U
#define SRT_NX51_nfifo_irq_arm_msk_reset_locking_req                 4
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_locking_req            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_locking_req         0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_fifo_active                 0x00000020U
#define SRT_NX51_nfifo_irq_arm_msk_reset_fifo_active                 5
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_fifo_active            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_fifo_active         0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_read                        0x00000040U
#define SRT_NX51_nfifo_irq_arm_msk_reset_read                        6
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_read                   0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_read                0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_write                       0x00000080U
#define SRT_NX51_nfifo_irq_arm_msk_reset_write                       7
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_write                  0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_write               0x00000000U
#define MSK_NX51_nfifo_irq_arm_msk_reset_ahbl_error                  0x00000100U
#define SRT_NX51_nfifo_irq_arm_msk_reset_ahbl_error                  8
#define DFLT_VAL_NX51_nfifo_irq_arm_msk_reset_ahbl_error             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_arm_msk_reset_ahbl_error          0x00000000U

/* all used bits of 'NX51_nfifo_irq_arm_msk_reset': */
#define MSK_USED_BITS_NX51_nfifo_irq_arm_msk_reset 0x000001ffU

enum {
	BFW_NX51_nfifo_irq_arm_msk_reset_reprogram_wait_req  = 1,  /* [0] */
	BFW_NX51_nfifo_irq_arm_msk_reset_reschedule_wait_req = 1,  /* [1] */
	BFW_NX51_nfifo_irq_arm_msk_reset_reschedule_req      = 1,  /* [2] */
	BFW_NX51_nfifo_irq_arm_msk_reset_update_req          = 1,  /* [3] */
	BFW_NX51_nfifo_irq_arm_msk_reset_locking_req         = 1,  /* [4] */
	BFW_NX51_nfifo_irq_arm_msk_reset_fifo_active         = 1,  /* [5] */
	BFW_NX51_nfifo_irq_arm_msk_reset_read                = 1,  /* [6] */
	BFW_NX51_nfifo_irq_arm_msk_reset_write               = 1,  /* [7] */
	BFW_NX51_nfifo_irq_arm_msk_reset_ahbl_error          = 1,  /* [8] */
	BFW_NX51_nfifo_irq_arm_msk_reset_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_NFIFO_IRQ_ARM_MSK_RESET_BIT_Ttag {
	unsigned int reprogram_wait_req  : BFW_NX51_nfifo_irq_arm_msk_reset_reprogram_wait_req;  /* request for reprogram and reschedule (used when requesting a FIFO)                                     */
	unsigned int reschedule_wait_req : BFW_NX51_nfifo_irq_arm_msk_reset_reschedule_wait_req; /* request for determine most prior task to be executed,                                                  */
	                                                                                         /* then acknowledge request and activate locking mechanism at reentry (multi-user-mode rdy-signal)        */
	unsigned int reschedule_req      : BFW_NX51_nfifo_irq_arm_msk_reset_reschedule_req;      /* request for determine most prior task to be executed, no acknowledge (wm/single-user-mode rdy-signal)  */
	unsigned int update_req          : BFW_NX51_nfifo_irq_arm_msk_reset_update_req;          /* request for only update scheduler tables, no new rescheduling (multi-user-mode not-rdy-signal)         */
	unsigned int locking_req         : BFW_NX51_nfifo_irq_arm_msk_reset_locking_req;         /* request for lock the scheduler until fifo_active unlocks it (used in multi-user-mode when FIFO is rdy) */
	unsigned int fifo_active         : BFW_NX51_nfifo_irq_arm_msk_reset_fifo_active;         /* to unlock the scheduler after locking_req                                                              */
	unsigned int read                : BFW_NX51_nfifo_irq_arm_msk_reset_read;                /* any read access happened to any FIFO                                                                   */
	unsigned int write               : BFW_NX51_nfifo_irq_arm_msk_reset_write;               /* any write access happened to any FIFO                                                                  */
	unsigned int ahbl_error          : BFW_NX51_nfifo_irq_arm_msk_reset_ahbl_error;          /* AHBL returned HRESP=1 (abort)                                                                          */
	unsigned int reserved1           : BFW_NX51_nfifo_irq_arm_msk_reset_reserved1;           /* reserved                                                                                               */
} NX51_NFIFO_IRQ_ARM_MSK_RESET_BIT_T;

typedef union {
	unsigned int                       val;
	NX51_NFIFO_IRQ_ARM_MSK_RESET_BIT_T bf;
} NX51_NFIFO_IRQ_ARM_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_xpic_masked */
/* => Masked IRQ of xPIC: */
/*    Shows status of masked IRQs as connected to xPIC. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_irq_xpic_masked   0x0000001CU
#define Adr_NX51_nfifo_nfifo_irq_xpic_masked 0x1020001CU
#define Adr_NX51_nfifo_irq_xpic_masked       0x1020001CU

#define MSK_NX51_nfifo_irq_xpic_masked_reprogram_wait_req  0x00000001U
#define SRT_NX51_nfifo_irq_xpic_masked_reprogram_wait_req  0
#define MSK_NX51_nfifo_irq_xpic_masked_reschedule_wait_req 0x00000002U
#define SRT_NX51_nfifo_irq_xpic_masked_reschedule_wait_req 1
#define MSK_NX51_nfifo_irq_xpic_masked_reschedule_req      0x00000004U
#define SRT_NX51_nfifo_irq_xpic_masked_reschedule_req      2
#define MSK_NX51_nfifo_irq_xpic_masked_update_req          0x00000008U
#define SRT_NX51_nfifo_irq_xpic_masked_update_req          3
#define MSK_NX51_nfifo_irq_xpic_masked_locking_req         0x00000010U
#define SRT_NX51_nfifo_irq_xpic_masked_locking_req         4
#define MSK_NX51_nfifo_irq_xpic_masked_fifo_active         0x00000020U
#define SRT_NX51_nfifo_irq_xpic_masked_fifo_active         5
#define MSK_NX51_nfifo_irq_xpic_masked_read                0x00000040U
#define SRT_NX51_nfifo_irq_xpic_masked_read                6
#define MSK_NX51_nfifo_irq_xpic_masked_write               0x00000080U
#define SRT_NX51_nfifo_irq_xpic_masked_write               7
#define MSK_NX51_nfifo_irq_xpic_masked_ahbl_error          0x00000100U
#define SRT_NX51_nfifo_irq_xpic_masked_ahbl_error          8

/* all used bits of 'NX51_nfifo_irq_xpic_masked': */
#define MSK_USED_BITS_NX51_nfifo_irq_xpic_masked 0x000001ffU

enum {
	BFW_NX51_nfifo_irq_xpic_masked_reprogram_wait_req  = 1,  /* [0] */
	BFW_NX51_nfifo_irq_xpic_masked_reschedule_wait_req = 1,  /* [1] */
	BFW_NX51_nfifo_irq_xpic_masked_reschedule_req      = 1,  /* [2] */
	BFW_NX51_nfifo_irq_xpic_masked_update_req          = 1,  /* [3] */
	BFW_NX51_nfifo_irq_xpic_masked_locking_req         = 1,  /* [4] */
	BFW_NX51_nfifo_irq_xpic_masked_fifo_active         = 1,  /* [5] */
	BFW_NX51_nfifo_irq_xpic_masked_read                = 1,  /* [6] */
	BFW_NX51_nfifo_irq_xpic_masked_write               = 1,  /* [7] */
	BFW_NX51_nfifo_irq_xpic_masked_ahbl_error          = 1,  /* [8] */
	BFW_NX51_nfifo_irq_xpic_masked_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_NFIFO_IRQ_XPIC_MASKED_BIT_Ttag {
	unsigned int reprogram_wait_req  : BFW_NX51_nfifo_irq_xpic_masked_reprogram_wait_req;  /* request for reprogram and reschedule (used when requesting a FIFO)                                     */
	unsigned int reschedule_wait_req : BFW_NX51_nfifo_irq_xpic_masked_reschedule_wait_req; /* request for determine most prior task to be executed,                                                  */
	                                                                                       /* then acknowledge request and activate locking mechanism at reentry (multi-user-mode rdy-signal)        */
	unsigned int reschedule_req      : BFW_NX51_nfifo_irq_xpic_masked_reschedule_req;      /* request for determine most prior task to be executed, no acknowledge (wm/single-user-mode rdy-signal)  */
	unsigned int update_req          : BFW_NX51_nfifo_irq_xpic_masked_update_req;          /* request for only update scheduler tables, no new rescheduling (multi-user-mode not-rdy-signal)         */
	unsigned int locking_req         : BFW_NX51_nfifo_irq_xpic_masked_locking_req;         /* request for lock the scheduler until fifo_active unlocks it (used in multi-user-mode when FIFO is rdy) */
	unsigned int fifo_active         : BFW_NX51_nfifo_irq_xpic_masked_fifo_active;         /* to unlock the scheduler after locking_req                                                              */
	unsigned int read                : BFW_NX51_nfifo_irq_xpic_masked_read;                /* any read access happened to any FIFO                                                                   */
	unsigned int write               : BFW_NX51_nfifo_irq_xpic_masked_write;               /* any write access happened to any FIFO                                                                  */
	unsigned int ahbl_error          : BFW_NX51_nfifo_irq_xpic_masked_ahbl_error;          /* AHBL returned HRESP=1 (abort)                                                                          */
	unsigned int reserved1           : BFW_NX51_nfifo_irq_xpic_masked_reserved1;           /* reserved                                                                                               */
} NX51_NFIFO_IRQ_XPIC_MASKED_BIT_T;

typedef union {
	unsigned int                     val;
	NX51_NFIFO_IRQ_XPIC_MASKED_BIT_T bf;
} NX51_NFIFO_IRQ_XPIC_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_xpic_msk_set */
/* => xPIC IRQ mask set: */
/*    The xPIC IRQ mask enables interrupt requests for corresponding interrupt sources to the xPIC processor. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_nfifo_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_irq_xpic_msk_set   0x00000020U
#define Adr_NX51_nfifo_nfifo_irq_xpic_msk_set 0x10200020U
#define Adr_NX51_nfifo_irq_xpic_msk_set       0x10200020U
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set  0x00000000U

#define MSK_NX51_nfifo_irq_xpic_msk_set_reprogram_wait_req          0x00000001U
#define SRT_NX51_nfifo_irq_xpic_msk_set_reprogram_wait_req          0
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_reprogram_wait_req     0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_reprogram_wait_req  0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_reschedule_wait_req         0x00000002U
#define SRT_NX51_nfifo_irq_xpic_msk_set_reschedule_wait_req         1
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_reschedule_wait_req    0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_reschedule_wait_req 0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_reschedule_req              0x00000004U
#define SRT_NX51_nfifo_irq_xpic_msk_set_reschedule_req              2
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_reschedule_req         0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_reschedule_req      0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_update_req                  0x00000008U
#define SRT_NX51_nfifo_irq_xpic_msk_set_update_req                  3
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_update_req             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_update_req          0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_locking_req                 0x00000010U
#define SRT_NX51_nfifo_irq_xpic_msk_set_locking_req                 4
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_locking_req            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_locking_req         0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_fifo_active                 0x00000020U
#define SRT_NX51_nfifo_irq_xpic_msk_set_fifo_active                 5
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_fifo_active            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_fifo_active         0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_read                        0x00000040U
#define SRT_NX51_nfifo_irq_xpic_msk_set_read                        6
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_read                   0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_read                0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_write                       0x00000080U
#define SRT_NX51_nfifo_irq_xpic_msk_set_write                       7
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_write                  0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_write               0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_set_ahbl_error                  0x00000100U
#define SRT_NX51_nfifo_irq_xpic_msk_set_ahbl_error                  8
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_set_ahbl_error             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_set_ahbl_error          0x00000000U

/* all used bits of 'NX51_nfifo_irq_xpic_msk_set': */
#define MSK_USED_BITS_NX51_nfifo_irq_xpic_msk_set 0x000001ffU

enum {
	BFW_NX51_nfifo_irq_xpic_msk_set_reprogram_wait_req  = 1,  /* [0] */
	BFW_NX51_nfifo_irq_xpic_msk_set_reschedule_wait_req = 1,  /* [1] */
	BFW_NX51_nfifo_irq_xpic_msk_set_reschedule_req      = 1,  /* [2] */
	BFW_NX51_nfifo_irq_xpic_msk_set_update_req          = 1,  /* [3] */
	BFW_NX51_nfifo_irq_xpic_msk_set_locking_req         = 1,  /* [4] */
	BFW_NX51_nfifo_irq_xpic_msk_set_fifo_active         = 1,  /* [5] */
	BFW_NX51_nfifo_irq_xpic_msk_set_read                = 1,  /* [6] */
	BFW_NX51_nfifo_irq_xpic_msk_set_write               = 1,  /* [7] */
	BFW_NX51_nfifo_irq_xpic_msk_set_ahbl_error          = 1,  /* [8] */
	BFW_NX51_nfifo_irq_xpic_msk_set_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_NFIFO_IRQ_XPIC_MSK_SET_BIT_Ttag {
	unsigned int reprogram_wait_req  : BFW_NX51_nfifo_irq_xpic_msk_set_reprogram_wait_req;  /* request for reprogram and reschedule (used when requesting a FIFO)                                     */
	unsigned int reschedule_wait_req : BFW_NX51_nfifo_irq_xpic_msk_set_reschedule_wait_req; /* request for determine most prior task to be executed,                                                  */
	                                                                                        /* then acknowledge request and activate locking mechanism at reentry (multi-user-mode rdy-signal)        */
	unsigned int reschedule_req      : BFW_NX51_nfifo_irq_xpic_msk_set_reschedule_req;      /* request for determine most prior task to be executed, no acknowledge (wm/single-user-mode rdy-signal)  */
	unsigned int update_req          : BFW_NX51_nfifo_irq_xpic_msk_set_update_req;          /* request for only update scheduler tables, no new rescheduling (multi-user-mode not-rdy-signal)         */
	unsigned int locking_req         : BFW_NX51_nfifo_irq_xpic_msk_set_locking_req;         /* request for lock the scheduler until fifo_active unlocks it (used in multi-user-mode when FIFO is rdy) */
	unsigned int fifo_active         : BFW_NX51_nfifo_irq_xpic_msk_set_fifo_active;         /* to unlock the scheduler after locking_req                                                              */
	unsigned int read                : BFW_NX51_nfifo_irq_xpic_msk_set_read;                /* any read access happened to any FIFO                                                                   */
	unsigned int write               : BFW_NX51_nfifo_irq_xpic_msk_set_write;               /* any write access happened to any FIFO                                                                  */
	unsigned int ahbl_error          : BFW_NX51_nfifo_irq_xpic_msk_set_ahbl_error;          /* AHBL returned HRESP=1 (abort)                                                                          */
	unsigned int reserved1           : BFW_NX51_nfifo_irq_xpic_msk_set_reserved1;           /* reserved                                                                                               */
} NX51_NFIFO_IRQ_XPIC_MSK_SET_BIT_T;

typedef union {
	unsigned int                      val;
	NX51_NFIFO_IRQ_XPIC_MSK_SET_BIT_T bf;
} NX51_NFIFO_IRQ_XPIC_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_irq_xpic_msk_reset */
/* => xPIC IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_irq_xpic_msk_reset   0x00000024U
#define Adr_NX51_nfifo_nfifo_irq_xpic_msk_reset 0x10200024U
#define Adr_NX51_nfifo_irq_xpic_msk_reset       0x10200024U
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset  0x00000000U

#define MSK_NX51_nfifo_irq_xpic_msk_reset_reprogram_wait_req          0x00000001U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_reprogram_wait_req          0
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_reprogram_wait_req     0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_reprogram_wait_req  0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_reschedule_wait_req         0x00000002U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_reschedule_wait_req         1
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_reschedule_wait_req    0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_reschedule_wait_req 0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_reschedule_req              0x00000004U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_reschedule_req              2
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_reschedule_req         0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_reschedule_req      0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_update_req                  0x00000008U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_update_req                  3
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_update_req             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_update_req          0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_locking_req                 0x00000010U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_locking_req                 4
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_locking_req            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_locking_req         0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_fifo_active                 0x00000020U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_fifo_active                 5
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_fifo_active            0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_fifo_active         0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_read                        0x00000040U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_read                        6
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_read                   0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_read                0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_write                       0x00000080U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_write                       7
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_write                  0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_write               0x00000000U
#define MSK_NX51_nfifo_irq_xpic_msk_reset_ahbl_error                  0x00000100U
#define SRT_NX51_nfifo_irq_xpic_msk_reset_ahbl_error                  8
#define DFLT_VAL_NX51_nfifo_irq_xpic_msk_reset_ahbl_error             0x00000000U
#define DFLT_BF_VAL_NX51_nfifo_irq_xpic_msk_reset_ahbl_error          0x00000000U

/* all used bits of 'NX51_nfifo_irq_xpic_msk_reset': */
#define MSK_USED_BITS_NX51_nfifo_irq_xpic_msk_reset 0x000001ffU

enum {
	BFW_NX51_nfifo_irq_xpic_msk_reset_reprogram_wait_req  = 1,  /* [0] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_reschedule_wait_req = 1,  /* [1] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_reschedule_req      = 1,  /* [2] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_update_req          = 1,  /* [3] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_locking_req         = 1,  /* [4] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_fifo_active         = 1,  /* [5] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_read                = 1,  /* [6] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_write               = 1,  /* [7] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_ahbl_error          = 1,  /* [8] */
	BFW_NX51_nfifo_irq_xpic_msk_reset_reserved1           = 23  /* [31:9] */
};

typedef struct NX51_NFIFO_IRQ_XPIC_MSK_RESET_BIT_Ttag {
	unsigned int reprogram_wait_req  : BFW_NX51_nfifo_irq_xpic_msk_reset_reprogram_wait_req;  /* request for reprogram and reschedule (used when requesting a FIFO)                                     */
	unsigned int reschedule_wait_req : BFW_NX51_nfifo_irq_xpic_msk_reset_reschedule_wait_req; /* request for determine most prior task to be executed,                                                  */
	                                                                                          /* then acknowledge request and activate locking mechanism at reentry (multi-user-mode rdy-signal)        */
	unsigned int reschedule_req      : BFW_NX51_nfifo_irq_xpic_msk_reset_reschedule_req;      /* request for determine most prior task to be executed, no acknowledge (wm/single-user-mode rdy-signal)  */
	unsigned int update_req          : BFW_NX51_nfifo_irq_xpic_msk_reset_update_req;          /* request for only update scheduler tables, no new rescheduling (multi-user-mode not-rdy-signal)         */
	unsigned int locking_req         : BFW_NX51_nfifo_irq_xpic_msk_reset_locking_req;         /* request for lock the scheduler until fifo_active unlocks it (used in multi-user-mode when FIFO is rdy) */
	unsigned int fifo_active         : BFW_NX51_nfifo_irq_xpic_msk_reset_fifo_active;         /* to unlock the scheduler after locking_req                                                              */
	unsigned int read                : BFW_NX51_nfifo_irq_xpic_msk_reset_read;                /* any read access happened to any FIFO                                                                   */
	unsigned int write               : BFW_NX51_nfifo_irq_xpic_msk_reset_write;               /* any write access happened to any FIFO                                                                  */
	unsigned int ahbl_error          : BFW_NX51_nfifo_irq_xpic_msk_reset_ahbl_error;          /* AHBL returned HRESP=1 (abort)                                                                          */
	unsigned int reserved1           : BFW_NX51_nfifo_irq_xpic_msk_reset_reserved1;           /* reserved                                                                                               */
} NX51_NFIFO_IRQ_XPIC_MSK_RESET_BIT_T;

typedef union {
	unsigned int                        val;
	NX51_NFIFO_IRQ_XPIC_MSK_RESET_BIT_T bf;
} NX51_NFIFO_IRQ_XPIC_MSK_RESET_T;

/* --------------------------------------------------------------------- */
/* Register nfifo_fifo_start */
/* => Start of NFIFO FIFO access addresses: */
/*    The following DW-addresses are associated with FIFOs: */
/*    Read accesses to an address in this area are reading from the appropriate FIFO, */
/*    write accesses to an address in this area are writing to the appropriate FIFO. */
/*    The number of FIFOs is limited by this address area to 1014. */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_fifo_start   0x00000028U
#define Adr_NX51_nfifo_nfifo_fifo_start 0x10200028U
#define Adr_NX51_nfifo_fifo_start       0x10200028U

/* --------------------------------------------------------------------- */
/* Register nfifo_fifo_end */
/* => End of NFIFO FIFO access addresses */
/* => Mode:  */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_nfifo_fifo_end   0x00000FFCU
#define Adr_NX51_nfifo_nfifo_fifo_end 0x10200FFCU
#define Adr_NX51_nfifo_fifo_end       0x10200FFCU


/* ===================================================================== */

/* AREA feth */
/* Area of feth, feth_buf */

/* ===================================================================== */

#define Addr_NX51_feth     0x10210000U
#define Addr_NX51_feth_buf 0x08210000U

/* ===================================================================== */

/* Area of eth */

/* ===================================================================== */

#define Addr_NX51_eth 0x10210000U

/* --------------------------------------------------------------------- */
/* Register eth_config */
/* => ETH config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_config  0x00000000U
#define Adr_NX51_eth_eth_config  0x10210000U
#define Adr_NX51_eth_config      0x10210000U
#define DFLT_VAL_NX51_eth_config 0x00000004U

#define MSK_NX51_eth_config_rx_watermark_irq               0x0000000fU
#define SRT_NX51_eth_config_rx_watermark_irq               0
#define DFLT_VAL_NX51_eth_config_rx_watermark_irq          0x00000004U
#define DFLT_BF_VAL_NX51_eth_config_rx_watermark_irq       0x00000004U
#define MSK_NX51_eth_config_rx_sample_phase                0x00000070U
#define SRT_NX51_eth_config_rx_sample_phase                4
#define DFLT_VAL_NX51_eth_config_rx_sample_phase           0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_sample_phase        0x00000000U
#define MSK_NX51_eth_config_rx_delay_inputs                0x00000080U
#define SRT_NX51_eth_config_rx_delay_inputs                7
#define DFLT_VAL_NX51_eth_config_rx_delay_inputs           0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_delay_inputs        0x00000000U
#define MSK_NX51_eth_config_rx_allow_jumbo_packets         0x00000100U
#define SRT_NX51_eth_config_rx_allow_jumbo_packets         8
#define DFLT_VAL_NX51_eth_config_rx_allow_jumbo_packets    0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_allow_jumbo_packets 0x00000000U
#define MSK_NX51_eth_config_rx_exact_preamble              0x00000200U
#define SRT_NX51_eth_config_rx_exact_preamble              9
#define DFLT_VAL_NX51_eth_config_rx_exact_preamble         0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_exact_preamble      0x00000000U
#define MSK_NX51_eth_config_rx_no_preamble                 0x00000400U
#define SRT_NX51_eth_config_rx_no_preamble                 10
#define DFLT_VAL_NX51_eth_config_rx_no_preamble            0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_no_preamble         0x00000000U
#define MSK_NX51_eth_config_rx_dma_mode                    0x00000800U
#define SRT_NX51_eth_config_rx_dma_mode                    11
#define DFLT_VAL_NX51_eth_config_rx_dma_mode               0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_dma_mode            0x00000000U
#define MSK_NX51_eth_config_rx_systime_sfd                 0x00001000U
#define SRT_NX51_eth_config_rx_systime_sfd                 12
#define DFLT_VAL_NX51_eth_config_rx_systime_sfd            0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_systime_sfd         0x00000000U
#define MSK_NX51_eth_config_rx_enable                      0x00002000U
#define SRT_NX51_eth_config_rx_enable                      13
#define DFLT_VAL_NX51_eth_config_rx_enable                 0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_rx_enable              0x00000000U
#define MSK_NX51_eth_config_frequency                      0x08000000U
#define SRT_NX51_eth_config_frequency                      27
#define DFLT_VAL_NX51_eth_config_frequency                 0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_frequency              0x00000000U
#define MSK_NX51_eth_config_hd_suppress_loopback           0x10000000U
#define SRT_NX51_eth_config_hd_suppress_loopback           28
#define DFLT_VAL_NX51_eth_config_hd_suppress_loopback      0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_hd_suppress_loopback   0x00000000U
#define MSK_NX51_eth_config_phy_mode                       0x20000000U
#define SRT_NX51_eth_config_phy_mode                       29
#define DFLT_VAL_NX51_eth_config_phy_mode                  0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_phy_mode               0x00000000U
#define MSK_NX51_eth_config_xpic_irq                       0x40000000U
#define SRT_NX51_eth_config_xpic_irq                       30
#define DFLT_VAL_NX51_eth_config_xpic_irq                  0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_xpic_irq               0x00000000U
#define MSK_NX51_eth_config_arm_irq                        0x80000000U
#define SRT_NX51_eth_config_arm_irq                        31
#define DFLT_VAL_NX51_eth_config_arm_irq                   0x00000000U
#define DFLT_BF_VAL_NX51_eth_config_arm_irq                0x00000000U

/* all used bits of 'NX51_eth_config': */
#define MSK_USED_BITS_NX51_eth_config 0xf8003fffU

enum {
	BFW_NX51_eth_config_rx_watermark_irq       = 4,  /* [3:0] */
	BFW_NX51_eth_config_rx_sample_phase        = 3,  /* [6:4] */
	BFW_NX51_eth_config_rx_delay_inputs        = 1,  /* [7] */
	BFW_NX51_eth_config_rx_allow_jumbo_packets = 1,  /* [8] */
	BFW_NX51_eth_config_rx_exact_preamble      = 1,  /* [9] */
	BFW_NX51_eth_config_rx_no_preamble         = 1,  /* [10] */
	BFW_NX51_eth_config_rx_dma_mode            = 1,  /* [11] */
	BFW_NX51_eth_config_rx_systime_sfd         = 1,  /* [12] */
	BFW_NX51_eth_config_rx_enable              = 1,  /* [13] */
	BFW_NX51_eth_config_reserved1              = 13, /* [26:14] */
	BFW_NX51_eth_config_frequency              = 1,  /* [27] */
	BFW_NX51_eth_config_hd_suppress_loopback   = 1,  /* [28] */
	BFW_NX51_eth_config_phy_mode               = 1,  /* [29] */
	BFW_NX51_eth_config_xpic_irq               = 1,  /* [30] */
	BFW_NX51_eth_config_arm_irq                = 1   /* [31] */
};

typedef struct NX51_ETH_CONFIG_BIT_Ttag {
	unsigned int rx_watermark_irq       : BFW_NX51_eth_config_rx_watermark_irq;       /* Watermark for RX-FIFO, that generates interrupt                                         */
	                                                                                  /* This number of DWords is available inside RX-FIFO                                       */
	unsigned int rx_sample_phase        : BFW_NX51_eth_config_rx_sample_phase;        /* clk-phase in which rxd is sampled                                                       */
	                                                                                  /* PHY mode (phy_mode=1):                                                                  */
	                                                                                  /* 0,4: sample at posedge tx_clk                                                           */
	                                                                                  /* 1,5: sample at posedge tx_clk + 1cc                                                     */
	                                                                                  /* 2,6: sample at posedge tx_clk + 2cc                                                     */
	                                                                                  /* 3,7: sample at posedge tx_clk + 3cc                                                     */
	                                                                                  /* MAC mode (phy_mode=0):                                                                  */
	                                                                                  /* 0: sample at posedge rx_clk + 1cc                                                       */
	                                                                                  /* 1: sample at posedge rx_clk + 2cc                                                       */
	                                                                                  /* 2: sample at posedge rx_clk + 3cc                                                       */
	                                                                                  /* 3: sample at posedge rx_clk + 4cc                                                       */
	                                                                                  /* 4: sample at negedge rx_clk + 3cc                                                       */
	                                                                                  /* 5: sample at negedge rx_clk + 4cc                                                       */
	                                                                                  /* 6: sample at negedge rx_clk + 1cc                                                       */
	                                                                                  /* 7: sample at negedge rx_clk + 2cc                                                       */
	unsigned int rx_delay_inputs        : BFW_NX51_eth_config_rx_delay_inputs;        /* Delay mii inputs (rx_d, rx_dv, rx_err, crs, col) by 1 clockcycle before sampling them.  */
	                                                                                  /* This leads to inputs fitting to sampled rxclk.                                          */
	                                                                                  /* Enable this in MAC mode, disable in PHY mode.                                           */
	unsigned int rx_allow_jumbo_packets : BFW_NX51_eth_config_rx_allow_jumbo_packets; /* receive frames > 1522 bytes                                                             */
	                                                                                  /* If jumbo_packets are not allowed, the receive frame buffer must be 1524 bytes.          */
	                                                                                  /* Warning: Frames with len > 2047 will be received, but rx_frame_len has only 11 bit.     */
	unsigned int rx_exact_preamble      : BFW_NX51_eth_config_rx_exact_preamble;      /* Accept only packages with exact preamble,                                               */
	                                                                                  /* rx_preamble_error IRQ will be generated independant on this setting                     */
	unsigned int rx_no_preamble         : BFW_NX51_eth_config_rx_no_preamble;         /* receive starts, when rxdv gets active                                                   */
	unsigned int rx_dma_mode            : BFW_NX51_eth_config_rx_dma_mode;            /* Receive DMA mode:                                                                       */
	                                                                                  /* Each received frame needs 2 DMA-transfers, one for package data and                     */
	                                                                                  /* one for rx_len/status.                                                                  */
	                                                                                  /* In rx_dma_mode irq_raw-rx_frame_finished is reset automatically.                        */
	unsigned int rx_systime_sfd         : BFW_NX51_eth_config_rx_systime_sfd;         /* Sample systime at SFD of received frame:                                                */
	                                                                                  /* 1: Sample systime_ns to eth_rx_systime_ns at SFD (+constant offset)                     */
	                                                                                  /* 0: Sample systime_ns to eth_rx_systime_ns when rxdv gets active (+constant offset)      */
	unsigned int rx_enable              : BFW_NX51_eth_config_rx_enable;              /* Enable of receive state machine                                                         */
	                                                                                  /* When disabled, receive state machine is reset.                                          */
	                                                                                  /* After enabling, receive state machine waits for rxdv going down.                        */
	                                                                                  /* If rxdv is already down, proper IFG is expected.                                        */
	unsigned int reserved1              : BFW_NX51_eth_config_reserved1;              /* reserved                                                                                */
	unsigned int frequency              : BFW_NX51_eth_config_frequency;              /* MII clock frequency:                                                                    */
	                                                                                  /* 1: 50MHz (use in PHY mode only)                                                         */
	                                                                                  /* 0: 25MHz                                                                                */
	unsigned int hd_suppress_loopback   : BFW_NX51_eth_config_hd_suppress_loopback;   /* Suppress loopback in half_duplex mode:                                                  */
	                                                                                  /* 1: don't start RX-process, if txen is active.                                           */
	                                                                                  /* 0: RX and TX work indepentently.                                                        */
	unsigned int phy_mode               : BFW_NX51_eth_config_phy_mode;               /* PHY mode:                                                                               */
	                                                                                  /* 0: behave like an ethernet MAC, sync to external rxclk/txclk                            */
	                                                                                  /* 1: behave like an ethernet PHY, generate txclk (=rxclk), signals change their function: */
	                                                                                  /*    rxclk   : not used                                                                   */
	                                                                                  /*    rxd[3:0]: data input, to be connected to txd[3:0] of MAC device                      */
	                                                                                  /*    rxdv    : Data valid input, to be connected to txen of MAC device                    */
	                                                                                  /*    rxer    : Error input, to be connected to txer of MAC device                         */
	                                                                                  /*    txclk   : Clock output, to be connected to rxclk and txclk of MAC device             */
	                                                                                  /*    txd[3:0]: Data output, to be connected to rxd[3:0] of MAC device                     */
	                                                                                  /*    txen    : Data valid output, to be connected to rxdv of MAC device                   */
	                                                                                  /*    txer    : Error output. to be connected to rxer of MAC device                        */
	                                                                                  /*    col     : not used                                                                   */
	                                                                                  /*    crs     : not used                                                                   */
	unsigned int xpic_irq               : BFW_NX51_eth_config_xpic_irq;               /* enable XPIC IRQ                                                                         */
	unsigned int arm_irq                : BFW_NX51_eth_config_arm_irq;                /* enable ARM IRQ                                                                          */
} NX51_ETH_CONFIG_BIT_T;

typedef union {
	unsigned int          val;
	NX51_ETH_CONFIG_BIT_T bf;
} NX51_ETH_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_config */
/* => ETH config register */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_tx_config  0x00000004U
#define Adr_NX51_eth_eth_tx_config  0x10210004U
#define Adr_NX51_eth_tx_config      0x10210004U
#define DFLT_VAL_NX51_eth_tx_config 0x02188084U

#define MSK_NX51_eth_tx_config_tx_watermark_irq           0x0000000fU
#define SRT_NX51_eth_tx_config_tx_watermark_irq           0
#define DFLT_VAL_NX51_eth_tx_config_tx_watermark_irq      0x00000004U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_watermark_irq   0x00000004U
#define MSK_NX51_eth_tx_config_tx_watermark_start         0x000000f0U
#define SRT_NX51_eth_tx_config_tx_watermark_start         4
#define DFLT_VAL_NX51_eth_tx_config_tx_watermark_start    0x00000080U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_watermark_start 0x00000008U
#define MSK_NX51_eth_tx_config_tx_output_phase            0x00000700U
#define SRT_NX51_eth_tx_config_tx_output_phase            8
#define DFLT_VAL_NX51_eth_tx_config_tx_output_phase       0x00000000U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_output_phase    0x00000000U
#define MSK_NX51_eth_tx_config_tx_preamble_len            0x0000f800U
#define SRT_NX51_eth_tx_config_tx_preamble_len            11
#define DFLT_VAL_NX51_eth_tx_config_tx_preamble_len       0x00008000U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_preamble_len    0x00000010U
#define MSK_NX51_eth_tx_config_tx_min_ifg_cycles          0x001f0000U
#define SRT_NX51_eth_tx_config_tx_min_ifg_cycles          16
#define DFLT_VAL_NX51_eth_tx_config_tx_min_ifg_cycles     0x00180000U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_min_ifg_cycles  0x00000018U
#define MSK_NX51_eth_tx_config_tx_crs_low_cycles          0x03e00000U
#define SRT_NX51_eth_tx_config_tx_crs_low_cycles          21
#define DFLT_VAL_NX51_eth_tx_config_tx_crs_low_cycles     0x02000000U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_crs_low_cycles  0x00000010U
#define MSK_NX51_eth_tx_config_tx_abort_frame             0x1c000000U
#define SRT_NX51_eth_tx_config_tx_abort_frame             26
#define DFLT_VAL_NX51_eth_tx_config_tx_abort_frame        0x00000000U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_abort_frame     0x00000000U
#define MSK_NX51_eth_tx_config_tx_systime_sfd             0x20000000U
#define SRT_NX51_eth_tx_config_tx_systime_sfd             29
#define DFLT_VAL_NX51_eth_tx_config_tx_systime_sfd        0x00000000U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_systime_sfd     0x00000000U
#define MSK_NX51_eth_tx_config_tx_dma_mode                0x40000000U
#define SRT_NX51_eth_tx_config_tx_dma_mode                30
#define DFLT_VAL_NX51_eth_tx_config_tx_dma_mode           0x00000000U
#define DFLT_BF_VAL_NX51_eth_tx_config_tx_dma_mode        0x00000000U
#define MSK_NX51_eth_tx_config_half_duplex                0x80000000U
#define SRT_NX51_eth_tx_config_half_duplex                31
#define DFLT_VAL_NX51_eth_tx_config_half_duplex           0x00000000U
#define DFLT_BF_VAL_NX51_eth_tx_config_half_duplex        0x00000000U

/* all used bits of 'NX51_eth_tx_config': */
#define MSK_USED_BITS_NX51_eth_tx_config 0xffffffffU

enum {
	BFW_NX51_eth_tx_config_tx_watermark_irq   = 4, /* [3:0] */
	BFW_NX51_eth_tx_config_tx_watermark_start = 4, /* [7:4] */
	BFW_NX51_eth_tx_config_tx_output_phase    = 3, /* [10:8] */
	BFW_NX51_eth_tx_config_tx_preamble_len    = 5, /* [15:11] */
	BFW_NX51_eth_tx_config_tx_min_ifg_cycles  = 5, /* [20:16] */
	BFW_NX51_eth_tx_config_tx_crs_low_cycles  = 5, /* [25:21] */
	BFW_NX51_eth_tx_config_tx_abort_frame     = 3, /* [28:26] */
	BFW_NX51_eth_tx_config_tx_systime_sfd     = 1, /* [29] */
	BFW_NX51_eth_tx_config_tx_dma_mode        = 1, /* [30] */
	BFW_NX51_eth_tx_config_half_duplex        = 1  /* [31] */
};

typedef struct NX51_ETH_TX_CONFIG_BIT_Ttag {
	unsigned int tx_watermark_irq   : BFW_NX51_eth_tx_config_tx_watermark_irq;   /* Watermark for TX-FIFO, that generates IRQ                                                                                      */
	                                                                             /* This number of DWords is free inside TX-FIFO                                                                                   */
	unsigned int tx_watermark_start : BFW_NX51_eth_tx_config_tx_watermark_start; /* Watermark for TX-FIFO, that starts transmission                                                                                */
	                                                                             /* This number of DWords is inside TX-FIFO                                                                                        */
	unsigned int tx_output_phase    : BFW_NX51_eth_tx_config_tx_output_phase;    /* clk-phase in which txd, txen, txer is changed at output                                                                        */
	                                                                             /* PHY mode (phy_mode=1):                                                                                                         */
	                                                                             /* 0,4: change output at negedge tx_clk                                                                                           */
	                                                                             /* 1,5: change output at negedge tx_clk + 1cc                                                                                     */
	                                                                             /* 2,6: change output at negedge tx_clk + 2cc                                                                                     */
	                                                                             /* 3,7: change output at negedge tx_clk + 3cc                                                                                     */
	                                                                             /* MAC mode (phy_mode=0):                                                                                                         */
	                                                                             /* 0: change output at posedge tx_clk + 2cc                                                                                       */
	                                                                             /* 1: change output at posedge tx_clk + 3cc                                                                                       */
	                                                                             /* 2: change output at posedge tx_clk + 4cc                                                                                       */
	                                                                             /* 3: change output at posedge tx_clk + 5cc                                                                                       */
	                                                                             /* 4: change output at negedge tx_clk + 4cc                                                                                       */
	                                                                             /* 5: change output at negedge tx_clk + 5cc                                                                                       */
	                                                                             /* 6: change output at negedge tx_clk + 2cc                                                                                       */
	                                                                             /* 7: change output at negedge tx_clk + 3cc                                                                                       */
	unsigned int tx_preamble_len    : BFW_NX51_eth_tx_config_tx_preamble_len;    /* Length of TX-preamble in nibbles (incl. SFD)                                                                                   */
	unsigned int tx_min_ifg_cycles  : BFW_NX51_eth_tx_config_tx_min_ifg_cycles;  /* minimum IFG in txclk-cycles                                                                                                    */
	                                                                             /* In half_duplex mode reduce value by 2 to compensate cycles for sampling of mii_crs.                                            */
	unsigned int tx_crs_low_cycles  : BFW_NX51_eth_tx_config_tx_crs_low_cycles;  /* txclk-cycles with mii_crs low, before free carrier is detected (only used in half_duplex mode):                                */
	                                                                             /* Value range: [0,tx_min_ifg_cycles].                                                                                            */
	                                                                             /* For details s. half_duplex mode.                                                                                               */
	unsigned int tx_abort_frame     : BFW_NX51_eth_tx_config_tx_abort_frame;     /* Different abort mechanisms:                                                                                                    */
	                                                                             /* 000: no abort:                                                                                                                 */
	                                                                             /*      Transmit frame from TX-FIFO until tx_len and append correct FCS.                                                          */
	                                                                             /* 001: standard abort:                                                                                                           */
	                                                                             /*      Abort transmission, send wrong FCS, activate mii_txer.                                                                    */
	                                                                             /*      SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO.                                                */
	                                                                             /* 010: abort with dribble nibble:                                                                                                */
	                                                                             /*      Like standard abort, but append dribble nibble after wrong FCS (needed by some PHYs to detect error condition)            */
	                                                                             /*      SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO.                                                */
	                                                                             /* 011: no FCS mode:                                                                                                              */
	                                                                             /*      Transmit frame from TX-FIFO until tx_len but do not append FCS. Never activate mii_txer (except in case of tx_fifo_undr). */
	                                                                             /* 100: Fast Track Switching controlled abort:                                                                                    */
	                                                                             /*      Wait for next byte-border, then attach special FCS as wrong FCS.                                                          */
	                                                                             /*      Special FCS is "a0a0a0a0", or "a0a0a0a1" in case that real FCS would end with "a0".                                       */
	                                                                             /*      Do not activate mii_txer.                                                                                                 */
	                                                                             /*      SW should keep bit active until irq-tx_frame_finished, then reset TX-FIFO.                                                */
	                                                                             /* 101: reserved                                                                                                                  */
	                                                                             /* 110: reserved                                                                                                                  */
	                                                                             /* 111: reserved                                                                                                                  */
	unsigned int tx_systime_sfd     : BFW_NX51_eth_tx_config_tx_systime_sfd;     /* Sample systime at SFD:                                                                                                         */
	                                                                             /* 1: Sample systime_ns to eth_tx_systime_ns at SFD (-constant offset)                                                            */
	                                                                             /* 0: Sample systime_ns to eth_tx_systime_ns when txen gets active (-constant offset)                                             */
	unsigned int tx_dma_mode        : BFW_NX51_eth_tx_config_tx_dma_mode;        /* In tx_dma_mode tx_len comes from DMAC automatically.                                                                           */
	                                                                             /* An extra tx_lsreq will be generated to request tx_len,                                                                         */
	                                                                             /* before frame data is requested (and after previous frame is finished).                                                         */
	                                                                             /* In tx_dma_mode irq_raw-tx_frame_finished is reset automatically.                                                               */
	unsigned int half_duplex        : BFW_NX51_eth_tx_config_half_duplex;        /* Half Duplex Mode:                                                                                                              */
	                                                                             /* 1: In half duplex mode transmission of a frame starts after the following sequence:                                            */
	                                                                             /*    - tx_watermark_start was reached                                                                                            */
	                                                                             /*    - mii_crs became low and stayed low for tx_crs_low_cycles                                                                   */
	                                                                             /*    - (tx_min_ifg_cycles - tx_crs_low_cycles) are passed                                                                        */
	                                                                             /* 0: In full duplex mode transmission of a frame starts after the following sequence:                                            */
	                                                                             /*    - tx_min_ifg_cycles are passed after the last transmitted frame                                                             */
	                                                                             /*    - tx_watermark_start was reached                                                                                            */
} NX51_ETH_TX_CONFIG_BIT_T;

typedef union {
	unsigned int             val;
	NX51_ETH_TX_CONFIG_BIT_T bf;
} NX51_ETH_TX_CONFIG_T;

/* --------------------------------------------------------------------- */
/* Register eth_status */
/* => ETH status register: */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_status 0x00000008U
#define Adr_NX51_eth_eth_status 0x10210008U
#define Adr_NX51_eth_status     0x10210008U

#define MSK_NX51_eth_status_rx_fill 0x0000001fU
#define SRT_NX51_eth_status_rx_fill 0
#define MSK_NX51_eth_status_tx_fill 0x00000f80U
#define SRT_NX51_eth_status_tx_fill 7

/* all used bits of 'NX51_eth_status': */
#define MSK_USED_BITS_NX51_eth_status 0x00000f9fU

enum {
	BFW_NX51_eth_status_rx_fill   = 5,  /* [4:0] */
	BFW_NX51_eth_status_reserved1 = 2,  /* [6:5] */
	BFW_NX51_eth_status_tx_fill   = 5,  /* [11:7] */
	BFW_NX51_eth_status_reserved2 = 20  /* [31:12] */
};

typedef struct NX51_ETH_STATUS_BIT_Ttag {
	unsigned int rx_fill   : BFW_NX51_eth_status_rx_fill;   /* Fill-level of RX-FIFO */
	unsigned int reserved1 : BFW_NX51_eth_status_reserved1; /* reserved              */
	unsigned int tx_fill   : BFW_NX51_eth_status_tx_fill;   /* Fill-level of TX-FIFO */
	unsigned int reserved2 : BFW_NX51_eth_status_reserved2; /* reserved              */
} NX51_ETH_STATUS_BIT_T;

typedef union {
	unsigned int          val;
	NX51_ETH_STATUS_BIT_T bf;
} NX51_ETH_STATUS_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_data */
/* => Data to TX-FIFO: */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_tx_data  0x0000000CU
#define Adr_NX51_eth_eth_tx_data  0x1021000CU
#define Adr_NX51_eth_tx_data      0x1021000CU
#define DFLT_VAL_NX51_eth_tx_data 0x00000000U

#define MSK_NX51_eth_tx_data_val         0xffffffffU
#define SRT_NX51_eth_tx_data_val         0
#define DFLT_VAL_NX51_eth_tx_data_val    0x00000000U
#define DFLT_BF_VAL_NX51_eth_tx_data_val 0x00000000U

/* all used bits of 'NX51_eth_tx_data': */
#define MSK_USED_BITS_NX51_eth_tx_data 0xffffffffU

enum {
	BFW_NX51_eth_tx_data_val = 32  /* [31:0] */
};

typedef struct NX51_ETH_TX_DATA_BIT_Ttag {
	unsigned int val : BFW_NX51_eth_tx_data_val; /* data to TX-FIFO */
} NX51_ETH_TX_DATA_BIT_T;

typedef union {
	unsigned int           val;
	NX51_ETH_TX_DATA_BIT_T bf;
} NX51_ETH_TX_DATA_T;

/* --------------------------------------------------------------------- */
/* Register eth_rx_data */
/* => Data from RX-FIFO: */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_rx_data 0x00000010U
#define Adr_NX51_eth_eth_rx_data 0x10210010U
#define Adr_NX51_eth_rx_data     0x10210010U

#define MSK_NX51_eth_rx_data_val 0xffffffffU
#define SRT_NX51_eth_rx_data_val 0

/* all used bits of 'NX51_eth_rx_data': */
#define MSK_USED_BITS_NX51_eth_rx_data 0xffffffffU

enum {
	BFW_NX51_eth_rx_data_val = 32  /* [31:0] */
};

typedef struct NX51_ETH_RX_DATA_BIT_Ttag {
	unsigned int val : BFW_NX51_eth_rx_data_val; /* data from RX-FIFO */
} NX51_ETH_RX_DATA_BIT_T;

typedef union {
	unsigned int           val;
	NX51_ETH_RX_DATA_BIT_T bf;
} NX51_ETH_RX_DATA_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_len */
/* => Length of data inside transmitted frame (between SFD and FCS) */
/*    Note: Set this value after previous frame is completely transmitted (irq-tx_frame_finished). */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_tx_len  0x00000014U
#define Adr_NX51_eth_eth_tx_len  0x10210014U
#define Adr_NX51_eth_tx_len      0x10210014U
#define DFLT_VAL_NX51_eth_tx_len 0x000005eaU

#define MSK_NX51_eth_tx_len_val         0x000007ffU
#define SRT_NX51_eth_tx_len_val         0
#define DFLT_VAL_NX51_eth_tx_len_val    0x000005eaU
#define DFLT_BF_VAL_NX51_eth_tx_len_val 0x000005eaU

/* all used bits of 'NX51_eth_tx_len': */
#define MSK_USED_BITS_NX51_eth_tx_len 0x000007ffU

enum {
	BFW_NX51_eth_tx_len_val       = 11, /* [10:0] */
	BFW_NX51_eth_tx_len_reserved1 = 21  /* [31:11] */
};

typedef struct NX51_ETH_TX_LEN_BIT_Ttag {
	unsigned int val       : BFW_NX51_eth_tx_len_val;       /* To be transmitted data length (excluding SFD and excluding FCS) */
	unsigned int reserved1 : BFW_NX51_eth_tx_len_reserved1; /* reserved                                                        */
} NX51_ETH_TX_LEN_BIT_T;

typedef union {
	unsigned int          val;
	NX51_ETH_TX_LEN_BIT_T bf;
} NX51_ETH_TX_LEN_T;

/* --------------------------------------------------------------------- */
/* Register eth_rx_len_stat */
/* => Length and status information of lastly received frame */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_rx_len_stat 0x00000018U
#define Adr_NX51_eth_eth_rx_len_stat 0x10210018U
#define Adr_NX51_eth_rx_len_stat     0x10210018U

#define MSK_NX51_eth_rx_len_stat_rx_len            0x000007ffU
#define SRT_NX51_eth_rx_len_stat_rx_len            0
#define MSK_NX51_eth_rx_len_stat_rx_short_ifg      0x08000000U
#define SRT_NX51_eth_rx_len_stat_rx_short_ifg      27
#define MSK_NX51_eth_rx_len_stat_rx_jumbo_packet   0x10000000U
#define SRT_NX51_eth_rx_len_stat_rx_jumbo_packet   28
#define MSK_NX51_eth_rx_len_stat_rx_dribble_nibble 0x20000000U
#define SRT_NX51_eth_rx_len_stat_rx_dribble_nibble 29
#define MSK_NX51_eth_rx_len_stat_rx_crc_error      0x40000000U
#define SRT_NX51_eth_rx_len_stat_rx_crc_error      30
#define MSK_NX51_eth_rx_len_stat_rx_mii_rxerr      0x80000000U
#define SRT_NX51_eth_rx_len_stat_rx_mii_rxerr      31

/* all used bits of 'NX51_eth_rx_len_stat': */
#define MSK_USED_BITS_NX51_eth_rx_len_stat 0xf80007ffU

enum {
	BFW_NX51_eth_rx_len_stat_rx_len            = 11, /* [10:0] */
	BFW_NX51_eth_rx_len_stat_reserved1         = 16, /* [26:11] */
	BFW_NX51_eth_rx_len_stat_rx_short_ifg      = 1,  /* [27] */
	BFW_NX51_eth_rx_len_stat_rx_jumbo_packet   = 1,  /* [28] */
	BFW_NX51_eth_rx_len_stat_rx_dribble_nibble = 1,  /* [29] */
	BFW_NX51_eth_rx_len_stat_rx_crc_error      = 1,  /* [30] */
	BFW_NX51_eth_rx_len_stat_rx_mii_rxerr      = 1   /* [31] */
};

typedef struct NX51_ETH_RX_LEN_STAT_BIT_Ttag {
	unsigned int rx_len            : BFW_NX51_eth_rx_len_stat_rx_len;            /* Received data (excluding SFD and including FCS)                               */
	unsigned int reserved1         : BFW_NX51_eth_rx_len_stat_reserved1;         /* reserved                                                                      */
	unsigned int rx_short_ifg      : BFW_NX51_eth_rx_len_stat_rx_short_ifg;      /* IFG shorter 960ns detected (preceeding this frame).                           */
	unsigned int rx_jumbo_packet   : BFW_NX51_eth_rx_len_stat_rx_jumbo_packet;   /* rx_frame_len > 1522 detected                                                  */
	                                                                             /* In case of eth_config-allow_jumbo_packets=1, this frame was received, but     */
	                                                                             /* rx_len will overflow at 2048.                                                 */
	                                                                             /* In case of eth_config-allow_jumbo_packets=0, frame is stopped after 1522, but */
	                                                                             /* other status information (rxerr, crc, dribble_nibble) will be checked anyway. */
	unsigned int rx_dribble_nibble : BFW_NX51_eth_rx_len_stat_rx_dribble_nibble; /* frame finished at non-even nibble count, last nibble was dropped              */
	unsigned int rx_crc_error      : BFW_NX51_eth_rx_len_stat_rx_crc_error;      /* wrong RX FCS detected                                                         */
	unsigned int rx_mii_rxerr      : BFW_NX51_eth_rx_len_stat_rx_mii_rxerr;      /* external rxerr signal was active in last frame                                */
} NX51_ETH_RX_LEN_STAT_BIT_T;

typedef union {
	unsigned int               val;
	NX51_ETH_RX_LEN_STAT_BIT_T bf;
} NX51_ETH_RX_LEN_STAT_T;

/* --------------------------------------------------------------------- */
/* Register eth_rx_systime_ns */
/* => Systime_ns sampled at start of received frame. */
/*    Exact position of start of frame is defined in eth_config-systime_sfd. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_rx_systime_ns 0x00000020U
#define Adr_NX51_eth_eth_rx_systime_ns 0x10210020U
#define Adr_NX51_eth_rx_systime_ns     0x10210020U

#define MSK_NX51_eth_rx_systime_ns_val 0xffffffffU
#define SRT_NX51_eth_rx_systime_ns_val 0

/* all used bits of 'NX51_eth_rx_systime_ns': */
#define MSK_USED_BITS_NX51_eth_rx_systime_ns 0xffffffffU

enum {
	BFW_NX51_eth_rx_systime_ns_val = 32  /* [31:0] */
};

typedef struct NX51_ETH_RX_SYSTIME_NS_BIT_Ttag {
	unsigned int val : BFW_NX51_eth_rx_systime_ns_val; /* Sampled systime_ns */
} NX51_ETH_RX_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_ETH_RX_SYSTIME_NS_BIT_T bf;
} NX51_ETH_RX_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register eth_tx_systime_ns */
/* => Systime_ns sampled at start of transmitted frame. */
/*    Exact position of start of frame is defined in eth_tx_config-systime_sfd. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_tx_systime_ns 0x00000024U
#define Adr_NX51_eth_eth_tx_systime_ns 0x10210024U
#define Adr_NX51_eth_tx_systime_ns     0x10210024U

#define MSK_NX51_eth_tx_systime_ns_val 0xffffffffU
#define SRT_NX51_eth_tx_systime_ns_val 0

/* all used bits of 'NX51_eth_tx_systime_ns': */
#define MSK_USED_BITS_NX51_eth_tx_systime_ns 0xffffffffU

enum {
	BFW_NX51_eth_tx_systime_ns_val = 32  /* [31:0] */
};

typedef struct NX51_ETH_TX_SYSTIME_NS_BIT_Ttag {
	unsigned int val : BFW_NX51_eth_tx_systime_ns_val; /* Sampled systime_ns */
} NX51_ETH_TX_SYSTIME_NS_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_ETH_TX_SYSTIME_NS_BIT_T bf;
} NX51_ETH_TX_SYSTIME_NS_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_raw */
/* => Raw IRQ: */
/*    Read access shows status of unmasked IRQs. \ */
/*    IRQs are set automatically and reset by writing to this register: */
/*    Write access with '1' resets the appropriate IRQ. */
/*    Write access with '0' does not influence this bit. */
/*    Write access with '1' to rx_/tx_fifo_undr/_ovfl resets RX-FIFO/TX-FIFO. */
/*    Bits rx_data and tx_fifo are cleared by reading from/filling the appropriate FIFO. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_irq_raw  0x00000028U
#define Adr_NX51_eth_eth_irq_raw  0x10210028U
#define Adr_NX51_eth_irq_raw      0x10210028U
#define DFLT_VAL_NX51_eth_irq_raw 0x00000000U

#define MSK_NX51_eth_irq_raw_tx_fifo                   0x00000001U
#define SRT_NX51_eth_irq_raw_tx_fifo                   0
#define DFLT_VAL_NX51_eth_irq_raw_tx_fifo              0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_tx_fifo           0x00000000U
#define MSK_NX51_eth_irq_raw_tx_frame_finished         0x00000002U
#define SRT_NX51_eth_irq_raw_tx_frame_finished         1
#define DFLT_VAL_NX51_eth_irq_raw_tx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_tx_frame_finished 0x00000000U
#define MSK_NX51_eth_irq_raw_rx_data                   0x00000004U
#define SRT_NX51_eth_irq_raw_rx_data                   2
#define DFLT_VAL_NX51_eth_irq_raw_rx_data              0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_rx_data           0x00000000U
#define MSK_NX51_eth_irq_raw_rx_frame_finished         0x00000008U
#define SRT_NX51_eth_irq_raw_rx_frame_finished         3
#define DFLT_VAL_NX51_eth_irq_raw_rx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_rx_frame_finished 0x00000000U
#define MSK_NX51_eth_irq_raw_tx_fifo_undr              0x00000010U
#define SRT_NX51_eth_irq_raw_tx_fifo_undr              4
#define DFLT_VAL_NX51_eth_irq_raw_tx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_tx_fifo_undr      0x00000000U
#define MSK_NX51_eth_irq_raw_tx_fifo_ovfl              0x00000020U
#define SRT_NX51_eth_irq_raw_tx_fifo_ovfl              5
#define DFLT_VAL_NX51_eth_irq_raw_tx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_tx_fifo_ovfl      0x00000000U
#define MSK_NX51_eth_irq_raw_rx_fifo_undr              0x00000040U
#define SRT_NX51_eth_irq_raw_rx_fifo_undr              6
#define DFLT_VAL_NX51_eth_irq_raw_rx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_rx_fifo_undr      0x00000000U
#define MSK_NX51_eth_irq_raw_rx_fifo_ovfl              0x00000080U
#define SRT_NX51_eth_irq_raw_rx_fifo_ovfl              7
#define DFLT_VAL_NX51_eth_irq_raw_rx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_rx_fifo_ovfl      0x00000000U
#define MSK_NX51_eth_irq_raw_rx_cpu_too_slow           0x00000100U
#define SRT_NX51_eth_irq_raw_rx_cpu_too_slow           8
#define DFLT_VAL_NX51_eth_irq_raw_rx_cpu_too_slow      0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_rx_cpu_too_slow   0x00000000U
#define MSK_NX51_eth_irq_raw_rx_short_dv               0x00000200U
#define SRT_NX51_eth_irq_raw_rx_short_dv               9
#define DFLT_VAL_NX51_eth_irq_raw_rx_short_dv          0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_rx_short_dv       0x00000000U
#define MSK_NX51_eth_irq_raw_rx_preamble_error         0x00000400U
#define SRT_NX51_eth_irq_raw_rx_preamble_error         10
#define DFLT_VAL_NX51_eth_irq_raw_rx_preamble_error    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_rx_preamble_error 0x00000000U
#define MSK_NX51_eth_irq_raw_tx_col                    0x00000800U
#define SRT_NX51_eth_irq_raw_tx_col                    11
#define DFLT_VAL_NX51_eth_irq_raw_tx_col               0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_tx_col            0x00000000U
#define MSK_NX51_eth_irq_raw_tx_late_col               0x00001000U
#define SRT_NX51_eth_irq_raw_tx_late_col               12
#define DFLT_VAL_NX51_eth_irq_raw_tx_late_col          0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_raw_tx_late_col       0x00000000U

/* all used bits of 'NX51_eth_irq_raw': */
#define MSK_USED_BITS_NX51_eth_irq_raw 0x00001fffU

enum {
	BFW_NX51_eth_irq_raw_tx_fifo           = 1,  /* [0] */
	BFW_NX51_eth_irq_raw_tx_frame_finished = 1,  /* [1] */
	BFW_NX51_eth_irq_raw_rx_data           = 1,  /* [2] */
	BFW_NX51_eth_irq_raw_rx_frame_finished = 1,  /* [3] */
	BFW_NX51_eth_irq_raw_tx_fifo_undr      = 1,  /* [4] */
	BFW_NX51_eth_irq_raw_tx_fifo_ovfl      = 1,  /* [5] */
	BFW_NX51_eth_irq_raw_rx_fifo_undr      = 1,  /* [6] */
	BFW_NX51_eth_irq_raw_rx_fifo_ovfl      = 1,  /* [7] */
	BFW_NX51_eth_irq_raw_rx_cpu_too_slow   = 1,  /* [8] */
	BFW_NX51_eth_irq_raw_rx_short_dv       = 1,  /* [9] */
	BFW_NX51_eth_irq_raw_rx_preamble_error = 1,  /* [10] */
	BFW_NX51_eth_irq_raw_tx_col            = 1,  /* [11] */
	BFW_NX51_eth_irq_raw_tx_late_col       = 1,  /* [12] */
	BFW_NX51_eth_irq_raw_reserved1         = 19  /* [31:13] */
};

typedef struct NX51_ETH_IRQ_RAW_BIT_Ttag {
	unsigned int tx_fifo           : BFW_NX51_eth_irq_raw_tx_fifo;           /* TX-FIFO has free entries                                                                                  */
	unsigned int tx_frame_finished : BFW_NX51_eth_irq_raw_tx_frame_finished; /* TX frame finished                                                                                         */
	                                                                         /* In tx_dma_mode this bit is handled automatically, demask it to the CPU.                                   */
	unsigned int rx_data           : BFW_NX51_eth_irq_raw_rx_data;           /* RX Data is available                                                                                      */
	unsigned int rx_frame_finished : BFW_NX51_eth_irq_raw_rx_frame_finished; /* RX frame finished:                                                                                        */
	                                                                         /* Clearing this bit tells the module, that the CPU has read rx_len_stat and the next frame can be received. */
	                                                                         /* In rx_dma_mode this bit is handled automatically, demask it to the CPU.                                   */
	unsigned int tx_fifo_undr      : BFW_NX51_eth_irq_raw_tx_fifo_undr;      /* TX-FIFO underrun                                                                                          */
	unsigned int tx_fifo_ovfl      : BFW_NX51_eth_irq_raw_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)                                                   */
	unsigned int rx_fifo_undr      : BFW_NX51_eth_irq_raw_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)                                                   */
	unsigned int rx_fifo_ovfl      : BFW_NX51_eth_irq_raw_rx_fifo_ovfl;      /* RX-FIFO overflow                                                                                          */
	unsigned int rx_cpu_too_slow   : BFW_NX51_eth_irq_raw_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared                                           */
	unsigned int rx_short_dv       : BFW_NX51_eth_irq_raw_rx_short_dv;       /* mii_rxdv becomes low before SFD                                                                           */
	unsigned int rx_preamble_error : BFW_NX51_eth_irq_raw_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble                                                   */
	unsigned int tx_col            : BFW_NX51_eth_irq_raw_tx_col;            /* collision detected in half_duplex mode, started sending jam                                               */
	unsigned int tx_late_col       : BFW_NX51_eth_irq_raw_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam                                           */
	unsigned int reserved1         : BFW_NX51_eth_irq_raw_reserved1;         /* reserved                                                                                                  */
} NX51_ETH_IRQ_RAW_BIT_T;

typedef union {
	unsigned int           val;
	NX51_ETH_IRQ_RAW_BIT_T bf;
} NX51_ETH_IRQ_RAW_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_masked */
/* => Masked IRQ: */
/*    Shows status of masked IRQs as connected to ARM/xPIC. */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_irq_masked 0x0000002CU
#define Adr_NX51_eth_eth_irq_masked 0x1021002CU
#define Adr_NX51_eth_irq_masked     0x1021002CU

#define MSK_NX51_eth_irq_masked_tx_fifo           0x00000001U
#define SRT_NX51_eth_irq_masked_tx_fifo           0
#define MSK_NX51_eth_irq_masked_tx_frame_finished 0x00000002U
#define SRT_NX51_eth_irq_masked_tx_frame_finished 1
#define MSK_NX51_eth_irq_masked_rx_data           0x00000004U
#define SRT_NX51_eth_irq_masked_rx_data           2
#define MSK_NX51_eth_irq_masked_rx_frame_finished 0x00000008U
#define SRT_NX51_eth_irq_masked_rx_frame_finished 3
#define MSK_NX51_eth_irq_masked_tx_fifo_undr      0x00000010U
#define SRT_NX51_eth_irq_masked_tx_fifo_undr      4
#define MSK_NX51_eth_irq_masked_tx_fifo_ovfl      0x00000020U
#define SRT_NX51_eth_irq_masked_tx_fifo_ovfl      5
#define MSK_NX51_eth_irq_masked_rx_fifo_undr      0x00000040U
#define SRT_NX51_eth_irq_masked_rx_fifo_undr      6
#define MSK_NX51_eth_irq_masked_rx_fifo_ovfl      0x00000080U
#define SRT_NX51_eth_irq_masked_rx_fifo_ovfl      7
#define MSK_NX51_eth_irq_masked_rx_cpu_too_slow   0x00000100U
#define SRT_NX51_eth_irq_masked_rx_cpu_too_slow   8
#define MSK_NX51_eth_irq_masked_rx_short_dv       0x00000200U
#define SRT_NX51_eth_irq_masked_rx_short_dv       9
#define MSK_NX51_eth_irq_masked_rx_preamble_error 0x00000400U
#define SRT_NX51_eth_irq_masked_rx_preamble_error 10
#define MSK_NX51_eth_irq_masked_tx_col            0x00000800U
#define SRT_NX51_eth_irq_masked_tx_col            11
#define MSK_NX51_eth_irq_masked_tx_late_col       0x00001000U
#define SRT_NX51_eth_irq_masked_tx_late_col       12

/* all used bits of 'NX51_eth_irq_masked': */
#define MSK_USED_BITS_NX51_eth_irq_masked 0x00001fffU

enum {
	BFW_NX51_eth_irq_masked_tx_fifo           = 1,  /* [0] */
	BFW_NX51_eth_irq_masked_tx_frame_finished = 1,  /* [1] */
	BFW_NX51_eth_irq_masked_rx_data           = 1,  /* [2] */
	BFW_NX51_eth_irq_masked_rx_frame_finished = 1,  /* [3] */
	BFW_NX51_eth_irq_masked_tx_fifo_undr      = 1,  /* [4] */
	BFW_NX51_eth_irq_masked_tx_fifo_ovfl      = 1,  /* [5] */
	BFW_NX51_eth_irq_masked_rx_fifo_undr      = 1,  /* [6] */
	BFW_NX51_eth_irq_masked_rx_fifo_ovfl      = 1,  /* [7] */
	BFW_NX51_eth_irq_masked_rx_cpu_too_slow   = 1,  /* [8] */
	BFW_NX51_eth_irq_masked_rx_short_dv       = 1,  /* [9] */
	BFW_NX51_eth_irq_masked_rx_preamble_error = 1,  /* [10] */
	BFW_NX51_eth_irq_masked_tx_col            = 1,  /* [11] */
	BFW_NX51_eth_irq_masked_tx_late_col       = 1,  /* [12] */
	BFW_NX51_eth_irq_masked_reserved1         = 19  /* [31:13] */
};

typedef struct NX51_ETH_IRQ_MASKED_BIT_Ttag {
	unsigned int tx_fifo           : BFW_NX51_eth_irq_masked_tx_fifo;           /* TX-FIFO has free entries                                        */
	unsigned int tx_frame_finished : BFW_NX51_eth_irq_masked_tx_frame_finished; /* TX frame finished                                               */
	unsigned int rx_data           : BFW_NX51_eth_irq_masked_rx_data;           /* RX Data is available                                            */
	unsigned int rx_frame_finished : BFW_NX51_eth_irq_masked_rx_frame_finished; /* RX frame finished                                               */
	unsigned int tx_fifo_undr      : BFW_NX51_eth_irq_masked_tx_fifo_undr;      /* TX-FIFO underrun                                                */
	unsigned int tx_fifo_ovfl      : BFW_NX51_eth_irq_masked_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)         */
	unsigned int rx_fifo_undr      : BFW_NX51_eth_irq_masked_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)         */
	unsigned int rx_fifo_ovfl      : BFW_NX51_eth_irq_masked_rx_fifo_ovfl;      /* RX-FIFO overflow                                                */
	unsigned int rx_cpu_too_slow   : BFW_NX51_eth_irq_masked_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared */
	unsigned int rx_short_dv       : BFW_NX51_eth_irq_masked_rx_short_dv;       /* mii_rxdv becomes low before SFD                                 */
	unsigned int rx_preamble_error : BFW_NX51_eth_irq_masked_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble         */
	unsigned int tx_col            : BFW_NX51_eth_irq_masked_tx_col;            /* collision detected in half_duplex mode, started sending jam     */
	unsigned int tx_late_col       : BFW_NX51_eth_irq_masked_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam */
	unsigned int reserved1         : BFW_NX51_eth_irq_masked_reserved1;         /* reserved                                                        */
} NX51_ETH_IRQ_MASKED_BIT_T;

typedef union {
	unsigned int              val;
	NX51_ETH_IRQ_MASKED_BIT_T bf;
} NX51_ETH_IRQ_MASKED_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_msk_set */
/* => IRQ mask set: */
/*    The IRQ mask enables interrupt requests for corresponding interrupt sources. \ */
/*    As its bits might be changed by different software tasks, \ */
/*    the IRQ mask register is not writable directly, but by set and reset masks: */
/*    Write access with '1' sets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/*    Attention: Before activating interrupt mask, delete old pending interrupts by writing the same value to adr_eth_irq_raw. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_irq_msk_set  0x00000030U
#define Adr_NX51_eth_eth_irq_msk_set  0x10210030U
#define Adr_NX51_eth_irq_msk_set      0x10210030U
#define DFLT_VAL_NX51_eth_irq_msk_set 0x00000000U

#define MSK_NX51_eth_irq_msk_set_tx_fifo                   0x00000001U
#define SRT_NX51_eth_irq_msk_set_tx_fifo                   0
#define DFLT_VAL_NX51_eth_irq_msk_set_tx_fifo              0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_tx_fifo           0x00000000U
#define MSK_NX51_eth_irq_msk_set_tx_frame_finished         0x00000002U
#define SRT_NX51_eth_irq_msk_set_tx_frame_finished         1
#define DFLT_VAL_NX51_eth_irq_msk_set_tx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_tx_frame_finished 0x00000000U
#define MSK_NX51_eth_irq_msk_set_rx_data                   0x00000004U
#define SRT_NX51_eth_irq_msk_set_rx_data                   2
#define DFLT_VAL_NX51_eth_irq_msk_set_rx_data              0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_rx_data           0x00000000U
#define MSK_NX51_eth_irq_msk_set_rx_frame_finished         0x00000008U
#define SRT_NX51_eth_irq_msk_set_rx_frame_finished         3
#define DFLT_VAL_NX51_eth_irq_msk_set_rx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_rx_frame_finished 0x00000000U
#define MSK_NX51_eth_irq_msk_set_tx_fifo_undr              0x00000010U
#define SRT_NX51_eth_irq_msk_set_tx_fifo_undr              4
#define DFLT_VAL_NX51_eth_irq_msk_set_tx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_tx_fifo_undr      0x00000000U
#define MSK_NX51_eth_irq_msk_set_tx_fifo_ovfl              0x00000020U
#define SRT_NX51_eth_irq_msk_set_tx_fifo_ovfl              5
#define DFLT_VAL_NX51_eth_irq_msk_set_tx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_tx_fifo_ovfl      0x00000000U
#define MSK_NX51_eth_irq_msk_set_rx_fifo_undr              0x00000040U
#define SRT_NX51_eth_irq_msk_set_rx_fifo_undr              6
#define DFLT_VAL_NX51_eth_irq_msk_set_rx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_rx_fifo_undr      0x00000000U
#define MSK_NX51_eth_irq_msk_set_rx_fifo_ovfl              0x00000080U
#define SRT_NX51_eth_irq_msk_set_rx_fifo_ovfl              7
#define DFLT_VAL_NX51_eth_irq_msk_set_rx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_rx_fifo_ovfl      0x00000000U
#define MSK_NX51_eth_irq_msk_set_rx_cpu_too_slow           0x00000100U
#define SRT_NX51_eth_irq_msk_set_rx_cpu_too_slow           8
#define DFLT_VAL_NX51_eth_irq_msk_set_rx_cpu_too_slow      0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_rx_cpu_too_slow   0x00000000U
#define MSK_NX51_eth_irq_msk_set_rx_short_dv               0x00000200U
#define SRT_NX51_eth_irq_msk_set_rx_short_dv               9
#define DFLT_VAL_NX51_eth_irq_msk_set_rx_short_dv          0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_rx_short_dv       0x00000000U
#define MSK_NX51_eth_irq_msk_set_rx_preamble_error         0x00000400U
#define SRT_NX51_eth_irq_msk_set_rx_preamble_error         10
#define DFLT_VAL_NX51_eth_irq_msk_set_rx_preamble_error    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_rx_preamble_error 0x00000000U
#define MSK_NX51_eth_irq_msk_set_tx_col                    0x00000800U
#define SRT_NX51_eth_irq_msk_set_tx_col                    11
#define DFLT_VAL_NX51_eth_irq_msk_set_tx_col               0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_tx_col            0x00000000U
#define MSK_NX51_eth_irq_msk_set_tx_late_col               0x00001000U
#define SRT_NX51_eth_irq_msk_set_tx_late_col               12
#define DFLT_VAL_NX51_eth_irq_msk_set_tx_late_col          0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_set_tx_late_col       0x00000000U

/* all used bits of 'NX51_eth_irq_msk_set': */
#define MSK_USED_BITS_NX51_eth_irq_msk_set 0x00001fffU

enum {
	BFW_NX51_eth_irq_msk_set_tx_fifo           = 1,  /* [0] */
	BFW_NX51_eth_irq_msk_set_tx_frame_finished = 1,  /* [1] */
	BFW_NX51_eth_irq_msk_set_rx_data           = 1,  /* [2] */
	BFW_NX51_eth_irq_msk_set_rx_frame_finished = 1,  /* [3] */
	BFW_NX51_eth_irq_msk_set_tx_fifo_undr      = 1,  /* [4] */
	BFW_NX51_eth_irq_msk_set_tx_fifo_ovfl      = 1,  /* [5] */
	BFW_NX51_eth_irq_msk_set_rx_fifo_undr      = 1,  /* [6] */
	BFW_NX51_eth_irq_msk_set_rx_fifo_ovfl      = 1,  /* [7] */
	BFW_NX51_eth_irq_msk_set_rx_cpu_too_slow   = 1,  /* [8] */
	BFW_NX51_eth_irq_msk_set_rx_short_dv       = 1,  /* [9] */
	BFW_NX51_eth_irq_msk_set_rx_preamble_error = 1,  /* [10] */
	BFW_NX51_eth_irq_msk_set_tx_col            = 1,  /* [11] */
	BFW_NX51_eth_irq_msk_set_tx_late_col       = 1,  /* [12] */
	BFW_NX51_eth_irq_msk_set_reserved1         = 19  /* [31:13] */
};

typedef struct NX51_ETH_IRQ_MSK_SET_BIT_Ttag {
	unsigned int tx_fifo           : BFW_NX51_eth_irq_msk_set_tx_fifo;           /* TX-FIFO has free entries                                        */
	unsigned int tx_frame_finished : BFW_NX51_eth_irq_msk_set_tx_frame_finished; /* TX frame finished                                               */
	unsigned int rx_data           : BFW_NX51_eth_irq_msk_set_rx_data;           /* RX Data is available                                            */
	unsigned int rx_frame_finished : BFW_NX51_eth_irq_msk_set_rx_frame_finished; /* RX frame finished                                               */
	unsigned int tx_fifo_undr      : BFW_NX51_eth_irq_msk_set_tx_fifo_undr;      /* TX-FIFO underrun                                                */
	unsigned int tx_fifo_ovfl      : BFW_NX51_eth_irq_msk_set_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)         */
	unsigned int rx_fifo_undr      : BFW_NX51_eth_irq_msk_set_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)         */
	unsigned int rx_fifo_ovfl      : BFW_NX51_eth_irq_msk_set_rx_fifo_ovfl;      /* RX-FIFO overflow                                                */
	unsigned int rx_cpu_too_slow   : BFW_NX51_eth_irq_msk_set_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared */
	unsigned int rx_short_dv       : BFW_NX51_eth_irq_msk_set_rx_short_dv;       /* mii_rxdv becomes low before SFD                                 */
	unsigned int rx_preamble_error : BFW_NX51_eth_irq_msk_set_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble         */
	unsigned int tx_col            : BFW_NX51_eth_irq_msk_set_tx_col;            /* collision detected in half_duplex mode, started sending jam     */
	unsigned int tx_late_col       : BFW_NX51_eth_irq_msk_set_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam */
	unsigned int reserved1         : BFW_NX51_eth_irq_msk_set_reserved1;         /* reserved                                                        */
} NX51_ETH_IRQ_MSK_SET_BIT_T;

typedef union {
	unsigned int               val;
	NX51_ETH_IRQ_MSK_SET_BIT_T bf;
} NX51_ETH_IRQ_MSK_SET_T;

/* --------------------------------------------------------------------- */
/* Register eth_irq_msk_reset */
/* => IRQ mask reset: */
/*    This is the corresponding reset mask to disable interrupt requests for corresponding interrupt sources: */
/*    Write access with '1' resets interrupt mask bit. */
/*    Write access with '0' does not influence this bit. */
/*    Read access shows actual interrupt mask. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_eth_irq_msk_reset  0x00000034U
#define Adr_NX51_eth_eth_irq_msk_reset  0x10210034U
#define Adr_NX51_eth_irq_msk_reset      0x10210034U
#define DFLT_VAL_NX51_eth_irq_msk_reset 0x00000000U

#define MSK_NX51_eth_irq_msk_reset_tx_fifo                   0x00000001U
#define SRT_NX51_eth_irq_msk_reset_tx_fifo                   0
#define DFLT_VAL_NX51_eth_irq_msk_reset_tx_fifo              0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_tx_fifo           0x00000000U
#define MSK_NX51_eth_irq_msk_reset_tx_frame_finished         0x00000002U
#define SRT_NX51_eth_irq_msk_reset_tx_frame_finished         1
#define DFLT_VAL_NX51_eth_irq_msk_reset_tx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_tx_frame_finished 0x00000000U
#define MSK_NX51_eth_irq_msk_reset_rx_data                   0x00000004U
#define SRT_NX51_eth_irq_msk_reset_rx_data                   2
#define DFLT_VAL_NX51_eth_irq_msk_reset_rx_data              0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_rx_data           0x00000000U
#define MSK_NX51_eth_irq_msk_reset_rx_frame_finished         0x00000008U
#define SRT_NX51_eth_irq_msk_reset_rx_frame_finished         3
#define DFLT_VAL_NX51_eth_irq_msk_reset_rx_frame_finished    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_rx_frame_finished 0x00000000U
#define MSK_NX51_eth_irq_msk_reset_tx_fifo_undr              0x00000010U
#define SRT_NX51_eth_irq_msk_reset_tx_fifo_undr              4
#define DFLT_VAL_NX51_eth_irq_msk_reset_tx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_tx_fifo_undr      0x00000000U
#define MSK_NX51_eth_irq_msk_reset_tx_fifo_ovfl              0x00000020U
#define SRT_NX51_eth_irq_msk_reset_tx_fifo_ovfl              5
#define DFLT_VAL_NX51_eth_irq_msk_reset_tx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_tx_fifo_ovfl      0x00000000U
#define MSK_NX51_eth_irq_msk_reset_rx_fifo_undr              0x00000040U
#define SRT_NX51_eth_irq_msk_reset_rx_fifo_undr              6
#define DFLT_VAL_NX51_eth_irq_msk_reset_rx_fifo_undr         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_rx_fifo_undr      0x00000000U
#define MSK_NX51_eth_irq_msk_reset_rx_fifo_ovfl              0x00000080U
#define SRT_NX51_eth_irq_msk_reset_rx_fifo_ovfl              7
#define DFLT_VAL_NX51_eth_irq_msk_reset_rx_fifo_ovfl         0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_rx_fifo_ovfl      0x00000000U
#define MSK_NX51_eth_irq_msk_reset_rx_cpu_too_slow           0x00000100U
#define SRT_NX51_eth_irq_msk_reset_rx_cpu_too_slow           8
#define DFLT_VAL_NX51_eth_irq_msk_reset_rx_cpu_too_slow      0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_rx_cpu_too_slow   0x00000000U
#define MSK_NX51_eth_irq_msk_reset_rx_short_dv               0x00000200U
#define SRT_NX51_eth_irq_msk_reset_rx_short_dv               9
#define DFLT_VAL_NX51_eth_irq_msk_reset_rx_short_dv          0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_rx_short_dv       0x00000000U
#define MSK_NX51_eth_irq_msk_reset_rx_preamble_error         0x00000400U
#define SRT_NX51_eth_irq_msk_reset_rx_preamble_error         10
#define DFLT_VAL_NX51_eth_irq_msk_reset_rx_preamble_error    0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_rx_preamble_error 0x00000000U
#define MSK_NX51_eth_irq_msk_reset_tx_col                    0x00000800U
#define SRT_NX51_eth_irq_msk_reset_tx_col                    11
#define DFLT_VAL_NX51_eth_irq_msk_reset_tx_col               0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_tx_col            0x00000000U
#define MSK_NX51_eth_irq_msk_reset_tx_late_col               0x00001000U
#define SRT_NX51_eth_irq_msk_reset_tx_late_col               12
#define DFLT_VAL_NX51_eth_irq_msk_reset_tx_late_col          0x00000000U
#define DFLT_BF_VAL_NX51_eth_irq_msk_reset_tx_late_col       0x00000000U

/* all used bits of 'NX51_eth_irq_msk_reset': */
#define MSK_USED_BITS_NX51_eth_irq_msk_reset 0x00001fffU

enum {
	BFW_NX51_eth_irq_msk_reset_tx_fifo           = 1,  /* [0] */
	BFW_NX51_eth_irq_msk_reset_tx_frame_finished = 1,  /* [1] */
	BFW_NX51_eth_irq_msk_reset_rx_data           = 1,  /* [2] */
	BFW_NX51_eth_irq_msk_reset_rx_frame_finished = 1,  /* [3] */
	BFW_NX51_eth_irq_msk_reset_tx_fifo_undr      = 1,  /* [4] */
	BFW_NX51_eth_irq_msk_reset_tx_fifo_ovfl      = 1,  /* [5] */
	BFW_NX51_eth_irq_msk_reset_rx_fifo_undr      = 1,  /* [6] */
	BFW_NX51_eth_irq_msk_reset_rx_fifo_ovfl      = 1,  /* [7] */
	BFW_NX51_eth_irq_msk_reset_rx_cpu_too_slow   = 1,  /* [8] */
	BFW_NX51_eth_irq_msk_reset_rx_short_dv       = 1,  /* [9] */
	BFW_NX51_eth_irq_msk_reset_rx_preamble_error = 1,  /* [10] */
	BFW_NX51_eth_irq_msk_reset_tx_col            = 1,  /* [11] */
	BFW_NX51_eth_irq_msk_reset_tx_late_col       = 1,  /* [12] */
	BFW_NX51_eth_irq_msk_reset_reserved1         = 19  /* [31:13] */
};

typedef struct NX51_ETH_IRQ_MSK_RESET_BIT_Ttag {
	unsigned int tx_fifo           : BFW_NX51_eth_irq_msk_reset_tx_fifo;           /* TX-FIFO has free entries                                        */
	unsigned int tx_frame_finished : BFW_NX51_eth_irq_msk_reset_tx_frame_finished; /* TX frame finished                                               */
	unsigned int rx_data           : BFW_NX51_eth_irq_msk_reset_rx_data;           /* RX Data is available                                            */
	unsigned int rx_frame_finished : BFW_NX51_eth_irq_msk_reset_rx_frame_finished; /* RX frame finished                                               */
	unsigned int tx_fifo_undr      : BFW_NX51_eth_irq_msk_reset_tx_fifo_undr;      /* TX-FIFO underrun                                                */
	unsigned int tx_fifo_ovfl      : BFW_NX51_eth_irq_msk_reset_tx_fifo_ovfl;      /* TX-FIFO overflow (debug only, can never happen in ASIC)         */
	unsigned int rx_fifo_undr      : BFW_NX51_eth_irq_msk_reset_rx_fifo_undr;      /* RX-FIFO underrun (debug only, can never happen in ASIC)         */
	unsigned int rx_fifo_ovfl      : BFW_NX51_eth_irq_msk_reset_rx_fifo_ovfl;      /* RX-FIFO overflow                                                */
	unsigned int rx_cpu_too_slow   : BFW_NX51_eth_irq_msk_reset_rx_cpu_too_slow;   /* next frame started before irq_raw_rx_frame_finished was cleared */
	unsigned int rx_short_dv       : BFW_NX51_eth_irq_msk_reset_rx_short_dv;       /* mii_rxdv becomes low before SFD                                 */
	unsigned int rx_preamble_error : BFW_NX51_eth_irq_msk_reset_rx_preamble_error; /* data <> 0x5 during preamble or wrong length of preamble         */
	unsigned int tx_col            : BFW_NX51_eth_irq_msk_reset_tx_col;            /* collision detected in half_duplex mode, started sending jam     */
	unsigned int tx_late_col       : BFW_NX51_eth_irq_msk_reset_tx_late_col;       /* late colision detected in half_duplex mode, started sending jam */
	unsigned int reserved1         : BFW_NX51_eth_irq_msk_reset_reserved1;         /* reserved                                                        */
} NX51_ETH_IRQ_MSK_RESET_BIT_T;

typedef union {
	unsigned int                 val;
	NX51_ETH_IRQ_MSK_RESET_BIT_T bf;
} NX51_ETH_IRQ_MSK_RESET_T;


/* ===================================================================== */

/* AREA erich */
/* Area of erich, erich_buf */

/* ===================================================================== */

#define Addr_NX51_erich     0x10280000U
#define Addr_NX51_erich_buf 0x08280000U

/* ===================================================================== */

/* AREA intramhs */
/* Area of intramhs_straight_mirror, intramhs_dpm_mirror, intramhs_arm_mirror, intramhs_xpic_mirror, intramhs_mirror_hi, intramhs_mirror_itcm, intramhs_buf_straight_mirror, intramhs_buf_xpic_mirror, intramhs_buf_arm_mirror, intramhs, intramhs_mirror_dtcm, intramhs_buf_dpm_mirror */

/* ===================================================================== */

#define Addr_NX51_intramhs_straight_mirror     0x1A000000U
#define Addr_NX51_intramhs_dpm_mirror          0x1A008000U
#define Addr_NX51_intramhs_arm_mirror          0x1A010000U
#define Addr_NX51_intramhs_xpic_mirror         0x1A018000U
#define Addr_NX51_intramhs_mirror_hi           0xFFEA0000U
#define Addr_NX51_intramhs_mirror_itcm         0x000A0000U
#define Addr_NX51_intramhs_buf_straight_mirror 0x0A000000U
#define Addr_NX51_intramhs_buf_xpic_mirror     0x0A018000U
#define Addr_NX51_intramhs_buf_arm_mirror      0x0A010000U
#define Addr_NX51_intramhs                     0x080A0000U
#define NX51_NETX_MEM_INTRN_DPM_AREA           0x080A0000U
#define Addr_NX51_intramhs_mirror_dtcm         0x040A0000U
#define Addr_NX51_intramhs_buf_dpm_mirror      0x0A008000U

/* --------------------------------------------------------------------- */
/* Register intramhs_base */
/* => Internal Handshake RAM start address. */
/*    Area size: 32kB */
/*    Handshake RAM is mirrored several times in this AHBL slave. Special handshake IRQ generation can be */
/*    associated to single mirrors. View HANDSHAKE_CTRL register area for details. */
/*    Read accesses in this memory area: 0WS, byte accessable */
/*    Write accesses in this memory area: 0WS, byte accessable */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intramhs_base                          0x00000000U
#define Adr_NX51_intramhs_straight_mirror_intramhs_base     0x1A000000U
#define Adr_NX51_intramhs_dpm_mirror_intramhs_base          0x1A008000U
#define Adr_NX51_intramhs_arm_mirror_intramhs_base          0x1A010000U
#define Adr_NX51_intramhs_xpic_mirror_intramhs_base         0x1A018000U
#define Adr_NX51_intramhs_mirror_hi_intramhs_base           0xFFEA0000U
#define Adr_NX51_intramhs_mirror_itcm_intramhs_base         0x000A0000U
#define Adr_NX51_intramhs_buf_straight_mirror_intramhs_base 0x0A000000U
#define Adr_NX51_intramhs_buf_xpic_mirror_intramhs_base     0x0A018000U
#define Adr_NX51_intramhs_buf_arm_mirror_intramhs_base      0x0A010000U
#define Adr_NX51_intramhs_intramhs_base                     0x080A0000U
#define Adr_NX51_intramhs_mirror_dtcm_intramhs_base         0x040A0000U
#define Adr_NX51_intramhs_buf_dpm_mirror_intramhs_base      0x0A008000U

/* --------------------------------------------------------------------- */
/* Register intramhs_end */
/* => Internal Handshake RAM end address */
/*    ARM special: When ARM instruction TCM is enabled, access to "mirror_itcm" areas can not be done. They are hidden by instruction TCM. */
/*    ARM special: When ARM data TCM is enabled, access to "mirror_dtcm" areas can not be done. They are hidden by data TCM. */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_intramhs_end                          0x00007FFCU
#define Adr_NX51_intramhs_straight_mirror_intramhs_end     0x1A007FFCU
#define Adr_NX51_intramhs_dpm_mirror_intramhs_end          0x1A00FFFCU
#define Adr_NX51_intramhs_arm_mirror_intramhs_end          0x1A017FFCU
#define Adr_NX51_intramhs_xpic_mirror_intramhs_end         0x1A01FFFCU
#define Adr_NX51_intramhs_mirror_hi_intramhs_end           0xFFEA7FFCU
#define Adr_NX51_intramhs_mirror_itcm_intramhs_end         0x000A7FFCU
#define Adr_NX51_intramhs_buf_straight_mirror_intramhs_end 0x0A007FFCU
#define Adr_NX51_intramhs_buf_xpic_mirror_intramhs_end     0x0A01FFFCU
#define Adr_NX51_intramhs_buf_arm_mirror_intramhs_end      0x0A017FFCU
#define Adr_NX51_intramhs_intramhs_end                     0x080A7FFCU
#define Adr_NX51_intramhs_mirror_dtcm_intramhs_end         0x040A7FFCU
#define Adr_NX51_intramhs_buf_dpm_mirror_intramhs_end      0x0A00FFFCU


/* ===================================================================== */

/* AREA sdram */
/* Area of hif_sdram_lite, sdram */

/* ===================================================================== */

#define Addr_NX51_hif_sdram_lite 0x40000000U
#define Addr_NX51_sdram          0x80000000U
#define NX51_NETX_MEM_SDRAM_AREA 0x80000000U

/* --------------------------------------------------------------------- */
/* Register sdram_base */
/* => external SDRAM chip-select start address */
/*    Area size: 512MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sdram_base            0x00000000U
#define Adr_NX51_hif_sdram_lite_sdram_base 0x40000000U
#define Adr_NX51_sdram_sdram_base          0x80000000U

/* --------------------------------------------------------------------- */
/* Register sdram_end */
/* => external SDRAM chip-select end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_sdram_end            0x1FFFFFFCU
#define Adr_NX51_hif_sdram_lite_sdram_end 0x5FFFFFFCU
#define Adr_NX51_sdram_sdram_end          0x9FFFFFFCU


/* ===================================================================== */

/* AREA extsram */
/* Area of hif_extsram, extsram */

/* ===================================================================== */

#define Addr_NX51_hif_extsram   0x60000000U
#define Addr_NX51_extsram       0xC0000000U
#define NX51_NETX_MEM_SRAM_AREA 0xC0000000U

/* --------------------------------------------------------------------- */
/* Register cs0_base */
/* => external SRAM/Flash/NVRAM,... chip-select 0 start address */
/*    Area size: 64MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs0_base         0x00000000U
#define Adr_NX51_hif_extsram_cs0_base 0x60000000U
#define Adr_NX51_extsram_cs0_base     0xC0000000U

/* --------------------------------------------------------------------- */
/* Register cs0_end */
/* => external SRAM/Flash/NVRAM,... chip-select 0 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs0_end         0x03FFFFFCU
#define Adr_NX51_hif_extsram_cs0_end 0x63FFFFFCU
#define Adr_NX51_extsram_cs0_end     0xC3FFFFFCU

/* --------------------------------------------------------------------- */
/* Register cs1_base */
/* => external SRAM/Flash/NVRAM,... chip-select 1 start address */
/*    Area size: 64MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs1_base         0x04000000U
#define Adr_NX51_hif_extsram_cs1_base 0x64000000U
#define Adr_NX51_extsram_cs1_base     0xC4000000U

/* --------------------------------------------------------------------- */
/* Register cs1_end */
/* => external SRAM/Flash/NVRAM,... chip-select 1 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs1_end         0x07FFFFFCU
#define Adr_NX51_hif_extsram_cs1_end 0x67FFFFFCU
#define Adr_NX51_extsram_cs1_end     0xC7FFFFFCU

/* --------------------------------------------------------------------- */
/* Register cs2_base */
/* => external SRAM/Flash/NVRAM,... chip-select 2 start address */
/*    Area size: 64MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs2_base         0x08000000U
#define Adr_NX51_hif_extsram_cs2_base 0x68000000U
#define Adr_NX51_extsram_cs2_base     0xC8000000U

/* --------------------------------------------------------------------- */
/* Register cs2_end */
/* => external SRAM/Flash/NVRAM,... chip-select 2 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs2_end         0x0BFFFFFCU
#define Adr_NX51_hif_extsram_cs2_end 0x6BFFFFFCU
#define Adr_NX51_extsram_cs2_end     0xCBFFFFFCU

/* --------------------------------------------------------------------- */
/* Register cs3_base */
/* => external SRAM/Flash/NVRAM,... chip-select 3 start address */
/*    Area size: 64MB */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs3_base         0x0C000000U
#define Adr_NX51_hif_extsram_cs3_base 0x6C000000U
#define Adr_NX51_extsram_cs3_base     0xCC000000U

/* --------------------------------------------------------------------- */
/* Register cs3_end */
/* => external SRAM/Flash/NVRAM,... chip-select 3 end address */
/* => Mode: R */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_cs3_end         0x0FFFFFFCU
#define Adr_NX51_hif_extsram_cs3_end 0x6FFFFFFCU
#define Adr_NX51_extsram_cs3_end     0xCFFFFFFCU


/* ===================================================================== */

/* AREA xc_extbus_sel */
/* Area of  */

/* ===================================================================== */


/* --------------------------------------------------------------------- */
/* Register xc_extbus_sel_ctrl */
/* => External XC-bus-selection register - FPGA/EVA-Board version only!!! */
/*    Bus coding: */
/*    0000 : PHY1 */
/*    0001 : PHY2 */
/*    0010 : MMC */
/*    0011 : ProfiBus */
/*    0100 : CAN */
/*    0101 : ASI */
/*    1111 : nothing selected */
/*    Each XC-block can be assigned to one of these busses by setting the according bit-arear to the */
/*    value, the bus is coded with. */
/*    NO bus MUST be assigned to more than one XC-Block! */
/* => Mode: R/W */
/* --------------------------------------------------------------------- */

#define REL_Adr_NX51_xc_extbus_sel_ctrl  0x00000000U
#define DFLT_VAL_NX51_xc_extbus_sel_ctrl 0x00003210U

#define MSK_NX51_xc_extbus_sel_ctrl_xmac0_sel         0x0000000fU
#define SRT_NX51_xc_extbus_sel_ctrl_xmac0_sel         0
#define DFLT_VAL_NX51_xc_extbus_sel_ctrl_xmac0_sel    0x00000000U
#define DFLT_BF_VAL_NX51_xc_extbus_sel_ctrl_xmac0_sel 0x00000000U
#define MSK_NX51_xc_extbus_sel_ctrl_xmac1_sel         0x000000f0U
#define SRT_NX51_xc_extbus_sel_ctrl_xmac1_sel         4
#define DFLT_VAL_NX51_xc_extbus_sel_ctrl_xmac1_sel    0x00000010U
#define DFLT_BF_VAL_NX51_xc_extbus_sel_ctrl_xmac1_sel 0x00000001U
#define MSK_NX51_xc_extbus_sel_ctrl_xmac2_sel         0x00000f00U
#define SRT_NX51_xc_extbus_sel_ctrl_xmac2_sel         8
#define DFLT_VAL_NX51_xc_extbus_sel_ctrl_xmac2_sel    0x00000200U
#define DFLT_BF_VAL_NX51_xc_extbus_sel_ctrl_xmac2_sel 0x00000002U
#define MSK_NX51_xc_extbus_sel_ctrl_xmac3_sel         0x0000f000U
#define SRT_NX51_xc_extbus_sel_ctrl_xmac3_sel         12
#define DFLT_VAL_NX51_xc_extbus_sel_ctrl_xmac3_sel    0x00003000U
#define DFLT_BF_VAL_NX51_xc_extbus_sel_ctrl_xmac3_sel 0x00000003U

/* all used bits of 'NX51_xc_extbus_sel_ctrl': */
#define MSK_USED_BITS_NX51_xc_extbus_sel_ctrl 0x0000ffffU

enum {
	BFW_NX51_xc_extbus_sel_ctrl_xmac0_sel = 4,  /* [3:0] */
	BFW_NX51_xc_extbus_sel_ctrl_xmac1_sel = 4,  /* [7:4] */
	BFW_NX51_xc_extbus_sel_ctrl_xmac2_sel = 4,  /* [11:8] */
	BFW_NX51_xc_extbus_sel_ctrl_xmac3_sel = 4,  /* [15:12] */
	BFW_NX51_xc_extbus_sel_ctrl_reserved1 = 16  /* [31:16] */
};

typedef struct NX51_XC_EXTBUS_SEL_CTRL_BIT_Ttag {
	unsigned int xmac0_sel : BFW_NX51_xc_extbus_sel_ctrl_xmac0_sel; /* selects the external bus, assigned to xMAC0 (default PHY1)     */
	unsigned int xmac1_sel : BFW_NX51_xc_extbus_sel_ctrl_xmac1_sel; /* selects the external bus, assigned to xMAC1 (default PHY2)     */
	unsigned int xmac2_sel : BFW_NX51_xc_extbus_sel_ctrl_xmac2_sel; /* selects the external bus, assigned to xMAC2 (default MMC)      */
	unsigned int xmac3_sel : BFW_NX51_xc_extbus_sel_ctrl_xmac3_sel; /* selects the external bus, assigned to xMAC3 (default ProfiBus) */
	unsigned int reserved1 : BFW_NX51_xc_extbus_sel_ctrl_reserved1; /* reserved                                                       */
} NX51_XC_EXTBUS_SEL_CTRL_BIT_T;

typedef union {
	unsigned int                  val;
	NX51_XC_EXTBUS_SEL_CTRL_BIT_T bf;
} NX51_XC_EXTBUS_SEL_CTRL_T;




/*********************************************************************/
/* area structure definitions                                        */
/*********************************************************************/


typedef struct NX51_ARM_BOOT_VECTOR_AREA_Ttag
{
  volatile unsigned long  ulArm_boot_vector;
} NX51_ARM_BOOT_VECTOR_AREA_T;

typedef struct NX51_SR_AREA_Ttag
{
  volatile unsigned long aulSr_sr[16];
  volatile unsigned long aulSr_statcfg[2];
  volatile unsigned long  ulSr_stat_bits_shared;
} NX51_SR_AREA_T;

typedef struct NX51_CORDIC_AREA_Ttag
{
  volatile unsigned long  ulCordic_ctrl;
  volatile unsigned long  ulCordic_x_reg;
  volatile unsigned long  ulCordic_y_reg;
  volatile unsigned long  ulCordic_z_reg;
} NX51_CORDIC_AREA_T;

typedef struct NX51_GPIO_AREA_Ttag
{
  volatile unsigned long aulGpio_cfg[32];
  volatile unsigned long aulGpio_tc[32];
  volatile unsigned long aulGpio_counter_ctrl[5];
  volatile unsigned long aulGpio_counter_max[5];
  volatile unsigned long aulGpio_counter_cnt[5];
  volatile unsigned long  ulGpio_line;
  volatile unsigned long  ulGpio_in;
  volatile unsigned long  ulGpio_irq_raw;
  volatile unsigned long  ulGpio_irq_masked;
  volatile unsigned long  ulGpio_irq_mask_set;
  volatile unsigned long  ulGpio_irq_mask_rst;
  volatile unsigned long  ulCnt_irq_raw;
  volatile unsigned long  ulCnt_irq_masked;
  volatile unsigned long  ulCnt_irq_mask_set;
  volatile unsigned long  ulCnt_irq_mask_rst;
} NX51_GPIO_AREA_T;

typedef struct NX51_XLINK_AREA_Ttag
{
  volatile unsigned long  ulXlink_cfg;
  volatile unsigned long  ulXlink_tx;
  volatile unsigned long  ulXlink_rx;
  volatile unsigned long  ulXlink_stat;
} NX51_XLINK_AREA_T;

typedef struct NX51_IO_LINK_IRQ_AREA_Ttag
{
  volatile unsigned long  ulIo_link_irq_raw;
  volatile unsigned long  ulIo_link_irq_masked;
  volatile unsigned long  ulIo_link_irq_msk_set;
  volatile unsigned long  ulIo_link_irq_msk_reset;
  volatile unsigned long  ulIo_link_irq_enable;
} NX51_IO_LINK_IRQ_AREA_T;

typedef struct NX51_SPI_AREA_Ttag
{
  volatile unsigned long aulSpi_cr[2];
  volatile unsigned long  ulSpi_dr;
  volatile unsigned long  ulSpi_sr;
  volatile unsigned long  ulSpi_cpsr;
  volatile unsigned long  ulSpi_imsc;
  volatile unsigned long  ulSpi_ris;
  volatile unsigned long  ulSpi_mis;
  volatile unsigned long  ulSpi_icr;
  volatile unsigned long  ulSpi_irq_cpu_sel;
  volatile unsigned long  ulSpi_dmacr;
  volatile unsigned long aulReserved0[1];
  volatile unsigned long  ulSpi_data_register;
  volatile unsigned long  ulSpi_status_register;
  volatile unsigned long  ulSpi_control_register;
  volatile unsigned long  ulSpi_interrupt_control_register;
} NX51_SPI_AREA_T;

typedef struct NX51_XPIC_TIMER_AREA_Ttag
{
  volatile unsigned long aulXpic_timer_config_timer[3];
  volatile unsigned long aulXpic_timer_preload_timer[3];
  volatile unsigned long aulXpic_timer_timer[3];
  volatile unsigned long  ulXpic_timer_irq_raw;
  volatile unsigned long  ulXpic_timer_irq_masked;
  volatile unsigned long  ulXpic_timer_irq_msk_set;
  volatile unsigned long  ulXpic_timer_irq_msk_reset;
  volatile unsigned long  ulXpic_timer_systime_s;
  volatile unsigned long  ulXpic_timer_systime_ns;
  volatile unsigned long  ulXpic_timer_compare_systime_s_value;
  volatile unsigned long  ulXpic_timer_systime_uc_s;
  volatile unsigned long  ulXpic_timer_systime_uc_ns;
  volatile unsigned long  ulXpic_timer_compare_systime_uc_s_value;
} NX51_XPIC_TIMER_AREA_T;

typedef struct NX51_XPIC_VIC_AREA_Ttag
{
  volatile unsigned long  ulXpic_vic_config;
  volatile unsigned long aulXpic_vic_raw_intr[2];
  volatile unsigned long aulXpic_vic_softint_set[2];
  volatile unsigned long aulXpic_vic_softint_reset[2];
  volatile unsigned long  ulXpic_vic_fiq_addr;
  volatile unsigned long  ulXpic_vic_irq_addr;
  volatile unsigned long  ulXpic_vic_vector_addr;
  volatile unsigned long  ulXpic_vic_table_base_addr;
  volatile unsigned long  ulXpic_vic_fiq_vect_config;
  volatile unsigned long aulXpic_vic_vect_config[16];
  volatile unsigned long aulXpic_vic_default[2];
  volatile unsigned long aulXpic_vic_fiq_default[2];
} NX51_XPIC_VIC_AREA_T;

typedef struct NX51_XPIC_WDG_AREA_Ttag
{
  volatile unsigned long  ulXpic_wdg_trig;
  volatile unsigned long  ulXpic_wdg_counter;
  volatile unsigned long  ulXpic_wdg_xpic_irq_timeout;
  volatile unsigned long  ulXpic_wdg_arm_irq_timeout;
  volatile unsigned long  ulXpic_wdg_irq_raw;
  volatile unsigned long  ulXpic_wdg_irq_masked;
  volatile unsigned long  ulXpic_wdg_irq_msk_set;
  volatile unsigned long  ulXpic_wdg_irq_msk_reset;
} NX51_XPIC_WDG_AREA_T;

typedef struct NX51_XPEC_AREA_Ttag
{
  volatile unsigned long aulXpec_r[8];
  volatile unsigned long  ulXpec_stat_bits_shared;
  volatile unsigned long  ulRange_urtx_count;
  volatile unsigned long  ulRange45;
  volatile unsigned long  ulRange67;
  volatile unsigned long aulTimer[4];
  volatile unsigned long  ulUrx_count;
  volatile unsigned long  ulUtx_count;
  volatile unsigned long  ulXpec_pc;
  volatile unsigned long  ulZero;
  volatile unsigned long  ulXpec_config;
  volatile unsigned long  ulEc_maska;
  volatile unsigned long  ulEc_maskb;
  volatile unsigned long aulEc_mask[10];
  volatile unsigned long  ulTimer4;
  volatile unsigned long  ulTimer5;
  volatile unsigned long  ulIrq;
  volatile unsigned long  ulXpec_systime_ns;
  volatile unsigned long  ulFifo_data;
  volatile unsigned long  ulXpec_systime_s;
  volatile unsigned long  ulDatach_data;
  volatile unsigned long aulXpec_sr[16];
  volatile unsigned long aulStatcfg[2];
  volatile unsigned long  ulDatach_wr_cfg;
  volatile unsigned long  ulDatach_rd_cfg;
  volatile unsigned long aulUrtx[2];
  volatile unsigned long  ulSysch_data;
  volatile unsigned long  ulSysch_addr;
} NX51_XPEC_AREA_T;

typedef struct NX51_XMAC_AREA_Ttag
{
  volatile unsigned long aulXmac_sr[16];
  volatile unsigned long  ulXmac_status_shared0;
  volatile unsigned long  ulXmac_config_shared0;
  volatile unsigned long  ulXmac_io_oe_shared0;
  volatile unsigned long  ulXmac_status_shared1;
  volatile unsigned long  ulXmac_config_shared1;
  volatile unsigned long  ulXmac_io_oe_shared1;
  volatile unsigned long aulReserved0[6];
  volatile unsigned long aulXmac_urx_utx[2];
  volatile unsigned long aulReserved1[2];
  volatile unsigned long  ulXmac_urx;
  volatile unsigned long  ulXmac_utx;
  volatile unsigned long  ulXmac_rx;
  volatile unsigned long  ulXmac_other_rx;
  volatile unsigned long  ulXmac_rx_hw;
  volatile unsigned long  ulXmac_rx_hw_count;
  volatile unsigned long  ulXmac_tx;
  volatile unsigned long  ulXmac_tx_hw;
  volatile unsigned long  ulXmac_tx_hw_count;
  volatile unsigned long  ulXmac_tx_sent;
  volatile unsigned long  ulXmac_rpu_pc;
  volatile unsigned long  ulXmac_rpu_jmp_latch;
  volatile unsigned long  ulXmac_tpu_pc;
  volatile unsigned long  ulXmac_tpu_jmp_latch;
  volatile unsigned long aulXmac_wr[10];
  volatile unsigned long  ulXmac_sys_time;
  volatile unsigned long  ulXmac_sys_time_upper;
  volatile unsigned long  ulXmac_sys_time_uc;
  volatile unsigned long  ulXmac_sys_time_uc_upper;
  volatile unsigned long aulXmac_cmp_status[5];
  volatile unsigned long  ulXmac_alu_flags;
  volatile unsigned long  ulXmac_status_int;
  volatile unsigned long  ulXmac_stat_bits;
  volatile unsigned long  ulXmac_stat_bits_shared_lower;
  volatile unsigned long  ulXmac_stat_bits_shared_upper;
  volatile unsigned long  ulXmac_status_mii;
  volatile unsigned long  ulXmac_status_mii2;
  volatile unsigned long  ulXmac_other_status_mii2;
  volatile unsigned long  ulXmac_config_mii;
  volatile unsigned long  ulXmac_config_rx_nibble_fifo;
  volatile unsigned long  ulXmac_config_tx_nibble_fifo;
  volatile unsigned long  ulXmac_config_sbu;
  volatile unsigned long  ulXmac_config_sbu2;
  volatile unsigned long  ulXmac_sbu_rate_mul_add;
  volatile unsigned long  ulXmac_sbu_rate_mul_start;
  volatile unsigned long  ulXmac_sbu_rate_mul;
  volatile unsigned long  ulXmac_start_sample_pos;
  volatile unsigned long  ulXmac_stop_sample_pos;
  volatile unsigned long  ulXmac_config_obu;
  volatile unsigned long  ulXmac_config_obu2;
  volatile unsigned long  ulXmac_obu_rate_mul_add;
  volatile unsigned long  ulXmac_obu_rate_mul_start;
  volatile unsigned long  ulXmac_obu_rate_mul;
  volatile unsigned long  ulXmac_start_trans_pos;
  volatile unsigned long  ulXmac_stop_trans_pos;
  volatile unsigned long  ulXmac_rpu_count1;
  volatile unsigned long  ulXmac_rpu_count2;
  volatile unsigned long  ulXmac_tpu_count1;
  volatile unsigned long  ulXmac_tpu_count2;
  volatile unsigned long  ulXmac_rx_count;
  volatile unsigned long  ulXmac_tx_count;
  volatile unsigned long  ulXmac_rpm_mask0;
  volatile unsigned long  ulXmac_rpm_val0;
  volatile unsigned long  ulXmac_rpm_mask1;
  volatile unsigned long  ulXmac_rpm_val1;
  volatile unsigned long  ulXmac_tpm_mask0;
  volatile unsigned long  ulXmac_tpm_val0;
  volatile unsigned long  ulXmac_tpm_mask1;
  volatile unsigned long  ulXmac_tpm_val1;
  volatile unsigned long aulReserved2[8];
  volatile unsigned long  ulXmac_rx_crc32_l;
  volatile unsigned long  ulXmac_rx_crc32_h;
  volatile unsigned long  ulXmac_rx_crc32_cfg;
  volatile unsigned long  ulXmac_tx_crc32_l;
  volatile unsigned long  ulXmac_tx_crc32_h;
  volatile unsigned long  ulXmac_tx_crc32_cfg;
  volatile unsigned long  ulXmac_rx_crc_polynomial_l;
  volatile unsigned long  ulXmac_rx_crc_polynomial_h;
  volatile unsigned long  ulXmac_rx_crc_l;
  volatile unsigned long  ulXmac_rx_crc_h;
  volatile unsigned long  ulXmac_rx_crc_cfg;
  volatile unsigned long  ulXmac_tx_crc_polynomial_l;
  volatile unsigned long  ulXmac_tx_crc_polynomial_h;
  volatile unsigned long  ulXmac_tx_crc_l;
  volatile unsigned long  ulXmac_tx_crc_h;
  volatile unsigned long  ulXmac_tx_crc_cfg;
} NX51_XMAC_AREA_T;

typedef struct NX51_POINTER_FIFO_AREA_Ttag
{
  volatile unsigned long aulPfifo[32];
  volatile unsigned long aulPfifo_border[32];
  volatile unsigned long  ulPfifo_reset;
  volatile unsigned long  ulPfifo_full;
  volatile unsigned long  ulPfifo_empty;
  volatile unsigned long  ulPfifo_overflow;
  volatile unsigned long  ulPfifo_underrun;
  volatile unsigned long aulReserved2[27];
  volatile unsigned long aulPfifo_fill_level[32];
} NX51_POINTER_FIFO_AREA_T;

typedef struct NX51_FMMUSM_AREA_Ttag
{
  struct
  {
    volatile unsigned long  ulCfg_log_startaddr;
    volatile unsigned long  ulCfg_length;
    volatile unsigned long  ulCfg_phys_startaddr;
    volatile unsigned long  ulCfg_enable;
  } asFmmu[8];
  struct
  {
    volatile unsigned long  ulCfg_adr_len;
    volatile unsigned long  ulCfg_mode;
  } asSm[8];
  volatile unsigned long aulReserved0[4];
  volatile unsigned long  ulPhys_addr_offset;
  volatile unsigned long  ulPhys_last_addr;
  volatile unsigned long  ulFmmusm_xpec_nr;
  volatile unsigned long aulReserved1[9];
  volatile unsigned long  ulFmmusm_read_addr_in;
  volatile unsigned long  ulFmmusm_write_addr_in;
  volatile unsigned long  ulSm_read_addr_out;
  volatile unsigned long  ulSm_write_addr_out;
  volatile unsigned long  ulFmmu_read_bit_rol_pos;
  volatile unsigned long  ulFmmu_read_bit_mask;
  volatile unsigned long  ulFmmu_write_bit_rol_pos;
  volatile unsigned long  ulFmmu_write_bit_mask;
  volatile unsigned long  ulFmmusm_len_en;
  volatile unsigned long  ulFmmusm_status_out;
  volatile unsigned long  ulSm_buf_statcfg;
  volatile unsigned long  ulSm_read_event;
  volatile unsigned long  ulSm_write_event;
  volatile unsigned long  ulSm_first_byte_addressed;
  volatile unsigned long  ulSm_last_byte_addressed;
  volatile unsigned long  ulSm_served;
} NX51_FMMUSM_AREA_T;

typedef struct NX51_TRIGGER_SAMPLE_UNIT_AREA_Ttag
{
  volatile unsigned long  ulTrigger_sample_config;
  volatile unsigned long  ulTrigger_sample_status;
  volatile unsigned long  ulTrigger_sample_irq;
  volatile unsigned long  ulTrigger_activate;
  volatile unsigned long  ulTrigger_impulse_length;
  volatile unsigned long aulTrigger__starttime_ns[2];
  volatile unsigned long aulTrigger__cyc_time[2];
  volatile unsigned long  ulSample_mode;
  struct
  {
    volatile unsigned long  ulPos_systime_ns;
    volatile unsigned long  ulNeg_systime_ns;
  } asSample_[2];
  volatile unsigned long  ulTrigger_offset;
  volatile unsigned long  ulSync1_interval;
} NX51_TRIGGER_SAMPLE_UNIT_AREA_T;

typedef struct NX51_BUF_MAN_AREA_Ttag
{
  volatile unsigned long aulBuf_man_rpec[2];
  volatile unsigned long  ulBuf_man;
} NX51_BUF_MAN_AREA_T;

typedef struct NX51_XPEC_IRQ_REGISTERS_AREA_Ttag
{
  volatile unsigned long aulIrq_xpec[2];
} NX51_XPEC_IRQ_REGISTERS_AREA_T;

typedef struct NX51_XC_DEBUG_AREA_Ttag
{
  volatile unsigned long  ulXc_debug_config;
} NX51_XC_DEBUG_AREA_T;

typedef struct NX51_XC_START_STOP_AREA_Ttag
{
  volatile unsigned long  ulXc_start_stop_ctrl;
  volatile unsigned long  ulXc_hold_status;
} NX51_XC_START_STOP_AREA_T;

typedef struct NX51_DPM_AREA_Ttag
{
  volatile unsigned long  ulDpm_cfg0x0;
  volatile unsigned long  ulDpm_if_cfg;
  volatile unsigned long aulDpm_pio_cfg[2];
  volatile unsigned long  ulDpm_addr_cfg;
  volatile unsigned long  ulDpm_timing_cfg;
  volatile unsigned long  ulDpm_rdy_cfg;
  volatile unsigned long  ulDpm_status;
  volatile unsigned long  ulDpm_status_err_reset;
  volatile unsigned long  ulDpm_status_err_addr;
  volatile unsigned long  ulDpm_misc_cfg;
  volatile unsigned long  ulDpm_io_cfg_misc;
  volatile unsigned long aulReserved0[2];
  volatile unsigned long  ulDpm_tunnel_cfg;
  volatile unsigned long  ulDpm_itbaddr;
  struct
  {
    volatile unsigned long  ulEnd;
    volatile unsigned long  ulMap;
  } asDpm_win[4];
  volatile unsigned long aulReserved1[8];
  volatile unsigned long  ulDpm_irq_raw;
  volatile unsigned long  ulDpm_irq_arm_mask_set;
  volatile unsigned long  ulDpm_irq_arm_mask_reset;
  volatile unsigned long  ulDpm_irq_arm_masked;
  volatile unsigned long  ulDpm_irq_xpic_mask_set;
  volatile unsigned long  ulDpm_irq_xpic_mask_reset;
  volatile unsigned long  ulDpm_irq_xpic_masked;
  volatile unsigned long  ulDpm_irq_fiq_mask_set;
  volatile unsigned long  ulDpm_irq_fiq_mask_reset;
  volatile unsigned long  ulDpm_irq_fiq_masked;
  volatile unsigned long  ulDpm_irq_irq_mask_set;
  volatile unsigned long  ulDpm_irq_irq_mask_reset;
  volatile unsigned long  ulDpm_irq_irq_masked;
  volatile unsigned long aulReserved2[1];
  volatile unsigned long  ulDpm_sw_irq;
  volatile unsigned long aulReserved3[1];
  volatile unsigned long  ulDpm_reserved_netx50_wgd_host_timeout;
  volatile unsigned long  ulDpm_reserved_netx50_wgd_host_trigger;
  volatile unsigned long  ulDpm_reserved_netx50_wgd_netx_timeout;
  volatile unsigned long  ulDpm_sys_sta_bigend16;
  volatile unsigned long  ulDpm_reserved_netx50_timer_ctrl;
  volatile unsigned long  ulDpm_reserved_netx50_timer_start_val;
  volatile unsigned long  ulDpm_sys_sta;
  volatile unsigned long  ulDpm_reset_request;
  volatile unsigned long  ulDpm_firmware_irq_raw;
  volatile unsigned long aulReserved4[1];
  volatile unsigned long  ulDpm_firmware_irq_raw2;
  volatile unsigned long aulReserved5[1];
  volatile unsigned long  ulDpm_firmware_irq_mask;
  volatile unsigned long  ulDpm_netx_version_bigend16;
  volatile unsigned long  ulDpm_firmware_irq_mask2;
  volatile unsigned long  ulDpm_netx_version;
} NX51_DPM_AREA_T;

typedef struct NX51_ASIC_CTRL_AREA_Ttag
{
  volatile unsigned long  ulIo_config;
  volatile unsigned long  ulIo_config_mask;
  volatile unsigned long  ulIo_config2;
  volatile unsigned long  ulIo_config2_mask;
  volatile unsigned long  ulReset_ctrl;
  volatile unsigned long  ulPhy_control;
  volatile unsigned long  ulArmclk_rate_mul_add;
  volatile unsigned long  ulUsb12clk_rate_mul_add;
  struct
  {
    volatile unsigned long  ulClk_rate_mul_add;
    volatile unsigned long  ulClk_div;
  } asFb[2];
  volatile unsigned long  ulClkout_rate_mul_add;
  volatile unsigned long  ulClkout_div;
  volatile unsigned long  ulClock_enable;
  volatile unsigned long  ulClock_enable_mask;
  volatile unsigned long  ulMisc_asic_ctrl;
  volatile unsigned long  ulOnly_porn;
  volatile unsigned long  ulNetx_version;
  volatile unsigned long  ulRom_wdg;
  volatile unsigned long  ulSample_at_nres;
  volatile unsigned long  ulNetx_status;
  volatile unsigned long  ulRdy_run_cfg;
  volatile unsigned long  ulSystem_status;
  volatile unsigned long  ulNetx_lic_id;
  volatile unsigned long aulNetx_lic_flags[2];
  volatile unsigned long aulNetx_lic_errors[2];
  volatile unsigned long  ulNetx_lock_reserved_ul;
  volatile unsigned long  ulNetx_lock_reserved_lf;
  volatile unsigned long  ulAsic_ctrl_access_key;
  volatile unsigned long aulNetx_lock_reserved[32];
} NX51_ASIC_CTRL_AREA_T;

typedef struct NX51_MMIO_CTRL_AREA_Ttag
{
  volatile unsigned long aulMmio_cfg[49];
  volatile unsigned long aulMmio_pio_out_line_cfg[2];
  volatile unsigned long aulMmio_pio_oe_line_cfg[2];
  volatile unsigned long aulMmio_in_line_status[2];
  volatile unsigned long aulMmio_is_pio_status[2];
} NX51_MMIO_CTRL_AREA_T;

typedef struct NX51_HANDSHAKE_CTRL_AREA_Ttag
{
  volatile unsigned long  ulHandshake_base_addr;
  volatile unsigned long aulReserved0[3];
  volatile unsigned long  ulHandshake_dpm_irq_raw_clear;
  volatile unsigned long  ulHandshake_dpm_irq_masked;
  volatile unsigned long  ulHandshake_dpm_irq_msk_set;
  volatile unsigned long  ulHandshake_dpm_irq_msk_reset;
  volatile unsigned long  ulHandshake_arm_irq_raw_clear;
  volatile unsigned long  ulHandshake_arm_irq_masked;
  volatile unsigned long  ulHandshake_arm_irq_msk_set;
  volatile unsigned long  ulHandshake_arm_irq_msk_reset;
  volatile unsigned long  ulHandshake_xpic_irq_raw_clear;
  volatile unsigned long  ulHandshake_xpic_irq_masked;
  volatile unsigned long  ulHandshake_xpic_irq_msk_set;
  volatile unsigned long  ulHandshake_xpic_irq_msk_reset;
  volatile unsigned long aulReserved1[16];
  volatile unsigned long aulHandshake_hsc_ctrl[16];
  struct
  {
    volatile unsigned long  ulCtrl;
    volatile unsigned long  ulStatus_ctrl_netx;
    volatile unsigned long  ulStatus_ctrl_host;
    volatile unsigned long  ulWin_map;
  } asHandshake_buf_man[2];
} NX51_HANDSHAKE_CTRL_AREA_T;

typedef struct NX51_XPIC_AREA_Ttag
{
  volatile unsigned long aulXpic_r[8];
  volatile unsigned long aulXpic_usr[5];
  volatile unsigned long  ulXpic_pc;
  volatile unsigned long  ulXpic_stat;
  volatile unsigned long  ulXpic_zero;
} NX51_XPIC_AREA_T;

typedef struct NX51_XPIC_DEBUG_AREA_Ttag
{
  volatile unsigned long  ulXpic_hold_pc;
  struct
  {
    volatile unsigned long  ulAddr;
    volatile unsigned long  ulAddr_mask;
    volatile unsigned long  ulData;
    volatile unsigned long  ulData_mask;
    volatile unsigned long  ulContr;
    volatile unsigned long  ulContr_mask;
  } asXpic_break[2];
  volatile unsigned long  ulXpic_break_last_pc;
  volatile unsigned long  ulXpic_break_status;
  volatile unsigned long  ulXpic_break_irq_raw;
  volatile unsigned long  ulXpic_break_irq_masked;
  volatile unsigned long  ulXpic_break_irq_msk_set;
  volatile unsigned long  ulXpic_break_irq_msk_reset;
  volatile unsigned long  ulXpic_break_own_irq_masked;
  volatile unsigned long  ulXpic_break_own_irq_msk_set;
  volatile unsigned long  ulXpic_break_own_irq_msk_reset;
  volatile unsigned long  ulXpic_break_return_fiq_pc;
  volatile unsigned long  ulXpic_break_return_irq_pc;
  volatile unsigned long  ulXpic_irq_status;
} NX51_XPIC_DEBUG_AREA_T;

typedef struct NX51_INT_PHY_CTRL_AREA_Ttag
{
  volatile unsigned long  ulInt_phy_ctrl_miimu;
  volatile unsigned long  ulInt_phy_ctrl_miimu_sw;
  volatile unsigned long  ulInt_phy_ctrl_led;
  volatile unsigned long  ulInt_phy_ctrl_enhanced_link_detection;
} NX51_INT_PHY_CTRL_AREA_T;

typedef struct NX51_MIIMU_AREA_Ttag
{
  volatile unsigned long  ulMiimu;
  volatile unsigned long  ulMiimu_sw;
} NX51_MIIMU_AREA_T;

typedef struct NX51_PIO_AREA_Ttag
{
  volatile unsigned long  ulPio_in;
  volatile unsigned long  ulPio_out;
  volatile unsigned long  ulPio_oe;
} NX51_PIO_AREA_T;

typedef struct NX51_HIF_IO_CTRL_AREA_Ttag
{
  volatile unsigned long  ulHif_io_cfg;
  volatile unsigned long  ulHif_pio_cfg;
  volatile unsigned long aulHif_pio_out[2];
  volatile unsigned long aulHif_pio_oe[2];
  volatile unsigned long aulHif_pio_in[2];
  volatile unsigned long aulReserved0[1];
  volatile unsigned long  ulHif_pio_irq_raw;
  volatile unsigned long  ulHif_pio_irq_arm_mask_set;
  volatile unsigned long  ulHif_pio_irq_arm_mask_reset;
  volatile unsigned long  ulHif_pio_irq_arm_masked;
  volatile unsigned long  ulHif_pio_irq_xpic_mask_set;
  volatile unsigned long  ulHif_pio_irq_xpic_mask_reset;
  volatile unsigned long  ulHif_pio_irq_xpic_masked;
} NX51_HIF_IO_CTRL_AREA_T;

typedef struct NX51_CRC_AREA_Ttag
{
  volatile unsigned long  ulCrc_crc;
  volatile unsigned long  ulCrc_data_in;
  volatile unsigned long  ulCrc_polynomial;
  volatile unsigned long  ulCrc_config;
} NX51_CRC_AREA_T;

typedef struct NX51_SYSTIME_AREA_Ttag
{
  volatile unsigned long  ulSystime_s;
  volatile unsigned long  ulSystime_ns;
  volatile unsigned long  ulSystime_border;
  volatile unsigned long  ulSystime_count_value;
} NX51_SYSTIME_AREA_T;

typedef struct NX51_WATCHDOG_AREA_Ttag
{
  volatile unsigned long  ulNetx_sys_wdg_ctrl;
  volatile unsigned long  ulNetx_sys_wdg;
  volatile unsigned long  ulNetx_sys_wdg_irq_timeout;
  volatile unsigned long  ulNetx_sys_wdg_res_timeout;
} NX51_WATCHDOG_AREA_T;

typedef struct NX51_SQI_AREA_Ttag
{
  volatile unsigned long aulSqi_cr[2];
  volatile unsigned long  ulSqi_dr;
  volatile unsigned long  ulSqi_sr;
  volatile unsigned long  ulSqi_tcr;
  volatile unsigned long  ulSqi_irq_mask;
  volatile unsigned long  ulSqi_irq_raw;
  volatile unsigned long  ulSqi_irq_masked;
  volatile unsigned long  ulSqi_irq_clear;
  volatile unsigned long  ulSqi_irq_cpu_sel;
  volatile unsigned long  ulSqi_dmacr;
  volatile unsigned long aulReserved0[1];
  volatile unsigned long  ulSqi_pio_out;
  volatile unsigned long  ulSqi_pio_oe;
  volatile unsigned long  ulSqi_pio_in;
  volatile unsigned long  ulSqi_sqirom_cfg;
} NX51_SQI_AREA_T;

typedef struct NX51_UART_AREA_Ttag
{
  volatile unsigned long  ulUartdr;
  volatile unsigned long  ulUartrsr;
  volatile unsigned long  ulUartlcr_h;
  volatile unsigned long  ulUartlcr_m;
  volatile unsigned long  ulUartlcr_l;
  volatile unsigned long  ulUartcr;
  volatile unsigned long  ulUartfr;
  volatile unsigned long  ulUartiir;
  volatile unsigned long  ulUartilpr;
  volatile unsigned long  ulUartrts;
  volatile unsigned long  ulUartforerun;
  volatile unsigned long  ulUarttrail;
  volatile unsigned long  ulUartdrvout;
  volatile unsigned long  ulUartcr_2;
  volatile unsigned long  ulUartrxiflsel;
  volatile unsigned long  ulUarttxiflsel;
} NX51_UART_AREA_T;

typedef struct NX51_I2C_AREA_Ttag
{
  volatile unsigned long  ulI2c_mcr;
  volatile unsigned long  ulI2c_scr;
  volatile unsigned long  ulI2c_cmd;
  volatile unsigned long  ulI2c_mdr;
  volatile unsigned long  ulI2c_sdr;
  volatile unsigned long  ulI2c_mfifo_cr;
  volatile unsigned long  ulI2c_sfifo_cr;
  volatile unsigned long  ulI2c_sr;
  volatile unsigned long  ulI2c_irqmsk;
  volatile unsigned long  ulI2c_irqsr;
  volatile unsigned long  ulI2c_irqmsked;
  volatile unsigned long  ulI2c_dmacr;
  volatile unsigned long  ulI2c_pio;
} NX51_I2C_AREA_T;

typedef struct NX51_PARITY_AREA_Ttag
{
  volatile unsigned long  ulParity_enable;
  volatile unsigned long  ulParity_abort_enable;
  volatile unsigned long  ulParity_error_mem_status;
  volatile unsigned long  ulParity_error_acc_status;
  volatile unsigned long  ulParity_irq_raw;
  volatile unsigned long  ulParity_irq_masked;
  volatile unsigned long  ulParity_irq_msk_set;
  volatile unsigned long  ulParity_irq_msk_reset;
} NX51_PARITY_AREA_T;

typedef struct NX51_USB_DEV_CTRL_AREA_Ttag
{
  volatile unsigned long  ulUsb_dev_cfg;
  volatile unsigned long  ulUsb_dev_status;
  volatile unsigned long  ulUsb_dev_vendor_features;
  volatile unsigned long  ulUsb_dev_irq_mask;
  volatile unsigned long  ulUsb_dev_irq_raw;
  volatile unsigned long  ulUsb_dev_irq_masked;
} NX51_USB_DEV_CTRL_AREA_T;

typedef struct NX51_USB_DEV_FIFO_CTRL_AREA_Ttag
{
  volatile unsigned long  ulUsb_dev_fifo_ctrl_conf;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_error;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_control_ep_rx_len;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_control_ep_rx_stat;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_control_ep_tx_len;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_control_ep_tx_stat;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_interrupt_ep_tx_len;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_interrupt_ep_tx_stat;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_uart_ep_rx_len;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_uart_ep_rx_stat;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_uart_ep_tx_len;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_uart_ep_tx_stat;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_jtag_ep_rx_len;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_jtag_ep_rx_stat;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_jtag_ep_tx_len;
  volatile unsigned long  ulUsb_dev_fifo_ctrl_jtag_ep_tx_stat;
} NX51_USB_DEV_FIFO_CTRL_AREA_T;

typedef struct NX51_USB_DEV_FIFO_AREA_Ttag
{
  volatile unsigned long  ulUsb_dev_control_out_data;
  volatile unsigned long  ulUsb_dev_control_in_data;
  volatile unsigned long  ulUsb_dev_interrupt_data;
  volatile unsigned long  ulUsb_dev_uart_rx_data;
  volatile unsigned long  ulUsb_dev_uart_tx_data;
  volatile unsigned long  ulUsb_dev_jtag_rx_data;
  volatile unsigned long  ulUsb_dev_jtag_tx_data;
} NX51_USB_DEV_FIFO_AREA_T;

typedef struct NX51_CANCTRL_AREA_Ttag
{
  volatile unsigned long  ulCanctrl_mode;
  volatile unsigned long  ulCanctrl_command;
  volatile unsigned long  ulCanctrl_status;
  volatile unsigned long  ulCanctrl_irq;
  volatile unsigned long  ulCanctrl_irq_en;
  volatile unsigned long  ulCanctrl_not_extended_acceptance_mask0;
  volatile unsigned long aulCanctrl_bus_timing[2];
  volatile unsigned long aulReserved0[2];
  volatile unsigned long  ulCanctrl_not_extended_data0;
  volatile unsigned long  ulCanctrl_arb_lost_capture;
  volatile unsigned long  ulCanctrl_err_code_capture;
  volatile unsigned long  ulCanctrl_err_warning_limit;
  volatile unsigned long  ulCanctrl_rx_error_cnt;
  volatile unsigned long  ulCanctrl_tx_error_cnt;
  volatile unsigned long aulCanctrl_data[13];
  volatile unsigned long  ulCanctrl_rx_message_cnt;
  volatile unsigned long aulReserved1[1];
  volatile unsigned long  ulCanctrl_mode_control;
  volatile unsigned long  ulCanctrl_arm_xpic_irq_enable;
} NX51_CANCTRL_AREA_T;

typedef struct NX51_DMAC_CH_AREA_Ttag
{
  volatile unsigned long  ulDmac_chsrc_ad;
  volatile unsigned long  ulDmac_chdest_ad;
  volatile unsigned long  ulDmac_chlink;
  volatile unsigned long  ulDmac_chctrl;
  volatile unsigned long  ulDmac_chcfg;
} NX51_DMAC_CH_AREA_T;

typedef struct NX51_DMAC_REG_AREA_Ttag
{
  volatile unsigned long  ulDmac_int_status;
  volatile unsigned long  ulDmac_inttc_status;
  volatile unsigned long  ulDmac_inttc_clear;
  volatile unsigned long  ulDmac_interr_status;
  volatile unsigned long  ulDmac_interr_clear;
  volatile unsigned long  ulDmac_rawinttc_status;
  volatile unsigned long  ulDmac_rawinterr_status;
  volatile unsigned long  ulDmac_enabled_channel;
  volatile unsigned long  ulDmac_softb_req;
  volatile unsigned long  ulDmac_softs_req;
  volatile unsigned long  ulDmac_softlb_req;
  volatile unsigned long  ulDmac_softls_req;
  volatile unsigned long  ulDmac_config;
  volatile unsigned long  ulDmac_sync;
} NX51_DMAC_REG_AREA_T;

typedef struct NX51_EXT_ASYNCMEM_CTRL_AREA_Ttag
{
  volatile unsigned long aulExtsram_ctrl[4];
  volatile unsigned long  ulExt_cs0_apm_ctrl;
  volatile unsigned long aulReserved0[3];
  volatile unsigned long  ulExt_rdy_cfg;
  volatile unsigned long  ulExt_rdy_status;
} NX51_EXT_ASYNCMEM_CTRL_AREA_T;

typedef struct NX51_EXTMEM_PRIORITY_CTRL_AREA_Ttag
{
  volatile unsigned long  ulExtmem_prio_timslot_ctrl;
  volatile unsigned long  ulExtmem_prio_accesstime_ctrl;
} NX51_EXTMEM_PRIORITY_CTRL_AREA_T;

typedef struct NX51_EXTMEM_PIO_CTRL_AREA_Ttag
{
  volatile unsigned long  ulExtmem_pio_ctrl_mem_d_pio_oe_set_clear;
  volatile unsigned long  ulExtmem_pio_ctrl_mem_d_pio_out_set_clear;
  volatile unsigned long  ulExtmem_pio_ctrl_mem_d_pio_in;
} NX51_EXTMEM_PIO_CTRL_AREA_T;

typedef struct NX51_ARM_TIMER_AREA_Ttag
{
  volatile unsigned long aulArm_timer_config_timer[2];
  volatile unsigned long aulArm_timer_preload_timer[2];
  volatile unsigned long aulArm_timer_timer[2];
  volatile unsigned long  ulArm_timer_systime_s;
  volatile unsigned long  ulArm_timer_systime_ns;
  volatile unsigned long  ulArm_timer_systime_ns_compare;
  volatile unsigned long  ulArm_timer_systime_s_compare;
  volatile unsigned long  ulArm_timer_systime_uc_s;
  volatile unsigned long  ulArm_timer_systime_uc_ns;
  volatile unsigned long  ulArm_timer_systime_uc_ns_compare;
  volatile unsigned long  ulArm_timer_systime_uc_s_compare;
  volatile unsigned long  ulArm_timer_irq_raw;
  volatile unsigned long  ulArm_timer_irq_masked;
  volatile unsigned long  ulArm_timer_irq_msk_set;
  volatile unsigned long  ulArm_timer_irq_msk_reset;
} NX51_ARM_TIMER_AREA_T;

typedef struct NX51_VIC_AREA_Ttag
{
  volatile unsigned long  ulVic_irq_status;
  volatile unsigned long  ulVic_fiq_status;
  volatile unsigned long  ulVic_raw_intr;
  volatile unsigned long  ulVic_int_select;
  volatile unsigned long  ulVic_int_enable;
  volatile unsigned long  ulVic_int_enclear;
  volatile unsigned long  ulVic_softint;
  volatile unsigned long  ulVic_softint_clear;
  volatile unsigned long  ulVic_protection;
  volatile unsigned long aulReserved0[3];
  volatile unsigned long  ulVic_vect_addr;
  volatile unsigned long  ulVic_def_vect_addr;
  volatile unsigned long aulReserved1[50];
  volatile unsigned long aulVic_vect_addr[16];
  volatile unsigned long aulReserved2[48];
  volatile unsigned long aulVic_vect_cntl[16];
} NX51_VIC_AREA_T;

typedef struct NX51_NFIFO_AREA_Ttag
{
  volatile unsigned long  ulNfifo_config;
  volatile unsigned long  ulNfifo_scheduler_req;
  volatile unsigned long  ulNfifo_last_access;
  volatile unsigned long  ulNfifo_irq_raw;
  volatile unsigned long  ulNfifo_irq_arm_masked;
  volatile unsigned long  ulNfifo_irq_arm_msk_set;
  volatile unsigned long  ulNfifo_irq_arm_msk_reset;
  volatile unsigned long  ulNfifo_irq_xpic_masked;
  volatile unsigned long  ulNfifo_irq_xpic_msk_set;
  volatile unsigned long  ulNfifo_irq_xpic_msk_reset;
  volatile unsigned long aulNfifo_fifo[1014];
} NX51_NFIFO_AREA_T;

typedef struct NX51_ETH_AREA_Ttag
{
  volatile unsigned long  ulEth_config;
  volatile unsigned long  ulEth_tx_config;
  volatile unsigned long  ulEth_status;
  volatile unsigned long  ulEth_tx_data;
  volatile unsigned long  ulEth_rx_data;
  volatile unsigned long  ulEth_tx_len;
  volatile unsigned long  ulEth_rx_len_stat;
  volatile unsigned long aulReserved0[1];
  volatile unsigned long  ulEth_rx_systime_ns;
  volatile unsigned long  ulEth_tx_systime_ns;
  volatile unsigned long  ulEth_irq_raw;
  volatile unsigned long  ulEth_irq_masked;
  volatile unsigned long  ulEth_irq_msk_set;
  volatile unsigned long  ulEth_irq_msk_reset;
} NX51_ETH_AREA_T;

typedef struct NX51_XC_EXTBUS_SEL_AREA_Ttag
{
  volatile unsigned long  ulXc_extbus_sel_ctrl;
} NX51_XC_EXTBUS_SEL_AREA_T;


#endif
